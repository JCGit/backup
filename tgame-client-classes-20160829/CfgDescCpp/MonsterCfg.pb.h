// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MonsterCfg.proto

#ifndef PROTOBUF_MonsterCfg_2eproto__INCLUDED
#define PROTOBUF_MonsterCfg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace cfg {
namespace vo {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MonsterCfg_2eproto();
void protobuf_AssignDesc_MonsterCfg_2eproto();
void protobuf_ShutdownFile_MonsterCfg_2eproto();

class DefAttElement;
class Movement;
class MonsterCfg;
class MonsterCfgSet;

// ===================================================================

class DefAttElement : public ::google::protobuf::MessageLite {
 public:
  DefAttElement();
  virtual ~DefAttElement();

  DefAttElement(const DefAttElement& from);

  inline DefAttElement& operator=(const DefAttElement& from) {
    CopyFrom(from);
    return *this;
  }

  static const DefAttElement& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DefAttElement* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DefAttElement* other);

  // implements Message ----------------------------------------------

  DefAttElement* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DefAttElement& from);
  void MergeFrom(const DefAttElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 defAtt = 1;
  inline bool has_defatt() const;
  inline void clear_defatt();
  static const int kDefAttFieldNumber = 1;
  inline ::google::protobuf::uint32 defatt() const;
  inline void set_defatt(::google::protobuf::uint32 value);

  // required uint32 defAttType = 2;
  inline bool has_defatttype() const;
  inline void clear_defatttype();
  static const int kDefAttTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 defatttype() const;
  inline void set_defatttype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.cfg.vo.DefAttElement)
 private:
  inline void set_has_defatt();
  inline void clear_has_defatt();
  inline void set_has_defatttype();
  inline void clear_has_defatttype();

  ::google::protobuf::uint32 defatt_;
  ::google::protobuf::uint32 defatttype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MonsterCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MonsterCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_MonsterCfg_2eproto();
  friend void protobuf_ShutdownFile_MonsterCfg_2eproto();

  void InitAsDefaultInstance();
  static DefAttElement* default_instance_;
};
// -------------------------------------------------------------------

class Movement : public ::google::protobuf::MessageLite {
 public:
  Movement();
  virtual ~Movement();

  Movement(const Movement& from);

  inline Movement& operator=(const Movement& from) {
    CopyFrom(from);
    return *this;
  }

  static const Movement& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Movement* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Movement* other);

  // implements Message ----------------------------------------------

  Movement* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Movement& from);
  void MergeFrom(const Movement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string emerge = 1;
  inline bool has_emerge() const;
  inline void clear_emerge();
  static const int kEmergeFieldNumber = 1;
  inline const ::std::string& emerge() const;
  inline void set_emerge(const ::std::string& value);
  inline void set_emerge(const char* value);
  inline void set_emerge(const char* value, size_t size);
  inline ::std::string* mutable_emerge();
  inline ::std::string* release_emerge();
  inline void set_allocated_emerge(::std::string* emerge);

  // @@protoc_insertion_point(class_scope:com.cfg.vo.Movement)
 private:
  inline void set_has_emerge();
  inline void clear_has_emerge();

  ::std::string* emerge_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MonsterCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MonsterCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_MonsterCfg_2eproto();
  friend void protobuf_ShutdownFile_MonsterCfg_2eproto();

  void InitAsDefaultInstance();
  static Movement* default_instance_;
};
// -------------------------------------------------------------------

class MonsterCfg : public ::google::protobuf::MessageLite {
 public:
  MonsterCfg();
  virtual ~MonsterCfg();

  MonsterCfg(const MonsterCfg& from);

  inline MonsterCfg& operator=(const MonsterCfg& from) {
    CopyFrom(from);
    return *this;
  }

  static const MonsterCfg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MonsterCfg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MonsterCfg* other);

  // implements Message ----------------------------------------------

  MonsterCfg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MonsterCfg& from);
  void MergeFrom(const MonsterCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required string monstername = 2;
  inline bool has_monstername() const;
  inline void clear_monstername();
  static const int kMonsternameFieldNumber = 2;
  inline const ::std::string& monstername() const;
  inline void set_monstername(const ::std::string& value);
  inline void set_monstername(const char* value);
  inline void set_monstername(const char* value, size_t size);
  inline ::std::string* mutable_monstername();
  inline ::std::string* release_monstername();
  inline void set_allocated_monstername(::std::string* monstername);

  // required string desc = 3;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 3;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // required string avatar = 4;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 4;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // required uint32 camp = 5;
  inline bool has_camp() const;
  inline void clear_camp();
  static const int kCampFieldNumber = 5;
  inline ::google::protobuf::uint32 camp() const;
  inline void set_camp(::google::protobuf::uint32 value);

  // required uint32 monstertype = 6;
  inline bool has_monstertype() const;
  inline void clear_monstertype();
  static const int kMonstertypeFieldNumber = 6;
  inline ::google::protobuf::uint32 monstertype() const;
  inline void set_monstertype(::google::protobuf::uint32 value);

  // required uint32 level = 7;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 7;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint64 hp = 8;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 8;
  inline ::google::protobuf::uint64 hp() const;
  inline void set_hp(::google::protobuf::uint64 value);

  // required uint32 attack = 9;
  inline bool has_attack() const;
  inline void clear_attack();
  static const int kAttackFieldNumber = 9;
  inline ::google::protobuf::uint32 attack() const;
  inline void set_attack(::google::protobuf::uint32 value);

  // required uint32 defence = 10;
  inline bool has_defence() const;
  inline void clear_defence();
  static const int kDefenceFieldNumber = 10;
  inline ::google::protobuf::uint32 defence() const;
  inline void set_defence(::google::protobuf::uint32 value);

  // required uint32 atktype = 11;
  inline bool has_atktype() const;
  inline void clear_atktype();
  static const int kAtktypeFieldNumber = 11;
  inline ::google::protobuf::uint32 atktype() const;
  inline void set_atktype(::google::protobuf::uint32 value);

  // required uint32 deftype = 12;
  inline bool has_deftype() const;
  inline void clear_deftype();
  static const int kDeftypeFieldNumber = 12;
  inline ::google::protobuf::uint32 deftype() const;
  inline void set_deftype(::google::protobuf::uint32 value);

  // required uint32 ballistic = 13;
  inline bool has_ballistic() const;
  inline void clear_ballistic();
  static const int kBallisticFieldNumber = 13;
  inline ::google::protobuf::uint32 ballistic() const;
  inline void set_ballistic(::google::protobuf::uint32 value);

  // repeated uint32 skills = 14;
  inline int skills_size() const;
  inline void clear_skills();
  static const int kSkillsFieldNumber = 14;
  inline ::google::protobuf::uint32 skills(int index) const;
  inline void set_skills(int index, ::google::protobuf::uint32 value);
  inline void add_skills(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      skills() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_skills();

  // required uint32 dropId = 15;
  inline bool has_dropid() const;
  inline void clear_dropid();
  static const int kDropIdFieldNumber = 15;
  inline ::google::protobuf::uint32 dropid() const;
  inline void set_dropid(::google::protobuf::uint32 value);

  // required uint32 highSpeed = 17;
  inline bool has_highspeed() const;
  inline void clear_highspeed();
  static const int kHighSpeedFieldNumber = 17;
  inline ::google::protobuf::uint32 highspeed() const;
  inline void set_highspeed(::google::protobuf::uint32 value);

  // required string emergeVoice = 18;
  inline bool has_emergevoice() const;
  inline void clear_emergevoice();
  static const int kEmergeVoiceFieldNumber = 18;
  inline const ::std::string& emergevoice() const;
  inline void set_emergevoice(const ::std::string& value);
  inline void set_emergevoice(const char* value);
  inline void set_emergevoice(const char* value, size_t size);
  inline ::std::string* mutable_emergevoice();
  inline ::std::string* release_emergevoice();
  inline void set_allocated_emergevoice(::std::string* emergevoice);

  // required string hurtVoice = 19;
  inline bool has_hurtvoice() const;
  inline void clear_hurtvoice();
  static const int kHurtVoiceFieldNumber = 19;
  inline const ::std::string& hurtvoice() const;
  inline void set_hurtvoice(const ::std::string& value);
  inline void set_hurtvoice(const char* value);
  inline void set_hurtvoice(const char* value, size_t size);
  inline ::std::string* mutable_hurtvoice();
  inline ::std::string* release_hurtvoice();
  inline void set_allocated_hurtvoice(::std::string* hurtvoice);

  // required string dieVoice = 20;
  inline bool has_dievoice() const;
  inline void clear_dievoice();
  static const int kDieVoiceFieldNumber = 20;
  inline const ::std::string& dievoice() const;
  inline void set_dievoice(const ::std::string& value);
  inline void set_dievoice(const char* value);
  inline void set_dievoice(const char* value, size_t size);
  inline ::std::string* mutable_dievoice();
  inline ::std::string* release_dievoice();
  inline void set_allocated_dievoice(::std::string* dievoice);

  // required string aiLuaFile = 21;
  inline bool has_ailuafile() const;
  inline void clear_ailuafile();
  static const int kAiLuaFileFieldNumber = 21;
  inline const ::std::string& ailuafile() const;
  inline void set_ailuafile(const ::std::string& value);
  inline void set_ailuafile(const char* value);
  inline void set_ailuafile(const char* value, size_t size);
  inline ::std::string* mutable_ailuafile();
  inline ::std::string* release_ailuafile();
  inline void set_allocated_ailuafile(::std::string* ailuafile);

  // required uint32 atkAtt = 22;
  inline bool has_atkatt() const;
  inline void clear_atkatt();
  static const int kAtkAttFieldNumber = 22;
  inline ::google::protobuf::uint32 atkatt() const;
  inline void set_atkatt(::google::protobuf::uint32 value);

  // required uint32 atkAttType = 23;
  inline bool has_atkatttype() const;
  inline void clear_atkatttype();
  static const int kAtkAttTypeFieldNumber = 23;
  inline ::google::protobuf::uint32 atkatttype() const;
  inline void set_atkatttype(::google::protobuf::uint32 value);

  // repeated .com.cfg.vo.DefAttElement defAtts = 24;
  inline int defatts_size() const;
  inline void clear_defatts();
  static const int kDefAttsFieldNumber = 24;
  inline const ::com::cfg::vo::DefAttElement& defatts(int index) const;
  inline ::com::cfg::vo::DefAttElement* mutable_defatts(int index);
  inline ::com::cfg::vo::DefAttElement* add_defatts();
  inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::DefAttElement >&
      defatts() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::DefAttElement >*
      mutable_defatts();

  // required uint32 walkType = 25;
  inline bool has_walktype() const;
  inline void clear_walktype();
  static const int kWalkTypeFieldNumber = 25;
  inline ::google::protobuf::uint32 walktype() const;
  inline void set_walktype(::google::protobuf::uint32 value);

  // required uint32 hurtActionCD = 26;
  inline bool has_hurtactioncd() const;
  inline void clear_hurtactioncd();
  static const int kHurtActionCDFieldNumber = 26;
  inline ::google::protobuf::uint32 hurtactioncd() const;
  inline void set_hurtactioncd(::google::protobuf::uint32 value);

  // required string dieAnimation = 27;
  inline bool has_dieanimation() const;
  inline void clear_dieanimation();
  static const int kDieAnimationFieldNumber = 27;
  inline const ::std::string& dieanimation() const;
  inline void set_dieanimation(const ::std::string& value);
  inline void set_dieanimation(const char* value);
  inline void set_dieanimation(const char* value, size_t size);
  inline ::std::string* mutable_dieanimation();
  inline ::std::string* release_dieanimation();
  inline void set_allocated_dieanimation(::std::string* dieanimation);

  // required uint32 minWalkSpeed = 28;
  inline bool has_minwalkspeed() const;
  inline void clear_minwalkspeed();
  static const int kMinWalkSpeedFieldNumber = 28;
  inline ::google::protobuf::uint32 minwalkspeed() const;
  inline void set_minwalkspeed(::google::protobuf::uint32 value);

  // required uint32 maxWalkSpeed = 29;
  inline bool has_maxwalkspeed() const;
  inline void clear_maxwalkspeed();
  static const int kMaxWalkSpeedFieldNumber = 29;
  inline ::google::protobuf::uint32 maxwalkspeed() const;
  inline void set_maxwalkspeed(::google::protobuf::uint32 value);

  // required uint32 bubbleId = 30;
  inline bool has_bubbleid() const;
  inline void clear_bubbleid();
  static const int kBubbleIdFieldNumber = 30;
  inline ::google::protobuf::uint32 bubbleid() const;
  inline void set_bubbleid(::google::protobuf::uint32 value);

  // required string hurtAnimation = 31;
  inline bool has_hurtanimation() const;
  inline void clear_hurtanimation();
  static const int kHurtAnimationFieldNumber = 31;
  inline const ::std::string& hurtanimation() const;
  inline void set_hurtanimation(const ::std::string& value);
  inline void set_hurtanimation(const char* value);
  inline void set_hurtanimation(const char* value, size_t size);
  inline ::std::string* mutable_hurtanimation();
  inline ::std::string* release_hurtanimation();
  inline void set_allocated_hurtanimation(::std::string* hurtanimation);

  // required uint32 floorBuffId = 32;
  inline bool has_floorbuffid() const;
  inline void clear_floorbuffid();
  static const int kFloorBuffIdFieldNumber = 32;
  inline ::google::protobuf::uint32 floorbuffid() const;
  inline void set_floorbuffid(::google::protobuf::uint32 value);

  // required uint32 aiID = 33;
  inline bool has_aiid() const;
  inline void clear_aiid();
  static const int kAiIDFieldNumber = 33;
  inline ::google::protobuf::uint32 aiid() const;
  inline void set_aiid(::google::protobuf::uint32 value);

  // required uint32 patrolArea = 34;
  inline bool has_patrolarea() const;
  inline void clear_patrolarea();
  static const int kPatrolAreaFieldNumber = 34;
  inline ::google::protobuf::uint32 patrolarea() const;
  inline void set_patrolarea(::google::protobuf::uint32 value);

  // required uint32 HurtColor = 35;
  inline bool has_hurtcolor() const;
  inline void clear_hurtcolor();
  static const int kHurtColorFieldNumber = 35;
  inline ::google::protobuf::uint32 hurtcolor() const;
  inline void set_hurtcolor(::google::protobuf::uint32 value);

  // required uint32 InitScale = 36;
  inline bool has_initscale() const;
  inline void clear_initscale();
  static const int kInitScaleFieldNumber = 36;
  inline ::google::protobuf::uint32 initscale() const;
  inline void set_initscale(::google::protobuf::uint32 value);

  // required uint32 IsBlock = 37;
  inline bool has_isblock() const;
  inline void clear_isblock();
  static const int kIsBlockFieldNumber = 37;
  inline ::google::protobuf::uint32 isblock() const;
  inline void set_isblock(::google::protobuf::uint32 value);

  // required .com.cfg.vo.Movement actions = 38;
  inline bool has_actions() const;
  inline void clear_actions();
  static const int kActionsFieldNumber = 38;
  inline const ::com::cfg::vo::Movement& actions() const;
  inline ::com::cfg::vo::Movement* mutable_actions();
  inline ::com::cfg::vo::Movement* release_actions();
  inline void set_allocated_actions(::com::cfg::vo::Movement* actions);

  // required uint32 dropCoin = 39;
  inline bool has_dropcoin() const;
  inline void clear_dropcoin();
  static const int kDropCoinFieldNumber = 39;
  inline ::google::protobuf::uint32 dropcoin() const;
  inline void set_dropcoin(::google::protobuf::uint32 value);

  // required string headImg = 40;
  inline bool has_headimg() const;
  inline void clear_headimg();
  static const int kHeadImgFieldNumber = 40;
  inline const ::std::string& headimg() const;
  inline void set_headimg(const ::std::string& value);
  inline void set_headimg(const char* value);
  inline void set_headimg(const char* value, size_t size);
  inline ::std::string* mutable_headimg();
  inline ::std::string* release_headimg();
  inline void set_allocated_headimg(::std::string* headimg);

  // @@protoc_insertion_point(class_scope:com.cfg.vo.MonsterCfg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_monstername();
  inline void clear_has_monstername();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_camp();
  inline void clear_has_camp();
  inline void set_has_monstertype();
  inline void clear_has_monstertype();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_attack();
  inline void clear_has_attack();
  inline void set_has_defence();
  inline void clear_has_defence();
  inline void set_has_atktype();
  inline void clear_has_atktype();
  inline void set_has_deftype();
  inline void clear_has_deftype();
  inline void set_has_ballistic();
  inline void clear_has_ballistic();
  inline void set_has_dropid();
  inline void clear_has_dropid();
  inline void set_has_highspeed();
  inline void clear_has_highspeed();
  inline void set_has_emergevoice();
  inline void clear_has_emergevoice();
  inline void set_has_hurtvoice();
  inline void clear_has_hurtvoice();
  inline void set_has_dievoice();
  inline void clear_has_dievoice();
  inline void set_has_ailuafile();
  inline void clear_has_ailuafile();
  inline void set_has_atkatt();
  inline void clear_has_atkatt();
  inline void set_has_atkatttype();
  inline void clear_has_atkatttype();
  inline void set_has_walktype();
  inline void clear_has_walktype();
  inline void set_has_hurtactioncd();
  inline void clear_has_hurtactioncd();
  inline void set_has_dieanimation();
  inline void clear_has_dieanimation();
  inline void set_has_minwalkspeed();
  inline void clear_has_minwalkspeed();
  inline void set_has_maxwalkspeed();
  inline void clear_has_maxwalkspeed();
  inline void set_has_bubbleid();
  inline void clear_has_bubbleid();
  inline void set_has_hurtanimation();
  inline void clear_has_hurtanimation();
  inline void set_has_floorbuffid();
  inline void clear_has_floorbuffid();
  inline void set_has_aiid();
  inline void clear_has_aiid();
  inline void set_has_patrolarea();
  inline void clear_has_patrolarea();
  inline void set_has_hurtcolor();
  inline void clear_has_hurtcolor();
  inline void set_has_initscale();
  inline void clear_has_initscale();
  inline void set_has_isblock();
  inline void clear_has_isblock();
  inline void set_has_actions();
  inline void clear_has_actions();
  inline void set_has_dropcoin();
  inline void clear_has_dropcoin();
  inline void set_has_headimg();
  inline void clear_has_headimg();

  ::std::string* monstername_;
  ::std::string* desc_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 camp_;
  ::std::string* avatar_;
  ::google::protobuf::uint32 monstertype_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint64 hp_;
  ::google::protobuf::uint32 attack_;
  ::google::protobuf::uint32 defence_;
  ::google::protobuf::uint32 atktype_;
  ::google::protobuf::uint32 deftype_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > skills_;
  ::google::protobuf::uint32 ballistic_;
  ::google::protobuf::uint32 dropid_;
  ::std::string* emergevoice_;
  ::std::string* hurtvoice_;
  ::google::protobuf::uint32 highspeed_;
  ::google::protobuf::uint32 atkatt_;
  ::std::string* dievoice_;
  ::std::string* ailuafile_;
  ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::DefAttElement > defatts_;
  ::google::protobuf::uint32 atkatttype_;
  ::google::protobuf::uint32 walktype_;
  ::std::string* dieanimation_;
  ::google::protobuf::uint32 hurtactioncd_;
  ::google::protobuf::uint32 minwalkspeed_;
  ::google::protobuf::uint32 maxwalkspeed_;
  ::google::protobuf::uint32 bubbleid_;
  ::std::string* hurtanimation_;
  ::google::protobuf::uint32 floorbuffid_;
  ::google::protobuf::uint32 aiid_;
  ::google::protobuf::uint32 patrolarea_;
  ::google::protobuf::uint32 hurtcolor_;
  ::google::protobuf::uint32 initscale_;
  ::google::protobuf::uint32 isblock_;
  ::com::cfg::vo::Movement* actions_;
  ::std::string* headimg_;
  ::google::protobuf::uint32 dropcoin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(39 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MonsterCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MonsterCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_MonsterCfg_2eproto();
  friend void protobuf_ShutdownFile_MonsterCfg_2eproto();

  void InitAsDefaultInstance();
  static MonsterCfg* default_instance_;
};
// -------------------------------------------------------------------

class MonsterCfgSet : public ::google::protobuf::MessageLite {
 public:
  MonsterCfgSet();
  virtual ~MonsterCfgSet();

  MonsterCfgSet(const MonsterCfgSet& from);

  inline MonsterCfgSet& operator=(const MonsterCfgSet& from) {
    CopyFrom(from);
    return *this;
  }

  static const MonsterCfgSet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MonsterCfgSet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MonsterCfgSet* other);

  // implements Message ----------------------------------------------

  MonsterCfgSet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MonsterCfgSet& from);
  void MergeFrom(const MonsterCfgSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.cfg.vo.MonsterCfg monstercfg = 1;
  inline int monstercfg_size() const;
  inline void clear_monstercfg();
  static const int kMonstercfgFieldNumber = 1;
  inline const ::com::cfg::vo::MonsterCfg& monstercfg(int index) const;
  inline ::com::cfg::vo::MonsterCfg* mutable_monstercfg(int index);
  inline ::com::cfg::vo::MonsterCfg* add_monstercfg();
  inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::MonsterCfg >&
      monstercfg() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::MonsterCfg >*
      mutable_monstercfg();

  // @@protoc_insertion_point(class_scope:com.cfg.vo.MonsterCfgSet)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::MonsterCfg > monstercfg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MonsterCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MonsterCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_MonsterCfg_2eproto();
  friend void protobuf_ShutdownFile_MonsterCfg_2eproto();

  void InitAsDefaultInstance();
  static MonsterCfgSet* default_instance_;
};
// ===================================================================


// ===================================================================

// DefAttElement

// required uint32 defAtt = 1;
inline bool DefAttElement::has_defatt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DefAttElement::set_has_defatt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DefAttElement::clear_has_defatt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DefAttElement::clear_defatt() {
  defatt_ = 0u;
  clear_has_defatt();
}
inline ::google::protobuf::uint32 DefAttElement::defatt() const {
  return defatt_;
}
inline void DefAttElement::set_defatt(::google::protobuf::uint32 value) {
  set_has_defatt();
  defatt_ = value;
}

// required uint32 defAttType = 2;
inline bool DefAttElement::has_defatttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DefAttElement::set_has_defatttype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DefAttElement::clear_has_defatttype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DefAttElement::clear_defatttype() {
  defatttype_ = 0u;
  clear_has_defatttype();
}
inline ::google::protobuf::uint32 DefAttElement::defatttype() const {
  return defatttype_;
}
inline void DefAttElement::set_defatttype(::google::protobuf::uint32 value) {
  set_has_defatttype();
  defatttype_ = value;
}

// -------------------------------------------------------------------

// Movement

// required string emerge = 1;
inline bool Movement::has_emerge() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Movement::set_has_emerge() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Movement::clear_has_emerge() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Movement::clear_emerge() {
  if (emerge_ != &::google::protobuf::internal::kEmptyString) {
    emerge_->clear();
  }
  clear_has_emerge();
}
inline const ::std::string& Movement::emerge() const {
  return *emerge_;
}
inline void Movement::set_emerge(const ::std::string& value) {
  set_has_emerge();
  if (emerge_ == &::google::protobuf::internal::kEmptyString) {
    emerge_ = new ::std::string;
  }
  emerge_->assign(value);
}
inline void Movement::set_emerge(const char* value) {
  set_has_emerge();
  if (emerge_ == &::google::protobuf::internal::kEmptyString) {
    emerge_ = new ::std::string;
  }
  emerge_->assign(value);
}
inline void Movement::set_emerge(const char* value, size_t size) {
  set_has_emerge();
  if (emerge_ == &::google::protobuf::internal::kEmptyString) {
    emerge_ = new ::std::string;
  }
  emerge_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Movement::mutable_emerge() {
  set_has_emerge();
  if (emerge_ == &::google::protobuf::internal::kEmptyString) {
    emerge_ = new ::std::string;
  }
  return emerge_;
}
inline ::std::string* Movement::release_emerge() {
  clear_has_emerge();
  if (emerge_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = emerge_;
    emerge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Movement::set_allocated_emerge(::std::string* emerge) {
  if (emerge_ != &::google::protobuf::internal::kEmptyString) {
    delete emerge_;
  }
  if (emerge) {
    set_has_emerge();
    emerge_ = emerge;
  } else {
    clear_has_emerge();
    emerge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MonsterCfg

// required uint32 id = 1;
inline bool MonsterCfg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MonsterCfg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MonsterCfg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MonsterCfg::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 MonsterCfg::id() const {
  return id_;
}
inline void MonsterCfg::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required string monstername = 2;
inline bool MonsterCfg::has_monstername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MonsterCfg::set_has_monstername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MonsterCfg::clear_has_monstername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MonsterCfg::clear_monstername() {
  if (monstername_ != &::google::protobuf::internal::kEmptyString) {
    monstername_->clear();
  }
  clear_has_monstername();
}
inline const ::std::string& MonsterCfg::monstername() const {
  return *monstername_;
}
inline void MonsterCfg::set_monstername(const ::std::string& value) {
  set_has_monstername();
  if (monstername_ == &::google::protobuf::internal::kEmptyString) {
    monstername_ = new ::std::string;
  }
  monstername_->assign(value);
}
inline void MonsterCfg::set_monstername(const char* value) {
  set_has_monstername();
  if (monstername_ == &::google::protobuf::internal::kEmptyString) {
    monstername_ = new ::std::string;
  }
  monstername_->assign(value);
}
inline void MonsterCfg::set_monstername(const char* value, size_t size) {
  set_has_monstername();
  if (monstername_ == &::google::protobuf::internal::kEmptyString) {
    monstername_ = new ::std::string;
  }
  monstername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonsterCfg::mutable_monstername() {
  set_has_monstername();
  if (monstername_ == &::google::protobuf::internal::kEmptyString) {
    monstername_ = new ::std::string;
  }
  return monstername_;
}
inline ::std::string* MonsterCfg::release_monstername() {
  clear_has_monstername();
  if (monstername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = monstername_;
    monstername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonsterCfg::set_allocated_monstername(::std::string* monstername) {
  if (monstername_ != &::google::protobuf::internal::kEmptyString) {
    delete monstername_;
  }
  if (monstername) {
    set_has_monstername();
    monstername_ = monstername;
  } else {
    clear_has_monstername();
    monstername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string desc = 3;
inline bool MonsterCfg::has_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MonsterCfg::set_has_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MonsterCfg::clear_has_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MonsterCfg::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& MonsterCfg::desc() const {
  return *desc_;
}
inline void MonsterCfg::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void MonsterCfg::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void MonsterCfg::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonsterCfg::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* MonsterCfg::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonsterCfg::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string avatar = 4;
inline bool MonsterCfg::has_avatar() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MonsterCfg::set_has_avatar() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MonsterCfg::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MonsterCfg::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& MonsterCfg::avatar() const {
  return *avatar_;
}
inline void MonsterCfg::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void MonsterCfg::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void MonsterCfg::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonsterCfg::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* MonsterCfg::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonsterCfg::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 camp = 5;
inline bool MonsterCfg::has_camp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MonsterCfg::set_has_camp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MonsterCfg::clear_has_camp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MonsterCfg::clear_camp() {
  camp_ = 0u;
  clear_has_camp();
}
inline ::google::protobuf::uint32 MonsterCfg::camp() const {
  return camp_;
}
inline void MonsterCfg::set_camp(::google::protobuf::uint32 value) {
  set_has_camp();
  camp_ = value;
}

// required uint32 monstertype = 6;
inline bool MonsterCfg::has_monstertype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MonsterCfg::set_has_monstertype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MonsterCfg::clear_has_monstertype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MonsterCfg::clear_monstertype() {
  monstertype_ = 0u;
  clear_has_monstertype();
}
inline ::google::protobuf::uint32 MonsterCfg::monstertype() const {
  return monstertype_;
}
inline void MonsterCfg::set_monstertype(::google::protobuf::uint32 value) {
  set_has_monstertype();
  monstertype_ = value;
}

// required uint32 level = 7;
inline bool MonsterCfg::has_level() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MonsterCfg::set_has_level() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MonsterCfg::clear_has_level() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MonsterCfg::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 MonsterCfg::level() const {
  return level_;
}
inline void MonsterCfg::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// required uint64 hp = 8;
inline bool MonsterCfg::has_hp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MonsterCfg::set_has_hp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MonsterCfg::clear_has_hp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MonsterCfg::clear_hp() {
  hp_ = GOOGLE_ULONGLONG(0);
  clear_has_hp();
}
inline ::google::protobuf::uint64 MonsterCfg::hp() const {
  return hp_;
}
inline void MonsterCfg::set_hp(::google::protobuf::uint64 value) {
  set_has_hp();
  hp_ = value;
}

// required uint32 attack = 9;
inline bool MonsterCfg::has_attack() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MonsterCfg::set_has_attack() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MonsterCfg::clear_has_attack() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MonsterCfg::clear_attack() {
  attack_ = 0u;
  clear_has_attack();
}
inline ::google::protobuf::uint32 MonsterCfg::attack() const {
  return attack_;
}
inline void MonsterCfg::set_attack(::google::protobuf::uint32 value) {
  set_has_attack();
  attack_ = value;
}

// required uint32 defence = 10;
inline bool MonsterCfg::has_defence() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MonsterCfg::set_has_defence() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MonsterCfg::clear_has_defence() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MonsterCfg::clear_defence() {
  defence_ = 0u;
  clear_has_defence();
}
inline ::google::protobuf::uint32 MonsterCfg::defence() const {
  return defence_;
}
inline void MonsterCfg::set_defence(::google::protobuf::uint32 value) {
  set_has_defence();
  defence_ = value;
}

// required uint32 atktype = 11;
inline bool MonsterCfg::has_atktype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MonsterCfg::set_has_atktype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MonsterCfg::clear_has_atktype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MonsterCfg::clear_atktype() {
  atktype_ = 0u;
  clear_has_atktype();
}
inline ::google::protobuf::uint32 MonsterCfg::atktype() const {
  return atktype_;
}
inline void MonsterCfg::set_atktype(::google::protobuf::uint32 value) {
  set_has_atktype();
  atktype_ = value;
}

// required uint32 deftype = 12;
inline bool MonsterCfg::has_deftype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MonsterCfg::set_has_deftype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MonsterCfg::clear_has_deftype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MonsterCfg::clear_deftype() {
  deftype_ = 0u;
  clear_has_deftype();
}
inline ::google::protobuf::uint32 MonsterCfg::deftype() const {
  return deftype_;
}
inline void MonsterCfg::set_deftype(::google::protobuf::uint32 value) {
  set_has_deftype();
  deftype_ = value;
}

// required uint32 ballistic = 13;
inline bool MonsterCfg::has_ballistic() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MonsterCfg::set_has_ballistic() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MonsterCfg::clear_has_ballistic() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MonsterCfg::clear_ballistic() {
  ballistic_ = 0u;
  clear_has_ballistic();
}
inline ::google::protobuf::uint32 MonsterCfg::ballistic() const {
  return ballistic_;
}
inline void MonsterCfg::set_ballistic(::google::protobuf::uint32 value) {
  set_has_ballistic();
  ballistic_ = value;
}

// repeated uint32 skills = 14;
inline int MonsterCfg::skills_size() const {
  return skills_.size();
}
inline void MonsterCfg::clear_skills() {
  skills_.Clear();
}
inline ::google::protobuf::uint32 MonsterCfg::skills(int index) const {
  return skills_.Get(index);
}
inline void MonsterCfg::set_skills(int index, ::google::protobuf::uint32 value) {
  skills_.Set(index, value);
}
inline void MonsterCfg::add_skills(::google::protobuf::uint32 value) {
  skills_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MonsterCfg::skills() const {
  return skills_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MonsterCfg::mutable_skills() {
  return &skills_;
}

// required uint32 dropId = 15;
inline bool MonsterCfg::has_dropid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MonsterCfg::set_has_dropid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MonsterCfg::clear_has_dropid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MonsterCfg::clear_dropid() {
  dropid_ = 0u;
  clear_has_dropid();
}
inline ::google::protobuf::uint32 MonsterCfg::dropid() const {
  return dropid_;
}
inline void MonsterCfg::set_dropid(::google::protobuf::uint32 value) {
  set_has_dropid();
  dropid_ = value;
}

// required uint32 highSpeed = 17;
inline bool MonsterCfg::has_highspeed() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MonsterCfg::set_has_highspeed() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MonsterCfg::clear_has_highspeed() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MonsterCfg::clear_highspeed() {
  highspeed_ = 0u;
  clear_has_highspeed();
}
inline ::google::protobuf::uint32 MonsterCfg::highspeed() const {
  return highspeed_;
}
inline void MonsterCfg::set_highspeed(::google::protobuf::uint32 value) {
  set_has_highspeed();
  highspeed_ = value;
}

// required string emergeVoice = 18;
inline bool MonsterCfg::has_emergevoice() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MonsterCfg::set_has_emergevoice() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MonsterCfg::clear_has_emergevoice() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MonsterCfg::clear_emergevoice() {
  if (emergevoice_ != &::google::protobuf::internal::kEmptyString) {
    emergevoice_->clear();
  }
  clear_has_emergevoice();
}
inline const ::std::string& MonsterCfg::emergevoice() const {
  return *emergevoice_;
}
inline void MonsterCfg::set_emergevoice(const ::std::string& value) {
  set_has_emergevoice();
  if (emergevoice_ == &::google::protobuf::internal::kEmptyString) {
    emergevoice_ = new ::std::string;
  }
  emergevoice_->assign(value);
}
inline void MonsterCfg::set_emergevoice(const char* value) {
  set_has_emergevoice();
  if (emergevoice_ == &::google::protobuf::internal::kEmptyString) {
    emergevoice_ = new ::std::string;
  }
  emergevoice_->assign(value);
}
inline void MonsterCfg::set_emergevoice(const char* value, size_t size) {
  set_has_emergevoice();
  if (emergevoice_ == &::google::protobuf::internal::kEmptyString) {
    emergevoice_ = new ::std::string;
  }
  emergevoice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonsterCfg::mutable_emergevoice() {
  set_has_emergevoice();
  if (emergevoice_ == &::google::protobuf::internal::kEmptyString) {
    emergevoice_ = new ::std::string;
  }
  return emergevoice_;
}
inline ::std::string* MonsterCfg::release_emergevoice() {
  clear_has_emergevoice();
  if (emergevoice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = emergevoice_;
    emergevoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonsterCfg::set_allocated_emergevoice(::std::string* emergevoice) {
  if (emergevoice_ != &::google::protobuf::internal::kEmptyString) {
    delete emergevoice_;
  }
  if (emergevoice) {
    set_has_emergevoice();
    emergevoice_ = emergevoice;
  } else {
    clear_has_emergevoice();
    emergevoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string hurtVoice = 19;
inline bool MonsterCfg::has_hurtvoice() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MonsterCfg::set_has_hurtvoice() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MonsterCfg::clear_has_hurtvoice() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MonsterCfg::clear_hurtvoice() {
  if (hurtvoice_ != &::google::protobuf::internal::kEmptyString) {
    hurtvoice_->clear();
  }
  clear_has_hurtvoice();
}
inline const ::std::string& MonsterCfg::hurtvoice() const {
  return *hurtvoice_;
}
inline void MonsterCfg::set_hurtvoice(const ::std::string& value) {
  set_has_hurtvoice();
  if (hurtvoice_ == &::google::protobuf::internal::kEmptyString) {
    hurtvoice_ = new ::std::string;
  }
  hurtvoice_->assign(value);
}
inline void MonsterCfg::set_hurtvoice(const char* value) {
  set_has_hurtvoice();
  if (hurtvoice_ == &::google::protobuf::internal::kEmptyString) {
    hurtvoice_ = new ::std::string;
  }
  hurtvoice_->assign(value);
}
inline void MonsterCfg::set_hurtvoice(const char* value, size_t size) {
  set_has_hurtvoice();
  if (hurtvoice_ == &::google::protobuf::internal::kEmptyString) {
    hurtvoice_ = new ::std::string;
  }
  hurtvoice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonsterCfg::mutable_hurtvoice() {
  set_has_hurtvoice();
  if (hurtvoice_ == &::google::protobuf::internal::kEmptyString) {
    hurtvoice_ = new ::std::string;
  }
  return hurtvoice_;
}
inline ::std::string* MonsterCfg::release_hurtvoice() {
  clear_has_hurtvoice();
  if (hurtvoice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hurtvoice_;
    hurtvoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonsterCfg::set_allocated_hurtvoice(::std::string* hurtvoice) {
  if (hurtvoice_ != &::google::protobuf::internal::kEmptyString) {
    delete hurtvoice_;
  }
  if (hurtvoice) {
    set_has_hurtvoice();
    hurtvoice_ = hurtvoice;
  } else {
    clear_has_hurtvoice();
    hurtvoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string dieVoice = 20;
inline bool MonsterCfg::has_dievoice() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MonsterCfg::set_has_dievoice() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MonsterCfg::clear_has_dievoice() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MonsterCfg::clear_dievoice() {
  if (dievoice_ != &::google::protobuf::internal::kEmptyString) {
    dievoice_->clear();
  }
  clear_has_dievoice();
}
inline const ::std::string& MonsterCfg::dievoice() const {
  return *dievoice_;
}
inline void MonsterCfg::set_dievoice(const ::std::string& value) {
  set_has_dievoice();
  if (dievoice_ == &::google::protobuf::internal::kEmptyString) {
    dievoice_ = new ::std::string;
  }
  dievoice_->assign(value);
}
inline void MonsterCfg::set_dievoice(const char* value) {
  set_has_dievoice();
  if (dievoice_ == &::google::protobuf::internal::kEmptyString) {
    dievoice_ = new ::std::string;
  }
  dievoice_->assign(value);
}
inline void MonsterCfg::set_dievoice(const char* value, size_t size) {
  set_has_dievoice();
  if (dievoice_ == &::google::protobuf::internal::kEmptyString) {
    dievoice_ = new ::std::string;
  }
  dievoice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonsterCfg::mutable_dievoice() {
  set_has_dievoice();
  if (dievoice_ == &::google::protobuf::internal::kEmptyString) {
    dievoice_ = new ::std::string;
  }
  return dievoice_;
}
inline ::std::string* MonsterCfg::release_dievoice() {
  clear_has_dievoice();
  if (dievoice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dievoice_;
    dievoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonsterCfg::set_allocated_dievoice(::std::string* dievoice) {
  if (dievoice_ != &::google::protobuf::internal::kEmptyString) {
    delete dievoice_;
  }
  if (dievoice) {
    set_has_dievoice();
    dievoice_ = dievoice;
  } else {
    clear_has_dievoice();
    dievoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string aiLuaFile = 21;
inline bool MonsterCfg::has_ailuafile() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MonsterCfg::set_has_ailuafile() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MonsterCfg::clear_has_ailuafile() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MonsterCfg::clear_ailuafile() {
  if (ailuafile_ != &::google::protobuf::internal::kEmptyString) {
    ailuafile_->clear();
  }
  clear_has_ailuafile();
}
inline const ::std::string& MonsterCfg::ailuafile() const {
  return *ailuafile_;
}
inline void MonsterCfg::set_ailuafile(const ::std::string& value) {
  set_has_ailuafile();
  if (ailuafile_ == &::google::protobuf::internal::kEmptyString) {
    ailuafile_ = new ::std::string;
  }
  ailuafile_->assign(value);
}
inline void MonsterCfg::set_ailuafile(const char* value) {
  set_has_ailuafile();
  if (ailuafile_ == &::google::protobuf::internal::kEmptyString) {
    ailuafile_ = new ::std::string;
  }
  ailuafile_->assign(value);
}
inline void MonsterCfg::set_ailuafile(const char* value, size_t size) {
  set_has_ailuafile();
  if (ailuafile_ == &::google::protobuf::internal::kEmptyString) {
    ailuafile_ = new ::std::string;
  }
  ailuafile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonsterCfg::mutable_ailuafile() {
  set_has_ailuafile();
  if (ailuafile_ == &::google::protobuf::internal::kEmptyString) {
    ailuafile_ = new ::std::string;
  }
  return ailuafile_;
}
inline ::std::string* MonsterCfg::release_ailuafile() {
  clear_has_ailuafile();
  if (ailuafile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ailuafile_;
    ailuafile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonsterCfg::set_allocated_ailuafile(::std::string* ailuafile) {
  if (ailuafile_ != &::google::protobuf::internal::kEmptyString) {
    delete ailuafile_;
  }
  if (ailuafile) {
    set_has_ailuafile();
    ailuafile_ = ailuafile;
  } else {
    clear_has_ailuafile();
    ailuafile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 atkAtt = 22;
inline bool MonsterCfg::has_atkatt() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MonsterCfg::set_has_atkatt() {
  _has_bits_[0] |= 0x00100000u;
}
inline void MonsterCfg::clear_has_atkatt() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void MonsterCfg::clear_atkatt() {
  atkatt_ = 0u;
  clear_has_atkatt();
}
inline ::google::protobuf::uint32 MonsterCfg::atkatt() const {
  return atkatt_;
}
inline void MonsterCfg::set_atkatt(::google::protobuf::uint32 value) {
  set_has_atkatt();
  atkatt_ = value;
}

// required uint32 atkAttType = 23;
inline bool MonsterCfg::has_atkatttype() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void MonsterCfg::set_has_atkatttype() {
  _has_bits_[0] |= 0x00200000u;
}
inline void MonsterCfg::clear_has_atkatttype() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void MonsterCfg::clear_atkatttype() {
  atkatttype_ = 0u;
  clear_has_atkatttype();
}
inline ::google::protobuf::uint32 MonsterCfg::atkatttype() const {
  return atkatttype_;
}
inline void MonsterCfg::set_atkatttype(::google::protobuf::uint32 value) {
  set_has_atkatttype();
  atkatttype_ = value;
}

// repeated .com.cfg.vo.DefAttElement defAtts = 24;
inline int MonsterCfg::defatts_size() const {
  return defatts_.size();
}
inline void MonsterCfg::clear_defatts() {
  defatts_.Clear();
}
inline const ::com::cfg::vo::DefAttElement& MonsterCfg::defatts(int index) const {
  return defatts_.Get(index);
}
inline ::com::cfg::vo::DefAttElement* MonsterCfg::mutable_defatts(int index) {
  return defatts_.Mutable(index);
}
inline ::com::cfg::vo::DefAttElement* MonsterCfg::add_defatts() {
  return defatts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::DefAttElement >&
MonsterCfg::defatts() const {
  return defatts_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::DefAttElement >*
MonsterCfg::mutable_defatts() {
  return &defatts_;
}

// required uint32 walkType = 25;
inline bool MonsterCfg::has_walktype() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void MonsterCfg::set_has_walktype() {
  _has_bits_[0] |= 0x00800000u;
}
inline void MonsterCfg::clear_has_walktype() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void MonsterCfg::clear_walktype() {
  walktype_ = 0u;
  clear_has_walktype();
}
inline ::google::protobuf::uint32 MonsterCfg::walktype() const {
  return walktype_;
}
inline void MonsterCfg::set_walktype(::google::protobuf::uint32 value) {
  set_has_walktype();
  walktype_ = value;
}

// required uint32 hurtActionCD = 26;
inline bool MonsterCfg::has_hurtactioncd() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void MonsterCfg::set_has_hurtactioncd() {
  _has_bits_[0] |= 0x01000000u;
}
inline void MonsterCfg::clear_has_hurtactioncd() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void MonsterCfg::clear_hurtactioncd() {
  hurtactioncd_ = 0u;
  clear_has_hurtactioncd();
}
inline ::google::protobuf::uint32 MonsterCfg::hurtactioncd() const {
  return hurtactioncd_;
}
inline void MonsterCfg::set_hurtactioncd(::google::protobuf::uint32 value) {
  set_has_hurtactioncd();
  hurtactioncd_ = value;
}

// required string dieAnimation = 27;
inline bool MonsterCfg::has_dieanimation() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void MonsterCfg::set_has_dieanimation() {
  _has_bits_[0] |= 0x02000000u;
}
inline void MonsterCfg::clear_has_dieanimation() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void MonsterCfg::clear_dieanimation() {
  if (dieanimation_ != &::google::protobuf::internal::kEmptyString) {
    dieanimation_->clear();
  }
  clear_has_dieanimation();
}
inline const ::std::string& MonsterCfg::dieanimation() const {
  return *dieanimation_;
}
inline void MonsterCfg::set_dieanimation(const ::std::string& value) {
  set_has_dieanimation();
  if (dieanimation_ == &::google::protobuf::internal::kEmptyString) {
    dieanimation_ = new ::std::string;
  }
  dieanimation_->assign(value);
}
inline void MonsterCfg::set_dieanimation(const char* value) {
  set_has_dieanimation();
  if (dieanimation_ == &::google::protobuf::internal::kEmptyString) {
    dieanimation_ = new ::std::string;
  }
  dieanimation_->assign(value);
}
inline void MonsterCfg::set_dieanimation(const char* value, size_t size) {
  set_has_dieanimation();
  if (dieanimation_ == &::google::protobuf::internal::kEmptyString) {
    dieanimation_ = new ::std::string;
  }
  dieanimation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonsterCfg::mutable_dieanimation() {
  set_has_dieanimation();
  if (dieanimation_ == &::google::protobuf::internal::kEmptyString) {
    dieanimation_ = new ::std::string;
  }
  return dieanimation_;
}
inline ::std::string* MonsterCfg::release_dieanimation() {
  clear_has_dieanimation();
  if (dieanimation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dieanimation_;
    dieanimation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonsterCfg::set_allocated_dieanimation(::std::string* dieanimation) {
  if (dieanimation_ != &::google::protobuf::internal::kEmptyString) {
    delete dieanimation_;
  }
  if (dieanimation) {
    set_has_dieanimation();
    dieanimation_ = dieanimation;
  } else {
    clear_has_dieanimation();
    dieanimation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 minWalkSpeed = 28;
inline bool MonsterCfg::has_minwalkspeed() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void MonsterCfg::set_has_minwalkspeed() {
  _has_bits_[0] |= 0x04000000u;
}
inline void MonsterCfg::clear_has_minwalkspeed() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void MonsterCfg::clear_minwalkspeed() {
  minwalkspeed_ = 0u;
  clear_has_minwalkspeed();
}
inline ::google::protobuf::uint32 MonsterCfg::minwalkspeed() const {
  return minwalkspeed_;
}
inline void MonsterCfg::set_minwalkspeed(::google::protobuf::uint32 value) {
  set_has_minwalkspeed();
  minwalkspeed_ = value;
}

// required uint32 maxWalkSpeed = 29;
inline bool MonsterCfg::has_maxwalkspeed() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void MonsterCfg::set_has_maxwalkspeed() {
  _has_bits_[0] |= 0x08000000u;
}
inline void MonsterCfg::clear_has_maxwalkspeed() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void MonsterCfg::clear_maxwalkspeed() {
  maxwalkspeed_ = 0u;
  clear_has_maxwalkspeed();
}
inline ::google::protobuf::uint32 MonsterCfg::maxwalkspeed() const {
  return maxwalkspeed_;
}
inline void MonsterCfg::set_maxwalkspeed(::google::protobuf::uint32 value) {
  set_has_maxwalkspeed();
  maxwalkspeed_ = value;
}

// required uint32 bubbleId = 30;
inline bool MonsterCfg::has_bubbleid() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void MonsterCfg::set_has_bubbleid() {
  _has_bits_[0] |= 0x10000000u;
}
inline void MonsterCfg::clear_has_bubbleid() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void MonsterCfg::clear_bubbleid() {
  bubbleid_ = 0u;
  clear_has_bubbleid();
}
inline ::google::protobuf::uint32 MonsterCfg::bubbleid() const {
  return bubbleid_;
}
inline void MonsterCfg::set_bubbleid(::google::protobuf::uint32 value) {
  set_has_bubbleid();
  bubbleid_ = value;
}

// required string hurtAnimation = 31;
inline bool MonsterCfg::has_hurtanimation() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void MonsterCfg::set_has_hurtanimation() {
  _has_bits_[0] |= 0x20000000u;
}
inline void MonsterCfg::clear_has_hurtanimation() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void MonsterCfg::clear_hurtanimation() {
  if (hurtanimation_ != &::google::protobuf::internal::kEmptyString) {
    hurtanimation_->clear();
  }
  clear_has_hurtanimation();
}
inline const ::std::string& MonsterCfg::hurtanimation() const {
  return *hurtanimation_;
}
inline void MonsterCfg::set_hurtanimation(const ::std::string& value) {
  set_has_hurtanimation();
  if (hurtanimation_ == &::google::protobuf::internal::kEmptyString) {
    hurtanimation_ = new ::std::string;
  }
  hurtanimation_->assign(value);
}
inline void MonsterCfg::set_hurtanimation(const char* value) {
  set_has_hurtanimation();
  if (hurtanimation_ == &::google::protobuf::internal::kEmptyString) {
    hurtanimation_ = new ::std::string;
  }
  hurtanimation_->assign(value);
}
inline void MonsterCfg::set_hurtanimation(const char* value, size_t size) {
  set_has_hurtanimation();
  if (hurtanimation_ == &::google::protobuf::internal::kEmptyString) {
    hurtanimation_ = new ::std::string;
  }
  hurtanimation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonsterCfg::mutable_hurtanimation() {
  set_has_hurtanimation();
  if (hurtanimation_ == &::google::protobuf::internal::kEmptyString) {
    hurtanimation_ = new ::std::string;
  }
  return hurtanimation_;
}
inline ::std::string* MonsterCfg::release_hurtanimation() {
  clear_has_hurtanimation();
  if (hurtanimation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hurtanimation_;
    hurtanimation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonsterCfg::set_allocated_hurtanimation(::std::string* hurtanimation) {
  if (hurtanimation_ != &::google::protobuf::internal::kEmptyString) {
    delete hurtanimation_;
  }
  if (hurtanimation) {
    set_has_hurtanimation();
    hurtanimation_ = hurtanimation;
  } else {
    clear_has_hurtanimation();
    hurtanimation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 floorBuffId = 32;
inline bool MonsterCfg::has_floorbuffid() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void MonsterCfg::set_has_floorbuffid() {
  _has_bits_[0] |= 0x40000000u;
}
inline void MonsterCfg::clear_has_floorbuffid() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void MonsterCfg::clear_floorbuffid() {
  floorbuffid_ = 0u;
  clear_has_floorbuffid();
}
inline ::google::protobuf::uint32 MonsterCfg::floorbuffid() const {
  return floorbuffid_;
}
inline void MonsterCfg::set_floorbuffid(::google::protobuf::uint32 value) {
  set_has_floorbuffid();
  floorbuffid_ = value;
}

// required uint32 aiID = 33;
inline bool MonsterCfg::has_aiid() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void MonsterCfg::set_has_aiid() {
  _has_bits_[0] |= 0x80000000u;
}
inline void MonsterCfg::clear_has_aiid() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void MonsterCfg::clear_aiid() {
  aiid_ = 0u;
  clear_has_aiid();
}
inline ::google::protobuf::uint32 MonsterCfg::aiid() const {
  return aiid_;
}
inline void MonsterCfg::set_aiid(::google::protobuf::uint32 value) {
  set_has_aiid();
  aiid_ = value;
}

// required uint32 patrolArea = 34;
inline bool MonsterCfg::has_patrolarea() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void MonsterCfg::set_has_patrolarea() {
  _has_bits_[1] |= 0x00000001u;
}
inline void MonsterCfg::clear_has_patrolarea() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void MonsterCfg::clear_patrolarea() {
  patrolarea_ = 0u;
  clear_has_patrolarea();
}
inline ::google::protobuf::uint32 MonsterCfg::patrolarea() const {
  return patrolarea_;
}
inline void MonsterCfg::set_patrolarea(::google::protobuf::uint32 value) {
  set_has_patrolarea();
  patrolarea_ = value;
}

// required uint32 HurtColor = 35;
inline bool MonsterCfg::has_hurtcolor() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void MonsterCfg::set_has_hurtcolor() {
  _has_bits_[1] |= 0x00000002u;
}
inline void MonsterCfg::clear_has_hurtcolor() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void MonsterCfg::clear_hurtcolor() {
  hurtcolor_ = 0u;
  clear_has_hurtcolor();
}
inline ::google::protobuf::uint32 MonsterCfg::hurtcolor() const {
  return hurtcolor_;
}
inline void MonsterCfg::set_hurtcolor(::google::protobuf::uint32 value) {
  set_has_hurtcolor();
  hurtcolor_ = value;
}

// required uint32 InitScale = 36;
inline bool MonsterCfg::has_initscale() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void MonsterCfg::set_has_initscale() {
  _has_bits_[1] |= 0x00000004u;
}
inline void MonsterCfg::clear_has_initscale() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void MonsterCfg::clear_initscale() {
  initscale_ = 0u;
  clear_has_initscale();
}
inline ::google::protobuf::uint32 MonsterCfg::initscale() const {
  return initscale_;
}
inline void MonsterCfg::set_initscale(::google::protobuf::uint32 value) {
  set_has_initscale();
  initscale_ = value;
}

// required uint32 IsBlock = 37;
inline bool MonsterCfg::has_isblock() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void MonsterCfg::set_has_isblock() {
  _has_bits_[1] |= 0x00000008u;
}
inline void MonsterCfg::clear_has_isblock() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void MonsterCfg::clear_isblock() {
  isblock_ = 0u;
  clear_has_isblock();
}
inline ::google::protobuf::uint32 MonsterCfg::isblock() const {
  return isblock_;
}
inline void MonsterCfg::set_isblock(::google::protobuf::uint32 value) {
  set_has_isblock();
  isblock_ = value;
}

// required .com.cfg.vo.Movement actions = 38;
inline bool MonsterCfg::has_actions() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void MonsterCfg::set_has_actions() {
  _has_bits_[1] |= 0x00000010u;
}
inline void MonsterCfg::clear_has_actions() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void MonsterCfg::clear_actions() {
  if (actions_ != NULL) actions_->::com::cfg::vo::Movement::Clear();
  clear_has_actions();
}
inline const ::com::cfg::vo::Movement& MonsterCfg::actions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return actions_ != NULL ? *actions_ : *default_instance().actions_;
#else
  return actions_ != NULL ? *actions_ : *default_instance_->actions_;
#endif
}
inline ::com::cfg::vo::Movement* MonsterCfg::mutable_actions() {
  set_has_actions();
  if (actions_ == NULL) actions_ = new ::com::cfg::vo::Movement;
  return actions_;
}
inline ::com::cfg::vo::Movement* MonsterCfg::release_actions() {
  clear_has_actions();
  ::com::cfg::vo::Movement* temp = actions_;
  actions_ = NULL;
  return temp;
}
inline void MonsterCfg::set_allocated_actions(::com::cfg::vo::Movement* actions) {
  delete actions_;
  actions_ = actions;
  if (actions) {
    set_has_actions();
  } else {
    clear_has_actions();
  }
}

// required uint32 dropCoin = 39;
inline bool MonsterCfg::has_dropcoin() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void MonsterCfg::set_has_dropcoin() {
  _has_bits_[1] |= 0x00000020u;
}
inline void MonsterCfg::clear_has_dropcoin() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void MonsterCfg::clear_dropcoin() {
  dropcoin_ = 0u;
  clear_has_dropcoin();
}
inline ::google::protobuf::uint32 MonsterCfg::dropcoin() const {
  return dropcoin_;
}
inline void MonsterCfg::set_dropcoin(::google::protobuf::uint32 value) {
  set_has_dropcoin();
  dropcoin_ = value;
}

// required string headImg = 40;
inline bool MonsterCfg::has_headimg() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void MonsterCfg::set_has_headimg() {
  _has_bits_[1] |= 0x00000040u;
}
inline void MonsterCfg::clear_has_headimg() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void MonsterCfg::clear_headimg() {
  if (headimg_ != &::google::protobuf::internal::kEmptyString) {
    headimg_->clear();
  }
  clear_has_headimg();
}
inline const ::std::string& MonsterCfg::headimg() const {
  return *headimg_;
}
inline void MonsterCfg::set_headimg(const ::std::string& value) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(value);
}
inline void MonsterCfg::set_headimg(const char* value) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(value);
}
inline void MonsterCfg::set_headimg(const char* value, size_t size) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonsterCfg::mutable_headimg() {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  return headimg_;
}
inline ::std::string* MonsterCfg::release_headimg() {
  clear_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headimg_;
    headimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonsterCfg::set_allocated_headimg(::std::string* headimg) {
  if (headimg_ != &::google::protobuf::internal::kEmptyString) {
    delete headimg_;
  }
  if (headimg) {
    set_has_headimg();
    headimg_ = headimg;
  } else {
    clear_has_headimg();
    headimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MonsterCfgSet

// repeated .com.cfg.vo.MonsterCfg monstercfg = 1;
inline int MonsterCfgSet::monstercfg_size() const {
  return monstercfg_.size();
}
inline void MonsterCfgSet::clear_monstercfg() {
  monstercfg_.Clear();
}
inline const ::com::cfg::vo::MonsterCfg& MonsterCfgSet::monstercfg(int index) const {
  return monstercfg_.Get(index);
}
inline ::com::cfg::vo::MonsterCfg* MonsterCfgSet::mutable_monstercfg(int index) {
  return monstercfg_.Mutable(index);
}
inline ::com::cfg::vo::MonsterCfg* MonsterCfgSet::add_monstercfg() {
  return monstercfg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::MonsterCfg >&
MonsterCfgSet::monstercfg() const {
  return monstercfg_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::MonsterCfg >*
MonsterCfgSet::mutable_monstercfg() {
  return &monstercfg_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vo
}  // namespace cfg
}  // namespace com

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MonsterCfg_2eproto__INCLUDED
