// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: WeaponArrayEffCfg.proto

#ifndef PROTOBUF_WeaponArrayEffCfg_2eproto__INCLUDED
#define PROTOBUF_WeaponArrayEffCfg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace cfg {
namespace vo {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_WeaponArrayEffCfg_2eproto();
void protobuf_AssignDesc_WeaponArrayEffCfg_2eproto();
void protobuf_ShutdownFile_WeaponArrayEffCfg_2eproto();

class EffectElmt;
class WeaponArrayEffCfg;
class WeaponArrayEffCfgSet;

// ===================================================================

class EffectElmt : public ::google::protobuf::MessageLite {
 public:
  EffectElmt();
  virtual ~EffectElmt();

  EffectElmt(const EffectElmt& from);

  inline EffectElmt& operator=(const EffectElmt& from) {
    CopyFrom(from);
    return *this;
  }

  static const EffectElmt& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EffectElmt* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EffectElmt* other);

  // implements Message ----------------------------------------------

  EffectElmt* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EffectElmt& from);
  void MergeFrom(const EffectElmt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 EffType = 1;
  inline bool has_efftype() const;
  inline void clear_efftype();
  static const int kEffTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 efftype() const;
  inline void set_efftype(::google::protobuf::uint32 value);

  // required uint32 EffVal = 2;
  inline bool has_effval() const;
  inline void clear_effval();
  static const int kEffValFieldNumber = 2;
  inline ::google::protobuf::uint32 effval() const;
  inline void set_effval(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.cfg.vo.EffectElmt)
 private:
  inline void set_has_efftype();
  inline void clear_has_efftype();
  inline void set_has_effval();
  inline void clear_has_effval();

  ::google::protobuf::uint32 efftype_;
  ::google::protobuf::uint32 effval_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_WeaponArrayEffCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_WeaponArrayEffCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_WeaponArrayEffCfg_2eproto();
  friend void protobuf_ShutdownFile_WeaponArrayEffCfg_2eproto();

  void InitAsDefaultInstance();
  static EffectElmt* default_instance_;
};
// -------------------------------------------------------------------

class WeaponArrayEffCfg : public ::google::protobuf::MessageLite {
 public:
  WeaponArrayEffCfg();
  virtual ~WeaponArrayEffCfg();

  WeaponArrayEffCfg(const WeaponArrayEffCfg& from);

  inline WeaponArrayEffCfg& operator=(const WeaponArrayEffCfg& from) {
    CopyFrom(from);
    return *this;
  }

  static const WeaponArrayEffCfg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WeaponArrayEffCfg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WeaponArrayEffCfg* other);

  // implements Message ----------------------------------------------

  WeaponArrayEffCfg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WeaponArrayEffCfg& from);
  void MergeFrom(const WeaponArrayEffCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Idx = 1;
  inline bool has_idx() const;
  inline void clear_idx();
  static const int kIdxFieldNumber = 1;
  inline ::google::protobuf::uint32 idx() const;
  inline void set_idx(::google::protobuf::uint32 value);

  // required uint32 WeaponStar = 2;
  inline bool has_weaponstar() const;
  inline void clear_weaponstar();
  static const int kWeaponStarFieldNumber = 2;
  inline ::google::protobuf::uint32 weaponstar() const;
  inline void set_weaponstar(::google::protobuf::uint32 value);

  // required uint32 WeaponStep = 3;
  inline bool has_weaponstep() const;
  inline void clear_weaponstep();
  static const int kWeaponStepFieldNumber = 3;
  inline ::google::protobuf::uint32 weaponstep() const;
  inline void set_weaponstep(::google::protobuf::uint32 value);

  // required uint32 HPAdd = 4;
  inline bool has_hpadd() const;
  inline void clear_hpadd();
  static const int kHPAddFieldNumber = 4;
  inline ::google::protobuf::uint32 hpadd() const;
  inline void set_hpadd(::google::protobuf::uint32 value);

  // required uint32 AtkAdd = 5;
  inline bool has_atkadd() const;
  inline void clear_atkadd();
  static const int kAtkAddFieldNumber = 5;
  inline ::google::protobuf::uint32 atkadd() const;
  inline void set_atkadd(::google::protobuf::uint32 value);

  // required uint32 DefAdd = 6;
  inline bool has_defadd() const;
  inline void clear_defadd();
  static const int kDefAddFieldNumber = 6;
  inline ::google::protobuf::uint32 defadd() const;
  inline void set_defadd(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.cfg.vo.WeaponArrayEffCfg)
 private:
  inline void set_has_idx();
  inline void clear_has_idx();
  inline void set_has_weaponstar();
  inline void clear_has_weaponstar();
  inline void set_has_weaponstep();
  inline void clear_has_weaponstep();
  inline void set_has_hpadd();
  inline void clear_has_hpadd();
  inline void set_has_atkadd();
  inline void clear_has_atkadd();
  inline void set_has_defadd();
  inline void clear_has_defadd();

  ::google::protobuf::uint32 idx_;
  ::google::protobuf::uint32 weaponstar_;
  ::google::protobuf::uint32 weaponstep_;
  ::google::protobuf::uint32 hpadd_;
  ::google::protobuf::uint32 atkadd_;
  ::google::protobuf::uint32 defadd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_WeaponArrayEffCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_WeaponArrayEffCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_WeaponArrayEffCfg_2eproto();
  friend void protobuf_ShutdownFile_WeaponArrayEffCfg_2eproto();

  void InitAsDefaultInstance();
  static WeaponArrayEffCfg* default_instance_;
};
// -------------------------------------------------------------------

class WeaponArrayEffCfgSet : public ::google::protobuf::MessageLite {
 public:
  WeaponArrayEffCfgSet();
  virtual ~WeaponArrayEffCfgSet();

  WeaponArrayEffCfgSet(const WeaponArrayEffCfgSet& from);

  inline WeaponArrayEffCfgSet& operator=(const WeaponArrayEffCfgSet& from) {
    CopyFrom(from);
    return *this;
  }

  static const WeaponArrayEffCfgSet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WeaponArrayEffCfgSet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WeaponArrayEffCfgSet* other);

  // implements Message ----------------------------------------------

  WeaponArrayEffCfgSet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WeaponArrayEffCfgSet& from);
  void MergeFrom(const WeaponArrayEffCfgSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.cfg.vo.WeaponArrayEffCfg effects = 1;
  inline int effects_size() const;
  inline void clear_effects();
  static const int kEffectsFieldNumber = 1;
  inline const ::com::cfg::vo::WeaponArrayEffCfg& effects(int index) const;
  inline ::com::cfg::vo::WeaponArrayEffCfg* mutable_effects(int index);
  inline ::com::cfg::vo::WeaponArrayEffCfg* add_effects();
  inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::WeaponArrayEffCfg >&
      effects() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::WeaponArrayEffCfg >*
      mutable_effects();

  // @@protoc_insertion_point(class_scope:com.cfg.vo.WeaponArrayEffCfgSet)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::WeaponArrayEffCfg > effects_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_WeaponArrayEffCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_WeaponArrayEffCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_WeaponArrayEffCfg_2eproto();
  friend void protobuf_ShutdownFile_WeaponArrayEffCfg_2eproto();

  void InitAsDefaultInstance();
  static WeaponArrayEffCfgSet* default_instance_;
};
// ===================================================================


// ===================================================================

// EffectElmt

// required uint32 EffType = 1;
inline bool EffectElmt::has_efftype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EffectElmt::set_has_efftype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EffectElmt::clear_has_efftype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EffectElmt::clear_efftype() {
  efftype_ = 0u;
  clear_has_efftype();
}
inline ::google::protobuf::uint32 EffectElmt::efftype() const {
  return efftype_;
}
inline void EffectElmt::set_efftype(::google::protobuf::uint32 value) {
  set_has_efftype();
  efftype_ = value;
}

// required uint32 EffVal = 2;
inline bool EffectElmt::has_effval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EffectElmt::set_has_effval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EffectElmt::clear_has_effval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EffectElmt::clear_effval() {
  effval_ = 0u;
  clear_has_effval();
}
inline ::google::protobuf::uint32 EffectElmt::effval() const {
  return effval_;
}
inline void EffectElmt::set_effval(::google::protobuf::uint32 value) {
  set_has_effval();
  effval_ = value;
}

// -------------------------------------------------------------------

// WeaponArrayEffCfg

// required uint32 Idx = 1;
inline bool WeaponArrayEffCfg::has_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeaponArrayEffCfg::set_has_idx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeaponArrayEffCfg::clear_has_idx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeaponArrayEffCfg::clear_idx() {
  idx_ = 0u;
  clear_has_idx();
}
inline ::google::protobuf::uint32 WeaponArrayEffCfg::idx() const {
  return idx_;
}
inline void WeaponArrayEffCfg::set_idx(::google::protobuf::uint32 value) {
  set_has_idx();
  idx_ = value;
}

// required uint32 WeaponStar = 2;
inline bool WeaponArrayEffCfg::has_weaponstar() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeaponArrayEffCfg::set_has_weaponstar() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeaponArrayEffCfg::clear_has_weaponstar() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeaponArrayEffCfg::clear_weaponstar() {
  weaponstar_ = 0u;
  clear_has_weaponstar();
}
inline ::google::protobuf::uint32 WeaponArrayEffCfg::weaponstar() const {
  return weaponstar_;
}
inline void WeaponArrayEffCfg::set_weaponstar(::google::protobuf::uint32 value) {
  set_has_weaponstar();
  weaponstar_ = value;
}

// required uint32 WeaponStep = 3;
inline bool WeaponArrayEffCfg::has_weaponstep() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WeaponArrayEffCfg::set_has_weaponstep() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WeaponArrayEffCfg::clear_has_weaponstep() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WeaponArrayEffCfg::clear_weaponstep() {
  weaponstep_ = 0u;
  clear_has_weaponstep();
}
inline ::google::protobuf::uint32 WeaponArrayEffCfg::weaponstep() const {
  return weaponstep_;
}
inline void WeaponArrayEffCfg::set_weaponstep(::google::protobuf::uint32 value) {
  set_has_weaponstep();
  weaponstep_ = value;
}

// required uint32 HPAdd = 4;
inline bool WeaponArrayEffCfg::has_hpadd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WeaponArrayEffCfg::set_has_hpadd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WeaponArrayEffCfg::clear_has_hpadd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WeaponArrayEffCfg::clear_hpadd() {
  hpadd_ = 0u;
  clear_has_hpadd();
}
inline ::google::protobuf::uint32 WeaponArrayEffCfg::hpadd() const {
  return hpadd_;
}
inline void WeaponArrayEffCfg::set_hpadd(::google::protobuf::uint32 value) {
  set_has_hpadd();
  hpadd_ = value;
}

// required uint32 AtkAdd = 5;
inline bool WeaponArrayEffCfg::has_atkadd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WeaponArrayEffCfg::set_has_atkadd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WeaponArrayEffCfg::clear_has_atkadd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WeaponArrayEffCfg::clear_atkadd() {
  atkadd_ = 0u;
  clear_has_atkadd();
}
inline ::google::protobuf::uint32 WeaponArrayEffCfg::atkadd() const {
  return atkadd_;
}
inline void WeaponArrayEffCfg::set_atkadd(::google::protobuf::uint32 value) {
  set_has_atkadd();
  atkadd_ = value;
}

// required uint32 DefAdd = 6;
inline bool WeaponArrayEffCfg::has_defadd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WeaponArrayEffCfg::set_has_defadd() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WeaponArrayEffCfg::clear_has_defadd() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WeaponArrayEffCfg::clear_defadd() {
  defadd_ = 0u;
  clear_has_defadd();
}
inline ::google::protobuf::uint32 WeaponArrayEffCfg::defadd() const {
  return defadd_;
}
inline void WeaponArrayEffCfg::set_defadd(::google::protobuf::uint32 value) {
  set_has_defadd();
  defadd_ = value;
}

// -------------------------------------------------------------------

// WeaponArrayEffCfgSet

// repeated .com.cfg.vo.WeaponArrayEffCfg effects = 1;
inline int WeaponArrayEffCfgSet::effects_size() const {
  return effects_.size();
}
inline void WeaponArrayEffCfgSet::clear_effects() {
  effects_.Clear();
}
inline const ::com::cfg::vo::WeaponArrayEffCfg& WeaponArrayEffCfgSet::effects(int index) const {
  return effects_.Get(index);
}
inline ::com::cfg::vo::WeaponArrayEffCfg* WeaponArrayEffCfgSet::mutable_effects(int index) {
  return effects_.Mutable(index);
}
inline ::com::cfg::vo::WeaponArrayEffCfg* WeaponArrayEffCfgSet::add_effects() {
  return effects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::WeaponArrayEffCfg >&
WeaponArrayEffCfgSet::effects() const {
  return effects_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::WeaponArrayEffCfg >*
WeaponArrayEffCfgSet::mutable_effects() {
  return &effects_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vo
}  // namespace cfg
}  // namespace com

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_WeaponArrayEffCfg_2eproto__INCLUDED
