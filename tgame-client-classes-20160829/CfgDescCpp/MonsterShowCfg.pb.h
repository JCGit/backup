// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MonsterShowCfg.proto

#ifndef PROTOBUF_MonsterShowCfg_2eproto__INCLUDED
#define PROTOBUF_MonsterShowCfg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MonsterCfg.pb.h"
// @@protoc_insertion_point(includes)

namespace com {
namespace cfg {
namespace vo {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MonsterShowCfg_2eproto();
void protobuf_AssignDesc_MonsterShowCfg_2eproto();
void protobuf_ShutdownFile_MonsterShowCfg_2eproto();

class MonsterShowCfg;
class MonsterShowCfgSet;

// ===================================================================

class MonsterShowCfg : public ::google::protobuf::MessageLite {
 public:
  MonsterShowCfg();
  virtual ~MonsterShowCfg();

  MonsterShowCfg(const MonsterShowCfg& from);

  inline MonsterShowCfg& operator=(const MonsterShowCfg& from) {
    CopyFrom(from);
    return *this;
  }

  static const MonsterShowCfg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MonsterShowCfg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MonsterShowCfg* other);

  // implements Message ----------------------------------------------

  MonsterShowCfg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MonsterShowCfg& from);
  void MergeFrom(const MonsterShowCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string avatar = 1;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 1;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // required uint32 walkType = 2;
  inline bool has_walktype() const;
  inline void clear_walktype();
  static const int kWalkTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 walktype() const;
  inline void set_walktype(::google::protobuf::uint32 value);

  // required uint32 atktype = 3;
  inline bool has_atktype() const;
  inline void clear_atktype();
  static const int kAtktypeFieldNumber = 3;
  inline ::google::protobuf::uint32 atktype() const;
  inline void set_atktype(::google::protobuf::uint32 value);

  // required uint32 atkAttType = 4;
  inline bool has_atkatttype() const;
  inline void clear_atkatttype();
  static const int kAtkAttTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 atkatttype() const;
  inline void set_atkatttype(::google::protobuf::uint32 value);

  // required uint32 deftype = 5;
  inline bool has_deftype() const;
  inline void clear_deftype();
  static const int kDeftypeFieldNumber = 5;
  inline ::google::protobuf::uint32 deftype() const;
  inline void set_deftype(::google::protobuf::uint32 value);

  // required uint32 highSpeed = 7;
  inline bool has_highspeed() const;
  inline void clear_highspeed();
  static const int kHighSpeedFieldNumber = 7;
  inline ::google::protobuf::uint32 highspeed() const;
  inline void set_highspeed(::google::protobuf::uint32 value);

  // required string emergeVoice = 8;
  inline bool has_emergevoice() const;
  inline void clear_emergevoice();
  static const int kEmergeVoiceFieldNumber = 8;
  inline const ::std::string& emergevoice() const;
  inline void set_emergevoice(const ::std::string& value);
  inline void set_emergevoice(const char* value);
  inline void set_emergevoice(const char* value, size_t size);
  inline ::std::string* mutable_emergevoice();
  inline ::std::string* release_emergevoice();
  inline void set_allocated_emergevoice(::std::string* emergevoice);

  // required string hurtVoice = 9;
  inline bool has_hurtvoice() const;
  inline void clear_hurtvoice();
  static const int kHurtVoiceFieldNumber = 9;
  inline const ::std::string& hurtvoice() const;
  inline void set_hurtvoice(const ::std::string& value);
  inline void set_hurtvoice(const char* value);
  inline void set_hurtvoice(const char* value, size_t size);
  inline ::std::string* mutable_hurtvoice();
  inline ::std::string* release_hurtvoice();
  inline void set_allocated_hurtvoice(::std::string* hurtvoice);

  // required string dieVoice = 10;
  inline bool has_dievoice() const;
  inline void clear_dievoice();
  static const int kDieVoiceFieldNumber = 10;
  inline const ::std::string& dievoice() const;
  inline void set_dievoice(const ::std::string& value);
  inline void set_dievoice(const char* value);
  inline void set_dievoice(const char* value, size_t size);
  inline ::std::string* mutable_dievoice();
  inline ::std::string* release_dievoice();
  inline void set_allocated_dievoice(::std::string* dievoice);

  // repeated uint32 skills = 11;
  inline int skills_size() const;
  inline void clear_skills();
  static const int kSkillsFieldNumber = 11;
  inline ::google::protobuf::uint32 skills(int index) const;
  inline void set_skills(int index, ::google::protobuf::uint32 value);
  inline void add_skills(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      skills() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_skills();

  // required uint32 monstertype = 12;
  inline bool has_monstertype() const;
  inline void clear_monstertype();
  static const int kMonstertypeFieldNumber = 12;
  inline ::google::protobuf::uint32 monstertype() const;
  inline void set_monstertype(::google::protobuf::uint32 value);

  // required uint32 hurtActionCD = 13;
  inline bool has_hurtactioncd() const;
  inline void clear_hurtactioncd();
  static const int kHurtActionCDFieldNumber = 13;
  inline ::google::protobuf::uint32 hurtactioncd() const;
  inline void set_hurtactioncd(::google::protobuf::uint32 value);

  // required string monstername = 14;
  inline bool has_monstername() const;
  inline void clear_monstername();
  static const int kMonsternameFieldNumber = 14;
  inline const ::std::string& monstername() const;
  inline void set_monstername(const ::std::string& value);
  inline void set_monstername(const char* value);
  inline void set_monstername(const char* value, size_t size);
  inline ::std::string* mutable_monstername();
  inline ::std::string* release_monstername();
  inline void set_allocated_monstername(::std::string* monstername);

  // required string desc = 15;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 15;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // required uint32 ballistic = 16;
  inline bool has_ballistic() const;
  inline void clear_ballistic();
  static const int kBallisticFieldNumber = 16;
  inline ::google::protobuf::uint32 ballistic() const;
  inline void set_ballistic(::google::protobuf::uint32 value);

  // required string dieAnimation = 17;
  inline bool has_dieanimation() const;
  inline void clear_dieanimation();
  static const int kDieAnimationFieldNumber = 17;
  inline const ::std::string& dieanimation() const;
  inline void set_dieanimation(const ::std::string& value);
  inline void set_dieanimation(const char* value);
  inline void set_dieanimation(const char* value, size_t size);
  inline ::std::string* mutable_dieanimation();
  inline ::std::string* release_dieanimation();
  inline void set_allocated_dieanimation(::std::string* dieanimation);

  // required uint32 minWalkSpeed = 18;
  inline bool has_minwalkspeed() const;
  inline void clear_minwalkspeed();
  static const int kMinWalkSpeedFieldNumber = 18;
  inline ::google::protobuf::uint32 minwalkspeed() const;
  inline void set_minwalkspeed(::google::protobuf::uint32 value);

  // required uint32 maxWalkSpeed = 19;
  inline bool has_maxwalkspeed() const;
  inline void clear_maxwalkspeed();
  static const int kMaxWalkSpeedFieldNumber = 19;
  inline ::google::protobuf::uint32 maxwalkspeed() const;
  inline void set_maxwalkspeed(::google::protobuf::uint32 value);

  // required uint32 bubbleId = 20;
  inline bool has_bubbleid() const;
  inline void clear_bubbleid();
  static const int kBubbleIdFieldNumber = 20;
  inline ::google::protobuf::uint32 bubbleid() const;
  inline void set_bubbleid(::google::protobuf::uint32 value);

  // required uint32 floorBuffId = 21;
  inline bool has_floorbuffid() const;
  inline void clear_floorbuffid();
  static const int kFloorBuffIdFieldNumber = 21;
  inline ::google::protobuf::uint32 floorbuffid() const;
  inline void set_floorbuffid(::google::protobuf::uint32 value);

  // required uint32 aiID = 22;
  inline bool has_aiid() const;
  inline void clear_aiid();
  static const int kAiIDFieldNumber = 22;
  inline ::google::protobuf::uint32 aiid() const;
  inline void set_aiid(::google::protobuf::uint32 value);

  // required uint32 patrolArea = 23;
  inline bool has_patrolarea() const;
  inline void clear_patrolarea();
  static const int kPatrolAreaFieldNumber = 23;
  inline ::google::protobuf::uint32 patrolarea() const;
  inline void set_patrolarea(::google::protobuf::uint32 value);

  // required uint32 HurtColor = 24;
  inline bool has_hurtcolor() const;
  inline void clear_hurtcolor();
  static const int kHurtColorFieldNumber = 24;
  inline ::google::protobuf::uint32 hurtcolor() const;
  inline void set_hurtcolor(::google::protobuf::uint32 value);

  // required uint32 InitScale = 25;
  inline bool has_initscale() const;
  inline void clear_initscale();
  static const int kInitScaleFieldNumber = 25;
  inline ::google::protobuf::uint32 initscale() const;
  inline void set_initscale(::google::protobuf::uint32 value);

  // required .com.cfg.vo.Movement actions = 26;
  inline bool has_actions() const;
  inline void clear_actions();
  static const int kActionsFieldNumber = 26;
  inline const ::com::cfg::vo::Movement& actions() const;
  inline ::com::cfg::vo::Movement* mutable_actions();
  inline ::com::cfg::vo::Movement* release_actions();
  inline void set_allocated_actions(::com::cfg::vo::Movement* actions);

  // required string headImg = 27;
  inline bool has_headimg() const;
  inline void clear_headimg();
  static const int kHeadImgFieldNumber = 27;
  inline const ::std::string& headimg() const;
  inline void set_headimg(const ::std::string& value);
  inline void set_headimg(const char* value);
  inline void set_headimg(const char* value, size_t size);
  inline ::std::string* mutable_headimg();
  inline ::std::string* release_headimg();
  inline void set_allocated_headimg(::std::string* headimg);

  // @@protoc_insertion_point(class_scope:com.cfg.vo.MonsterShowCfg)
 private:
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_walktype();
  inline void clear_has_walktype();
  inline void set_has_atktype();
  inline void clear_has_atktype();
  inline void set_has_atkatttype();
  inline void clear_has_atkatttype();
  inline void set_has_deftype();
  inline void clear_has_deftype();
  inline void set_has_highspeed();
  inline void clear_has_highspeed();
  inline void set_has_emergevoice();
  inline void clear_has_emergevoice();
  inline void set_has_hurtvoice();
  inline void clear_has_hurtvoice();
  inline void set_has_dievoice();
  inline void clear_has_dievoice();
  inline void set_has_monstertype();
  inline void clear_has_monstertype();
  inline void set_has_hurtactioncd();
  inline void clear_has_hurtactioncd();
  inline void set_has_monstername();
  inline void clear_has_monstername();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_ballistic();
  inline void clear_has_ballistic();
  inline void set_has_dieanimation();
  inline void clear_has_dieanimation();
  inline void set_has_minwalkspeed();
  inline void clear_has_minwalkspeed();
  inline void set_has_maxwalkspeed();
  inline void clear_has_maxwalkspeed();
  inline void set_has_bubbleid();
  inline void clear_has_bubbleid();
  inline void set_has_floorbuffid();
  inline void clear_has_floorbuffid();
  inline void set_has_aiid();
  inline void clear_has_aiid();
  inline void set_has_patrolarea();
  inline void clear_has_patrolarea();
  inline void set_has_hurtcolor();
  inline void clear_has_hurtcolor();
  inline void set_has_initscale();
  inline void clear_has_initscale();
  inline void set_has_actions();
  inline void clear_has_actions();
  inline void set_has_headimg();
  inline void clear_has_headimg();

  ::std::string* avatar_;
  ::google::protobuf::uint32 walktype_;
  ::google::protobuf::uint32 atktype_;
  ::google::protobuf::uint32 atkatttype_;
  ::google::protobuf::uint32 deftype_;
  ::std::string* emergevoice_;
  ::std::string* hurtvoice_;
  ::google::protobuf::uint32 highspeed_;
  ::google::protobuf::uint32 monstertype_;
  ::std::string* dievoice_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > skills_;
  ::std::string* monstername_;
  ::google::protobuf::uint32 hurtactioncd_;
  ::google::protobuf::uint32 ballistic_;
  ::std::string* desc_;
  ::std::string* dieanimation_;
  ::google::protobuf::uint32 minwalkspeed_;
  ::google::protobuf::uint32 maxwalkspeed_;
  ::google::protobuf::uint32 bubbleid_;
  ::google::protobuf::uint32 floorbuffid_;
  ::google::protobuf::uint32 aiid_;
  ::google::protobuf::uint32 patrolarea_;
  ::google::protobuf::uint32 hurtcolor_;
  ::google::protobuf::uint32 initscale_;
  ::com::cfg::vo::Movement* actions_;
  ::std::string* headimg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(26 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MonsterShowCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MonsterShowCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_MonsterShowCfg_2eproto();
  friend void protobuf_ShutdownFile_MonsterShowCfg_2eproto();

  void InitAsDefaultInstance();
  static MonsterShowCfg* default_instance_;
};
// -------------------------------------------------------------------

class MonsterShowCfgSet : public ::google::protobuf::MessageLite {
 public:
  MonsterShowCfgSet();
  virtual ~MonsterShowCfgSet();

  MonsterShowCfgSet(const MonsterShowCfgSet& from);

  inline MonsterShowCfgSet& operator=(const MonsterShowCfgSet& from) {
    CopyFrom(from);
    return *this;
  }

  static const MonsterShowCfgSet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MonsterShowCfgSet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MonsterShowCfgSet* other);

  // implements Message ----------------------------------------------

  MonsterShowCfgSet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MonsterShowCfgSet& from);
  void MergeFrom(const MonsterShowCfgSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.cfg.vo.MonsterShowCfg monsterShowCfg = 1;
  inline int monstershowcfg_size() const;
  inline void clear_monstershowcfg();
  static const int kMonsterShowCfgFieldNumber = 1;
  inline const ::com::cfg::vo::MonsterShowCfg& monstershowcfg(int index) const;
  inline ::com::cfg::vo::MonsterShowCfg* mutable_monstershowcfg(int index);
  inline ::com::cfg::vo::MonsterShowCfg* add_monstershowcfg();
  inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::MonsterShowCfg >&
      monstershowcfg() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::MonsterShowCfg >*
      mutable_monstershowcfg();

  // @@protoc_insertion_point(class_scope:com.cfg.vo.MonsterShowCfgSet)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::MonsterShowCfg > monstershowcfg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MonsterShowCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MonsterShowCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_MonsterShowCfg_2eproto();
  friend void protobuf_ShutdownFile_MonsterShowCfg_2eproto();

  void InitAsDefaultInstance();
  static MonsterShowCfgSet* default_instance_;
};
// ===================================================================


// ===================================================================

// MonsterShowCfg

// required string avatar = 1;
inline bool MonsterShowCfg::has_avatar() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MonsterShowCfg::set_has_avatar() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MonsterShowCfg::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MonsterShowCfg::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& MonsterShowCfg::avatar() const {
  return *avatar_;
}
inline void MonsterShowCfg::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void MonsterShowCfg::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void MonsterShowCfg::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonsterShowCfg::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* MonsterShowCfg::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonsterShowCfg::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 walkType = 2;
inline bool MonsterShowCfg::has_walktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MonsterShowCfg::set_has_walktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MonsterShowCfg::clear_has_walktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MonsterShowCfg::clear_walktype() {
  walktype_ = 0u;
  clear_has_walktype();
}
inline ::google::protobuf::uint32 MonsterShowCfg::walktype() const {
  return walktype_;
}
inline void MonsterShowCfg::set_walktype(::google::protobuf::uint32 value) {
  set_has_walktype();
  walktype_ = value;
}

// required uint32 atktype = 3;
inline bool MonsterShowCfg::has_atktype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MonsterShowCfg::set_has_atktype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MonsterShowCfg::clear_has_atktype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MonsterShowCfg::clear_atktype() {
  atktype_ = 0u;
  clear_has_atktype();
}
inline ::google::protobuf::uint32 MonsterShowCfg::atktype() const {
  return atktype_;
}
inline void MonsterShowCfg::set_atktype(::google::protobuf::uint32 value) {
  set_has_atktype();
  atktype_ = value;
}

// required uint32 atkAttType = 4;
inline bool MonsterShowCfg::has_atkatttype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MonsterShowCfg::set_has_atkatttype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MonsterShowCfg::clear_has_atkatttype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MonsterShowCfg::clear_atkatttype() {
  atkatttype_ = 0u;
  clear_has_atkatttype();
}
inline ::google::protobuf::uint32 MonsterShowCfg::atkatttype() const {
  return atkatttype_;
}
inline void MonsterShowCfg::set_atkatttype(::google::protobuf::uint32 value) {
  set_has_atkatttype();
  atkatttype_ = value;
}

// required uint32 deftype = 5;
inline bool MonsterShowCfg::has_deftype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MonsterShowCfg::set_has_deftype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MonsterShowCfg::clear_has_deftype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MonsterShowCfg::clear_deftype() {
  deftype_ = 0u;
  clear_has_deftype();
}
inline ::google::protobuf::uint32 MonsterShowCfg::deftype() const {
  return deftype_;
}
inline void MonsterShowCfg::set_deftype(::google::protobuf::uint32 value) {
  set_has_deftype();
  deftype_ = value;
}

// required uint32 highSpeed = 7;
inline bool MonsterShowCfg::has_highspeed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MonsterShowCfg::set_has_highspeed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MonsterShowCfg::clear_has_highspeed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MonsterShowCfg::clear_highspeed() {
  highspeed_ = 0u;
  clear_has_highspeed();
}
inline ::google::protobuf::uint32 MonsterShowCfg::highspeed() const {
  return highspeed_;
}
inline void MonsterShowCfg::set_highspeed(::google::protobuf::uint32 value) {
  set_has_highspeed();
  highspeed_ = value;
}

// required string emergeVoice = 8;
inline bool MonsterShowCfg::has_emergevoice() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MonsterShowCfg::set_has_emergevoice() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MonsterShowCfg::clear_has_emergevoice() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MonsterShowCfg::clear_emergevoice() {
  if (emergevoice_ != &::google::protobuf::internal::kEmptyString) {
    emergevoice_->clear();
  }
  clear_has_emergevoice();
}
inline const ::std::string& MonsterShowCfg::emergevoice() const {
  return *emergevoice_;
}
inline void MonsterShowCfg::set_emergevoice(const ::std::string& value) {
  set_has_emergevoice();
  if (emergevoice_ == &::google::protobuf::internal::kEmptyString) {
    emergevoice_ = new ::std::string;
  }
  emergevoice_->assign(value);
}
inline void MonsterShowCfg::set_emergevoice(const char* value) {
  set_has_emergevoice();
  if (emergevoice_ == &::google::protobuf::internal::kEmptyString) {
    emergevoice_ = new ::std::string;
  }
  emergevoice_->assign(value);
}
inline void MonsterShowCfg::set_emergevoice(const char* value, size_t size) {
  set_has_emergevoice();
  if (emergevoice_ == &::google::protobuf::internal::kEmptyString) {
    emergevoice_ = new ::std::string;
  }
  emergevoice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonsterShowCfg::mutable_emergevoice() {
  set_has_emergevoice();
  if (emergevoice_ == &::google::protobuf::internal::kEmptyString) {
    emergevoice_ = new ::std::string;
  }
  return emergevoice_;
}
inline ::std::string* MonsterShowCfg::release_emergevoice() {
  clear_has_emergevoice();
  if (emergevoice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = emergevoice_;
    emergevoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonsterShowCfg::set_allocated_emergevoice(::std::string* emergevoice) {
  if (emergevoice_ != &::google::protobuf::internal::kEmptyString) {
    delete emergevoice_;
  }
  if (emergevoice) {
    set_has_emergevoice();
    emergevoice_ = emergevoice;
  } else {
    clear_has_emergevoice();
    emergevoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string hurtVoice = 9;
inline bool MonsterShowCfg::has_hurtvoice() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MonsterShowCfg::set_has_hurtvoice() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MonsterShowCfg::clear_has_hurtvoice() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MonsterShowCfg::clear_hurtvoice() {
  if (hurtvoice_ != &::google::protobuf::internal::kEmptyString) {
    hurtvoice_->clear();
  }
  clear_has_hurtvoice();
}
inline const ::std::string& MonsterShowCfg::hurtvoice() const {
  return *hurtvoice_;
}
inline void MonsterShowCfg::set_hurtvoice(const ::std::string& value) {
  set_has_hurtvoice();
  if (hurtvoice_ == &::google::protobuf::internal::kEmptyString) {
    hurtvoice_ = new ::std::string;
  }
  hurtvoice_->assign(value);
}
inline void MonsterShowCfg::set_hurtvoice(const char* value) {
  set_has_hurtvoice();
  if (hurtvoice_ == &::google::protobuf::internal::kEmptyString) {
    hurtvoice_ = new ::std::string;
  }
  hurtvoice_->assign(value);
}
inline void MonsterShowCfg::set_hurtvoice(const char* value, size_t size) {
  set_has_hurtvoice();
  if (hurtvoice_ == &::google::protobuf::internal::kEmptyString) {
    hurtvoice_ = new ::std::string;
  }
  hurtvoice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonsterShowCfg::mutable_hurtvoice() {
  set_has_hurtvoice();
  if (hurtvoice_ == &::google::protobuf::internal::kEmptyString) {
    hurtvoice_ = new ::std::string;
  }
  return hurtvoice_;
}
inline ::std::string* MonsterShowCfg::release_hurtvoice() {
  clear_has_hurtvoice();
  if (hurtvoice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hurtvoice_;
    hurtvoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonsterShowCfg::set_allocated_hurtvoice(::std::string* hurtvoice) {
  if (hurtvoice_ != &::google::protobuf::internal::kEmptyString) {
    delete hurtvoice_;
  }
  if (hurtvoice) {
    set_has_hurtvoice();
    hurtvoice_ = hurtvoice;
  } else {
    clear_has_hurtvoice();
    hurtvoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string dieVoice = 10;
inline bool MonsterShowCfg::has_dievoice() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MonsterShowCfg::set_has_dievoice() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MonsterShowCfg::clear_has_dievoice() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MonsterShowCfg::clear_dievoice() {
  if (dievoice_ != &::google::protobuf::internal::kEmptyString) {
    dievoice_->clear();
  }
  clear_has_dievoice();
}
inline const ::std::string& MonsterShowCfg::dievoice() const {
  return *dievoice_;
}
inline void MonsterShowCfg::set_dievoice(const ::std::string& value) {
  set_has_dievoice();
  if (dievoice_ == &::google::protobuf::internal::kEmptyString) {
    dievoice_ = new ::std::string;
  }
  dievoice_->assign(value);
}
inline void MonsterShowCfg::set_dievoice(const char* value) {
  set_has_dievoice();
  if (dievoice_ == &::google::protobuf::internal::kEmptyString) {
    dievoice_ = new ::std::string;
  }
  dievoice_->assign(value);
}
inline void MonsterShowCfg::set_dievoice(const char* value, size_t size) {
  set_has_dievoice();
  if (dievoice_ == &::google::protobuf::internal::kEmptyString) {
    dievoice_ = new ::std::string;
  }
  dievoice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonsterShowCfg::mutable_dievoice() {
  set_has_dievoice();
  if (dievoice_ == &::google::protobuf::internal::kEmptyString) {
    dievoice_ = new ::std::string;
  }
  return dievoice_;
}
inline ::std::string* MonsterShowCfg::release_dievoice() {
  clear_has_dievoice();
  if (dievoice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dievoice_;
    dievoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonsterShowCfg::set_allocated_dievoice(::std::string* dievoice) {
  if (dievoice_ != &::google::protobuf::internal::kEmptyString) {
    delete dievoice_;
  }
  if (dievoice) {
    set_has_dievoice();
    dievoice_ = dievoice;
  } else {
    clear_has_dievoice();
    dievoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated uint32 skills = 11;
inline int MonsterShowCfg::skills_size() const {
  return skills_.size();
}
inline void MonsterShowCfg::clear_skills() {
  skills_.Clear();
}
inline ::google::protobuf::uint32 MonsterShowCfg::skills(int index) const {
  return skills_.Get(index);
}
inline void MonsterShowCfg::set_skills(int index, ::google::protobuf::uint32 value) {
  skills_.Set(index, value);
}
inline void MonsterShowCfg::add_skills(::google::protobuf::uint32 value) {
  skills_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MonsterShowCfg::skills() const {
  return skills_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MonsterShowCfg::mutable_skills() {
  return &skills_;
}

// required uint32 monstertype = 12;
inline bool MonsterShowCfg::has_monstertype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MonsterShowCfg::set_has_monstertype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MonsterShowCfg::clear_has_monstertype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MonsterShowCfg::clear_monstertype() {
  monstertype_ = 0u;
  clear_has_monstertype();
}
inline ::google::protobuf::uint32 MonsterShowCfg::monstertype() const {
  return monstertype_;
}
inline void MonsterShowCfg::set_monstertype(::google::protobuf::uint32 value) {
  set_has_monstertype();
  monstertype_ = value;
}

// required uint32 hurtActionCD = 13;
inline bool MonsterShowCfg::has_hurtactioncd() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MonsterShowCfg::set_has_hurtactioncd() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MonsterShowCfg::clear_has_hurtactioncd() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MonsterShowCfg::clear_hurtactioncd() {
  hurtactioncd_ = 0u;
  clear_has_hurtactioncd();
}
inline ::google::protobuf::uint32 MonsterShowCfg::hurtactioncd() const {
  return hurtactioncd_;
}
inline void MonsterShowCfg::set_hurtactioncd(::google::protobuf::uint32 value) {
  set_has_hurtactioncd();
  hurtactioncd_ = value;
}

// required string monstername = 14;
inline bool MonsterShowCfg::has_monstername() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MonsterShowCfg::set_has_monstername() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MonsterShowCfg::clear_has_monstername() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MonsterShowCfg::clear_monstername() {
  if (monstername_ != &::google::protobuf::internal::kEmptyString) {
    monstername_->clear();
  }
  clear_has_monstername();
}
inline const ::std::string& MonsterShowCfg::monstername() const {
  return *monstername_;
}
inline void MonsterShowCfg::set_monstername(const ::std::string& value) {
  set_has_monstername();
  if (monstername_ == &::google::protobuf::internal::kEmptyString) {
    monstername_ = new ::std::string;
  }
  monstername_->assign(value);
}
inline void MonsterShowCfg::set_monstername(const char* value) {
  set_has_monstername();
  if (monstername_ == &::google::protobuf::internal::kEmptyString) {
    monstername_ = new ::std::string;
  }
  monstername_->assign(value);
}
inline void MonsterShowCfg::set_monstername(const char* value, size_t size) {
  set_has_monstername();
  if (monstername_ == &::google::protobuf::internal::kEmptyString) {
    monstername_ = new ::std::string;
  }
  monstername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonsterShowCfg::mutable_monstername() {
  set_has_monstername();
  if (monstername_ == &::google::protobuf::internal::kEmptyString) {
    monstername_ = new ::std::string;
  }
  return monstername_;
}
inline ::std::string* MonsterShowCfg::release_monstername() {
  clear_has_monstername();
  if (monstername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = monstername_;
    monstername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonsterShowCfg::set_allocated_monstername(::std::string* monstername) {
  if (monstername_ != &::google::protobuf::internal::kEmptyString) {
    delete monstername_;
  }
  if (monstername) {
    set_has_monstername();
    monstername_ = monstername;
  } else {
    clear_has_monstername();
    monstername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string desc = 15;
inline bool MonsterShowCfg::has_desc() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MonsterShowCfg::set_has_desc() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MonsterShowCfg::clear_has_desc() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MonsterShowCfg::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& MonsterShowCfg::desc() const {
  return *desc_;
}
inline void MonsterShowCfg::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void MonsterShowCfg::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void MonsterShowCfg::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonsterShowCfg::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* MonsterShowCfg::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonsterShowCfg::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 ballistic = 16;
inline bool MonsterShowCfg::has_ballistic() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MonsterShowCfg::set_has_ballistic() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MonsterShowCfg::clear_has_ballistic() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MonsterShowCfg::clear_ballistic() {
  ballistic_ = 0u;
  clear_has_ballistic();
}
inline ::google::protobuf::uint32 MonsterShowCfg::ballistic() const {
  return ballistic_;
}
inline void MonsterShowCfg::set_ballistic(::google::protobuf::uint32 value) {
  set_has_ballistic();
  ballistic_ = value;
}

// required string dieAnimation = 17;
inline bool MonsterShowCfg::has_dieanimation() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MonsterShowCfg::set_has_dieanimation() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MonsterShowCfg::clear_has_dieanimation() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MonsterShowCfg::clear_dieanimation() {
  if (dieanimation_ != &::google::protobuf::internal::kEmptyString) {
    dieanimation_->clear();
  }
  clear_has_dieanimation();
}
inline const ::std::string& MonsterShowCfg::dieanimation() const {
  return *dieanimation_;
}
inline void MonsterShowCfg::set_dieanimation(const ::std::string& value) {
  set_has_dieanimation();
  if (dieanimation_ == &::google::protobuf::internal::kEmptyString) {
    dieanimation_ = new ::std::string;
  }
  dieanimation_->assign(value);
}
inline void MonsterShowCfg::set_dieanimation(const char* value) {
  set_has_dieanimation();
  if (dieanimation_ == &::google::protobuf::internal::kEmptyString) {
    dieanimation_ = new ::std::string;
  }
  dieanimation_->assign(value);
}
inline void MonsterShowCfg::set_dieanimation(const char* value, size_t size) {
  set_has_dieanimation();
  if (dieanimation_ == &::google::protobuf::internal::kEmptyString) {
    dieanimation_ = new ::std::string;
  }
  dieanimation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonsterShowCfg::mutable_dieanimation() {
  set_has_dieanimation();
  if (dieanimation_ == &::google::protobuf::internal::kEmptyString) {
    dieanimation_ = new ::std::string;
  }
  return dieanimation_;
}
inline ::std::string* MonsterShowCfg::release_dieanimation() {
  clear_has_dieanimation();
  if (dieanimation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dieanimation_;
    dieanimation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonsterShowCfg::set_allocated_dieanimation(::std::string* dieanimation) {
  if (dieanimation_ != &::google::protobuf::internal::kEmptyString) {
    delete dieanimation_;
  }
  if (dieanimation) {
    set_has_dieanimation();
    dieanimation_ = dieanimation;
  } else {
    clear_has_dieanimation();
    dieanimation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 minWalkSpeed = 18;
inline bool MonsterShowCfg::has_minwalkspeed() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MonsterShowCfg::set_has_minwalkspeed() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MonsterShowCfg::clear_has_minwalkspeed() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MonsterShowCfg::clear_minwalkspeed() {
  minwalkspeed_ = 0u;
  clear_has_minwalkspeed();
}
inline ::google::protobuf::uint32 MonsterShowCfg::minwalkspeed() const {
  return minwalkspeed_;
}
inline void MonsterShowCfg::set_minwalkspeed(::google::protobuf::uint32 value) {
  set_has_minwalkspeed();
  minwalkspeed_ = value;
}

// required uint32 maxWalkSpeed = 19;
inline bool MonsterShowCfg::has_maxwalkspeed() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MonsterShowCfg::set_has_maxwalkspeed() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MonsterShowCfg::clear_has_maxwalkspeed() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MonsterShowCfg::clear_maxwalkspeed() {
  maxwalkspeed_ = 0u;
  clear_has_maxwalkspeed();
}
inline ::google::protobuf::uint32 MonsterShowCfg::maxwalkspeed() const {
  return maxwalkspeed_;
}
inline void MonsterShowCfg::set_maxwalkspeed(::google::protobuf::uint32 value) {
  set_has_maxwalkspeed();
  maxwalkspeed_ = value;
}

// required uint32 bubbleId = 20;
inline bool MonsterShowCfg::has_bubbleid() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MonsterShowCfg::set_has_bubbleid() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MonsterShowCfg::clear_has_bubbleid() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MonsterShowCfg::clear_bubbleid() {
  bubbleid_ = 0u;
  clear_has_bubbleid();
}
inline ::google::protobuf::uint32 MonsterShowCfg::bubbleid() const {
  return bubbleid_;
}
inline void MonsterShowCfg::set_bubbleid(::google::protobuf::uint32 value) {
  set_has_bubbleid();
  bubbleid_ = value;
}

// required uint32 floorBuffId = 21;
inline bool MonsterShowCfg::has_floorbuffid() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MonsterShowCfg::set_has_floorbuffid() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MonsterShowCfg::clear_has_floorbuffid() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MonsterShowCfg::clear_floorbuffid() {
  floorbuffid_ = 0u;
  clear_has_floorbuffid();
}
inline ::google::protobuf::uint32 MonsterShowCfg::floorbuffid() const {
  return floorbuffid_;
}
inline void MonsterShowCfg::set_floorbuffid(::google::protobuf::uint32 value) {
  set_has_floorbuffid();
  floorbuffid_ = value;
}

// required uint32 aiID = 22;
inline bool MonsterShowCfg::has_aiid() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MonsterShowCfg::set_has_aiid() {
  _has_bits_[0] |= 0x00100000u;
}
inline void MonsterShowCfg::clear_has_aiid() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void MonsterShowCfg::clear_aiid() {
  aiid_ = 0u;
  clear_has_aiid();
}
inline ::google::protobuf::uint32 MonsterShowCfg::aiid() const {
  return aiid_;
}
inline void MonsterShowCfg::set_aiid(::google::protobuf::uint32 value) {
  set_has_aiid();
  aiid_ = value;
}

// required uint32 patrolArea = 23;
inline bool MonsterShowCfg::has_patrolarea() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void MonsterShowCfg::set_has_patrolarea() {
  _has_bits_[0] |= 0x00200000u;
}
inline void MonsterShowCfg::clear_has_patrolarea() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void MonsterShowCfg::clear_patrolarea() {
  patrolarea_ = 0u;
  clear_has_patrolarea();
}
inline ::google::protobuf::uint32 MonsterShowCfg::patrolarea() const {
  return patrolarea_;
}
inline void MonsterShowCfg::set_patrolarea(::google::protobuf::uint32 value) {
  set_has_patrolarea();
  patrolarea_ = value;
}

// required uint32 HurtColor = 24;
inline bool MonsterShowCfg::has_hurtcolor() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void MonsterShowCfg::set_has_hurtcolor() {
  _has_bits_[0] |= 0x00400000u;
}
inline void MonsterShowCfg::clear_has_hurtcolor() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void MonsterShowCfg::clear_hurtcolor() {
  hurtcolor_ = 0u;
  clear_has_hurtcolor();
}
inline ::google::protobuf::uint32 MonsterShowCfg::hurtcolor() const {
  return hurtcolor_;
}
inline void MonsterShowCfg::set_hurtcolor(::google::protobuf::uint32 value) {
  set_has_hurtcolor();
  hurtcolor_ = value;
}

// required uint32 InitScale = 25;
inline bool MonsterShowCfg::has_initscale() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void MonsterShowCfg::set_has_initscale() {
  _has_bits_[0] |= 0x00800000u;
}
inline void MonsterShowCfg::clear_has_initscale() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void MonsterShowCfg::clear_initscale() {
  initscale_ = 0u;
  clear_has_initscale();
}
inline ::google::protobuf::uint32 MonsterShowCfg::initscale() const {
  return initscale_;
}
inline void MonsterShowCfg::set_initscale(::google::protobuf::uint32 value) {
  set_has_initscale();
  initscale_ = value;
}

// required .com.cfg.vo.Movement actions = 26;
inline bool MonsterShowCfg::has_actions() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void MonsterShowCfg::set_has_actions() {
  _has_bits_[0] |= 0x01000000u;
}
inline void MonsterShowCfg::clear_has_actions() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void MonsterShowCfg::clear_actions() {
  if (actions_ != NULL) actions_->::com::cfg::vo::Movement::Clear();
  clear_has_actions();
}
inline const ::com::cfg::vo::Movement& MonsterShowCfg::actions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return actions_ != NULL ? *actions_ : *default_instance().actions_;
#else
  return actions_ != NULL ? *actions_ : *default_instance_->actions_;
#endif
}
inline ::com::cfg::vo::Movement* MonsterShowCfg::mutable_actions() {
  set_has_actions();
  if (actions_ == NULL) actions_ = new ::com::cfg::vo::Movement;
  return actions_;
}
inline ::com::cfg::vo::Movement* MonsterShowCfg::release_actions() {
  clear_has_actions();
  ::com::cfg::vo::Movement* temp = actions_;
  actions_ = NULL;
  return temp;
}
inline void MonsterShowCfg::set_allocated_actions(::com::cfg::vo::Movement* actions) {
  delete actions_;
  actions_ = actions;
  if (actions) {
    set_has_actions();
  } else {
    clear_has_actions();
  }
}

// required string headImg = 27;
inline bool MonsterShowCfg::has_headimg() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void MonsterShowCfg::set_has_headimg() {
  _has_bits_[0] |= 0x02000000u;
}
inline void MonsterShowCfg::clear_has_headimg() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void MonsterShowCfg::clear_headimg() {
  if (headimg_ != &::google::protobuf::internal::kEmptyString) {
    headimg_->clear();
  }
  clear_has_headimg();
}
inline const ::std::string& MonsterShowCfg::headimg() const {
  return *headimg_;
}
inline void MonsterShowCfg::set_headimg(const ::std::string& value) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(value);
}
inline void MonsterShowCfg::set_headimg(const char* value) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(value);
}
inline void MonsterShowCfg::set_headimg(const char* value, size_t size) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonsterShowCfg::mutable_headimg() {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  return headimg_;
}
inline ::std::string* MonsterShowCfg::release_headimg() {
  clear_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headimg_;
    headimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonsterShowCfg::set_allocated_headimg(::std::string* headimg) {
  if (headimg_ != &::google::protobuf::internal::kEmptyString) {
    delete headimg_;
  }
  if (headimg) {
    set_has_headimg();
    headimg_ = headimg;
  } else {
    clear_has_headimg();
    headimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MonsterShowCfgSet

// repeated .com.cfg.vo.MonsterShowCfg monsterShowCfg = 1;
inline int MonsterShowCfgSet::monstershowcfg_size() const {
  return monstershowcfg_.size();
}
inline void MonsterShowCfgSet::clear_monstershowcfg() {
  monstershowcfg_.Clear();
}
inline const ::com::cfg::vo::MonsterShowCfg& MonsterShowCfgSet::monstershowcfg(int index) const {
  return monstershowcfg_.Get(index);
}
inline ::com::cfg::vo::MonsterShowCfg* MonsterShowCfgSet::mutable_monstershowcfg(int index) {
  return monstershowcfg_.Mutable(index);
}
inline ::com::cfg::vo::MonsterShowCfg* MonsterShowCfgSet::add_monstershowcfg() {
  return monstershowcfg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::MonsterShowCfg >&
MonsterShowCfgSet::monstershowcfg() const {
  return monstershowcfg_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::MonsterShowCfg >*
MonsterShowCfgSet::mutable_monstershowcfg() {
  return &monstershowcfg_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vo
}  // namespace cfg
}  // namespace com

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MonsterShowCfg_2eproto__INCLUDED
