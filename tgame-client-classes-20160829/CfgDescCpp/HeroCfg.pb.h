// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: HeroCfg.proto

#ifndef PROTOBUF_HeroCfg_2eproto__INCLUDED
#define PROTOBUF_HeroCfg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace cfg {
namespace vo {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_HeroCfg_2eproto();
void protobuf_AssignDesc_HeroCfg_2eproto();
void protobuf_ShutdownFile_HeroCfg_2eproto();

class HeroCfg;
class HeroCfgSet;

// ===================================================================

class HeroCfg : public ::google::protobuf::MessageLite {
 public:
  HeroCfg();
  virtual ~HeroCfg();

  HeroCfg(const HeroCfg& from);

  inline HeroCfg& operator=(const HeroCfg& from) {
    CopyFrom(from);
    return *this;
  }

  static const HeroCfg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HeroCfg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HeroCfg* other);

  // implements Message ----------------------------------------------

  HeroCfg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HeroCfg& from);
  void MergeFrom(const HeroCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ShowID = 1;
  inline bool has_showid() const;
  inline void clear_showid();
  static const int kShowIDFieldNumber = 1;
  inline ::google::protobuf::uint32 showid() const;
  inline void set_showid(::google::protobuf::uint32 value);

  // required string RoleName = 2;
  inline bool has_rolename() const;
  inline void clear_rolename();
  static const int kRoleNameFieldNumber = 2;
  inline const ::std::string& rolename() const;
  inline void set_rolename(const ::std::string& value);
  inline void set_rolename(const char* value);
  inline void set_rolename(const char* value, size_t size);
  inline ::std::string* mutable_rolename();
  inline ::std::string* release_rolename();
  inline void set_allocated_rolename(::std::string* rolename);

  // required string RoleIntro = 3;
  inline bool has_roleintro() const;
  inline void clear_roleintro();
  static const int kRoleIntroFieldNumber = 3;
  inline const ::std::string& roleintro() const;
  inline void set_roleintro(const ::std::string& value);
  inline void set_roleintro(const char* value);
  inline void set_roleintro(const char* value, size_t size);
  inline ::std::string* mutable_roleintro();
  inline ::std::string* release_roleintro();
  inline void set_allocated_roleintro(::std::string* roleintro);

  // required string ResName = 4;
  inline bool has_resname() const;
  inline void clear_resname();
  static const int kResNameFieldNumber = 4;
  inline const ::std::string& resname() const;
  inline void set_resname(const ::std::string& value);
  inline void set_resname(const char* value);
  inline void set_resname(const char* value, size_t size);
  inline ::std::string* mutable_resname();
  inline ::std::string* release_resname();
  inline void set_allocated_resname(::std::string* resname);

  // required string WordsVoice = 5;
  inline bool has_wordsvoice() const;
  inline void clear_wordsvoice();
  static const int kWordsVoiceFieldNumber = 5;
  inline const ::std::string& wordsvoice() const;
  inline void set_wordsvoice(const ::std::string& value);
  inline void set_wordsvoice(const char* value);
  inline void set_wordsvoice(const char* value, size_t size);
  inline ::std::string* mutable_wordsvoice();
  inline ::std::string* release_wordsvoice();
  inline void set_allocated_wordsvoice(::std::string* wordsvoice);

  // required string EmergeVoice = 6;
  inline bool has_emergevoice() const;
  inline void clear_emergevoice();
  static const int kEmergeVoiceFieldNumber = 6;
  inline const ::std::string& emergevoice() const;
  inline void set_emergevoice(const ::std::string& value);
  inline void set_emergevoice(const char* value);
  inline void set_emergevoice(const char* value, size_t size);
  inline ::std::string* mutable_emergevoice();
  inline ::std::string* release_emergevoice();
  inline void set_allocated_emergevoice(::std::string* emergevoice);

  // required string HurtVoice = 7;
  inline bool has_hurtvoice() const;
  inline void clear_hurtvoice();
  static const int kHurtVoiceFieldNumber = 7;
  inline const ::std::string& hurtvoice() const;
  inline void set_hurtvoice(const ::std::string& value);
  inline void set_hurtvoice(const char* value);
  inline void set_hurtvoice(const char* value, size_t size);
  inline ::std::string* mutable_hurtvoice();
  inline ::std::string* release_hurtvoice();
  inline void set_allocated_hurtvoice(::std::string* hurtvoice);

  // required string DieVoice = 8;
  inline bool has_dievoice() const;
  inline void clear_dievoice();
  static const int kDieVoiceFieldNumber = 8;
  inline const ::std::string& dievoice() const;
  inline void set_dievoice(const ::std::string& value);
  inline void set_dievoice(const char* value);
  inline void set_dievoice(const char* value, size_t size);
  inline ::std::string* mutable_dievoice();
  inline ::std::string* release_dievoice();
  inline void set_allocated_dievoice(::std::string* dievoice);

  // required uint32 StiffTime = 9;
  inline bool has_stifftime() const;
  inline void clear_stifftime();
  static const int kStiffTimeFieldNumber = 9;
  inline ::google::protobuf::uint32 stifftime() const;
  inline void set_stifftime(::google::protobuf::uint32 value);

  // required string SwitchWeaponVoice = 10;
  inline bool has_switchweaponvoice() const;
  inline void clear_switchweaponvoice();
  static const int kSwitchWeaponVoiceFieldNumber = 10;
  inline const ::std::string& switchweaponvoice() const;
  inline void set_switchweaponvoice(const ::std::string& value);
  inline void set_switchweaponvoice(const char* value);
  inline void set_switchweaponvoice(const char* value, size_t size);
  inline ::std::string* mutable_switchweaponvoice();
  inline ::std::string* release_switchweaponvoice();
  inline void set_allocated_switchweaponvoice(::std::string* switchweaponvoice);

  // required string HeadIcon = 11;
  inline bool has_headicon() const;
  inline void clear_headicon();
  static const int kHeadIconFieldNumber = 11;
  inline const ::std::string& headicon() const;
  inline void set_headicon(const ::std::string& value);
  inline void set_headicon(const char* value);
  inline void set_headicon(const char* value, size_t size);
  inline ::std::string* mutable_headicon();
  inline ::std::string* release_headicon();
  inline void set_allocated_headicon(::std::string* headicon);

  // required string DodgeSound = 12;
  inline bool has_dodgesound() const;
  inline void clear_dodgesound();
  static const int kDodgeSoundFieldNumber = 12;
  inline const ::std::string& dodgesound() const;
  inline void set_dodgesound(const ::std::string& value);
  inline void set_dodgesound(const char* value);
  inline void set_dodgesound(const char* value, size_t size);
  inline ::std::string* mutable_dodgesound();
  inline ::std::string* release_dodgesound();
  inline void set_allocated_dodgesound(::std::string* dodgesound);

  // required uint32 HurtColor = 13;
  inline bool has_hurtcolor() const;
  inline void clear_hurtcolor();
  static const int kHurtColorFieldNumber = 13;
  inline ::google::protobuf::uint32 hurtcolor() const;
  inline void set_hurtcolor(::google::protobuf::uint32 value);

  // required uint32 RunDis = 14;
  inline bool has_rundis() const;
  inline void clear_rundis();
  static const int kRunDisFieldNumber = 14;
  inline ::google::protobuf::uint32 rundis() const;
  inline void set_rundis(::google::protobuf::uint32 value);

  // required uint32 ActNum = 15;
  inline bool has_actnum() const;
  inline void clear_actnum();
  static const int kActNumFieldNumber = 15;
  inline ::google::protobuf::uint32 actnum() const;
  inline void set_actnum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.cfg.vo.HeroCfg)
 private:
  inline void set_has_showid();
  inline void clear_has_showid();
  inline void set_has_rolename();
  inline void clear_has_rolename();
  inline void set_has_roleintro();
  inline void clear_has_roleintro();
  inline void set_has_resname();
  inline void clear_has_resname();
  inline void set_has_wordsvoice();
  inline void clear_has_wordsvoice();
  inline void set_has_emergevoice();
  inline void clear_has_emergevoice();
  inline void set_has_hurtvoice();
  inline void clear_has_hurtvoice();
  inline void set_has_dievoice();
  inline void clear_has_dievoice();
  inline void set_has_stifftime();
  inline void clear_has_stifftime();
  inline void set_has_switchweaponvoice();
  inline void clear_has_switchweaponvoice();
  inline void set_has_headicon();
  inline void clear_has_headicon();
  inline void set_has_dodgesound();
  inline void clear_has_dodgesound();
  inline void set_has_hurtcolor();
  inline void clear_has_hurtcolor();
  inline void set_has_rundis();
  inline void clear_has_rundis();
  inline void set_has_actnum();
  inline void clear_has_actnum();

  ::std::string* rolename_;
  ::std::string* roleintro_;
  ::std::string* resname_;
  ::std::string* wordsvoice_;
  ::google::protobuf::uint32 showid_;
  ::google::protobuf::uint32 stifftime_;
  ::std::string* emergevoice_;
  ::std::string* hurtvoice_;
  ::std::string* dievoice_;
  ::std::string* switchweaponvoice_;
  ::std::string* headicon_;
  ::std::string* dodgesound_;
  ::google::protobuf::uint32 hurtcolor_;
  ::google::protobuf::uint32 rundis_;
  ::google::protobuf::uint32 actnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_HeroCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_HeroCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_HeroCfg_2eproto();
  friend void protobuf_ShutdownFile_HeroCfg_2eproto();

  void InitAsDefaultInstance();
  static HeroCfg* default_instance_;
};
// -------------------------------------------------------------------

class HeroCfgSet : public ::google::protobuf::MessageLite {
 public:
  HeroCfgSet();
  virtual ~HeroCfgSet();

  HeroCfgSet(const HeroCfgSet& from);

  inline HeroCfgSet& operator=(const HeroCfgSet& from) {
    CopyFrom(from);
    return *this;
  }

  static const HeroCfgSet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HeroCfgSet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HeroCfgSet* other);

  // implements Message ----------------------------------------------

  HeroCfgSet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HeroCfgSet& from);
  void MergeFrom(const HeroCfgSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.cfg.vo.HeroCfg heroCfg = 1;
  inline int herocfg_size() const;
  inline void clear_herocfg();
  static const int kHeroCfgFieldNumber = 1;
  inline const ::com::cfg::vo::HeroCfg& herocfg(int index) const;
  inline ::com::cfg::vo::HeroCfg* mutable_herocfg(int index);
  inline ::com::cfg::vo::HeroCfg* add_herocfg();
  inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::HeroCfg >&
      herocfg() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::HeroCfg >*
      mutable_herocfg();

  // @@protoc_insertion_point(class_scope:com.cfg.vo.HeroCfgSet)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::HeroCfg > herocfg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_HeroCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_HeroCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_HeroCfg_2eproto();
  friend void protobuf_ShutdownFile_HeroCfg_2eproto();

  void InitAsDefaultInstance();
  static HeroCfgSet* default_instance_;
};
// ===================================================================


// ===================================================================

// HeroCfg

// required uint32 ShowID = 1;
inline bool HeroCfg::has_showid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeroCfg::set_has_showid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeroCfg::clear_has_showid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeroCfg::clear_showid() {
  showid_ = 0u;
  clear_has_showid();
}
inline ::google::protobuf::uint32 HeroCfg::showid() const {
  return showid_;
}
inline void HeroCfg::set_showid(::google::protobuf::uint32 value) {
  set_has_showid();
  showid_ = value;
}

// required string RoleName = 2;
inline bool HeroCfg::has_rolename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeroCfg::set_has_rolename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeroCfg::clear_has_rolename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeroCfg::clear_rolename() {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    rolename_->clear();
  }
  clear_has_rolename();
}
inline const ::std::string& HeroCfg::rolename() const {
  return *rolename_;
}
inline void HeroCfg::set_rolename(const ::std::string& value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void HeroCfg::set_rolename(const char* value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void HeroCfg::set_rolename(const char* value, size_t size) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeroCfg::mutable_rolename() {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  return rolename_;
}
inline ::std::string* HeroCfg::release_rolename() {
  clear_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rolename_;
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HeroCfg::set_allocated_rolename(::std::string* rolename) {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    delete rolename_;
  }
  if (rolename) {
    set_has_rolename();
    rolename_ = rolename;
  } else {
    clear_has_rolename();
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string RoleIntro = 3;
inline bool HeroCfg::has_roleintro() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeroCfg::set_has_roleintro() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HeroCfg::clear_has_roleintro() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HeroCfg::clear_roleintro() {
  if (roleintro_ != &::google::protobuf::internal::kEmptyString) {
    roleintro_->clear();
  }
  clear_has_roleintro();
}
inline const ::std::string& HeroCfg::roleintro() const {
  return *roleintro_;
}
inline void HeroCfg::set_roleintro(const ::std::string& value) {
  set_has_roleintro();
  if (roleintro_ == &::google::protobuf::internal::kEmptyString) {
    roleintro_ = new ::std::string;
  }
  roleintro_->assign(value);
}
inline void HeroCfg::set_roleintro(const char* value) {
  set_has_roleintro();
  if (roleintro_ == &::google::protobuf::internal::kEmptyString) {
    roleintro_ = new ::std::string;
  }
  roleintro_->assign(value);
}
inline void HeroCfg::set_roleintro(const char* value, size_t size) {
  set_has_roleintro();
  if (roleintro_ == &::google::protobuf::internal::kEmptyString) {
    roleintro_ = new ::std::string;
  }
  roleintro_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeroCfg::mutable_roleintro() {
  set_has_roleintro();
  if (roleintro_ == &::google::protobuf::internal::kEmptyString) {
    roleintro_ = new ::std::string;
  }
  return roleintro_;
}
inline ::std::string* HeroCfg::release_roleintro() {
  clear_has_roleintro();
  if (roleintro_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roleintro_;
    roleintro_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HeroCfg::set_allocated_roleintro(::std::string* roleintro) {
  if (roleintro_ != &::google::protobuf::internal::kEmptyString) {
    delete roleintro_;
  }
  if (roleintro) {
    set_has_roleintro();
    roleintro_ = roleintro;
  } else {
    clear_has_roleintro();
    roleintro_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ResName = 4;
inline bool HeroCfg::has_resname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HeroCfg::set_has_resname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HeroCfg::clear_has_resname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HeroCfg::clear_resname() {
  if (resname_ != &::google::protobuf::internal::kEmptyString) {
    resname_->clear();
  }
  clear_has_resname();
}
inline const ::std::string& HeroCfg::resname() const {
  return *resname_;
}
inline void HeroCfg::set_resname(const ::std::string& value) {
  set_has_resname();
  if (resname_ == &::google::protobuf::internal::kEmptyString) {
    resname_ = new ::std::string;
  }
  resname_->assign(value);
}
inline void HeroCfg::set_resname(const char* value) {
  set_has_resname();
  if (resname_ == &::google::protobuf::internal::kEmptyString) {
    resname_ = new ::std::string;
  }
  resname_->assign(value);
}
inline void HeroCfg::set_resname(const char* value, size_t size) {
  set_has_resname();
  if (resname_ == &::google::protobuf::internal::kEmptyString) {
    resname_ = new ::std::string;
  }
  resname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeroCfg::mutable_resname() {
  set_has_resname();
  if (resname_ == &::google::protobuf::internal::kEmptyString) {
    resname_ = new ::std::string;
  }
  return resname_;
}
inline ::std::string* HeroCfg::release_resname() {
  clear_has_resname();
  if (resname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resname_;
    resname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HeroCfg::set_allocated_resname(::std::string* resname) {
  if (resname_ != &::google::protobuf::internal::kEmptyString) {
    delete resname_;
  }
  if (resname) {
    set_has_resname();
    resname_ = resname;
  } else {
    clear_has_resname();
    resname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string WordsVoice = 5;
inline bool HeroCfg::has_wordsvoice() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HeroCfg::set_has_wordsvoice() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HeroCfg::clear_has_wordsvoice() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HeroCfg::clear_wordsvoice() {
  if (wordsvoice_ != &::google::protobuf::internal::kEmptyString) {
    wordsvoice_->clear();
  }
  clear_has_wordsvoice();
}
inline const ::std::string& HeroCfg::wordsvoice() const {
  return *wordsvoice_;
}
inline void HeroCfg::set_wordsvoice(const ::std::string& value) {
  set_has_wordsvoice();
  if (wordsvoice_ == &::google::protobuf::internal::kEmptyString) {
    wordsvoice_ = new ::std::string;
  }
  wordsvoice_->assign(value);
}
inline void HeroCfg::set_wordsvoice(const char* value) {
  set_has_wordsvoice();
  if (wordsvoice_ == &::google::protobuf::internal::kEmptyString) {
    wordsvoice_ = new ::std::string;
  }
  wordsvoice_->assign(value);
}
inline void HeroCfg::set_wordsvoice(const char* value, size_t size) {
  set_has_wordsvoice();
  if (wordsvoice_ == &::google::protobuf::internal::kEmptyString) {
    wordsvoice_ = new ::std::string;
  }
  wordsvoice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeroCfg::mutable_wordsvoice() {
  set_has_wordsvoice();
  if (wordsvoice_ == &::google::protobuf::internal::kEmptyString) {
    wordsvoice_ = new ::std::string;
  }
  return wordsvoice_;
}
inline ::std::string* HeroCfg::release_wordsvoice() {
  clear_has_wordsvoice();
  if (wordsvoice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wordsvoice_;
    wordsvoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HeroCfg::set_allocated_wordsvoice(::std::string* wordsvoice) {
  if (wordsvoice_ != &::google::protobuf::internal::kEmptyString) {
    delete wordsvoice_;
  }
  if (wordsvoice) {
    set_has_wordsvoice();
    wordsvoice_ = wordsvoice;
  } else {
    clear_has_wordsvoice();
    wordsvoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string EmergeVoice = 6;
inline bool HeroCfg::has_emergevoice() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HeroCfg::set_has_emergevoice() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HeroCfg::clear_has_emergevoice() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HeroCfg::clear_emergevoice() {
  if (emergevoice_ != &::google::protobuf::internal::kEmptyString) {
    emergevoice_->clear();
  }
  clear_has_emergevoice();
}
inline const ::std::string& HeroCfg::emergevoice() const {
  return *emergevoice_;
}
inline void HeroCfg::set_emergevoice(const ::std::string& value) {
  set_has_emergevoice();
  if (emergevoice_ == &::google::protobuf::internal::kEmptyString) {
    emergevoice_ = new ::std::string;
  }
  emergevoice_->assign(value);
}
inline void HeroCfg::set_emergevoice(const char* value) {
  set_has_emergevoice();
  if (emergevoice_ == &::google::protobuf::internal::kEmptyString) {
    emergevoice_ = new ::std::string;
  }
  emergevoice_->assign(value);
}
inline void HeroCfg::set_emergevoice(const char* value, size_t size) {
  set_has_emergevoice();
  if (emergevoice_ == &::google::protobuf::internal::kEmptyString) {
    emergevoice_ = new ::std::string;
  }
  emergevoice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeroCfg::mutable_emergevoice() {
  set_has_emergevoice();
  if (emergevoice_ == &::google::protobuf::internal::kEmptyString) {
    emergevoice_ = new ::std::string;
  }
  return emergevoice_;
}
inline ::std::string* HeroCfg::release_emergevoice() {
  clear_has_emergevoice();
  if (emergevoice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = emergevoice_;
    emergevoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HeroCfg::set_allocated_emergevoice(::std::string* emergevoice) {
  if (emergevoice_ != &::google::protobuf::internal::kEmptyString) {
    delete emergevoice_;
  }
  if (emergevoice) {
    set_has_emergevoice();
    emergevoice_ = emergevoice;
  } else {
    clear_has_emergevoice();
    emergevoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string HurtVoice = 7;
inline bool HeroCfg::has_hurtvoice() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HeroCfg::set_has_hurtvoice() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HeroCfg::clear_has_hurtvoice() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HeroCfg::clear_hurtvoice() {
  if (hurtvoice_ != &::google::protobuf::internal::kEmptyString) {
    hurtvoice_->clear();
  }
  clear_has_hurtvoice();
}
inline const ::std::string& HeroCfg::hurtvoice() const {
  return *hurtvoice_;
}
inline void HeroCfg::set_hurtvoice(const ::std::string& value) {
  set_has_hurtvoice();
  if (hurtvoice_ == &::google::protobuf::internal::kEmptyString) {
    hurtvoice_ = new ::std::string;
  }
  hurtvoice_->assign(value);
}
inline void HeroCfg::set_hurtvoice(const char* value) {
  set_has_hurtvoice();
  if (hurtvoice_ == &::google::protobuf::internal::kEmptyString) {
    hurtvoice_ = new ::std::string;
  }
  hurtvoice_->assign(value);
}
inline void HeroCfg::set_hurtvoice(const char* value, size_t size) {
  set_has_hurtvoice();
  if (hurtvoice_ == &::google::protobuf::internal::kEmptyString) {
    hurtvoice_ = new ::std::string;
  }
  hurtvoice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeroCfg::mutable_hurtvoice() {
  set_has_hurtvoice();
  if (hurtvoice_ == &::google::protobuf::internal::kEmptyString) {
    hurtvoice_ = new ::std::string;
  }
  return hurtvoice_;
}
inline ::std::string* HeroCfg::release_hurtvoice() {
  clear_has_hurtvoice();
  if (hurtvoice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hurtvoice_;
    hurtvoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HeroCfg::set_allocated_hurtvoice(::std::string* hurtvoice) {
  if (hurtvoice_ != &::google::protobuf::internal::kEmptyString) {
    delete hurtvoice_;
  }
  if (hurtvoice) {
    set_has_hurtvoice();
    hurtvoice_ = hurtvoice;
  } else {
    clear_has_hurtvoice();
    hurtvoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DieVoice = 8;
inline bool HeroCfg::has_dievoice() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HeroCfg::set_has_dievoice() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HeroCfg::clear_has_dievoice() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HeroCfg::clear_dievoice() {
  if (dievoice_ != &::google::protobuf::internal::kEmptyString) {
    dievoice_->clear();
  }
  clear_has_dievoice();
}
inline const ::std::string& HeroCfg::dievoice() const {
  return *dievoice_;
}
inline void HeroCfg::set_dievoice(const ::std::string& value) {
  set_has_dievoice();
  if (dievoice_ == &::google::protobuf::internal::kEmptyString) {
    dievoice_ = new ::std::string;
  }
  dievoice_->assign(value);
}
inline void HeroCfg::set_dievoice(const char* value) {
  set_has_dievoice();
  if (dievoice_ == &::google::protobuf::internal::kEmptyString) {
    dievoice_ = new ::std::string;
  }
  dievoice_->assign(value);
}
inline void HeroCfg::set_dievoice(const char* value, size_t size) {
  set_has_dievoice();
  if (dievoice_ == &::google::protobuf::internal::kEmptyString) {
    dievoice_ = new ::std::string;
  }
  dievoice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeroCfg::mutable_dievoice() {
  set_has_dievoice();
  if (dievoice_ == &::google::protobuf::internal::kEmptyString) {
    dievoice_ = new ::std::string;
  }
  return dievoice_;
}
inline ::std::string* HeroCfg::release_dievoice() {
  clear_has_dievoice();
  if (dievoice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dievoice_;
    dievoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HeroCfg::set_allocated_dievoice(::std::string* dievoice) {
  if (dievoice_ != &::google::protobuf::internal::kEmptyString) {
    delete dievoice_;
  }
  if (dievoice) {
    set_has_dievoice();
    dievoice_ = dievoice;
  } else {
    clear_has_dievoice();
    dievoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 StiffTime = 9;
inline bool HeroCfg::has_stifftime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HeroCfg::set_has_stifftime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HeroCfg::clear_has_stifftime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HeroCfg::clear_stifftime() {
  stifftime_ = 0u;
  clear_has_stifftime();
}
inline ::google::protobuf::uint32 HeroCfg::stifftime() const {
  return stifftime_;
}
inline void HeroCfg::set_stifftime(::google::protobuf::uint32 value) {
  set_has_stifftime();
  stifftime_ = value;
}

// required string SwitchWeaponVoice = 10;
inline bool HeroCfg::has_switchweaponvoice() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HeroCfg::set_has_switchweaponvoice() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HeroCfg::clear_has_switchweaponvoice() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HeroCfg::clear_switchweaponvoice() {
  if (switchweaponvoice_ != &::google::protobuf::internal::kEmptyString) {
    switchweaponvoice_->clear();
  }
  clear_has_switchweaponvoice();
}
inline const ::std::string& HeroCfg::switchweaponvoice() const {
  return *switchweaponvoice_;
}
inline void HeroCfg::set_switchweaponvoice(const ::std::string& value) {
  set_has_switchweaponvoice();
  if (switchweaponvoice_ == &::google::protobuf::internal::kEmptyString) {
    switchweaponvoice_ = new ::std::string;
  }
  switchweaponvoice_->assign(value);
}
inline void HeroCfg::set_switchweaponvoice(const char* value) {
  set_has_switchweaponvoice();
  if (switchweaponvoice_ == &::google::protobuf::internal::kEmptyString) {
    switchweaponvoice_ = new ::std::string;
  }
  switchweaponvoice_->assign(value);
}
inline void HeroCfg::set_switchweaponvoice(const char* value, size_t size) {
  set_has_switchweaponvoice();
  if (switchweaponvoice_ == &::google::protobuf::internal::kEmptyString) {
    switchweaponvoice_ = new ::std::string;
  }
  switchweaponvoice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeroCfg::mutable_switchweaponvoice() {
  set_has_switchweaponvoice();
  if (switchweaponvoice_ == &::google::protobuf::internal::kEmptyString) {
    switchweaponvoice_ = new ::std::string;
  }
  return switchweaponvoice_;
}
inline ::std::string* HeroCfg::release_switchweaponvoice() {
  clear_has_switchweaponvoice();
  if (switchweaponvoice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = switchweaponvoice_;
    switchweaponvoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HeroCfg::set_allocated_switchweaponvoice(::std::string* switchweaponvoice) {
  if (switchweaponvoice_ != &::google::protobuf::internal::kEmptyString) {
    delete switchweaponvoice_;
  }
  if (switchweaponvoice) {
    set_has_switchweaponvoice();
    switchweaponvoice_ = switchweaponvoice;
  } else {
    clear_has_switchweaponvoice();
    switchweaponvoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string HeadIcon = 11;
inline bool HeroCfg::has_headicon() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HeroCfg::set_has_headicon() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HeroCfg::clear_has_headicon() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HeroCfg::clear_headicon() {
  if (headicon_ != &::google::protobuf::internal::kEmptyString) {
    headicon_->clear();
  }
  clear_has_headicon();
}
inline const ::std::string& HeroCfg::headicon() const {
  return *headicon_;
}
inline void HeroCfg::set_headicon(const ::std::string& value) {
  set_has_headicon();
  if (headicon_ == &::google::protobuf::internal::kEmptyString) {
    headicon_ = new ::std::string;
  }
  headicon_->assign(value);
}
inline void HeroCfg::set_headicon(const char* value) {
  set_has_headicon();
  if (headicon_ == &::google::protobuf::internal::kEmptyString) {
    headicon_ = new ::std::string;
  }
  headicon_->assign(value);
}
inline void HeroCfg::set_headicon(const char* value, size_t size) {
  set_has_headicon();
  if (headicon_ == &::google::protobuf::internal::kEmptyString) {
    headicon_ = new ::std::string;
  }
  headicon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeroCfg::mutable_headicon() {
  set_has_headicon();
  if (headicon_ == &::google::protobuf::internal::kEmptyString) {
    headicon_ = new ::std::string;
  }
  return headicon_;
}
inline ::std::string* HeroCfg::release_headicon() {
  clear_has_headicon();
  if (headicon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headicon_;
    headicon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HeroCfg::set_allocated_headicon(::std::string* headicon) {
  if (headicon_ != &::google::protobuf::internal::kEmptyString) {
    delete headicon_;
  }
  if (headicon) {
    set_has_headicon();
    headicon_ = headicon;
  } else {
    clear_has_headicon();
    headicon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DodgeSound = 12;
inline bool HeroCfg::has_dodgesound() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void HeroCfg::set_has_dodgesound() {
  _has_bits_[0] |= 0x00000800u;
}
inline void HeroCfg::clear_has_dodgesound() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void HeroCfg::clear_dodgesound() {
  if (dodgesound_ != &::google::protobuf::internal::kEmptyString) {
    dodgesound_->clear();
  }
  clear_has_dodgesound();
}
inline const ::std::string& HeroCfg::dodgesound() const {
  return *dodgesound_;
}
inline void HeroCfg::set_dodgesound(const ::std::string& value) {
  set_has_dodgesound();
  if (dodgesound_ == &::google::protobuf::internal::kEmptyString) {
    dodgesound_ = new ::std::string;
  }
  dodgesound_->assign(value);
}
inline void HeroCfg::set_dodgesound(const char* value) {
  set_has_dodgesound();
  if (dodgesound_ == &::google::protobuf::internal::kEmptyString) {
    dodgesound_ = new ::std::string;
  }
  dodgesound_->assign(value);
}
inline void HeroCfg::set_dodgesound(const char* value, size_t size) {
  set_has_dodgesound();
  if (dodgesound_ == &::google::protobuf::internal::kEmptyString) {
    dodgesound_ = new ::std::string;
  }
  dodgesound_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeroCfg::mutable_dodgesound() {
  set_has_dodgesound();
  if (dodgesound_ == &::google::protobuf::internal::kEmptyString) {
    dodgesound_ = new ::std::string;
  }
  return dodgesound_;
}
inline ::std::string* HeroCfg::release_dodgesound() {
  clear_has_dodgesound();
  if (dodgesound_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dodgesound_;
    dodgesound_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HeroCfg::set_allocated_dodgesound(::std::string* dodgesound) {
  if (dodgesound_ != &::google::protobuf::internal::kEmptyString) {
    delete dodgesound_;
  }
  if (dodgesound) {
    set_has_dodgesound();
    dodgesound_ = dodgesound;
  } else {
    clear_has_dodgesound();
    dodgesound_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 HurtColor = 13;
inline bool HeroCfg::has_hurtcolor() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void HeroCfg::set_has_hurtcolor() {
  _has_bits_[0] |= 0x00001000u;
}
inline void HeroCfg::clear_has_hurtcolor() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void HeroCfg::clear_hurtcolor() {
  hurtcolor_ = 0u;
  clear_has_hurtcolor();
}
inline ::google::protobuf::uint32 HeroCfg::hurtcolor() const {
  return hurtcolor_;
}
inline void HeroCfg::set_hurtcolor(::google::protobuf::uint32 value) {
  set_has_hurtcolor();
  hurtcolor_ = value;
}

// required uint32 RunDis = 14;
inline bool HeroCfg::has_rundis() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void HeroCfg::set_has_rundis() {
  _has_bits_[0] |= 0x00002000u;
}
inline void HeroCfg::clear_has_rundis() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void HeroCfg::clear_rundis() {
  rundis_ = 0u;
  clear_has_rundis();
}
inline ::google::protobuf::uint32 HeroCfg::rundis() const {
  return rundis_;
}
inline void HeroCfg::set_rundis(::google::protobuf::uint32 value) {
  set_has_rundis();
  rundis_ = value;
}

// required uint32 ActNum = 15;
inline bool HeroCfg::has_actnum() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void HeroCfg::set_has_actnum() {
  _has_bits_[0] |= 0x00004000u;
}
inline void HeroCfg::clear_has_actnum() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void HeroCfg::clear_actnum() {
  actnum_ = 0u;
  clear_has_actnum();
}
inline ::google::protobuf::uint32 HeroCfg::actnum() const {
  return actnum_;
}
inline void HeroCfg::set_actnum(::google::protobuf::uint32 value) {
  set_has_actnum();
  actnum_ = value;
}

// -------------------------------------------------------------------

// HeroCfgSet

// repeated .com.cfg.vo.HeroCfg heroCfg = 1;
inline int HeroCfgSet::herocfg_size() const {
  return herocfg_.size();
}
inline void HeroCfgSet::clear_herocfg() {
  herocfg_.Clear();
}
inline const ::com::cfg::vo::HeroCfg& HeroCfgSet::herocfg(int index) const {
  return herocfg_.Get(index);
}
inline ::com::cfg::vo::HeroCfg* HeroCfgSet::mutable_herocfg(int index) {
  return herocfg_.Mutable(index);
}
inline ::com::cfg::vo::HeroCfg* HeroCfgSet::add_herocfg() {
  return herocfg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::HeroCfg >&
HeroCfgSet::herocfg() const {
  return herocfg_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::HeroCfg >*
HeroCfgSet::mutable_herocfg() {
  return &herocfg_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vo
}  // namespace cfg
}  // namespace com

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_HeroCfg_2eproto__INCLUDED
