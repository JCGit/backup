// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SkillCfg.proto

#ifndef PROTOBUF_SkillCfg_2eproto__INCLUDED
#define PROTOBUF_SkillCfg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace cfg {
namespace vo {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SkillCfg_2eproto();
void protobuf_AssignDesc_SkillCfg_2eproto();
void protobuf_ShutdownFile_SkillCfg_2eproto();

class SkillEffect;
class SkillCfg;
class SkillCfgSet;

// ===================================================================

class SkillEffect : public ::google::protobuf::MessageLite {
 public:
  SkillEffect();
  virtual ~SkillEffect();

  SkillEffect(const SkillEffect& from);

  inline SkillEffect& operator=(const SkillEffect& from) {
    CopyFrom(from);
    return *this;
  }

  static const SkillEffect& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SkillEffect* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SkillEffect* other);

  // implements Message ----------------------------------------------

  SkillEffect* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SkillEffect& from);
  void MergeFrom(const SkillEffect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 TargetType = 1;
  inline bool has_targettype() const;
  inline void clear_targettype();
  static const int kTargetTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 targettype() const;
  inline void set_targettype(::google::protobuf::uint32 value);

  // required uint32 EffectType = 2;
  inline bool has_effecttype() const;
  inline void clear_effecttype();
  static const int kEffectTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 effecttype() const;
  inline void set_effecttype(::google::protobuf::uint32 value);

  // required uint32 EffectVal = 3;
  inline bool has_effectval() const;
  inline void clear_effectval();
  static const int kEffectValFieldNumber = 3;
  inline ::google::protobuf::uint32 effectval() const;
  inline void set_effectval(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.cfg.vo.SkillEffect)
 private:
  inline void set_has_targettype();
  inline void clear_has_targettype();
  inline void set_has_effecttype();
  inline void clear_has_effecttype();
  inline void set_has_effectval();
  inline void clear_has_effectval();

  ::google::protobuf::uint32 targettype_;
  ::google::protobuf::uint32 effecttype_;
  ::google::protobuf::uint32 effectval_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SkillCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SkillCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_SkillCfg_2eproto();
  friend void protobuf_ShutdownFile_SkillCfg_2eproto();

  void InitAsDefaultInstance();
  static SkillEffect* default_instance_;
};
// -------------------------------------------------------------------

class SkillCfg : public ::google::protobuf::MessageLite {
 public:
  SkillCfg();
  virtual ~SkillCfg();

  SkillCfg(const SkillCfg& from);

  inline SkillCfg& operator=(const SkillCfg& from) {
    CopyFrom(from);
    return *this;
  }

  static const SkillCfg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SkillCfg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SkillCfg* other);

  // implements Message ----------------------------------------------

  SkillCfg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SkillCfg& from);
  void MergeFrom(const SkillCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 SkillID = 1;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillIDFieldNumber = 1;
  inline ::google::protobuf::uint32 skillid() const;
  inline void set_skillid(::google::protobuf::uint32 value);

  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string Desc = 3;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 3;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // required uint32 CD = 4;
  inline bool has_cd() const;
  inline void clear_cd();
  static const int kCDFieldNumber = 4;
  inline ::google::protobuf::uint32 cd() const;
  inline void set_cd(::google::protobuf::uint32 value);

  // required uint32 EPCost = 5;
  inline bool has_epcost() const;
  inline void clear_epcost();
  static const int kEPCostFieldNumber = 5;
  inline ::google::protobuf::uint32 epcost() const;
  inline void set_epcost(::google::protobuf::uint32 value);

  // required uint32 CastDist = 6;
  inline bool has_castdist() const;
  inline void clear_castdist();
  static const int kCastDistFieldNumber = 6;
  inline ::google::protobuf::uint32 castdist() const;
  inline void set_castdist(::google::protobuf::uint32 value);

  // required uint32 CastLoopCnt = 7;
  inline bool has_castloopcnt() const;
  inline void clear_castloopcnt();
  static const int kCastLoopCntFieldNumber = 7;
  inline ::google::protobuf::uint32 castloopcnt() const;
  inline void set_castloopcnt(::google::protobuf::uint32 value);

  // required uint32 FlySpeed = 8;
  inline bool has_flyspeed() const;
  inline void clear_flyspeed();
  static const int kFlySpeedFieldNumber = 8;
  inline ::google::protobuf::uint32 flyspeed() const;
  inline void set_flyspeed(::google::protobuf::uint32 value);

  // required string CastAction = 9;
  inline bool has_castaction() const;
  inline void clear_castaction();
  static const int kCastActionFieldNumber = 9;
  inline const ::std::string& castaction() const;
  inline void set_castaction(const ::std::string& value);
  inline void set_castaction(const char* value);
  inline void set_castaction(const char* value, size_t size);
  inline ::std::string* mutable_castaction();
  inline ::std::string* release_castaction();
  inline void set_allocated_castaction(::std::string* castaction);

  // required string CastAnimation = 10;
  inline bool has_castanimation() const;
  inline void clear_castanimation();
  static const int kCastAnimationFieldNumber = 10;
  inline const ::std::string& castanimation() const;
  inline void set_castanimation(const ::std::string& value);
  inline void set_castanimation(const char* value);
  inline void set_castanimation(const char* value, size_t size);
  inline ::std::string* mutable_castanimation();
  inline ::std::string* release_castanimation();
  inline void set_allocated_castanimation(::std::string* castanimation);

  // required string CastSound = 11;
  inline bool has_castsound() const;
  inline void clear_castsound();
  static const int kCastSoundFieldNumber = 11;
  inline const ::std::string& castsound() const;
  inline void set_castsound(const ::std::string& value);
  inline void set_castsound(const char* value);
  inline void set_castsound(const char* value, size_t size);
  inline ::std::string* mutable_castsound();
  inline ::std::string* release_castsound();
  inline void set_allocated_castsound(::std::string* castsound);

  // required string FlyAnimation = 12;
  inline bool has_flyanimation() const;
  inline void clear_flyanimation();
  static const int kFlyAnimationFieldNumber = 12;
  inline const ::std::string& flyanimation() const;
  inline void set_flyanimation(const ::std::string& value);
  inline void set_flyanimation(const char* value);
  inline void set_flyanimation(const char* value, size_t size);
  inline ::std::string* mutable_flyanimation();
  inline ::std::string* release_flyanimation();
  inline void set_allocated_flyanimation(::std::string* flyanimation);

  // required string AtkSound = 13;
  inline bool has_atksound() const;
  inline void clear_atksound();
  static const int kAtkSoundFieldNumber = 13;
  inline const ::std::string& atksound() const;
  inline void set_atksound(const ::std::string& value);
  inline void set_atksound(const char* value);
  inline void set_atksound(const char* value, size_t size);
  inline ::std::string* mutable_atksound();
  inline ::std::string* release_atksound();
  inline void set_allocated_atksound(::std::string* atksound);

  // required string HurtAnimation = 14;
  inline bool has_hurtanimation() const;
  inline void clear_hurtanimation();
  static const int kHurtAnimationFieldNumber = 14;
  inline const ::std::string& hurtanimation() const;
  inline void set_hurtanimation(const ::std::string& value);
  inline void set_hurtanimation(const char* value);
  inline void set_hurtanimation(const char* value, size_t size);
  inline ::std::string* mutable_hurtanimation();
  inline ::std::string* release_hurtanimation();
  inline void set_allocated_hurtanimation(::std::string* hurtanimation);

  // required string HitSound = 15;
  inline bool has_hitsound() const;
  inline void clear_hitsound();
  static const int kHitSoundFieldNumber = 15;
  inline const ::std::string& hitsound() const;
  inline void set_hitsound(const ::std::string& value);
  inline void set_hitsound(const char* value);
  inline void set_hitsound(const char* value, size_t size);
  inline ::std::string* mutable_hitsound();
  inline ::std::string* release_hitsound();
  inline void set_allocated_hitsound(::std::string* hitsound);

  // required uint32 TriggerType = 16;
  inline bool has_triggertype() const;
  inline void clear_triggertype();
  static const int kTriggerTypeFieldNumber = 16;
  inline ::google::protobuf::uint32 triggertype() const;
  inline void set_triggertype(::google::protobuf::uint32 value);

  // required uint32 DamageZone = 17;
  inline bool has_damagezone() const;
  inline void clear_damagezone();
  static const int kDamageZoneFieldNumber = 17;
  inline ::google::protobuf::uint32 damagezone() const;
  inline void set_damagezone(::google::protobuf::uint32 value);

  // required uint32 TargetCnt = 18;
  inline bool has_targetcnt() const;
  inline void clear_targetcnt();
  static const int kTargetCntFieldNumber = 18;
  inline ::google::protobuf::uint32 targetcnt() const;
  inline void set_targetcnt(::google::protobuf::uint32 value);

  // required uint32 DamageAreaType = 19;
  inline bool has_damageareatype() const;
  inline void clear_damageareatype();
  static const int kDamageAreaTypeFieldNumber = 19;
  inline ::google::protobuf::uint32 damageareatype() const;
  inline void set_damageareatype(::google::protobuf::uint32 value);

  // required uint32 EffectX = 20;
  inline bool has_effectx() const;
  inline void clear_effectx();
  static const int kEffectXFieldNumber = 20;
  inline ::google::protobuf::uint32 effectx() const;
  inline void set_effectx(::google::protobuf::uint32 value);

  // required uint32 EffectY = 21;
  inline bool has_effecty() const;
  inline void clear_effecty();
  static const int kEffectYFieldNumber = 21;
  inline ::google::protobuf::uint32 effecty() const;
  inline void set_effecty(::google::protobuf::uint32 value);

  // required uint32 HitBackDist = 22;
  inline bool has_hitbackdist() const;
  inline void clear_hitbackdist();
  static const int kHitBackDistFieldNumber = 22;
  inline ::google::protobuf::uint32 hitbackdist() const;
  inline void set_hitbackdist(::google::protobuf::uint32 value);

  // repeated .com.cfg.vo.SkillEffect Effects = 23;
  inline int effects_size() const;
  inline void clear_effects();
  static const int kEffectsFieldNumber = 23;
  inline const ::com::cfg::vo::SkillEffect& effects(int index) const;
  inline ::com::cfg::vo::SkillEffect* mutable_effects(int index);
  inline ::com::cfg::vo::SkillEffect* add_effects();
  inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::SkillEffect >&
      effects() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::SkillEffect >*
      mutable_effects();

  // required uint32 FloorBuffID = 24;
  inline bool has_floorbuffid() const;
  inline void clear_floorbuffid();
  static const int kFloorBuffIDFieldNumber = 24;
  inline ::google::protobuf::uint32 floorbuffid() const;
  inline void set_floorbuffid(::google::protobuf::uint32 value);

  // required string SkillIcon = 28;
  inline bool has_skillicon() const;
  inline void clear_skillicon();
  static const int kSkillIconFieldNumber = 28;
  inline const ::std::string& skillicon() const;
  inline void set_skillicon(const ::std::string& value);
  inline void set_skillicon(const char* value);
  inline void set_skillicon(const char* value, size_t size);
  inline ::std::string* mutable_skillicon();
  inline ::std::string* release_skillicon();
  inline void set_allocated_skillicon(::std::string* skillicon);

  // required string GunAnimation = 29;
  inline bool has_gunanimation() const;
  inline void clear_gunanimation();
  static const int kGunAnimationFieldNumber = 29;
  inline const ::std::string& gunanimation() const;
  inline void set_gunanimation(const ::std::string& value);
  inline void set_gunanimation(const char* value);
  inline void set_gunanimation(const char* value, size_t size);
  inline ::std::string* mutable_gunanimation();
  inline ::std::string* release_gunanimation();
  inline void set_allocated_gunanimation(::std::string* gunanimation);

  // required uint32 SkillValidTime = 30;
  inline bool has_skillvalidtime() const;
  inline void clear_skillvalidtime();
  static const int kSkillValidTimeFieldNumber = 30;
  inline ::google::protobuf::uint32 skillvalidtime() const;
  inline void set_skillvalidtime(::google::protobuf::uint32 value);

  // required uint32 CastCondType = 31;
  inline bool has_castcondtype() const;
  inline void clear_castcondtype();
  static const int kCastCondTypeFieldNumber = 31;
  inline ::google::protobuf::uint32 castcondtype() const;
  inline void set_castcondtype(::google::protobuf::uint32 value);

  // required uint32 CastCondValue = 32;
  inline bool has_castcondvalue() const;
  inline void clear_castcondvalue();
  static const int kCastCondValueFieldNumber = 32;
  inline ::google::protobuf::uint32 castcondvalue() const;
  inline void set_castcondvalue(::google::protobuf::uint32 value);

  // required uint32 DamageCnt = 33;
  inline bool has_damagecnt() const;
  inline void clear_damagecnt();
  static const int kDamageCntFieldNumber = 33;
  inline ::google::protobuf::uint32 damagecnt() const;
  inline void set_damagecnt(::google::protobuf::uint32 value);

  // required uint32 EffInter = 34;
  inline bool has_effinter() const;
  inline void clear_effinter();
  static const int kEffInterFieldNumber = 34;
  inline ::google::protobuf::uint32 effinter() const;
  inline void set_effinter(::google::protobuf::uint32 value);

  // required string NextAction = 35;
  inline bool has_nextaction() const;
  inline void clear_nextaction();
  static const int kNextActionFieldNumber = 35;
  inline const ::std::string& nextaction() const;
  inline void set_nextaction(const ::std::string& value);
  inline void set_nextaction(const char* value);
  inline void set_nextaction(const char* value, size_t size);
  inline ::std::string* mutable_nextaction();
  inline ::std::string* release_nextaction();
  inline void set_allocated_nextaction(::std::string* nextaction);

  // required string NextActSound = 36;
  inline bool has_nextactsound() const;
  inline void clear_nextactsound();
  static const int kNextActSoundFieldNumber = 36;
  inline const ::std::string& nextactsound() const;
  inline void set_nextactsound(const ::std::string& value);
  inline void set_nextactsound(const char* value);
  inline void set_nextactsound(const char* value, size_t size);
  inline ::std::string* mutable_nextactsound();
  inline ::std::string* release_nextactsound();
  inline void set_allocated_nextactsound(::std::string* nextactsound);

  // required string DieAction = 37;
  inline bool has_dieaction() const;
  inline void clear_dieaction();
  static const int kDieActionFieldNumber = 37;
  inline const ::std::string& dieaction() const;
  inline void set_dieaction(const ::std::string& value);
  inline void set_dieaction(const char* value);
  inline void set_dieaction(const char* value, size_t size);
  inline ::std::string* mutable_dieaction();
  inline ::std::string* release_dieaction();
  inline void set_allocated_dieaction(::std::string* dieaction);

  // @@protoc_insertion_point(class_scope:com.cfg.vo.SkillCfg)
 private:
  inline void set_has_skillid();
  inline void clear_has_skillid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_cd();
  inline void clear_has_cd();
  inline void set_has_epcost();
  inline void clear_has_epcost();
  inline void set_has_castdist();
  inline void clear_has_castdist();
  inline void set_has_castloopcnt();
  inline void clear_has_castloopcnt();
  inline void set_has_flyspeed();
  inline void clear_has_flyspeed();
  inline void set_has_castaction();
  inline void clear_has_castaction();
  inline void set_has_castanimation();
  inline void clear_has_castanimation();
  inline void set_has_castsound();
  inline void clear_has_castsound();
  inline void set_has_flyanimation();
  inline void clear_has_flyanimation();
  inline void set_has_atksound();
  inline void clear_has_atksound();
  inline void set_has_hurtanimation();
  inline void clear_has_hurtanimation();
  inline void set_has_hitsound();
  inline void clear_has_hitsound();
  inline void set_has_triggertype();
  inline void clear_has_triggertype();
  inline void set_has_damagezone();
  inline void clear_has_damagezone();
  inline void set_has_targetcnt();
  inline void clear_has_targetcnt();
  inline void set_has_damageareatype();
  inline void clear_has_damageareatype();
  inline void set_has_effectx();
  inline void clear_has_effectx();
  inline void set_has_effecty();
  inline void clear_has_effecty();
  inline void set_has_hitbackdist();
  inline void clear_has_hitbackdist();
  inline void set_has_floorbuffid();
  inline void clear_has_floorbuffid();
  inline void set_has_skillicon();
  inline void clear_has_skillicon();
  inline void set_has_gunanimation();
  inline void clear_has_gunanimation();
  inline void set_has_skillvalidtime();
  inline void clear_has_skillvalidtime();
  inline void set_has_castcondtype();
  inline void clear_has_castcondtype();
  inline void set_has_castcondvalue();
  inline void clear_has_castcondvalue();
  inline void set_has_damagecnt();
  inline void clear_has_damagecnt();
  inline void set_has_effinter();
  inline void clear_has_effinter();
  inline void set_has_nextaction();
  inline void clear_has_nextaction();
  inline void set_has_nextactsound();
  inline void clear_has_nextactsound();
  inline void set_has_dieaction();
  inline void clear_has_dieaction();

  ::std::string* name_;
  ::google::protobuf::uint32 skillid_;
  ::google::protobuf::uint32 cd_;
  ::std::string* desc_;
  ::google::protobuf::uint32 epcost_;
  ::google::protobuf::uint32 castdist_;
  ::google::protobuf::uint32 castloopcnt_;
  ::google::protobuf::uint32 flyspeed_;
  ::std::string* castaction_;
  ::std::string* castanimation_;
  ::std::string* castsound_;
  ::std::string* flyanimation_;
  ::std::string* atksound_;
  ::std::string* hurtanimation_;
  ::std::string* hitsound_;
  ::google::protobuf::uint32 triggertype_;
  ::google::protobuf::uint32 damagezone_;
  ::google::protobuf::uint32 targetcnt_;
  ::google::protobuf::uint32 damageareatype_;
  ::google::protobuf::uint32 effectx_;
  ::google::protobuf::uint32 effecty_;
  ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::SkillEffect > effects_;
  ::google::protobuf::uint32 hitbackdist_;
  ::google::protobuf::uint32 floorbuffid_;
  ::std::string* skillicon_;
  ::std::string* gunanimation_;
  ::google::protobuf::uint32 skillvalidtime_;
  ::google::protobuf::uint32 castcondtype_;
  ::google::protobuf::uint32 castcondvalue_;
  ::google::protobuf::uint32 damagecnt_;
  ::std::string* nextaction_;
  ::std::string* nextactsound_;
  ::std::string* dieaction_;
  ::google::protobuf::uint32 effinter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(34 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SkillCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SkillCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_SkillCfg_2eproto();
  friend void protobuf_ShutdownFile_SkillCfg_2eproto();

  void InitAsDefaultInstance();
  static SkillCfg* default_instance_;
};
// -------------------------------------------------------------------

class SkillCfgSet : public ::google::protobuf::MessageLite {
 public:
  SkillCfgSet();
  virtual ~SkillCfgSet();

  SkillCfgSet(const SkillCfgSet& from);

  inline SkillCfgSet& operator=(const SkillCfgSet& from) {
    CopyFrom(from);
    return *this;
  }

  static const SkillCfgSet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SkillCfgSet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SkillCfgSet* other);

  // implements Message ----------------------------------------------

  SkillCfgSet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SkillCfgSet& from);
  void MergeFrom(const SkillCfgSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.cfg.vo.SkillCfg skillcfg = 1;
  inline int skillcfg_size() const;
  inline void clear_skillcfg();
  static const int kSkillcfgFieldNumber = 1;
  inline const ::com::cfg::vo::SkillCfg& skillcfg(int index) const;
  inline ::com::cfg::vo::SkillCfg* mutable_skillcfg(int index);
  inline ::com::cfg::vo::SkillCfg* add_skillcfg();
  inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::SkillCfg >&
      skillcfg() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::SkillCfg >*
      mutable_skillcfg();

  // @@protoc_insertion_point(class_scope:com.cfg.vo.SkillCfgSet)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::SkillCfg > skillcfg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_SkillCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_SkillCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_SkillCfg_2eproto();
  friend void protobuf_ShutdownFile_SkillCfg_2eproto();

  void InitAsDefaultInstance();
  static SkillCfgSet* default_instance_;
};
// ===================================================================


// ===================================================================

// SkillEffect

// required uint32 TargetType = 1;
inline bool SkillEffect::has_targettype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkillEffect::set_has_targettype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SkillEffect::clear_has_targettype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SkillEffect::clear_targettype() {
  targettype_ = 0u;
  clear_has_targettype();
}
inline ::google::protobuf::uint32 SkillEffect::targettype() const {
  return targettype_;
}
inline void SkillEffect::set_targettype(::google::protobuf::uint32 value) {
  set_has_targettype();
  targettype_ = value;
}

// required uint32 EffectType = 2;
inline bool SkillEffect::has_effecttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SkillEffect::set_has_effecttype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SkillEffect::clear_has_effecttype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SkillEffect::clear_effecttype() {
  effecttype_ = 0u;
  clear_has_effecttype();
}
inline ::google::protobuf::uint32 SkillEffect::effecttype() const {
  return effecttype_;
}
inline void SkillEffect::set_effecttype(::google::protobuf::uint32 value) {
  set_has_effecttype();
  effecttype_ = value;
}

// required uint32 EffectVal = 3;
inline bool SkillEffect::has_effectval() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SkillEffect::set_has_effectval() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SkillEffect::clear_has_effectval() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SkillEffect::clear_effectval() {
  effectval_ = 0u;
  clear_has_effectval();
}
inline ::google::protobuf::uint32 SkillEffect::effectval() const {
  return effectval_;
}
inline void SkillEffect::set_effectval(::google::protobuf::uint32 value) {
  set_has_effectval();
  effectval_ = value;
}

// -------------------------------------------------------------------

// SkillCfg

// required uint32 SkillID = 1;
inline bool SkillCfg::has_skillid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkillCfg::set_has_skillid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SkillCfg::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SkillCfg::clear_skillid() {
  skillid_ = 0u;
  clear_has_skillid();
}
inline ::google::protobuf::uint32 SkillCfg::skillid() const {
  return skillid_;
}
inline void SkillCfg::set_skillid(::google::protobuf::uint32 value) {
  set_has_skillid();
  skillid_ = value;
}

// required string Name = 2;
inline bool SkillCfg::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SkillCfg::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SkillCfg::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SkillCfg::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SkillCfg::name() const {
  return *name_;
}
inline void SkillCfg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SkillCfg::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SkillCfg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillCfg::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SkillCfg::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkillCfg::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Desc = 3;
inline bool SkillCfg::has_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SkillCfg::set_has_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SkillCfg::clear_has_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SkillCfg::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& SkillCfg::desc() const {
  return *desc_;
}
inline void SkillCfg::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void SkillCfg::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void SkillCfg::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillCfg::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* SkillCfg::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkillCfg::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 CD = 4;
inline bool SkillCfg::has_cd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SkillCfg::set_has_cd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SkillCfg::clear_has_cd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SkillCfg::clear_cd() {
  cd_ = 0u;
  clear_has_cd();
}
inline ::google::protobuf::uint32 SkillCfg::cd() const {
  return cd_;
}
inline void SkillCfg::set_cd(::google::protobuf::uint32 value) {
  set_has_cd();
  cd_ = value;
}

// required uint32 EPCost = 5;
inline bool SkillCfg::has_epcost() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SkillCfg::set_has_epcost() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SkillCfg::clear_has_epcost() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SkillCfg::clear_epcost() {
  epcost_ = 0u;
  clear_has_epcost();
}
inline ::google::protobuf::uint32 SkillCfg::epcost() const {
  return epcost_;
}
inline void SkillCfg::set_epcost(::google::protobuf::uint32 value) {
  set_has_epcost();
  epcost_ = value;
}

// required uint32 CastDist = 6;
inline bool SkillCfg::has_castdist() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SkillCfg::set_has_castdist() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SkillCfg::clear_has_castdist() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SkillCfg::clear_castdist() {
  castdist_ = 0u;
  clear_has_castdist();
}
inline ::google::protobuf::uint32 SkillCfg::castdist() const {
  return castdist_;
}
inline void SkillCfg::set_castdist(::google::protobuf::uint32 value) {
  set_has_castdist();
  castdist_ = value;
}

// required uint32 CastLoopCnt = 7;
inline bool SkillCfg::has_castloopcnt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SkillCfg::set_has_castloopcnt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SkillCfg::clear_has_castloopcnt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SkillCfg::clear_castloopcnt() {
  castloopcnt_ = 0u;
  clear_has_castloopcnt();
}
inline ::google::protobuf::uint32 SkillCfg::castloopcnt() const {
  return castloopcnt_;
}
inline void SkillCfg::set_castloopcnt(::google::protobuf::uint32 value) {
  set_has_castloopcnt();
  castloopcnt_ = value;
}

// required uint32 FlySpeed = 8;
inline bool SkillCfg::has_flyspeed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SkillCfg::set_has_flyspeed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SkillCfg::clear_has_flyspeed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SkillCfg::clear_flyspeed() {
  flyspeed_ = 0u;
  clear_has_flyspeed();
}
inline ::google::protobuf::uint32 SkillCfg::flyspeed() const {
  return flyspeed_;
}
inline void SkillCfg::set_flyspeed(::google::protobuf::uint32 value) {
  set_has_flyspeed();
  flyspeed_ = value;
}

// required string CastAction = 9;
inline bool SkillCfg::has_castaction() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SkillCfg::set_has_castaction() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SkillCfg::clear_has_castaction() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SkillCfg::clear_castaction() {
  if (castaction_ != &::google::protobuf::internal::kEmptyString) {
    castaction_->clear();
  }
  clear_has_castaction();
}
inline const ::std::string& SkillCfg::castaction() const {
  return *castaction_;
}
inline void SkillCfg::set_castaction(const ::std::string& value) {
  set_has_castaction();
  if (castaction_ == &::google::protobuf::internal::kEmptyString) {
    castaction_ = new ::std::string;
  }
  castaction_->assign(value);
}
inline void SkillCfg::set_castaction(const char* value) {
  set_has_castaction();
  if (castaction_ == &::google::protobuf::internal::kEmptyString) {
    castaction_ = new ::std::string;
  }
  castaction_->assign(value);
}
inline void SkillCfg::set_castaction(const char* value, size_t size) {
  set_has_castaction();
  if (castaction_ == &::google::protobuf::internal::kEmptyString) {
    castaction_ = new ::std::string;
  }
  castaction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillCfg::mutable_castaction() {
  set_has_castaction();
  if (castaction_ == &::google::protobuf::internal::kEmptyString) {
    castaction_ = new ::std::string;
  }
  return castaction_;
}
inline ::std::string* SkillCfg::release_castaction() {
  clear_has_castaction();
  if (castaction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = castaction_;
    castaction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkillCfg::set_allocated_castaction(::std::string* castaction) {
  if (castaction_ != &::google::protobuf::internal::kEmptyString) {
    delete castaction_;
  }
  if (castaction) {
    set_has_castaction();
    castaction_ = castaction;
  } else {
    clear_has_castaction();
    castaction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string CastAnimation = 10;
inline bool SkillCfg::has_castanimation() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SkillCfg::set_has_castanimation() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SkillCfg::clear_has_castanimation() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SkillCfg::clear_castanimation() {
  if (castanimation_ != &::google::protobuf::internal::kEmptyString) {
    castanimation_->clear();
  }
  clear_has_castanimation();
}
inline const ::std::string& SkillCfg::castanimation() const {
  return *castanimation_;
}
inline void SkillCfg::set_castanimation(const ::std::string& value) {
  set_has_castanimation();
  if (castanimation_ == &::google::protobuf::internal::kEmptyString) {
    castanimation_ = new ::std::string;
  }
  castanimation_->assign(value);
}
inline void SkillCfg::set_castanimation(const char* value) {
  set_has_castanimation();
  if (castanimation_ == &::google::protobuf::internal::kEmptyString) {
    castanimation_ = new ::std::string;
  }
  castanimation_->assign(value);
}
inline void SkillCfg::set_castanimation(const char* value, size_t size) {
  set_has_castanimation();
  if (castanimation_ == &::google::protobuf::internal::kEmptyString) {
    castanimation_ = new ::std::string;
  }
  castanimation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillCfg::mutable_castanimation() {
  set_has_castanimation();
  if (castanimation_ == &::google::protobuf::internal::kEmptyString) {
    castanimation_ = new ::std::string;
  }
  return castanimation_;
}
inline ::std::string* SkillCfg::release_castanimation() {
  clear_has_castanimation();
  if (castanimation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = castanimation_;
    castanimation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkillCfg::set_allocated_castanimation(::std::string* castanimation) {
  if (castanimation_ != &::google::protobuf::internal::kEmptyString) {
    delete castanimation_;
  }
  if (castanimation) {
    set_has_castanimation();
    castanimation_ = castanimation;
  } else {
    clear_has_castanimation();
    castanimation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string CastSound = 11;
inline bool SkillCfg::has_castsound() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SkillCfg::set_has_castsound() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SkillCfg::clear_has_castsound() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SkillCfg::clear_castsound() {
  if (castsound_ != &::google::protobuf::internal::kEmptyString) {
    castsound_->clear();
  }
  clear_has_castsound();
}
inline const ::std::string& SkillCfg::castsound() const {
  return *castsound_;
}
inline void SkillCfg::set_castsound(const ::std::string& value) {
  set_has_castsound();
  if (castsound_ == &::google::protobuf::internal::kEmptyString) {
    castsound_ = new ::std::string;
  }
  castsound_->assign(value);
}
inline void SkillCfg::set_castsound(const char* value) {
  set_has_castsound();
  if (castsound_ == &::google::protobuf::internal::kEmptyString) {
    castsound_ = new ::std::string;
  }
  castsound_->assign(value);
}
inline void SkillCfg::set_castsound(const char* value, size_t size) {
  set_has_castsound();
  if (castsound_ == &::google::protobuf::internal::kEmptyString) {
    castsound_ = new ::std::string;
  }
  castsound_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillCfg::mutable_castsound() {
  set_has_castsound();
  if (castsound_ == &::google::protobuf::internal::kEmptyString) {
    castsound_ = new ::std::string;
  }
  return castsound_;
}
inline ::std::string* SkillCfg::release_castsound() {
  clear_has_castsound();
  if (castsound_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = castsound_;
    castsound_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkillCfg::set_allocated_castsound(::std::string* castsound) {
  if (castsound_ != &::google::protobuf::internal::kEmptyString) {
    delete castsound_;
  }
  if (castsound) {
    set_has_castsound();
    castsound_ = castsound;
  } else {
    clear_has_castsound();
    castsound_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string FlyAnimation = 12;
inline bool SkillCfg::has_flyanimation() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SkillCfg::set_has_flyanimation() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SkillCfg::clear_has_flyanimation() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SkillCfg::clear_flyanimation() {
  if (flyanimation_ != &::google::protobuf::internal::kEmptyString) {
    flyanimation_->clear();
  }
  clear_has_flyanimation();
}
inline const ::std::string& SkillCfg::flyanimation() const {
  return *flyanimation_;
}
inline void SkillCfg::set_flyanimation(const ::std::string& value) {
  set_has_flyanimation();
  if (flyanimation_ == &::google::protobuf::internal::kEmptyString) {
    flyanimation_ = new ::std::string;
  }
  flyanimation_->assign(value);
}
inline void SkillCfg::set_flyanimation(const char* value) {
  set_has_flyanimation();
  if (flyanimation_ == &::google::protobuf::internal::kEmptyString) {
    flyanimation_ = new ::std::string;
  }
  flyanimation_->assign(value);
}
inline void SkillCfg::set_flyanimation(const char* value, size_t size) {
  set_has_flyanimation();
  if (flyanimation_ == &::google::protobuf::internal::kEmptyString) {
    flyanimation_ = new ::std::string;
  }
  flyanimation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillCfg::mutable_flyanimation() {
  set_has_flyanimation();
  if (flyanimation_ == &::google::protobuf::internal::kEmptyString) {
    flyanimation_ = new ::std::string;
  }
  return flyanimation_;
}
inline ::std::string* SkillCfg::release_flyanimation() {
  clear_has_flyanimation();
  if (flyanimation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = flyanimation_;
    flyanimation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkillCfg::set_allocated_flyanimation(::std::string* flyanimation) {
  if (flyanimation_ != &::google::protobuf::internal::kEmptyString) {
    delete flyanimation_;
  }
  if (flyanimation) {
    set_has_flyanimation();
    flyanimation_ = flyanimation;
  } else {
    clear_has_flyanimation();
    flyanimation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string AtkSound = 13;
inline bool SkillCfg::has_atksound() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SkillCfg::set_has_atksound() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SkillCfg::clear_has_atksound() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SkillCfg::clear_atksound() {
  if (atksound_ != &::google::protobuf::internal::kEmptyString) {
    atksound_->clear();
  }
  clear_has_atksound();
}
inline const ::std::string& SkillCfg::atksound() const {
  return *atksound_;
}
inline void SkillCfg::set_atksound(const ::std::string& value) {
  set_has_atksound();
  if (atksound_ == &::google::protobuf::internal::kEmptyString) {
    atksound_ = new ::std::string;
  }
  atksound_->assign(value);
}
inline void SkillCfg::set_atksound(const char* value) {
  set_has_atksound();
  if (atksound_ == &::google::protobuf::internal::kEmptyString) {
    atksound_ = new ::std::string;
  }
  atksound_->assign(value);
}
inline void SkillCfg::set_atksound(const char* value, size_t size) {
  set_has_atksound();
  if (atksound_ == &::google::protobuf::internal::kEmptyString) {
    atksound_ = new ::std::string;
  }
  atksound_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillCfg::mutable_atksound() {
  set_has_atksound();
  if (atksound_ == &::google::protobuf::internal::kEmptyString) {
    atksound_ = new ::std::string;
  }
  return atksound_;
}
inline ::std::string* SkillCfg::release_atksound() {
  clear_has_atksound();
  if (atksound_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = atksound_;
    atksound_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkillCfg::set_allocated_atksound(::std::string* atksound) {
  if (atksound_ != &::google::protobuf::internal::kEmptyString) {
    delete atksound_;
  }
  if (atksound) {
    set_has_atksound();
    atksound_ = atksound;
  } else {
    clear_has_atksound();
    atksound_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string HurtAnimation = 14;
inline bool SkillCfg::has_hurtanimation() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SkillCfg::set_has_hurtanimation() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SkillCfg::clear_has_hurtanimation() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SkillCfg::clear_hurtanimation() {
  if (hurtanimation_ != &::google::protobuf::internal::kEmptyString) {
    hurtanimation_->clear();
  }
  clear_has_hurtanimation();
}
inline const ::std::string& SkillCfg::hurtanimation() const {
  return *hurtanimation_;
}
inline void SkillCfg::set_hurtanimation(const ::std::string& value) {
  set_has_hurtanimation();
  if (hurtanimation_ == &::google::protobuf::internal::kEmptyString) {
    hurtanimation_ = new ::std::string;
  }
  hurtanimation_->assign(value);
}
inline void SkillCfg::set_hurtanimation(const char* value) {
  set_has_hurtanimation();
  if (hurtanimation_ == &::google::protobuf::internal::kEmptyString) {
    hurtanimation_ = new ::std::string;
  }
  hurtanimation_->assign(value);
}
inline void SkillCfg::set_hurtanimation(const char* value, size_t size) {
  set_has_hurtanimation();
  if (hurtanimation_ == &::google::protobuf::internal::kEmptyString) {
    hurtanimation_ = new ::std::string;
  }
  hurtanimation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillCfg::mutable_hurtanimation() {
  set_has_hurtanimation();
  if (hurtanimation_ == &::google::protobuf::internal::kEmptyString) {
    hurtanimation_ = new ::std::string;
  }
  return hurtanimation_;
}
inline ::std::string* SkillCfg::release_hurtanimation() {
  clear_has_hurtanimation();
  if (hurtanimation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hurtanimation_;
    hurtanimation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkillCfg::set_allocated_hurtanimation(::std::string* hurtanimation) {
  if (hurtanimation_ != &::google::protobuf::internal::kEmptyString) {
    delete hurtanimation_;
  }
  if (hurtanimation) {
    set_has_hurtanimation();
    hurtanimation_ = hurtanimation;
  } else {
    clear_has_hurtanimation();
    hurtanimation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string HitSound = 15;
inline bool SkillCfg::has_hitsound() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SkillCfg::set_has_hitsound() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SkillCfg::clear_has_hitsound() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SkillCfg::clear_hitsound() {
  if (hitsound_ != &::google::protobuf::internal::kEmptyString) {
    hitsound_->clear();
  }
  clear_has_hitsound();
}
inline const ::std::string& SkillCfg::hitsound() const {
  return *hitsound_;
}
inline void SkillCfg::set_hitsound(const ::std::string& value) {
  set_has_hitsound();
  if (hitsound_ == &::google::protobuf::internal::kEmptyString) {
    hitsound_ = new ::std::string;
  }
  hitsound_->assign(value);
}
inline void SkillCfg::set_hitsound(const char* value) {
  set_has_hitsound();
  if (hitsound_ == &::google::protobuf::internal::kEmptyString) {
    hitsound_ = new ::std::string;
  }
  hitsound_->assign(value);
}
inline void SkillCfg::set_hitsound(const char* value, size_t size) {
  set_has_hitsound();
  if (hitsound_ == &::google::protobuf::internal::kEmptyString) {
    hitsound_ = new ::std::string;
  }
  hitsound_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillCfg::mutable_hitsound() {
  set_has_hitsound();
  if (hitsound_ == &::google::protobuf::internal::kEmptyString) {
    hitsound_ = new ::std::string;
  }
  return hitsound_;
}
inline ::std::string* SkillCfg::release_hitsound() {
  clear_has_hitsound();
  if (hitsound_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hitsound_;
    hitsound_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkillCfg::set_allocated_hitsound(::std::string* hitsound) {
  if (hitsound_ != &::google::protobuf::internal::kEmptyString) {
    delete hitsound_;
  }
  if (hitsound) {
    set_has_hitsound();
    hitsound_ = hitsound;
  } else {
    clear_has_hitsound();
    hitsound_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 TriggerType = 16;
inline bool SkillCfg::has_triggertype() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SkillCfg::set_has_triggertype() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SkillCfg::clear_has_triggertype() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SkillCfg::clear_triggertype() {
  triggertype_ = 0u;
  clear_has_triggertype();
}
inline ::google::protobuf::uint32 SkillCfg::triggertype() const {
  return triggertype_;
}
inline void SkillCfg::set_triggertype(::google::protobuf::uint32 value) {
  set_has_triggertype();
  triggertype_ = value;
}

// required uint32 DamageZone = 17;
inline bool SkillCfg::has_damagezone() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SkillCfg::set_has_damagezone() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SkillCfg::clear_has_damagezone() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SkillCfg::clear_damagezone() {
  damagezone_ = 0u;
  clear_has_damagezone();
}
inline ::google::protobuf::uint32 SkillCfg::damagezone() const {
  return damagezone_;
}
inline void SkillCfg::set_damagezone(::google::protobuf::uint32 value) {
  set_has_damagezone();
  damagezone_ = value;
}

// required uint32 TargetCnt = 18;
inline bool SkillCfg::has_targetcnt() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SkillCfg::set_has_targetcnt() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SkillCfg::clear_has_targetcnt() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SkillCfg::clear_targetcnt() {
  targetcnt_ = 0u;
  clear_has_targetcnt();
}
inline ::google::protobuf::uint32 SkillCfg::targetcnt() const {
  return targetcnt_;
}
inline void SkillCfg::set_targetcnt(::google::protobuf::uint32 value) {
  set_has_targetcnt();
  targetcnt_ = value;
}

// required uint32 DamageAreaType = 19;
inline bool SkillCfg::has_damageareatype() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SkillCfg::set_has_damageareatype() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SkillCfg::clear_has_damageareatype() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SkillCfg::clear_damageareatype() {
  damageareatype_ = 0u;
  clear_has_damageareatype();
}
inline ::google::protobuf::uint32 SkillCfg::damageareatype() const {
  return damageareatype_;
}
inline void SkillCfg::set_damageareatype(::google::protobuf::uint32 value) {
  set_has_damageareatype();
  damageareatype_ = value;
}

// required uint32 EffectX = 20;
inline bool SkillCfg::has_effectx() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SkillCfg::set_has_effectx() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SkillCfg::clear_has_effectx() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SkillCfg::clear_effectx() {
  effectx_ = 0u;
  clear_has_effectx();
}
inline ::google::protobuf::uint32 SkillCfg::effectx() const {
  return effectx_;
}
inline void SkillCfg::set_effectx(::google::protobuf::uint32 value) {
  set_has_effectx();
  effectx_ = value;
}

// required uint32 EffectY = 21;
inline bool SkillCfg::has_effecty() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SkillCfg::set_has_effecty() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SkillCfg::clear_has_effecty() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SkillCfg::clear_effecty() {
  effecty_ = 0u;
  clear_has_effecty();
}
inline ::google::protobuf::uint32 SkillCfg::effecty() const {
  return effecty_;
}
inline void SkillCfg::set_effecty(::google::protobuf::uint32 value) {
  set_has_effecty();
  effecty_ = value;
}

// required uint32 HitBackDist = 22;
inline bool SkillCfg::has_hitbackdist() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SkillCfg::set_has_hitbackdist() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SkillCfg::clear_has_hitbackdist() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SkillCfg::clear_hitbackdist() {
  hitbackdist_ = 0u;
  clear_has_hitbackdist();
}
inline ::google::protobuf::uint32 SkillCfg::hitbackdist() const {
  return hitbackdist_;
}
inline void SkillCfg::set_hitbackdist(::google::protobuf::uint32 value) {
  set_has_hitbackdist();
  hitbackdist_ = value;
}

// repeated .com.cfg.vo.SkillEffect Effects = 23;
inline int SkillCfg::effects_size() const {
  return effects_.size();
}
inline void SkillCfg::clear_effects() {
  effects_.Clear();
}
inline const ::com::cfg::vo::SkillEffect& SkillCfg::effects(int index) const {
  return effects_.Get(index);
}
inline ::com::cfg::vo::SkillEffect* SkillCfg::mutable_effects(int index) {
  return effects_.Mutable(index);
}
inline ::com::cfg::vo::SkillEffect* SkillCfg::add_effects() {
  return effects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::SkillEffect >&
SkillCfg::effects() const {
  return effects_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::SkillEffect >*
SkillCfg::mutable_effects() {
  return &effects_;
}

// required uint32 FloorBuffID = 24;
inline bool SkillCfg::has_floorbuffid() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void SkillCfg::set_has_floorbuffid() {
  _has_bits_[0] |= 0x00800000u;
}
inline void SkillCfg::clear_has_floorbuffid() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void SkillCfg::clear_floorbuffid() {
  floorbuffid_ = 0u;
  clear_has_floorbuffid();
}
inline ::google::protobuf::uint32 SkillCfg::floorbuffid() const {
  return floorbuffid_;
}
inline void SkillCfg::set_floorbuffid(::google::protobuf::uint32 value) {
  set_has_floorbuffid();
  floorbuffid_ = value;
}

// required string SkillIcon = 28;
inline bool SkillCfg::has_skillicon() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void SkillCfg::set_has_skillicon() {
  _has_bits_[0] |= 0x01000000u;
}
inline void SkillCfg::clear_has_skillicon() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void SkillCfg::clear_skillicon() {
  if (skillicon_ != &::google::protobuf::internal::kEmptyString) {
    skillicon_->clear();
  }
  clear_has_skillicon();
}
inline const ::std::string& SkillCfg::skillicon() const {
  return *skillicon_;
}
inline void SkillCfg::set_skillicon(const ::std::string& value) {
  set_has_skillicon();
  if (skillicon_ == &::google::protobuf::internal::kEmptyString) {
    skillicon_ = new ::std::string;
  }
  skillicon_->assign(value);
}
inline void SkillCfg::set_skillicon(const char* value) {
  set_has_skillicon();
  if (skillicon_ == &::google::protobuf::internal::kEmptyString) {
    skillicon_ = new ::std::string;
  }
  skillicon_->assign(value);
}
inline void SkillCfg::set_skillicon(const char* value, size_t size) {
  set_has_skillicon();
  if (skillicon_ == &::google::protobuf::internal::kEmptyString) {
    skillicon_ = new ::std::string;
  }
  skillicon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillCfg::mutable_skillicon() {
  set_has_skillicon();
  if (skillicon_ == &::google::protobuf::internal::kEmptyString) {
    skillicon_ = new ::std::string;
  }
  return skillicon_;
}
inline ::std::string* SkillCfg::release_skillicon() {
  clear_has_skillicon();
  if (skillicon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = skillicon_;
    skillicon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkillCfg::set_allocated_skillicon(::std::string* skillicon) {
  if (skillicon_ != &::google::protobuf::internal::kEmptyString) {
    delete skillicon_;
  }
  if (skillicon) {
    set_has_skillicon();
    skillicon_ = skillicon;
  } else {
    clear_has_skillicon();
    skillicon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string GunAnimation = 29;
inline bool SkillCfg::has_gunanimation() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void SkillCfg::set_has_gunanimation() {
  _has_bits_[0] |= 0x02000000u;
}
inline void SkillCfg::clear_has_gunanimation() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void SkillCfg::clear_gunanimation() {
  if (gunanimation_ != &::google::protobuf::internal::kEmptyString) {
    gunanimation_->clear();
  }
  clear_has_gunanimation();
}
inline const ::std::string& SkillCfg::gunanimation() const {
  return *gunanimation_;
}
inline void SkillCfg::set_gunanimation(const ::std::string& value) {
  set_has_gunanimation();
  if (gunanimation_ == &::google::protobuf::internal::kEmptyString) {
    gunanimation_ = new ::std::string;
  }
  gunanimation_->assign(value);
}
inline void SkillCfg::set_gunanimation(const char* value) {
  set_has_gunanimation();
  if (gunanimation_ == &::google::protobuf::internal::kEmptyString) {
    gunanimation_ = new ::std::string;
  }
  gunanimation_->assign(value);
}
inline void SkillCfg::set_gunanimation(const char* value, size_t size) {
  set_has_gunanimation();
  if (gunanimation_ == &::google::protobuf::internal::kEmptyString) {
    gunanimation_ = new ::std::string;
  }
  gunanimation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillCfg::mutable_gunanimation() {
  set_has_gunanimation();
  if (gunanimation_ == &::google::protobuf::internal::kEmptyString) {
    gunanimation_ = new ::std::string;
  }
  return gunanimation_;
}
inline ::std::string* SkillCfg::release_gunanimation() {
  clear_has_gunanimation();
  if (gunanimation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gunanimation_;
    gunanimation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkillCfg::set_allocated_gunanimation(::std::string* gunanimation) {
  if (gunanimation_ != &::google::protobuf::internal::kEmptyString) {
    delete gunanimation_;
  }
  if (gunanimation) {
    set_has_gunanimation();
    gunanimation_ = gunanimation;
  } else {
    clear_has_gunanimation();
    gunanimation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 SkillValidTime = 30;
inline bool SkillCfg::has_skillvalidtime() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void SkillCfg::set_has_skillvalidtime() {
  _has_bits_[0] |= 0x04000000u;
}
inline void SkillCfg::clear_has_skillvalidtime() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void SkillCfg::clear_skillvalidtime() {
  skillvalidtime_ = 0u;
  clear_has_skillvalidtime();
}
inline ::google::protobuf::uint32 SkillCfg::skillvalidtime() const {
  return skillvalidtime_;
}
inline void SkillCfg::set_skillvalidtime(::google::protobuf::uint32 value) {
  set_has_skillvalidtime();
  skillvalidtime_ = value;
}

// required uint32 CastCondType = 31;
inline bool SkillCfg::has_castcondtype() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void SkillCfg::set_has_castcondtype() {
  _has_bits_[0] |= 0x08000000u;
}
inline void SkillCfg::clear_has_castcondtype() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void SkillCfg::clear_castcondtype() {
  castcondtype_ = 0u;
  clear_has_castcondtype();
}
inline ::google::protobuf::uint32 SkillCfg::castcondtype() const {
  return castcondtype_;
}
inline void SkillCfg::set_castcondtype(::google::protobuf::uint32 value) {
  set_has_castcondtype();
  castcondtype_ = value;
}

// required uint32 CastCondValue = 32;
inline bool SkillCfg::has_castcondvalue() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void SkillCfg::set_has_castcondvalue() {
  _has_bits_[0] |= 0x10000000u;
}
inline void SkillCfg::clear_has_castcondvalue() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void SkillCfg::clear_castcondvalue() {
  castcondvalue_ = 0u;
  clear_has_castcondvalue();
}
inline ::google::protobuf::uint32 SkillCfg::castcondvalue() const {
  return castcondvalue_;
}
inline void SkillCfg::set_castcondvalue(::google::protobuf::uint32 value) {
  set_has_castcondvalue();
  castcondvalue_ = value;
}

// required uint32 DamageCnt = 33;
inline bool SkillCfg::has_damagecnt() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void SkillCfg::set_has_damagecnt() {
  _has_bits_[0] |= 0x20000000u;
}
inline void SkillCfg::clear_has_damagecnt() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void SkillCfg::clear_damagecnt() {
  damagecnt_ = 0u;
  clear_has_damagecnt();
}
inline ::google::protobuf::uint32 SkillCfg::damagecnt() const {
  return damagecnt_;
}
inline void SkillCfg::set_damagecnt(::google::protobuf::uint32 value) {
  set_has_damagecnt();
  damagecnt_ = value;
}

// required uint32 EffInter = 34;
inline bool SkillCfg::has_effinter() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void SkillCfg::set_has_effinter() {
  _has_bits_[0] |= 0x40000000u;
}
inline void SkillCfg::clear_has_effinter() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void SkillCfg::clear_effinter() {
  effinter_ = 0u;
  clear_has_effinter();
}
inline ::google::protobuf::uint32 SkillCfg::effinter() const {
  return effinter_;
}
inline void SkillCfg::set_effinter(::google::protobuf::uint32 value) {
  set_has_effinter();
  effinter_ = value;
}

// required string NextAction = 35;
inline bool SkillCfg::has_nextaction() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void SkillCfg::set_has_nextaction() {
  _has_bits_[0] |= 0x80000000u;
}
inline void SkillCfg::clear_has_nextaction() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void SkillCfg::clear_nextaction() {
  if (nextaction_ != &::google::protobuf::internal::kEmptyString) {
    nextaction_->clear();
  }
  clear_has_nextaction();
}
inline const ::std::string& SkillCfg::nextaction() const {
  return *nextaction_;
}
inline void SkillCfg::set_nextaction(const ::std::string& value) {
  set_has_nextaction();
  if (nextaction_ == &::google::protobuf::internal::kEmptyString) {
    nextaction_ = new ::std::string;
  }
  nextaction_->assign(value);
}
inline void SkillCfg::set_nextaction(const char* value) {
  set_has_nextaction();
  if (nextaction_ == &::google::protobuf::internal::kEmptyString) {
    nextaction_ = new ::std::string;
  }
  nextaction_->assign(value);
}
inline void SkillCfg::set_nextaction(const char* value, size_t size) {
  set_has_nextaction();
  if (nextaction_ == &::google::protobuf::internal::kEmptyString) {
    nextaction_ = new ::std::string;
  }
  nextaction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillCfg::mutable_nextaction() {
  set_has_nextaction();
  if (nextaction_ == &::google::protobuf::internal::kEmptyString) {
    nextaction_ = new ::std::string;
  }
  return nextaction_;
}
inline ::std::string* SkillCfg::release_nextaction() {
  clear_has_nextaction();
  if (nextaction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nextaction_;
    nextaction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkillCfg::set_allocated_nextaction(::std::string* nextaction) {
  if (nextaction_ != &::google::protobuf::internal::kEmptyString) {
    delete nextaction_;
  }
  if (nextaction) {
    set_has_nextaction();
    nextaction_ = nextaction;
  } else {
    clear_has_nextaction();
    nextaction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string NextActSound = 36;
inline bool SkillCfg::has_nextactsound() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void SkillCfg::set_has_nextactsound() {
  _has_bits_[1] |= 0x00000001u;
}
inline void SkillCfg::clear_has_nextactsound() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void SkillCfg::clear_nextactsound() {
  if (nextactsound_ != &::google::protobuf::internal::kEmptyString) {
    nextactsound_->clear();
  }
  clear_has_nextactsound();
}
inline const ::std::string& SkillCfg::nextactsound() const {
  return *nextactsound_;
}
inline void SkillCfg::set_nextactsound(const ::std::string& value) {
  set_has_nextactsound();
  if (nextactsound_ == &::google::protobuf::internal::kEmptyString) {
    nextactsound_ = new ::std::string;
  }
  nextactsound_->assign(value);
}
inline void SkillCfg::set_nextactsound(const char* value) {
  set_has_nextactsound();
  if (nextactsound_ == &::google::protobuf::internal::kEmptyString) {
    nextactsound_ = new ::std::string;
  }
  nextactsound_->assign(value);
}
inline void SkillCfg::set_nextactsound(const char* value, size_t size) {
  set_has_nextactsound();
  if (nextactsound_ == &::google::protobuf::internal::kEmptyString) {
    nextactsound_ = new ::std::string;
  }
  nextactsound_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillCfg::mutable_nextactsound() {
  set_has_nextactsound();
  if (nextactsound_ == &::google::protobuf::internal::kEmptyString) {
    nextactsound_ = new ::std::string;
  }
  return nextactsound_;
}
inline ::std::string* SkillCfg::release_nextactsound() {
  clear_has_nextactsound();
  if (nextactsound_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nextactsound_;
    nextactsound_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkillCfg::set_allocated_nextactsound(::std::string* nextactsound) {
  if (nextactsound_ != &::google::protobuf::internal::kEmptyString) {
    delete nextactsound_;
  }
  if (nextactsound) {
    set_has_nextactsound();
    nextactsound_ = nextactsound;
  } else {
    clear_has_nextactsound();
    nextactsound_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string DieAction = 37;
inline bool SkillCfg::has_dieaction() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void SkillCfg::set_has_dieaction() {
  _has_bits_[1] |= 0x00000002u;
}
inline void SkillCfg::clear_has_dieaction() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void SkillCfg::clear_dieaction() {
  if (dieaction_ != &::google::protobuf::internal::kEmptyString) {
    dieaction_->clear();
  }
  clear_has_dieaction();
}
inline const ::std::string& SkillCfg::dieaction() const {
  return *dieaction_;
}
inline void SkillCfg::set_dieaction(const ::std::string& value) {
  set_has_dieaction();
  if (dieaction_ == &::google::protobuf::internal::kEmptyString) {
    dieaction_ = new ::std::string;
  }
  dieaction_->assign(value);
}
inline void SkillCfg::set_dieaction(const char* value) {
  set_has_dieaction();
  if (dieaction_ == &::google::protobuf::internal::kEmptyString) {
    dieaction_ = new ::std::string;
  }
  dieaction_->assign(value);
}
inline void SkillCfg::set_dieaction(const char* value, size_t size) {
  set_has_dieaction();
  if (dieaction_ == &::google::protobuf::internal::kEmptyString) {
    dieaction_ = new ::std::string;
  }
  dieaction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SkillCfg::mutable_dieaction() {
  set_has_dieaction();
  if (dieaction_ == &::google::protobuf::internal::kEmptyString) {
    dieaction_ = new ::std::string;
  }
  return dieaction_;
}
inline ::std::string* SkillCfg::release_dieaction() {
  clear_has_dieaction();
  if (dieaction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dieaction_;
    dieaction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SkillCfg::set_allocated_dieaction(::std::string* dieaction) {
  if (dieaction_ != &::google::protobuf::internal::kEmptyString) {
    delete dieaction_;
  }
  if (dieaction) {
    set_has_dieaction();
    dieaction_ = dieaction;
  } else {
    clear_has_dieaction();
    dieaction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SkillCfgSet

// repeated .com.cfg.vo.SkillCfg skillcfg = 1;
inline int SkillCfgSet::skillcfg_size() const {
  return skillcfg_.size();
}
inline void SkillCfgSet::clear_skillcfg() {
  skillcfg_.Clear();
}
inline const ::com::cfg::vo::SkillCfg& SkillCfgSet::skillcfg(int index) const {
  return skillcfg_.Get(index);
}
inline ::com::cfg::vo::SkillCfg* SkillCfgSet::mutable_skillcfg(int index) {
  return skillcfg_.Mutable(index);
}
inline ::com::cfg::vo::SkillCfg* SkillCfgSet::add_skillcfg() {
  return skillcfg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::SkillCfg >&
SkillCfgSet::skillcfg() const {
  return skillcfg_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::SkillCfg >*
SkillCfgSet::mutable_skillcfg() {
  return &skillcfg_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vo
}  // namespace cfg
}  // namespace com

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SkillCfg_2eproto__INCLUDED
