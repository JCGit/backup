// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NihilityMonsterShowCfg.proto

#ifndef PROTOBUF_NihilityMonsterShowCfg_2eproto__INCLUDED
#define PROTOBUF_NihilityMonsterShowCfg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MonsterCfg.pb.h"
// @@protoc_insertion_point(includes)

namespace com {
namespace cfg {
namespace vo {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_NihilityMonsterShowCfg_2eproto();
void protobuf_AssignDesc_NihilityMonsterShowCfg_2eproto();
void protobuf_ShutdownFile_NihilityMonsterShowCfg_2eproto();

class NihilityMonsterShowCfg;
class NihilityMonsterShowCfgSet;

// ===================================================================

class NihilityMonsterShowCfg : public ::google::protobuf::MessageLite {
 public:
  NihilityMonsterShowCfg();
  virtual ~NihilityMonsterShowCfg();

  NihilityMonsterShowCfg(const NihilityMonsterShowCfg& from);

  inline NihilityMonsterShowCfg& operator=(const NihilityMonsterShowCfg& from) {
    CopyFrom(from);
    return *this;
  }

  static const NihilityMonsterShowCfg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NihilityMonsterShowCfg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NihilityMonsterShowCfg* other);

  // implements Message ----------------------------------------------

  NihilityMonsterShowCfg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NihilityMonsterShowCfg& from);
  void MergeFrom(const NihilityMonsterShowCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 cfgID = 1;
  inline bool has_cfgid() const;
  inline void clear_cfgid();
  static const int kCfgIDFieldNumber = 1;
  inline ::google::protobuf::uint32 cfgid() const;
  inline void set_cfgid(::google::protobuf::uint32 value);

  // required string avatar = 2;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 2;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // required uint32 walkType = 3;
  inline bool has_walktype() const;
  inline void clear_walktype();
  static const int kWalkTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 walktype() const;
  inline void set_walktype(::google::protobuf::uint32 value);

  // required uint32 atktype = 4;
  inline bool has_atktype() const;
  inline void clear_atktype();
  static const int kAtktypeFieldNumber = 4;
  inline ::google::protobuf::uint32 atktype() const;
  inline void set_atktype(::google::protobuf::uint32 value);

  // required uint32 atkAttType = 5;
  inline bool has_atkatttype() const;
  inline void clear_atkatttype();
  static const int kAtkAttTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 atkatttype() const;
  inline void set_atkatttype(::google::protobuf::uint32 value);

  // required uint32 deftype = 6;
  inline bool has_deftype() const;
  inline void clear_deftype();
  static const int kDeftypeFieldNumber = 6;
  inline ::google::protobuf::uint32 deftype() const;
  inline void set_deftype(::google::protobuf::uint32 value);

  // required uint32 highSpeed = 7;
  inline bool has_highspeed() const;
  inline void clear_highspeed();
  static const int kHighSpeedFieldNumber = 7;
  inline ::google::protobuf::uint32 highspeed() const;
  inline void set_highspeed(::google::protobuf::uint32 value);

  // required string emergeVoice = 8;
  inline bool has_emergevoice() const;
  inline void clear_emergevoice();
  static const int kEmergeVoiceFieldNumber = 8;
  inline const ::std::string& emergevoice() const;
  inline void set_emergevoice(const ::std::string& value);
  inline void set_emergevoice(const char* value);
  inline void set_emergevoice(const char* value, size_t size);
  inline ::std::string* mutable_emergevoice();
  inline ::std::string* release_emergevoice();
  inline void set_allocated_emergevoice(::std::string* emergevoice);

  // required string hurtVoice = 9;
  inline bool has_hurtvoice() const;
  inline void clear_hurtvoice();
  static const int kHurtVoiceFieldNumber = 9;
  inline const ::std::string& hurtvoice() const;
  inline void set_hurtvoice(const ::std::string& value);
  inline void set_hurtvoice(const char* value);
  inline void set_hurtvoice(const char* value, size_t size);
  inline ::std::string* mutable_hurtvoice();
  inline ::std::string* release_hurtvoice();
  inline void set_allocated_hurtvoice(::std::string* hurtvoice);

  // required string dieVoice = 10;
  inline bool has_dievoice() const;
  inline void clear_dievoice();
  static const int kDieVoiceFieldNumber = 10;
  inline const ::std::string& dievoice() const;
  inline void set_dievoice(const ::std::string& value);
  inline void set_dievoice(const char* value);
  inline void set_dievoice(const char* value, size_t size);
  inline ::std::string* mutable_dievoice();
  inline ::std::string* release_dievoice();
  inline void set_allocated_dievoice(::std::string* dievoice);

  // repeated uint32 skills = 11;
  inline int skills_size() const;
  inline void clear_skills();
  static const int kSkillsFieldNumber = 11;
  inline ::google::protobuf::uint32 skills(int index) const;
  inline void set_skills(int index, ::google::protobuf::uint32 value);
  inline void add_skills(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      skills() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_skills();

  // required uint32 monstertype = 12;
  inline bool has_monstertype() const;
  inline void clear_monstertype();
  static const int kMonstertypeFieldNumber = 12;
  inline ::google::protobuf::uint32 monstertype() const;
  inline void set_monstertype(::google::protobuf::uint32 value);

  // required uint32 hurtActionCD = 13;
  inline bool has_hurtactioncd() const;
  inline void clear_hurtactioncd();
  static const int kHurtActionCDFieldNumber = 13;
  inline ::google::protobuf::uint32 hurtactioncd() const;
  inline void set_hurtactioncd(::google::protobuf::uint32 value);

  // required string monstername = 14;
  inline bool has_monstername() const;
  inline void clear_monstername();
  static const int kMonsternameFieldNumber = 14;
  inline const ::std::string& monstername() const;
  inline void set_monstername(const ::std::string& value);
  inline void set_monstername(const char* value);
  inline void set_monstername(const char* value, size_t size);
  inline ::std::string* mutable_monstername();
  inline ::std::string* release_monstername();
  inline void set_allocated_monstername(::std::string* monstername);

  // required string desc = 15;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 15;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // required uint32 ballistic = 16;
  inline bool has_ballistic() const;
  inline void clear_ballistic();
  static const int kBallisticFieldNumber = 16;
  inline ::google::protobuf::uint32 ballistic() const;
  inline void set_ballistic(::google::protobuf::uint32 value);

  // required string dieAnimation = 17;
  inline bool has_dieanimation() const;
  inline void clear_dieanimation();
  static const int kDieAnimationFieldNumber = 17;
  inline const ::std::string& dieanimation() const;
  inline void set_dieanimation(const ::std::string& value);
  inline void set_dieanimation(const char* value);
  inline void set_dieanimation(const char* value, size_t size);
  inline ::std::string* mutable_dieanimation();
  inline ::std::string* release_dieanimation();
  inline void set_allocated_dieanimation(::std::string* dieanimation);

  // required uint32 minWalkSpeed = 18;
  inline bool has_minwalkspeed() const;
  inline void clear_minwalkspeed();
  static const int kMinWalkSpeedFieldNumber = 18;
  inline ::google::protobuf::uint32 minwalkspeed() const;
  inline void set_minwalkspeed(::google::protobuf::uint32 value);

  // required uint32 maxWalkSpeed = 19;
  inline bool has_maxwalkspeed() const;
  inline void clear_maxwalkspeed();
  static const int kMaxWalkSpeedFieldNumber = 19;
  inline ::google::protobuf::uint32 maxwalkspeed() const;
  inline void set_maxwalkspeed(::google::protobuf::uint32 value);

  // required uint32 bubbleId = 20;
  inline bool has_bubbleid() const;
  inline void clear_bubbleid();
  static const int kBubbleIdFieldNumber = 20;
  inline ::google::protobuf::uint32 bubbleid() const;
  inline void set_bubbleid(::google::protobuf::uint32 value);

  // required uint32 floorBuffId = 21;
  inline bool has_floorbuffid() const;
  inline void clear_floorbuffid();
  static const int kFloorBuffIdFieldNumber = 21;
  inline ::google::protobuf::uint32 floorbuffid() const;
  inline void set_floorbuffid(::google::protobuf::uint32 value);

  // required uint32 aiID = 22;
  inline bool has_aiid() const;
  inline void clear_aiid();
  static const int kAiIDFieldNumber = 22;
  inline ::google::protobuf::uint32 aiid() const;
  inline void set_aiid(::google::protobuf::uint32 value);

  // required uint32 patrolArea = 23;
  inline bool has_patrolarea() const;
  inline void clear_patrolarea();
  static const int kPatrolAreaFieldNumber = 23;
  inline ::google::protobuf::uint32 patrolarea() const;
  inline void set_patrolarea(::google::protobuf::uint32 value);

  // required uint32 HurtColor = 24;
  inline bool has_hurtcolor() const;
  inline void clear_hurtcolor();
  static const int kHurtColorFieldNumber = 24;
  inline ::google::protobuf::uint32 hurtcolor() const;
  inline void set_hurtcolor(::google::protobuf::uint32 value);

  // required uint32 InitScale = 25;
  inline bool has_initscale() const;
  inline void clear_initscale();
  static const int kInitScaleFieldNumber = 25;
  inline ::google::protobuf::uint32 initscale() const;
  inline void set_initscale(::google::protobuf::uint32 value);

  // required uint32 IsBlock = 26;
  inline bool has_isblock() const;
  inline void clear_isblock();
  static const int kIsBlockFieldNumber = 26;
  inline ::google::protobuf::uint32 isblock() const;
  inline void set_isblock(::google::protobuf::uint32 value);

  // required string hurtAnimation = 27;
  inline bool has_hurtanimation() const;
  inline void clear_hurtanimation();
  static const int kHurtAnimationFieldNumber = 27;
  inline const ::std::string& hurtanimation() const;
  inline void set_hurtanimation(const ::std::string& value);
  inline void set_hurtanimation(const char* value);
  inline void set_hurtanimation(const char* value, size_t size);
  inline ::std::string* mutable_hurtanimation();
  inline ::std::string* release_hurtanimation();
  inline void set_allocated_hurtanimation(::std::string* hurtanimation);

  // required uint32 dropGoldNum = 28;
  inline bool has_dropgoldnum() const;
  inline void clear_dropgoldnum();
  static const int kDropGoldNumFieldNumber = 28;
  inline ::google::protobuf::uint32 dropgoldnum() const;
  inline void set_dropgoldnum(::google::protobuf::uint32 value);

  // required uint32 score = 29;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 29;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // required .com.cfg.vo.Movement actions = 30;
  inline bool has_actions() const;
  inline void clear_actions();
  static const int kActionsFieldNumber = 30;
  inline const ::com::cfg::vo::Movement& actions() const;
  inline ::com::cfg::vo::Movement* mutable_actions();
  inline ::com::cfg::vo::Movement* release_actions();
  inline void set_allocated_actions(::com::cfg::vo::Movement* actions);

  // required string headImg = 31;
  inline bool has_headimg() const;
  inline void clear_headimg();
  static const int kHeadImgFieldNumber = 31;
  inline const ::std::string& headimg() const;
  inline void set_headimg(const ::std::string& value);
  inline void set_headimg(const char* value);
  inline void set_headimg(const char* value, size_t size);
  inline ::std::string* mutable_headimg();
  inline ::std::string* release_headimg();
  inline void set_allocated_headimg(::std::string* headimg);

  // @@protoc_insertion_point(class_scope:com.cfg.vo.NihilityMonsterShowCfg)
 private:
  inline void set_has_cfgid();
  inline void clear_has_cfgid();
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_walktype();
  inline void clear_has_walktype();
  inline void set_has_atktype();
  inline void clear_has_atktype();
  inline void set_has_atkatttype();
  inline void clear_has_atkatttype();
  inline void set_has_deftype();
  inline void clear_has_deftype();
  inline void set_has_highspeed();
  inline void clear_has_highspeed();
  inline void set_has_emergevoice();
  inline void clear_has_emergevoice();
  inline void set_has_hurtvoice();
  inline void clear_has_hurtvoice();
  inline void set_has_dievoice();
  inline void clear_has_dievoice();
  inline void set_has_monstertype();
  inline void clear_has_monstertype();
  inline void set_has_hurtactioncd();
  inline void clear_has_hurtactioncd();
  inline void set_has_monstername();
  inline void clear_has_monstername();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_ballistic();
  inline void clear_has_ballistic();
  inline void set_has_dieanimation();
  inline void clear_has_dieanimation();
  inline void set_has_minwalkspeed();
  inline void clear_has_minwalkspeed();
  inline void set_has_maxwalkspeed();
  inline void clear_has_maxwalkspeed();
  inline void set_has_bubbleid();
  inline void clear_has_bubbleid();
  inline void set_has_floorbuffid();
  inline void clear_has_floorbuffid();
  inline void set_has_aiid();
  inline void clear_has_aiid();
  inline void set_has_patrolarea();
  inline void clear_has_patrolarea();
  inline void set_has_hurtcolor();
  inline void clear_has_hurtcolor();
  inline void set_has_initscale();
  inline void clear_has_initscale();
  inline void set_has_isblock();
  inline void clear_has_isblock();
  inline void set_has_hurtanimation();
  inline void clear_has_hurtanimation();
  inline void set_has_dropgoldnum();
  inline void clear_has_dropgoldnum();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_actions();
  inline void clear_has_actions();
  inline void set_has_headimg();
  inline void clear_has_headimg();

  ::std::string* avatar_;
  ::google::protobuf::uint32 cfgid_;
  ::google::protobuf::uint32 walktype_;
  ::google::protobuf::uint32 atktype_;
  ::google::protobuf::uint32 atkatttype_;
  ::google::protobuf::uint32 deftype_;
  ::google::protobuf::uint32 highspeed_;
  ::std::string* emergevoice_;
  ::std::string* hurtvoice_;
  ::std::string* dievoice_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > skills_;
  ::google::protobuf::uint32 monstertype_;
  ::google::protobuf::uint32 hurtactioncd_;
  ::std::string* monstername_;
  ::std::string* desc_;
  ::std::string* dieanimation_;
  ::google::protobuf::uint32 ballistic_;
  ::google::protobuf::uint32 minwalkspeed_;
  ::google::protobuf::uint32 maxwalkspeed_;
  ::google::protobuf::uint32 bubbleid_;
  ::google::protobuf::uint32 floorbuffid_;
  ::google::protobuf::uint32 aiid_;
  ::google::protobuf::uint32 patrolarea_;
  ::google::protobuf::uint32 hurtcolor_;
  ::google::protobuf::uint32 initscale_;
  ::google::protobuf::uint32 isblock_;
  ::std::string* hurtanimation_;
  ::google::protobuf::uint32 dropgoldnum_;
  ::google::protobuf::uint32 score_;
  ::com::cfg::vo::Movement* actions_;
  ::std::string* headimg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(31 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NihilityMonsterShowCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NihilityMonsterShowCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_NihilityMonsterShowCfg_2eproto();
  friend void protobuf_ShutdownFile_NihilityMonsterShowCfg_2eproto();

  void InitAsDefaultInstance();
  static NihilityMonsterShowCfg* default_instance_;
};
// -------------------------------------------------------------------

class NihilityMonsterShowCfgSet : public ::google::protobuf::MessageLite {
 public:
  NihilityMonsterShowCfgSet();
  virtual ~NihilityMonsterShowCfgSet();

  NihilityMonsterShowCfgSet(const NihilityMonsterShowCfgSet& from);

  inline NihilityMonsterShowCfgSet& operator=(const NihilityMonsterShowCfgSet& from) {
    CopyFrom(from);
    return *this;
  }

  static const NihilityMonsterShowCfgSet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NihilityMonsterShowCfgSet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NihilityMonsterShowCfgSet* other);

  // implements Message ----------------------------------------------

  NihilityMonsterShowCfgSet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NihilityMonsterShowCfgSet& from);
  void MergeFrom(const NihilityMonsterShowCfgSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.cfg.vo.NihilityMonsterShowCfg nihilityMonsterShowCfg = 1;
  inline int nihilitymonstershowcfg_size() const;
  inline void clear_nihilitymonstershowcfg();
  static const int kNihilityMonsterShowCfgFieldNumber = 1;
  inline const ::com::cfg::vo::NihilityMonsterShowCfg& nihilitymonstershowcfg(int index) const;
  inline ::com::cfg::vo::NihilityMonsterShowCfg* mutable_nihilitymonstershowcfg(int index);
  inline ::com::cfg::vo::NihilityMonsterShowCfg* add_nihilitymonstershowcfg();
  inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::NihilityMonsterShowCfg >&
      nihilitymonstershowcfg() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::NihilityMonsterShowCfg >*
      mutable_nihilitymonstershowcfg();

  // @@protoc_insertion_point(class_scope:com.cfg.vo.NihilityMonsterShowCfgSet)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::NihilityMonsterShowCfg > nihilitymonstershowcfg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_NihilityMonsterShowCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_NihilityMonsterShowCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_NihilityMonsterShowCfg_2eproto();
  friend void protobuf_ShutdownFile_NihilityMonsterShowCfg_2eproto();

  void InitAsDefaultInstance();
  static NihilityMonsterShowCfgSet* default_instance_;
};
// ===================================================================


// ===================================================================

// NihilityMonsterShowCfg

// required uint32 cfgID = 1;
inline bool NihilityMonsterShowCfg::has_cfgid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_cfgid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NihilityMonsterShowCfg::clear_has_cfgid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NihilityMonsterShowCfg::clear_cfgid() {
  cfgid_ = 0u;
  clear_has_cfgid();
}
inline ::google::protobuf::uint32 NihilityMonsterShowCfg::cfgid() const {
  return cfgid_;
}
inline void NihilityMonsterShowCfg::set_cfgid(::google::protobuf::uint32 value) {
  set_has_cfgid();
  cfgid_ = value;
}

// required string avatar = 2;
inline bool NihilityMonsterShowCfg::has_avatar() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_avatar() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NihilityMonsterShowCfg::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NihilityMonsterShowCfg::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& NihilityMonsterShowCfg::avatar() const {
  return *avatar_;
}
inline void NihilityMonsterShowCfg::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void NihilityMonsterShowCfg::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void NihilityMonsterShowCfg::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NihilityMonsterShowCfg::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* NihilityMonsterShowCfg::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NihilityMonsterShowCfg::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 walkType = 3;
inline bool NihilityMonsterShowCfg::has_walktype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_walktype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NihilityMonsterShowCfg::clear_has_walktype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NihilityMonsterShowCfg::clear_walktype() {
  walktype_ = 0u;
  clear_has_walktype();
}
inline ::google::protobuf::uint32 NihilityMonsterShowCfg::walktype() const {
  return walktype_;
}
inline void NihilityMonsterShowCfg::set_walktype(::google::protobuf::uint32 value) {
  set_has_walktype();
  walktype_ = value;
}

// required uint32 atktype = 4;
inline bool NihilityMonsterShowCfg::has_atktype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_atktype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NihilityMonsterShowCfg::clear_has_atktype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NihilityMonsterShowCfg::clear_atktype() {
  atktype_ = 0u;
  clear_has_atktype();
}
inline ::google::protobuf::uint32 NihilityMonsterShowCfg::atktype() const {
  return atktype_;
}
inline void NihilityMonsterShowCfg::set_atktype(::google::protobuf::uint32 value) {
  set_has_atktype();
  atktype_ = value;
}

// required uint32 atkAttType = 5;
inline bool NihilityMonsterShowCfg::has_atkatttype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_atkatttype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NihilityMonsterShowCfg::clear_has_atkatttype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NihilityMonsterShowCfg::clear_atkatttype() {
  atkatttype_ = 0u;
  clear_has_atkatttype();
}
inline ::google::protobuf::uint32 NihilityMonsterShowCfg::atkatttype() const {
  return atkatttype_;
}
inline void NihilityMonsterShowCfg::set_atkatttype(::google::protobuf::uint32 value) {
  set_has_atkatttype();
  atkatttype_ = value;
}

// required uint32 deftype = 6;
inline bool NihilityMonsterShowCfg::has_deftype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_deftype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NihilityMonsterShowCfg::clear_has_deftype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NihilityMonsterShowCfg::clear_deftype() {
  deftype_ = 0u;
  clear_has_deftype();
}
inline ::google::protobuf::uint32 NihilityMonsterShowCfg::deftype() const {
  return deftype_;
}
inline void NihilityMonsterShowCfg::set_deftype(::google::protobuf::uint32 value) {
  set_has_deftype();
  deftype_ = value;
}

// required uint32 highSpeed = 7;
inline bool NihilityMonsterShowCfg::has_highspeed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_highspeed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NihilityMonsterShowCfg::clear_has_highspeed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NihilityMonsterShowCfg::clear_highspeed() {
  highspeed_ = 0u;
  clear_has_highspeed();
}
inline ::google::protobuf::uint32 NihilityMonsterShowCfg::highspeed() const {
  return highspeed_;
}
inline void NihilityMonsterShowCfg::set_highspeed(::google::protobuf::uint32 value) {
  set_has_highspeed();
  highspeed_ = value;
}

// required string emergeVoice = 8;
inline bool NihilityMonsterShowCfg::has_emergevoice() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_emergevoice() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NihilityMonsterShowCfg::clear_has_emergevoice() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NihilityMonsterShowCfg::clear_emergevoice() {
  if (emergevoice_ != &::google::protobuf::internal::kEmptyString) {
    emergevoice_->clear();
  }
  clear_has_emergevoice();
}
inline const ::std::string& NihilityMonsterShowCfg::emergevoice() const {
  return *emergevoice_;
}
inline void NihilityMonsterShowCfg::set_emergevoice(const ::std::string& value) {
  set_has_emergevoice();
  if (emergevoice_ == &::google::protobuf::internal::kEmptyString) {
    emergevoice_ = new ::std::string;
  }
  emergevoice_->assign(value);
}
inline void NihilityMonsterShowCfg::set_emergevoice(const char* value) {
  set_has_emergevoice();
  if (emergevoice_ == &::google::protobuf::internal::kEmptyString) {
    emergevoice_ = new ::std::string;
  }
  emergevoice_->assign(value);
}
inline void NihilityMonsterShowCfg::set_emergevoice(const char* value, size_t size) {
  set_has_emergevoice();
  if (emergevoice_ == &::google::protobuf::internal::kEmptyString) {
    emergevoice_ = new ::std::string;
  }
  emergevoice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NihilityMonsterShowCfg::mutable_emergevoice() {
  set_has_emergevoice();
  if (emergevoice_ == &::google::protobuf::internal::kEmptyString) {
    emergevoice_ = new ::std::string;
  }
  return emergevoice_;
}
inline ::std::string* NihilityMonsterShowCfg::release_emergevoice() {
  clear_has_emergevoice();
  if (emergevoice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = emergevoice_;
    emergevoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NihilityMonsterShowCfg::set_allocated_emergevoice(::std::string* emergevoice) {
  if (emergevoice_ != &::google::protobuf::internal::kEmptyString) {
    delete emergevoice_;
  }
  if (emergevoice) {
    set_has_emergevoice();
    emergevoice_ = emergevoice;
  } else {
    clear_has_emergevoice();
    emergevoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string hurtVoice = 9;
inline bool NihilityMonsterShowCfg::has_hurtvoice() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_hurtvoice() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NihilityMonsterShowCfg::clear_has_hurtvoice() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NihilityMonsterShowCfg::clear_hurtvoice() {
  if (hurtvoice_ != &::google::protobuf::internal::kEmptyString) {
    hurtvoice_->clear();
  }
  clear_has_hurtvoice();
}
inline const ::std::string& NihilityMonsterShowCfg::hurtvoice() const {
  return *hurtvoice_;
}
inline void NihilityMonsterShowCfg::set_hurtvoice(const ::std::string& value) {
  set_has_hurtvoice();
  if (hurtvoice_ == &::google::protobuf::internal::kEmptyString) {
    hurtvoice_ = new ::std::string;
  }
  hurtvoice_->assign(value);
}
inline void NihilityMonsterShowCfg::set_hurtvoice(const char* value) {
  set_has_hurtvoice();
  if (hurtvoice_ == &::google::protobuf::internal::kEmptyString) {
    hurtvoice_ = new ::std::string;
  }
  hurtvoice_->assign(value);
}
inline void NihilityMonsterShowCfg::set_hurtvoice(const char* value, size_t size) {
  set_has_hurtvoice();
  if (hurtvoice_ == &::google::protobuf::internal::kEmptyString) {
    hurtvoice_ = new ::std::string;
  }
  hurtvoice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NihilityMonsterShowCfg::mutable_hurtvoice() {
  set_has_hurtvoice();
  if (hurtvoice_ == &::google::protobuf::internal::kEmptyString) {
    hurtvoice_ = new ::std::string;
  }
  return hurtvoice_;
}
inline ::std::string* NihilityMonsterShowCfg::release_hurtvoice() {
  clear_has_hurtvoice();
  if (hurtvoice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hurtvoice_;
    hurtvoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NihilityMonsterShowCfg::set_allocated_hurtvoice(::std::string* hurtvoice) {
  if (hurtvoice_ != &::google::protobuf::internal::kEmptyString) {
    delete hurtvoice_;
  }
  if (hurtvoice) {
    set_has_hurtvoice();
    hurtvoice_ = hurtvoice;
  } else {
    clear_has_hurtvoice();
    hurtvoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string dieVoice = 10;
inline bool NihilityMonsterShowCfg::has_dievoice() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_dievoice() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NihilityMonsterShowCfg::clear_has_dievoice() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NihilityMonsterShowCfg::clear_dievoice() {
  if (dievoice_ != &::google::protobuf::internal::kEmptyString) {
    dievoice_->clear();
  }
  clear_has_dievoice();
}
inline const ::std::string& NihilityMonsterShowCfg::dievoice() const {
  return *dievoice_;
}
inline void NihilityMonsterShowCfg::set_dievoice(const ::std::string& value) {
  set_has_dievoice();
  if (dievoice_ == &::google::protobuf::internal::kEmptyString) {
    dievoice_ = new ::std::string;
  }
  dievoice_->assign(value);
}
inline void NihilityMonsterShowCfg::set_dievoice(const char* value) {
  set_has_dievoice();
  if (dievoice_ == &::google::protobuf::internal::kEmptyString) {
    dievoice_ = new ::std::string;
  }
  dievoice_->assign(value);
}
inline void NihilityMonsterShowCfg::set_dievoice(const char* value, size_t size) {
  set_has_dievoice();
  if (dievoice_ == &::google::protobuf::internal::kEmptyString) {
    dievoice_ = new ::std::string;
  }
  dievoice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NihilityMonsterShowCfg::mutable_dievoice() {
  set_has_dievoice();
  if (dievoice_ == &::google::protobuf::internal::kEmptyString) {
    dievoice_ = new ::std::string;
  }
  return dievoice_;
}
inline ::std::string* NihilityMonsterShowCfg::release_dievoice() {
  clear_has_dievoice();
  if (dievoice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dievoice_;
    dievoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NihilityMonsterShowCfg::set_allocated_dievoice(::std::string* dievoice) {
  if (dievoice_ != &::google::protobuf::internal::kEmptyString) {
    delete dievoice_;
  }
  if (dievoice) {
    set_has_dievoice();
    dievoice_ = dievoice;
  } else {
    clear_has_dievoice();
    dievoice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated uint32 skills = 11;
inline int NihilityMonsterShowCfg::skills_size() const {
  return skills_.size();
}
inline void NihilityMonsterShowCfg::clear_skills() {
  skills_.Clear();
}
inline ::google::protobuf::uint32 NihilityMonsterShowCfg::skills(int index) const {
  return skills_.Get(index);
}
inline void NihilityMonsterShowCfg::set_skills(int index, ::google::protobuf::uint32 value) {
  skills_.Set(index, value);
}
inline void NihilityMonsterShowCfg::add_skills(::google::protobuf::uint32 value) {
  skills_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
NihilityMonsterShowCfg::skills() const {
  return skills_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
NihilityMonsterShowCfg::mutable_skills() {
  return &skills_;
}

// required uint32 monstertype = 12;
inline bool NihilityMonsterShowCfg::has_monstertype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_monstertype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NihilityMonsterShowCfg::clear_has_monstertype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NihilityMonsterShowCfg::clear_monstertype() {
  monstertype_ = 0u;
  clear_has_monstertype();
}
inline ::google::protobuf::uint32 NihilityMonsterShowCfg::monstertype() const {
  return monstertype_;
}
inline void NihilityMonsterShowCfg::set_monstertype(::google::protobuf::uint32 value) {
  set_has_monstertype();
  monstertype_ = value;
}

// required uint32 hurtActionCD = 13;
inline bool NihilityMonsterShowCfg::has_hurtactioncd() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_hurtactioncd() {
  _has_bits_[0] |= 0x00001000u;
}
inline void NihilityMonsterShowCfg::clear_has_hurtactioncd() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void NihilityMonsterShowCfg::clear_hurtactioncd() {
  hurtactioncd_ = 0u;
  clear_has_hurtactioncd();
}
inline ::google::protobuf::uint32 NihilityMonsterShowCfg::hurtactioncd() const {
  return hurtactioncd_;
}
inline void NihilityMonsterShowCfg::set_hurtactioncd(::google::protobuf::uint32 value) {
  set_has_hurtactioncd();
  hurtactioncd_ = value;
}

// required string monstername = 14;
inline bool NihilityMonsterShowCfg::has_monstername() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_monstername() {
  _has_bits_[0] |= 0x00002000u;
}
inline void NihilityMonsterShowCfg::clear_has_monstername() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void NihilityMonsterShowCfg::clear_monstername() {
  if (monstername_ != &::google::protobuf::internal::kEmptyString) {
    monstername_->clear();
  }
  clear_has_monstername();
}
inline const ::std::string& NihilityMonsterShowCfg::monstername() const {
  return *monstername_;
}
inline void NihilityMonsterShowCfg::set_monstername(const ::std::string& value) {
  set_has_monstername();
  if (monstername_ == &::google::protobuf::internal::kEmptyString) {
    monstername_ = new ::std::string;
  }
  monstername_->assign(value);
}
inline void NihilityMonsterShowCfg::set_monstername(const char* value) {
  set_has_monstername();
  if (monstername_ == &::google::protobuf::internal::kEmptyString) {
    monstername_ = new ::std::string;
  }
  monstername_->assign(value);
}
inline void NihilityMonsterShowCfg::set_monstername(const char* value, size_t size) {
  set_has_monstername();
  if (monstername_ == &::google::protobuf::internal::kEmptyString) {
    monstername_ = new ::std::string;
  }
  monstername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NihilityMonsterShowCfg::mutable_monstername() {
  set_has_monstername();
  if (monstername_ == &::google::protobuf::internal::kEmptyString) {
    monstername_ = new ::std::string;
  }
  return monstername_;
}
inline ::std::string* NihilityMonsterShowCfg::release_monstername() {
  clear_has_monstername();
  if (monstername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = monstername_;
    monstername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NihilityMonsterShowCfg::set_allocated_monstername(::std::string* monstername) {
  if (monstername_ != &::google::protobuf::internal::kEmptyString) {
    delete monstername_;
  }
  if (monstername) {
    set_has_monstername();
    monstername_ = monstername;
  } else {
    clear_has_monstername();
    monstername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string desc = 15;
inline bool NihilityMonsterShowCfg::has_desc() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_desc() {
  _has_bits_[0] |= 0x00004000u;
}
inline void NihilityMonsterShowCfg::clear_has_desc() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void NihilityMonsterShowCfg::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& NihilityMonsterShowCfg::desc() const {
  return *desc_;
}
inline void NihilityMonsterShowCfg::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void NihilityMonsterShowCfg::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void NihilityMonsterShowCfg::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NihilityMonsterShowCfg::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* NihilityMonsterShowCfg::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NihilityMonsterShowCfg::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 ballistic = 16;
inline bool NihilityMonsterShowCfg::has_ballistic() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_ballistic() {
  _has_bits_[0] |= 0x00008000u;
}
inline void NihilityMonsterShowCfg::clear_has_ballistic() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void NihilityMonsterShowCfg::clear_ballistic() {
  ballistic_ = 0u;
  clear_has_ballistic();
}
inline ::google::protobuf::uint32 NihilityMonsterShowCfg::ballistic() const {
  return ballistic_;
}
inline void NihilityMonsterShowCfg::set_ballistic(::google::protobuf::uint32 value) {
  set_has_ballistic();
  ballistic_ = value;
}

// required string dieAnimation = 17;
inline bool NihilityMonsterShowCfg::has_dieanimation() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_dieanimation() {
  _has_bits_[0] |= 0x00010000u;
}
inline void NihilityMonsterShowCfg::clear_has_dieanimation() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void NihilityMonsterShowCfg::clear_dieanimation() {
  if (dieanimation_ != &::google::protobuf::internal::kEmptyString) {
    dieanimation_->clear();
  }
  clear_has_dieanimation();
}
inline const ::std::string& NihilityMonsterShowCfg::dieanimation() const {
  return *dieanimation_;
}
inline void NihilityMonsterShowCfg::set_dieanimation(const ::std::string& value) {
  set_has_dieanimation();
  if (dieanimation_ == &::google::protobuf::internal::kEmptyString) {
    dieanimation_ = new ::std::string;
  }
  dieanimation_->assign(value);
}
inline void NihilityMonsterShowCfg::set_dieanimation(const char* value) {
  set_has_dieanimation();
  if (dieanimation_ == &::google::protobuf::internal::kEmptyString) {
    dieanimation_ = new ::std::string;
  }
  dieanimation_->assign(value);
}
inline void NihilityMonsterShowCfg::set_dieanimation(const char* value, size_t size) {
  set_has_dieanimation();
  if (dieanimation_ == &::google::protobuf::internal::kEmptyString) {
    dieanimation_ = new ::std::string;
  }
  dieanimation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NihilityMonsterShowCfg::mutable_dieanimation() {
  set_has_dieanimation();
  if (dieanimation_ == &::google::protobuf::internal::kEmptyString) {
    dieanimation_ = new ::std::string;
  }
  return dieanimation_;
}
inline ::std::string* NihilityMonsterShowCfg::release_dieanimation() {
  clear_has_dieanimation();
  if (dieanimation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dieanimation_;
    dieanimation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NihilityMonsterShowCfg::set_allocated_dieanimation(::std::string* dieanimation) {
  if (dieanimation_ != &::google::protobuf::internal::kEmptyString) {
    delete dieanimation_;
  }
  if (dieanimation) {
    set_has_dieanimation();
    dieanimation_ = dieanimation;
  } else {
    clear_has_dieanimation();
    dieanimation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 minWalkSpeed = 18;
inline bool NihilityMonsterShowCfg::has_minwalkspeed() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_minwalkspeed() {
  _has_bits_[0] |= 0x00020000u;
}
inline void NihilityMonsterShowCfg::clear_has_minwalkspeed() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void NihilityMonsterShowCfg::clear_minwalkspeed() {
  minwalkspeed_ = 0u;
  clear_has_minwalkspeed();
}
inline ::google::protobuf::uint32 NihilityMonsterShowCfg::minwalkspeed() const {
  return minwalkspeed_;
}
inline void NihilityMonsterShowCfg::set_minwalkspeed(::google::protobuf::uint32 value) {
  set_has_minwalkspeed();
  minwalkspeed_ = value;
}

// required uint32 maxWalkSpeed = 19;
inline bool NihilityMonsterShowCfg::has_maxwalkspeed() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_maxwalkspeed() {
  _has_bits_[0] |= 0x00040000u;
}
inline void NihilityMonsterShowCfg::clear_has_maxwalkspeed() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void NihilityMonsterShowCfg::clear_maxwalkspeed() {
  maxwalkspeed_ = 0u;
  clear_has_maxwalkspeed();
}
inline ::google::protobuf::uint32 NihilityMonsterShowCfg::maxwalkspeed() const {
  return maxwalkspeed_;
}
inline void NihilityMonsterShowCfg::set_maxwalkspeed(::google::protobuf::uint32 value) {
  set_has_maxwalkspeed();
  maxwalkspeed_ = value;
}

// required uint32 bubbleId = 20;
inline bool NihilityMonsterShowCfg::has_bubbleid() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_bubbleid() {
  _has_bits_[0] |= 0x00080000u;
}
inline void NihilityMonsterShowCfg::clear_has_bubbleid() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void NihilityMonsterShowCfg::clear_bubbleid() {
  bubbleid_ = 0u;
  clear_has_bubbleid();
}
inline ::google::protobuf::uint32 NihilityMonsterShowCfg::bubbleid() const {
  return bubbleid_;
}
inline void NihilityMonsterShowCfg::set_bubbleid(::google::protobuf::uint32 value) {
  set_has_bubbleid();
  bubbleid_ = value;
}

// required uint32 floorBuffId = 21;
inline bool NihilityMonsterShowCfg::has_floorbuffid() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_floorbuffid() {
  _has_bits_[0] |= 0x00100000u;
}
inline void NihilityMonsterShowCfg::clear_has_floorbuffid() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void NihilityMonsterShowCfg::clear_floorbuffid() {
  floorbuffid_ = 0u;
  clear_has_floorbuffid();
}
inline ::google::protobuf::uint32 NihilityMonsterShowCfg::floorbuffid() const {
  return floorbuffid_;
}
inline void NihilityMonsterShowCfg::set_floorbuffid(::google::protobuf::uint32 value) {
  set_has_floorbuffid();
  floorbuffid_ = value;
}

// required uint32 aiID = 22;
inline bool NihilityMonsterShowCfg::has_aiid() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_aiid() {
  _has_bits_[0] |= 0x00200000u;
}
inline void NihilityMonsterShowCfg::clear_has_aiid() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void NihilityMonsterShowCfg::clear_aiid() {
  aiid_ = 0u;
  clear_has_aiid();
}
inline ::google::protobuf::uint32 NihilityMonsterShowCfg::aiid() const {
  return aiid_;
}
inline void NihilityMonsterShowCfg::set_aiid(::google::protobuf::uint32 value) {
  set_has_aiid();
  aiid_ = value;
}

// required uint32 patrolArea = 23;
inline bool NihilityMonsterShowCfg::has_patrolarea() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_patrolarea() {
  _has_bits_[0] |= 0x00400000u;
}
inline void NihilityMonsterShowCfg::clear_has_patrolarea() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void NihilityMonsterShowCfg::clear_patrolarea() {
  patrolarea_ = 0u;
  clear_has_patrolarea();
}
inline ::google::protobuf::uint32 NihilityMonsterShowCfg::patrolarea() const {
  return patrolarea_;
}
inline void NihilityMonsterShowCfg::set_patrolarea(::google::protobuf::uint32 value) {
  set_has_patrolarea();
  patrolarea_ = value;
}

// required uint32 HurtColor = 24;
inline bool NihilityMonsterShowCfg::has_hurtcolor() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_hurtcolor() {
  _has_bits_[0] |= 0x00800000u;
}
inline void NihilityMonsterShowCfg::clear_has_hurtcolor() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void NihilityMonsterShowCfg::clear_hurtcolor() {
  hurtcolor_ = 0u;
  clear_has_hurtcolor();
}
inline ::google::protobuf::uint32 NihilityMonsterShowCfg::hurtcolor() const {
  return hurtcolor_;
}
inline void NihilityMonsterShowCfg::set_hurtcolor(::google::protobuf::uint32 value) {
  set_has_hurtcolor();
  hurtcolor_ = value;
}

// required uint32 InitScale = 25;
inline bool NihilityMonsterShowCfg::has_initscale() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_initscale() {
  _has_bits_[0] |= 0x01000000u;
}
inline void NihilityMonsterShowCfg::clear_has_initscale() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void NihilityMonsterShowCfg::clear_initscale() {
  initscale_ = 0u;
  clear_has_initscale();
}
inline ::google::protobuf::uint32 NihilityMonsterShowCfg::initscale() const {
  return initscale_;
}
inline void NihilityMonsterShowCfg::set_initscale(::google::protobuf::uint32 value) {
  set_has_initscale();
  initscale_ = value;
}

// required uint32 IsBlock = 26;
inline bool NihilityMonsterShowCfg::has_isblock() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_isblock() {
  _has_bits_[0] |= 0x02000000u;
}
inline void NihilityMonsterShowCfg::clear_has_isblock() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void NihilityMonsterShowCfg::clear_isblock() {
  isblock_ = 0u;
  clear_has_isblock();
}
inline ::google::protobuf::uint32 NihilityMonsterShowCfg::isblock() const {
  return isblock_;
}
inline void NihilityMonsterShowCfg::set_isblock(::google::protobuf::uint32 value) {
  set_has_isblock();
  isblock_ = value;
}

// required string hurtAnimation = 27;
inline bool NihilityMonsterShowCfg::has_hurtanimation() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_hurtanimation() {
  _has_bits_[0] |= 0x04000000u;
}
inline void NihilityMonsterShowCfg::clear_has_hurtanimation() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void NihilityMonsterShowCfg::clear_hurtanimation() {
  if (hurtanimation_ != &::google::protobuf::internal::kEmptyString) {
    hurtanimation_->clear();
  }
  clear_has_hurtanimation();
}
inline const ::std::string& NihilityMonsterShowCfg::hurtanimation() const {
  return *hurtanimation_;
}
inline void NihilityMonsterShowCfg::set_hurtanimation(const ::std::string& value) {
  set_has_hurtanimation();
  if (hurtanimation_ == &::google::protobuf::internal::kEmptyString) {
    hurtanimation_ = new ::std::string;
  }
  hurtanimation_->assign(value);
}
inline void NihilityMonsterShowCfg::set_hurtanimation(const char* value) {
  set_has_hurtanimation();
  if (hurtanimation_ == &::google::protobuf::internal::kEmptyString) {
    hurtanimation_ = new ::std::string;
  }
  hurtanimation_->assign(value);
}
inline void NihilityMonsterShowCfg::set_hurtanimation(const char* value, size_t size) {
  set_has_hurtanimation();
  if (hurtanimation_ == &::google::protobuf::internal::kEmptyString) {
    hurtanimation_ = new ::std::string;
  }
  hurtanimation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NihilityMonsterShowCfg::mutable_hurtanimation() {
  set_has_hurtanimation();
  if (hurtanimation_ == &::google::protobuf::internal::kEmptyString) {
    hurtanimation_ = new ::std::string;
  }
  return hurtanimation_;
}
inline ::std::string* NihilityMonsterShowCfg::release_hurtanimation() {
  clear_has_hurtanimation();
  if (hurtanimation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hurtanimation_;
    hurtanimation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NihilityMonsterShowCfg::set_allocated_hurtanimation(::std::string* hurtanimation) {
  if (hurtanimation_ != &::google::protobuf::internal::kEmptyString) {
    delete hurtanimation_;
  }
  if (hurtanimation) {
    set_has_hurtanimation();
    hurtanimation_ = hurtanimation;
  } else {
    clear_has_hurtanimation();
    hurtanimation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 dropGoldNum = 28;
inline bool NihilityMonsterShowCfg::has_dropgoldnum() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_dropgoldnum() {
  _has_bits_[0] |= 0x08000000u;
}
inline void NihilityMonsterShowCfg::clear_has_dropgoldnum() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void NihilityMonsterShowCfg::clear_dropgoldnum() {
  dropgoldnum_ = 0u;
  clear_has_dropgoldnum();
}
inline ::google::protobuf::uint32 NihilityMonsterShowCfg::dropgoldnum() const {
  return dropgoldnum_;
}
inline void NihilityMonsterShowCfg::set_dropgoldnum(::google::protobuf::uint32 value) {
  set_has_dropgoldnum();
  dropgoldnum_ = value;
}

// required uint32 score = 29;
inline bool NihilityMonsterShowCfg::has_score() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_score() {
  _has_bits_[0] |= 0x10000000u;
}
inline void NihilityMonsterShowCfg::clear_has_score() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void NihilityMonsterShowCfg::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 NihilityMonsterShowCfg::score() const {
  return score_;
}
inline void NihilityMonsterShowCfg::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
}

// required .com.cfg.vo.Movement actions = 30;
inline bool NihilityMonsterShowCfg::has_actions() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_actions() {
  _has_bits_[0] |= 0x20000000u;
}
inline void NihilityMonsterShowCfg::clear_has_actions() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void NihilityMonsterShowCfg::clear_actions() {
  if (actions_ != NULL) actions_->::com::cfg::vo::Movement::Clear();
  clear_has_actions();
}
inline const ::com::cfg::vo::Movement& NihilityMonsterShowCfg::actions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return actions_ != NULL ? *actions_ : *default_instance().actions_;
#else
  return actions_ != NULL ? *actions_ : *default_instance_->actions_;
#endif
}
inline ::com::cfg::vo::Movement* NihilityMonsterShowCfg::mutable_actions() {
  set_has_actions();
  if (actions_ == NULL) actions_ = new ::com::cfg::vo::Movement;
  return actions_;
}
inline ::com::cfg::vo::Movement* NihilityMonsterShowCfg::release_actions() {
  clear_has_actions();
  ::com::cfg::vo::Movement* temp = actions_;
  actions_ = NULL;
  return temp;
}
inline void NihilityMonsterShowCfg::set_allocated_actions(::com::cfg::vo::Movement* actions) {
  delete actions_;
  actions_ = actions;
  if (actions) {
    set_has_actions();
  } else {
    clear_has_actions();
  }
}

// required string headImg = 31;
inline bool NihilityMonsterShowCfg::has_headimg() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void NihilityMonsterShowCfg::set_has_headimg() {
  _has_bits_[0] |= 0x40000000u;
}
inline void NihilityMonsterShowCfg::clear_has_headimg() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void NihilityMonsterShowCfg::clear_headimg() {
  if (headimg_ != &::google::protobuf::internal::kEmptyString) {
    headimg_->clear();
  }
  clear_has_headimg();
}
inline const ::std::string& NihilityMonsterShowCfg::headimg() const {
  return *headimg_;
}
inline void NihilityMonsterShowCfg::set_headimg(const ::std::string& value) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(value);
}
inline void NihilityMonsterShowCfg::set_headimg(const char* value) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(value);
}
inline void NihilityMonsterShowCfg::set_headimg(const char* value, size_t size) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NihilityMonsterShowCfg::mutable_headimg() {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  return headimg_;
}
inline ::std::string* NihilityMonsterShowCfg::release_headimg() {
  clear_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headimg_;
    headimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NihilityMonsterShowCfg::set_allocated_headimg(::std::string* headimg) {
  if (headimg_ != &::google::protobuf::internal::kEmptyString) {
    delete headimg_;
  }
  if (headimg) {
    set_has_headimg();
    headimg_ = headimg;
  } else {
    clear_has_headimg();
    headimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NihilityMonsterShowCfgSet

// repeated .com.cfg.vo.NihilityMonsterShowCfg nihilityMonsterShowCfg = 1;
inline int NihilityMonsterShowCfgSet::nihilitymonstershowcfg_size() const {
  return nihilitymonstershowcfg_.size();
}
inline void NihilityMonsterShowCfgSet::clear_nihilitymonstershowcfg() {
  nihilitymonstershowcfg_.Clear();
}
inline const ::com::cfg::vo::NihilityMonsterShowCfg& NihilityMonsterShowCfgSet::nihilitymonstershowcfg(int index) const {
  return nihilitymonstershowcfg_.Get(index);
}
inline ::com::cfg::vo::NihilityMonsterShowCfg* NihilityMonsterShowCfgSet::mutable_nihilitymonstershowcfg(int index) {
  return nihilitymonstershowcfg_.Mutable(index);
}
inline ::com::cfg::vo::NihilityMonsterShowCfg* NihilityMonsterShowCfgSet::add_nihilitymonstershowcfg() {
  return nihilitymonstershowcfg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::NihilityMonsterShowCfg >&
NihilityMonsterShowCfgSet::nihilitymonstershowcfg() const {
  return nihilitymonstershowcfg_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::NihilityMonsterShowCfg >*
NihilityMonsterShowCfgSet::mutable_nihilitymonstershowcfg() {
  return &nihilitymonstershowcfg_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vo
}  // namespace cfg
}  // namespace com

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_NihilityMonsterShowCfg_2eproto__INCLUDED
