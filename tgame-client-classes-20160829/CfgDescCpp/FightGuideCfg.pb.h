// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FightGuideCfg.proto

#ifndef PROTOBUF_FightGuideCfg_2eproto__INCLUDED
#define PROTOBUF_FightGuideCfg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace cfg {
namespace vo {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_FightGuideCfg_2eproto();
void protobuf_AssignDesc_FightGuideCfg_2eproto();
void protobuf_ShutdownFile_FightGuideCfg_2eproto();

class FightGuideCfg;
class FightGuideCfgSet;

// ===================================================================

class FightGuideCfg : public ::google::protobuf::MessageLite {
 public:
  FightGuideCfg();
  virtual ~FightGuideCfg();

  FightGuideCfg(const FightGuideCfg& from);

  inline FightGuideCfg& operator=(const FightGuideCfg& from) {
    CopyFrom(from);
    return *this;
  }

  static const FightGuideCfg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FightGuideCfg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FightGuideCfg* other);

  // implements Message ----------------------------------------------

  FightGuideCfg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FightGuideCfg& from);
  void MergeFrom(const FightGuideCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 StepID = 1;
  inline bool has_stepid() const;
  inline void clear_stepid();
  static const int kStepIDFieldNumber = 1;
  inline ::google::protobuf::uint32 stepid() const;
  inline void set_stepid(::google::protobuf::uint32 value);

  // required uint32 Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required string Desc = 3;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 3;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // required uint32 IsPlayer = 4;
  inline bool has_isplayer() const;
  inline void clear_isplayer();
  static const int kIsPlayerFieldNumber = 4;
  inline ::google::protobuf::uint32 isplayer() const;
  inline void set_isplayer(::google::protobuf::uint32 value);

  // required string PauseDesc = 5;
  inline bool has_pausedesc() const;
  inline void clear_pausedesc();
  static const int kPauseDescFieldNumber = 5;
  inline const ::std::string& pausedesc() const;
  inline void set_pausedesc(const ::std::string& value);
  inline void set_pausedesc(const char* value);
  inline void set_pausedesc(const char* value, size_t size);
  inline ::std::string* mutable_pausedesc();
  inline ::std::string* release_pausedesc();
  inline void set_allocated_pausedesc(::std::string* pausedesc);

  // required string MonName = 6;
  inline bool has_monname() const;
  inline void clear_monname();
  static const int kMonNameFieldNumber = 6;
  inline const ::std::string& monname() const;
  inline void set_monname(const ::std::string& value);
  inline void set_monname(const char* value);
  inline void set_monname(const char* value, size_t size);
  inline ::std::string* mutable_monname();
  inline ::std::string* release_monname();
  inline void set_allocated_monname(::std::string* monname);

  // @@protoc_insertion_point(class_scope:com.cfg.vo.FightGuideCfg)
 private:
  inline void set_has_stepid();
  inline void clear_has_stepid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_isplayer();
  inline void clear_has_isplayer();
  inline void set_has_pausedesc();
  inline void clear_has_pausedesc();
  inline void set_has_monname();
  inline void clear_has_monname();

  ::google::protobuf::uint32 stepid_;
  ::google::protobuf::uint32 type_;
  ::std::string* desc_;
  ::std::string* pausedesc_;
  ::std::string* monname_;
  ::google::protobuf::uint32 isplayer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightGuideCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightGuideCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightGuideCfg_2eproto();
  friend void protobuf_ShutdownFile_FightGuideCfg_2eproto();

  void InitAsDefaultInstance();
  static FightGuideCfg* default_instance_;
};
// -------------------------------------------------------------------

class FightGuideCfgSet : public ::google::protobuf::MessageLite {
 public:
  FightGuideCfgSet();
  virtual ~FightGuideCfgSet();

  FightGuideCfgSet(const FightGuideCfgSet& from);

  inline FightGuideCfgSet& operator=(const FightGuideCfgSet& from) {
    CopyFrom(from);
    return *this;
  }

  static const FightGuideCfgSet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FightGuideCfgSet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FightGuideCfgSet* other);

  // implements Message ----------------------------------------------

  FightGuideCfgSet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FightGuideCfgSet& from);
  void MergeFrom(const FightGuideCfgSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.cfg.vo.FightGuideCfg fightGuideCfg = 1;
  inline int fightguidecfg_size() const;
  inline void clear_fightguidecfg();
  static const int kFightGuideCfgFieldNumber = 1;
  inline const ::com::cfg::vo::FightGuideCfg& fightguidecfg(int index) const;
  inline ::com::cfg::vo::FightGuideCfg* mutable_fightguidecfg(int index);
  inline ::com::cfg::vo::FightGuideCfg* add_fightguidecfg();
  inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::FightGuideCfg >&
      fightguidecfg() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::FightGuideCfg >*
      mutable_fightguidecfg();

  // @@protoc_insertion_point(class_scope:com.cfg.vo.FightGuideCfgSet)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::FightGuideCfg > fightguidecfg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_FightGuideCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_FightGuideCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_FightGuideCfg_2eproto();
  friend void protobuf_ShutdownFile_FightGuideCfg_2eproto();

  void InitAsDefaultInstance();
  static FightGuideCfgSet* default_instance_;
};
// ===================================================================


// ===================================================================

// FightGuideCfg

// required uint32 StepID = 1;
inline bool FightGuideCfg::has_stepid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightGuideCfg::set_has_stepid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightGuideCfg::clear_has_stepid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightGuideCfg::clear_stepid() {
  stepid_ = 0u;
  clear_has_stepid();
}
inline ::google::protobuf::uint32 FightGuideCfg::stepid() const {
  return stepid_;
}
inline void FightGuideCfg::set_stepid(::google::protobuf::uint32 value) {
  set_has_stepid();
  stepid_ = value;
}

// required uint32 Type = 2;
inline bool FightGuideCfg::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FightGuideCfg::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FightGuideCfg::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FightGuideCfg::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 FightGuideCfg::type() const {
  return type_;
}
inline void FightGuideCfg::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required string Desc = 3;
inline bool FightGuideCfg::has_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FightGuideCfg::set_has_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FightGuideCfg::clear_has_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FightGuideCfg::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& FightGuideCfg::desc() const {
  return *desc_;
}
inline void FightGuideCfg::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void FightGuideCfg::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void FightGuideCfg::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FightGuideCfg::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* FightGuideCfg::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FightGuideCfg::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 IsPlayer = 4;
inline bool FightGuideCfg::has_isplayer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FightGuideCfg::set_has_isplayer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FightGuideCfg::clear_has_isplayer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FightGuideCfg::clear_isplayer() {
  isplayer_ = 0u;
  clear_has_isplayer();
}
inline ::google::protobuf::uint32 FightGuideCfg::isplayer() const {
  return isplayer_;
}
inline void FightGuideCfg::set_isplayer(::google::protobuf::uint32 value) {
  set_has_isplayer();
  isplayer_ = value;
}

// required string PauseDesc = 5;
inline bool FightGuideCfg::has_pausedesc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FightGuideCfg::set_has_pausedesc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FightGuideCfg::clear_has_pausedesc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FightGuideCfg::clear_pausedesc() {
  if (pausedesc_ != &::google::protobuf::internal::kEmptyString) {
    pausedesc_->clear();
  }
  clear_has_pausedesc();
}
inline const ::std::string& FightGuideCfg::pausedesc() const {
  return *pausedesc_;
}
inline void FightGuideCfg::set_pausedesc(const ::std::string& value) {
  set_has_pausedesc();
  if (pausedesc_ == &::google::protobuf::internal::kEmptyString) {
    pausedesc_ = new ::std::string;
  }
  pausedesc_->assign(value);
}
inline void FightGuideCfg::set_pausedesc(const char* value) {
  set_has_pausedesc();
  if (pausedesc_ == &::google::protobuf::internal::kEmptyString) {
    pausedesc_ = new ::std::string;
  }
  pausedesc_->assign(value);
}
inline void FightGuideCfg::set_pausedesc(const char* value, size_t size) {
  set_has_pausedesc();
  if (pausedesc_ == &::google::protobuf::internal::kEmptyString) {
    pausedesc_ = new ::std::string;
  }
  pausedesc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FightGuideCfg::mutable_pausedesc() {
  set_has_pausedesc();
  if (pausedesc_ == &::google::protobuf::internal::kEmptyString) {
    pausedesc_ = new ::std::string;
  }
  return pausedesc_;
}
inline ::std::string* FightGuideCfg::release_pausedesc() {
  clear_has_pausedesc();
  if (pausedesc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pausedesc_;
    pausedesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FightGuideCfg::set_allocated_pausedesc(::std::string* pausedesc) {
  if (pausedesc_ != &::google::protobuf::internal::kEmptyString) {
    delete pausedesc_;
  }
  if (pausedesc) {
    set_has_pausedesc();
    pausedesc_ = pausedesc;
  } else {
    clear_has_pausedesc();
    pausedesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string MonName = 6;
inline bool FightGuideCfg::has_monname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FightGuideCfg::set_has_monname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FightGuideCfg::clear_has_monname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FightGuideCfg::clear_monname() {
  if (monname_ != &::google::protobuf::internal::kEmptyString) {
    monname_->clear();
  }
  clear_has_monname();
}
inline const ::std::string& FightGuideCfg::monname() const {
  return *monname_;
}
inline void FightGuideCfg::set_monname(const ::std::string& value) {
  set_has_monname();
  if (monname_ == &::google::protobuf::internal::kEmptyString) {
    monname_ = new ::std::string;
  }
  monname_->assign(value);
}
inline void FightGuideCfg::set_monname(const char* value) {
  set_has_monname();
  if (monname_ == &::google::protobuf::internal::kEmptyString) {
    monname_ = new ::std::string;
  }
  monname_->assign(value);
}
inline void FightGuideCfg::set_monname(const char* value, size_t size) {
  set_has_monname();
  if (monname_ == &::google::protobuf::internal::kEmptyString) {
    monname_ = new ::std::string;
  }
  monname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FightGuideCfg::mutable_monname() {
  set_has_monname();
  if (monname_ == &::google::protobuf::internal::kEmptyString) {
    monname_ = new ::std::string;
  }
  return monname_;
}
inline ::std::string* FightGuideCfg::release_monname() {
  clear_has_monname();
  if (monname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = monname_;
    monname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FightGuideCfg::set_allocated_monname(::std::string* monname) {
  if (monname_ != &::google::protobuf::internal::kEmptyString) {
    delete monname_;
  }
  if (monname) {
    set_has_monname();
    monname_ = monname;
  } else {
    clear_has_monname();
    monname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FightGuideCfgSet

// repeated .com.cfg.vo.FightGuideCfg fightGuideCfg = 1;
inline int FightGuideCfgSet::fightguidecfg_size() const {
  return fightguidecfg_.size();
}
inline void FightGuideCfgSet::clear_fightguidecfg() {
  fightguidecfg_.Clear();
}
inline const ::com::cfg::vo::FightGuideCfg& FightGuideCfgSet::fightguidecfg(int index) const {
  return fightguidecfg_.Get(index);
}
inline ::com::cfg::vo::FightGuideCfg* FightGuideCfgSet::mutable_fightguidecfg(int index) {
  return fightguidecfg_.Mutable(index);
}
inline ::com::cfg::vo::FightGuideCfg* FightGuideCfgSet::add_fightguidecfg() {
  return fightguidecfg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::FightGuideCfg >&
FightGuideCfgSet::fightguidecfg() const {
  return fightguidecfg_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::FightGuideCfg >*
FightGuideCfgSet::mutable_fightguidecfg() {
  return &fightguidecfg_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vo
}  // namespace cfg
}  // namespace com

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_FightGuideCfg_2eproto__INCLUDED
