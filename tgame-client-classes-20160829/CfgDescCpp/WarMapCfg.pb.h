// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: WarMapCfg.proto

#ifndef PROTOBUF_WarMapCfg_2eproto__INCLUDED
#define PROTOBUF_WarMapCfg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace cfg {
namespace vo {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_WarMapCfg_2eproto();
void protobuf_AssignDesc_WarMapCfg_2eproto();
void protobuf_ShutdownFile_WarMapCfg_2eproto();

class MapItem;
class MapMonster;
class HidenAward;
class WarMapCfg;
class WarMapCfgSet;

// ===================================================================

class MapItem : public ::google::protobuf::MessageLite {
 public:
  MapItem();
  virtual ~MapItem();

  MapItem(const MapItem& from);

  inline MapItem& operator=(const MapItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const MapItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MapItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MapItem* other);

  // implements Message ----------------------------------------------

  MapItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MapItem& from);
  void MergeFrom(const MapItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ItemID = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIDFieldNumber = 1;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // required uint32 ItemNum = 2;
  inline bool has_itemnum() const;
  inline void clear_itemnum();
  static const int kItemNumFieldNumber = 2;
  inline ::google::protobuf::uint32 itemnum() const;
  inline void set_itemnum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.cfg.vo.MapItem)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_itemnum();
  inline void clear_has_itemnum();

  ::google::protobuf::uint32 itemid_;
  ::google::protobuf::uint32 itemnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_WarMapCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_WarMapCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_WarMapCfg_2eproto();
  friend void protobuf_ShutdownFile_WarMapCfg_2eproto();

  void InitAsDefaultInstance();
  static MapItem* default_instance_;
};
// -------------------------------------------------------------------

class MapMonster : public ::google::protobuf::MessageLite {
 public:
  MapMonster();
  virtual ~MapMonster();

  MapMonster(const MapMonster& from);

  inline MapMonster& operator=(const MapMonster& from) {
    CopyFrom(from);
    return *this;
  }

  static const MapMonster& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MapMonster* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MapMonster* other);

  // implements Message ----------------------------------------------

  MapMonster* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MapMonster& from);
  void MergeFrom(const MapMonster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 MonsterID = 1;
  inline bool has_monsterid() const;
  inline void clear_monsterid();
  static const int kMonsterIDFieldNumber = 1;
  inline ::google::protobuf::uint32 monsterid() const;
  inline void set_monsterid(::google::protobuf::uint32 value);

  // required uint32 MonsterNum = 2;
  inline bool has_monsternum() const;
  inline void clear_monsternum();
  static const int kMonsterNumFieldNumber = 2;
  inline ::google::protobuf::uint32 monsternum() const;
  inline void set_monsternum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.cfg.vo.MapMonster)
 private:
  inline void set_has_monsterid();
  inline void clear_has_monsterid();
  inline void set_has_monsternum();
  inline void clear_has_monsternum();

  ::google::protobuf::uint32 monsterid_;
  ::google::protobuf::uint32 monsternum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_WarMapCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_WarMapCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_WarMapCfg_2eproto();
  friend void protobuf_ShutdownFile_WarMapCfg_2eproto();

  void InitAsDefaultInstance();
  static MapMonster* default_instance_;
};
// -------------------------------------------------------------------

class HidenAward : public ::google::protobuf::MessageLite {
 public:
  HidenAward();
  virtual ~HidenAward();

  HidenAward(const HidenAward& from);

  inline HidenAward& operator=(const HidenAward& from) {
    CopyFrom(from);
    return *this;
  }

  static const HidenAward& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HidenAward* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HidenAward* other);

  // implements Message ----------------------------------------------

  HidenAward* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HidenAward& from);
  void MergeFrom(const HidenAward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 WinType = 1;
  inline bool has_wintype() const;
  inline void clear_wintype();
  static const int kWinTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 wintype() const;
  inline void set_wintype(::google::protobuf::uint32 value);

  // required uint32 WinCondition = 2;
  inline bool has_wincondition() const;
  inline void clear_wincondition();
  static const int kWinConditionFieldNumber = 2;
  inline ::google::protobuf::uint32 wincondition() const;
  inline void set_wincondition(::google::protobuf::uint32 value);

  // required uint32 WinAwardID = 3;
  inline bool has_winawardid() const;
  inline void clear_winawardid();
  static const int kWinAwardIDFieldNumber = 3;
  inline ::google::protobuf::uint32 winawardid() const;
  inline void set_winawardid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.cfg.vo.HidenAward)
 private:
  inline void set_has_wintype();
  inline void clear_has_wintype();
  inline void set_has_wincondition();
  inline void clear_has_wincondition();
  inline void set_has_winawardid();
  inline void clear_has_winawardid();

  ::google::protobuf::uint32 wintype_;
  ::google::protobuf::uint32 wincondition_;
  ::google::protobuf::uint32 winawardid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_WarMapCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_WarMapCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_WarMapCfg_2eproto();
  friend void protobuf_ShutdownFile_WarMapCfg_2eproto();

  void InitAsDefaultInstance();
  static HidenAward* default_instance_;
};
// -------------------------------------------------------------------

class WarMapCfg : public ::google::protobuf::MessageLite {
 public:
  WarMapCfg();
  virtual ~WarMapCfg();

  WarMapCfg(const WarMapCfg& from);

  inline WarMapCfg& operator=(const WarMapCfg& from) {
    CopyFrom(from);
    return *this;
  }

  static const WarMapCfg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WarMapCfg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WarMapCfg* other);

  // implements Message ----------------------------------------------

  WarMapCfg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WarMapCfg& from);
  void MergeFrom(const WarMapCfg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 MapID = 3;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapIDFieldNumber = 3;
  inline ::google::protobuf::uint32 mapid() const;
  inline void set_mapid(::google::protobuf::uint32 value);

  // repeated .com.cfg.vo.MapItem Items = 4;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 4;
  inline const ::com::cfg::vo::MapItem& items(int index) const;
  inline ::com::cfg::vo::MapItem* mutable_items(int index);
  inline ::com::cfg::vo::MapItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::MapItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::MapItem >*
      mutable_items();

  // repeated .com.cfg.vo.MapMonster Monsters = 5;
  inline int monsters_size() const;
  inline void clear_monsters();
  static const int kMonstersFieldNumber = 5;
  inline const ::com::cfg::vo::MapMonster& monsters(int index) const;
  inline ::com::cfg::vo::MapMonster* mutable_monsters(int index);
  inline ::com::cfg::vo::MapMonster* add_monsters();
  inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::MapMonster >&
      monsters() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::MapMonster >*
      mutable_monsters();

  // required uint32 BossID = 6;
  inline bool has_bossid() const;
  inline void clear_bossid();
  static const int kBossIDFieldNumber = 6;
  inline ::google::protobuf::uint32 bossid() const;
  inline void set_bossid(::google::protobuf::uint32 value);

  // required uint32 Exp = 7;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 7;
  inline ::google::protobuf::uint32 exp() const;
  inline void set_exp(::google::protobuf::uint32 value);

  // required uint32 Coin = 8;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 8;
  inline ::google::protobuf::uint32 coin() const;
  inline void set_coin(::google::protobuf::uint32 value);

  // required uint32 WinType = 9;
  inline bool has_wintype() const;
  inline void clear_wintype();
  static const int kWinTypeFieldNumber = 9;
  inline ::google::protobuf::uint32 wintype() const;
  inline void set_wintype(::google::protobuf::uint32 value);

  // required uint32 StageNum = 10;
  inline bool has_stagenum() const;
  inline void clear_stagenum();
  static const int kStageNumFieldNumber = 10;
  inline ::google::protobuf::uint32 stagenum() const;
  inline void set_stagenum(::google::protobuf::uint32 value);

  // repeated uint32 PackageIDs = 11;
  inline int packageids_size() const;
  inline void clear_packageids();
  static const int kPackageIDsFieldNumber = 11;
  inline ::google::protobuf::uint32 packageids(int index) const;
  inline void set_packageids(int index, ::google::protobuf::uint32 value);
  inline void add_packageids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      packageids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_packageids();

  // required uint32 WarID = 12;
  inline bool has_warid() const;
  inline void clear_warid();
  static const int kWarIDFieldNumber = 12;
  inline ::google::protobuf::uint32 warid() const;
  inline void set_warid(::google::protobuf::uint32 value);

  // required uint32 Manual = 13;
  inline bool has_manual() const;
  inline void clear_manual();
  static const int kManualFieldNumber = 13;
  inline ::google::protobuf::uint32 manual() const;
  inline void set_manual(::google::protobuf::uint32 value);

  // required uint32 RepeatNum = 14;
  inline bool has_repeatnum() const;
  inline void clear_repeatnum();
  static const int kRepeatNumFieldNumber = 14;
  inline ::google::protobuf::uint32 repeatnum() const;
  inline void set_repeatnum(::google::protobuf::uint32 value);

  // required uint32 CardID = 15;
  inline bool has_cardid() const;
  inline void clear_cardid();
  static const int kCardIDFieldNumber = 15;
  inline ::google::protobuf::uint32 cardid() const;
  inline void set_cardid(::google::protobuf::uint32 value);

  // required uint32 Level = 16;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 16;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint32 LimitTime = 17;
  inline bool has_limittime() const;
  inline void clear_limittime();
  static const int kLimitTimeFieldNumber = 17;
  inline ::google::protobuf::uint32 limittime() const;
  inline void set_limittime(::google::protobuf::uint32 value);

  // required string SimpleViewRes = 18;
  inline bool has_simpleviewres() const;
  inline void clear_simpleviewres();
  static const int kSimpleViewResFieldNumber = 18;
  inline const ::std::string& simpleviewres() const;
  inline void set_simpleviewres(const ::std::string& value);
  inline void set_simpleviewres(const char* value);
  inline void set_simpleviewres(const char* value, size_t size);
  inline ::std::string* mutable_simpleviewres();
  inline ::std::string* release_simpleviewres();
  inline void set_allocated_simpleviewres(::std::string* simpleviewres);

  // required uint32 WinValue1 = 19;
  inline bool has_winvalue1() const;
  inline void clear_winvalue1();
  static const int kWinValue1FieldNumber = 19;
  inline ::google::protobuf::uint32 winvalue1() const;
  inline void set_winvalue1(::google::protobuf::uint32 value);

  // required uint32 WinValue2 = 20;
  inline bool has_winvalue2() const;
  inline void clear_winvalue2();
  static const int kWinValue2FieldNumber = 20;
  inline ::google::protobuf::uint32 winvalue2() const;
  inline void set_winvalue2(::google::protobuf::uint32 value);

  // repeated .com.cfg.vo.HidenAward HidenAwards = 21;
  inline int hidenawards_size() const;
  inline void clear_hidenawards();
  static const int kHidenAwardsFieldNumber = 21;
  inline const ::com::cfg::vo::HidenAward& hidenawards(int index) const;
  inline ::com::cfg::vo::HidenAward* mutable_hidenawards(int index);
  inline ::com::cfg::vo::HidenAward* add_hidenawards();
  inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::HidenAward >&
      hidenawards() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::HidenAward >*
      mutable_hidenawards();

  // repeated uint32 StarCondition = 22;
  inline int starcondition_size() const;
  inline void clear_starcondition();
  static const int kStarConditionFieldNumber = 22;
  inline ::google::protobuf::uint32 starcondition(int index) const;
  inline void set_starcondition(int index, ::google::protobuf::uint32 value);
  inline void add_starcondition(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      starcondition() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_starcondition();

  // @@protoc_insertion_point(class_scope:com.cfg.vo.WarMapCfg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_bossid();
  inline void clear_has_bossid();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_wintype();
  inline void clear_has_wintype();
  inline void set_has_stagenum();
  inline void clear_has_stagenum();
  inline void set_has_warid();
  inline void clear_has_warid();
  inline void set_has_manual();
  inline void clear_has_manual();
  inline void set_has_repeatnum();
  inline void clear_has_repeatnum();
  inline void set_has_cardid();
  inline void clear_has_cardid();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_limittime();
  inline void clear_has_limittime();
  inline void set_has_simpleviewres();
  inline void clear_has_simpleviewres();
  inline void set_has_winvalue1();
  inline void clear_has_winvalue1();
  inline void set_has_winvalue2();
  inline void clear_has_winvalue2();

  ::std::string* name_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 mapid_;
  ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::MapItem > items_;
  ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::MapMonster > monsters_;
  ::google::protobuf::uint32 bossid_;
  ::google::protobuf::uint32 exp_;
  ::google::protobuf::uint32 coin_;
  ::google::protobuf::uint32 wintype_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > packageids_;
  ::google::protobuf::uint32 stagenum_;
  ::google::protobuf::uint32 warid_;
  ::google::protobuf::uint32 manual_;
  ::google::protobuf::uint32 repeatnum_;
  ::google::protobuf::uint32 cardid_;
  ::google::protobuf::uint32 level_;
  ::std::string* simpleviewres_;
  ::google::protobuf::uint32 limittime_;
  ::google::protobuf::uint32 winvalue1_;
  ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::HidenAward > hidenawards_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > starcondition_;
  ::google::protobuf::uint32 winvalue2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(22 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_WarMapCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_WarMapCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_WarMapCfg_2eproto();
  friend void protobuf_ShutdownFile_WarMapCfg_2eproto();

  void InitAsDefaultInstance();
  static WarMapCfg* default_instance_;
};
// -------------------------------------------------------------------

class WarMapCfgSet : public ::google::protobuf::MessageLite {
 public:
  WarMapCfgSet();
  virtual ~WarMapCfgSet();

  WarMapCfgSet(const WarMapCfgSet& from);

  inline WarMapCfgSet& operator=(const WarMapCfgSet& from) {
    CopyFrom(from);
    return *this;
  }

  static const WarMapCfgSet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WarMapCfgSet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WarMapCfgSet* other);

  // implements Message ----------------------------------------------

  WarMapCfgSet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WarMapCfgSet& from);
  void MergeFrom(const WarMapCfgSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.cfg.vo.WarMapCfg warMapCfg = 1;
  inline int warmapcfg_size() const;
  inline void clear_warmapcfg();
  static const int kWarMapCfgFieldNumber = 1;
  inline const ::com::cfg::vo::WarMapCfg& warmapcfg(int index) const;
  inline ::com::cfg::vo::WarMapCfg* mutable_warmapcfg(int index);
  inline ::com::cfg::vo::WarMapCfg* add_warmapcfg();
  inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::WarMapCfg >&
      warmapcfg() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::WarMapCfg >*
      mutable_warmapcfg();

  // @@protoc_insertion_point(class_scope:com.cfg.vo.WarMapCfgSet)
 private:

  ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::WarMapCfg > warmapcfg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_WarMapCfg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_WarMapCfg_2eproto();
  #endif
  friend void protobuf_AssignDesc_WarMapCfg_2eproto();
  friend void protobuf_ShutdownFile_WarMapCfg_2eproto();

  void InitAsDefaultInstance();
  static WarMapCfgSet* default_instance_;
};
// ===================================================================


// ===================================================================

// MapItem

// required uint32 ItemID = 1;
inline bool MapItem::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapItem::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapItem::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapItem::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 MapItem::itemid() const {
  return itemid_;
}
inline void MapItem::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
}

// required uint32 ItemNum = 2;
inline bool MapItem::has_itemnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapItem::set_has_itemnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapItem::clear_has_itemnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapItem::clear_itemnum() {
  itemnum_ = 0u;
  clear_has_itemnum();
}
inline ::google::protobuf::uint32 MapItem::itemnum() const {
  return itemnum_;
}
inline void MapItem::set_itemnum(::google::protobuf::uint32 value) {
  set_has_itemnum();
  itemnum_ = value;
}

// -------------------------------------------------------------------

// MapMonster

// required uint32 MonsterID = 1;
inline bool MapMonster::has_monsterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapMonster::set_has_monsterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapMonster::clear_has_monsterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapMonster::clear_monsterid() {
  monsterid_ = 0u;
  clear_has_monsterid();
}
inline ::google::protobuf::uint32 MapMonster::monsterid() const {
  return monsterid_;
}
inline void MapMonster::set_monsterid(::google::protobuf::uint32 value) {
  set_has_monsterid();
  monsterid_ = value;
}

// required uint32 MonsterNum = 2;
inline bool MapMonster::has_monsternum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapMonster::set_has_monsternum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapMonster::clear_has_monsternum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapMonster::clear_monsternum() {
  monsternum_ = 0u;
  clear_has_monsternum();
}
inline ::google::protobuf::uint32 MapMonster::monsternum() const {
  return monsternum_;
}
inline void MapMonster::set_monsternum(::google::protobuf::uint32 value) {
  set_has_monsternum();
  monsternum_ = value;
}

// -------------------------------------------------------------------

// HidenAward

// required uint32 WinType = 1;
inline bool HidenAward::has_wintype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HidenAward::set_has_wintype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HidenAward::clear_has_wintype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HidenAward::clear_wintype() {
  wintype_ = 0u;
  clear_has_wintype();
}
inline ::google::protobuf::uint32 HidenAward::wintype() const {
  return wintype_;
}
inline void HidenAward::set_wintype(::google::protobuf::uint32 value) {
  set_has_wintype();
  wintype_ = value;
}

// required uint32 WinCondition = 2;
inline bool HidenAward::has_wincondition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HidenAward::set_has_wincondition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HidenAward::clear_has_wincondition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HidenAward::clear_wincondition() {
  wincondition_ = 0u;
  clear_has_wincondition();
}
inline ::google::protobuf::uint32 HidenAward::wincondition() const {
  return wincondition_;
}
inline void HidenAward::set_wincondition(::google::protobuf::uint32 value) {
  set_has_wincondition();
  wincondition_ = value;
}

// required uint32 WinAwardID = 3;
inline bool HidenAward::has_winawardid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HidenAward::set_has_winawardid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HidenAward::clear_has_winawardid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HidenAward::clear_winawardid() {
  winawardid_ = 0u;
  clear_has_winawardid();
}
inline ::google::protobuf::uint32 HidenAward::winawardid() const {
  return winawardid_;
}
inline void HidenAward::set_winawardid(::google::protobuf::uint32 value) {
  set_has_winawardid();
  winawardid_ = value;
}

// -------------------------------------------------------------------

// WarMapCfg

// required uint32 ID = 1;
inline bool WarMapCfg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WarMapCfg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WarMapCfg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WarMapCfg::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 WarMapCfg::id() const {
  return id_;
}
inline void WarMapCfg::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required string Name = 2;
inline bool WarMapCfg::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WarMapCfg::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WarMapCfg::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WarMapCfg::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& WarMapCfg::name() const {
  return *name_;
}
inline void WarMapCfg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void WarMapCfg::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void WarMapCfg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WarMapCfg::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* WarMapCfg::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WarMapCfg::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 MapID = 3;
inline bool WarMapCfg::has_mapid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WarMapCfg::set_has_mapid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WarMapCfg::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WarMapCfg::clear_mapid() {
  mapid_ = 0u;
  clear_has_mapid();
}
inline ::google::protobuf::uint32 WarMapCfg::mapid() const {
  return mapid_;
}
inline void WarMapCfg::set_mapid(::google::protobuf::uint32 value) {
  set_has_mapid();
  mapid_ = value;
}

// repeated .com.cfg.vo.MapItem Items = 4;
inline int WarMapCfg::items_size() const {
  return items_.size();
}
inline void WarMapCfg::clear_items() {
  items_.Clear();
}
inline const ::com::cfg::vo::MapItem& WarMapCfg::items(int index) const {
  return items_.Get(index);
}
inline ::com::cfg::vo::MapItem* WarMapCfg::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::com::cfg::vo::MapItem* WarMapCfg::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::MapItem >&
WarMapCfg::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::MapItem >*
WarMapCfg::mutable_items() {
  return &items_;
}

// repeated .com.cfg.vo.MapMonster Monsters = 5;
inline int WarMapCfg::monsters_size() const {
  return monsters_.size();
}
inline void WarMapCfg::clear_monsters() {
  monsters_.Clear();
}
inline const ::com::cfg::vo::MapMonster& WarMapCfg::monsters(int index) const {
  return monsters_.Get(index);
}
inline ::com::cfg::vo::MapMonster* WarMapCfg::mutable_monsters(int index) {
  return monsters_.Mutable(index);
}
inline ::com::cfg::vo::MapMonster* WarMapCfg::add_monsters() {
  return monsters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::MapMonster >&
WarMapCfg::monsters() const {
  return monsters_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::MapMonster >*
WarMapCfg::mutable_monsters() {
  return &monsters_;
}

// required uint32 BossID = 6;
inline bool WarMapCfg::has_bossid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WarMapCfg::set_has_bossid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WarMapCfg::clear_has_bossid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WarMapCfg::clear_bossid() {
  bossid_ = 0u;
  clear_has_bossid();
}
inline ::google::protobuf::uint32 WarMapCfg::bossid() const {
  return bossid_;
}
inline void WarMapCfg::set_bossid(::google::protobuf::uint32 value) {
  set_has_bossid();
  bossid_ = value;
}

// required uint32 Exp = 7;
inline bool WarMapCfg::has_exp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WarMapCfg::set_has_exp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WarMapCfg::clear_has_exp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WarMapCfg::clear_exp() {
  exp_ = 0u;
  clear_has_exp();
}
inline ::google::protobuf::uint32 WarMapCfg::exp() const {
  return exp_;
}
inline void WarMapCfg::set_exp(::google::protobuf::uint32 value) {
  set_has_exp();
  exp_ = value;
}

// required uint32 Coin = 8;
inline bool WarMapCfg::has_coin() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void WarMapCfg::set_has_coin() {
  _has_bits_[0] |= 0x00000080u;
}
inline void WarMapCfg::clear_has_coin() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void WarMapCfg::clear_coin() {
  coin_ = 0u;
  clear_has_coin();
}
inline ::google::protobuf::uint32 WarMapCfg::coin() const {
  return coin_;
}
inline void WarMapCfg::set_coin(::google::protobuf::uint32 value) {
  set_has_coin();
  coin_ = value;
}

// required uint32 WinType = 9;
inline bool WarMapCfg::has_wintype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void WarMapCfg::set_has_wintype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void WarMapCfg::clear_has_wintype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void WarMapCfg::clear_wintype() {
  wintype_ = 0u;
  clear_has_wintype();
}
inline ::google::protobuf::uint32 WarMapCfg::wintype() const {
  return wintype_;
}
inline void WarMapCfg::set_wintype(::google::protobuf::uint32 value) {
  set_has_wintype();
  wintype_ = value;
}

// required uint32 StageNum = 10;
inline bool WarMapCfg::has_stagenum() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void WarMapCfg::set_has_stagenum() {
  _has_bits_[0] |= 0x00000200u;
}
inline void WarMapCfg::clear_has_stagenum() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void WarMapCfg::clear_stagenum() {
  stagenum_ = 0u;
  clear_has_stagenum();
}
inline ::google::protobuf::uint32 WarMapCfg::stagenum() const {
  return stagenum_;
}
inline void WarMapCfg::set_stagenum(::google::protobuf::uint32 value) {
  set_has_stagenum();
  stagenum_ = value;
}

// repeated uint32 PackageIDs = 11;
inline int WarMapCfg::packageids_size() const {
  return packageids_.size();
}
inline void WarMapCfg::clear_packageids() {
  packageids_.Clear();
}
inline ::google::protobuf::uint32 WarMapCfg::packageids(int index) const {
  return packageids_.Get(index);
}
inline void WarMapCfg::set_packageids(int index, ::google::protobuf::uint32 value) {
  packageids_.Set(index, value);
}
inline void WarMapCfg::add_packageids(::google::protobuf::uint32 value) {
  packageids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
WarMapCfg::packageids() const {
  return packageids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
WarMapCfg::mutable_packageids() {
  return &packageids_;
}

// required uint32 WarID = 12;
inline bool WarMapCfg::has_warid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void WarMapCfg::set_has_warid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void WarMapCfg::clear_has_warid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void WarMapCfg::clear_warid() {
  warid_ = 0u;
  clear_has_warid();
}
inline ::google::protobuf::uint32 WarMapCfg::warid() const {
  return warid_;
}
inline void WarMapCfg::set_warid(::google::protobuf::uint32 value) {
  set_has_warid();
  warid_ = value;
}

// required uint32 Manual = 13;
inline bool WarMapCfg::has_manual() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void WarMapCfg::set_has_manual() {
  _has_bits_[0] |= 0x00001000u;
}
inline void WarMapCfg::clear_has_manual() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void WarMapCfg::clear_manual() {
  manual_ = 0u;
  clear_has_manual();
}
inline ::google::protobuf::uint32 WarMapCfg::manual() const {
  return manual_;
}
inline void WarMapCfg::set_manual(::google::protobuf::uint32 value) {
  set_has_manual();
  manual_ = value;
}

// required uint32 RepeatNum = 14;
inline bool WarMapCfg::has_repeatnum() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void WarMapCfg::set_has_repeatnum() {
  _has_bits_[0] |= 0x00002000u;
}
inline void WarMapCfg::clear_has_repeatnum() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void WarMapCfg::clear_repeatnum() {
  repeatnum_ = 0u;
  clear_has_repeatnum();
}
inline ::google::protobuf::uint32 WarMapCfg::repeatnum() const {
  return repeatnum_;
}
inline void WarMapCfg::set_repeatnum(::google::protobuf::uint32 value) {
  set_has_repeatnum();
  repeatnum_ = value;
}

// required uint32 CardID = 15;
inline bool WarMapCfg::has_cardid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void WarMapCfg::set_has_cardid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void WarMapCfg::clear_has_cardid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void WarMapCfg::clear_cardid() {
  cardid_ = 0u;
  clear_has_cardid();
}
inline ::google::protobuf::uint32 WarMapCfg::cardid() const {
  return cardid_;
}
inline void WarMapCfg::set_cardid(::google::protobuf::uint32 value) {
  set_has_cardid();
  cardid_ = value;
}

// required uint32 Level = 16;
inline bool WarMapCfg::has_level() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void WarMapCfg::set_has_level() {
  _has_bits_[0] |= 0x00008000u;
}
inline void WarMapCfg::clear_has_level() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void WarMapCfg::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 WarMapCfg::level() const {
  return level_;
}
inline void WarMapCfg::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// required uint32 LimitTime = 17;
inline bool WarMapCfg::has_limittime() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void WarMapCfg::set_has_limittime() {
  _has_bits_[0] |= 0x00010000u;
}
inline void WarMapCfg::clear_has_limittime() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void WarMapCfg::clear_limittime() {
  limittime_ = 0u;
  clear_has_limittime();
}
inline ::google::protobuf::uint32 WarMapCfg::limittime() const {
  return limittime_;
}
inline void WarMapCfg::set_limittime(::google::protobuf::uint32 value) {
  set_has_limittime();
  limittime_ = value;
}

// required string SimpleViewRes = 18;
inline bool WarMapCfg::has_simpleviewres() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void WarMapCfg::set_has_simpleviewres() {
  _has_bits_[0] |= 0x00020000u;
}
inline void WarMapCfg::clear_has_simpleviewres() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void WarMapCfg::clear_simpleviewres() {
  if (simpleviewres_ != &::google::protobuf::internal::kEmptyString) {
    simpleviewres_->clear();
  }
  clear_has_simpleviewres();
}
inline const ::std::string& WarMapCfg::simpleviewres() const {
  return *simpleviewres_;
}
inline void WarMapCfg::set_simpleviewres(const ::std::string& value) {
  set_has_simpleviewres();
  if (simpleviewres_ == &::google::protobuf::internal::kEmptyString) {
    simpleviewres_ = new ::std::string;
  }
  simpleviewres_->assign(value);
}
inline void WarMapCfg::set_simpleviewres(const char* value) {
  set_has_simpleviewres();
  if (simpleviewres_ == &::google::protobuf::internal::kEmptyString) {
    simpleviewres_ = new ::std::string;
  }
  simpleviewres_->assign(value);
}
inline void WarMapCfg::set_simpleviewres(const char* value, size_t size) {
  set_has_simpleviewres();
  if (simpleviewres_ == &::google::protobuf::internal::kEmptyString) {
    simpleviewres_ = new ::std::string;
  }
  simpleviewres_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WarMapCfg::mutable_simpleviewres() {
  set_has_simpleviewres();
  if (simpleviewres_ == &::google::protobuf::internal::kEmptyString) {
    simpleviewres_ = new ::std::string;
  }
  return simpleviewres_;
}
inline ::std::string* WarMapCfg::release_simpleviewres() {
  clear_has_simpleviewres();
  if (simpleviewres_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = simpleviewres_;
    simpleviewres_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WarMapCfg::set_allocated_simpleviewres(::std::string* simpleviewres) {
  if (simpleviewres_ != &::google::protobuf::internal::kEmptyString) {
    delete simpleviewres_;
  }
  if (simpleviewres) {
    set_has_simpleviewres();
    simpleviewres_ = simpleviewres;
  } else {
    clear_has_simpleviewres();
    simpleviewres_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 WinValue1 = 19;
inline bool WarMapCfg::has_winvalue1() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void WarMapCfg::set_has_winvalue1() {
  _has_bits_[0] |= 0x00040000u;
}
inline void WarMapCfg::clear_has_winvalue1() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void WarMapCfg::clear_winvalue1() {
  winvalue1_ = 0u;
  clear_has_winvalue1();
}
inline ::google::protobuf::uint32 WarMapCfg::winvalue1() const {
  return winvalue1_;
}
inline void WarMapCfg::set_winvalue1(::google::protobuf::uint32 value) {
  set_has_winvalue1();
  winvalue1_ = value;
}

// required uint32 WinValue2 = 20;
inline bool WarMapCfg::has_winvalue2() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void WarMapCfg::set_has_winvalue2() {
  _has_bits_[0] |= 0x00080000u;
}
inline void WarMapCfg::clear_has_winvalue2() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void WarMapCfg::clear_winvalue2() {
  winvalue2_ = 0u;
  clear_has_winvalue2();
}
inline ::google::protobuf::uint32 WarMapCfg::winvalue2() const {
  return winvalue2_;
}
inline void WarMapCfg::set_winvalue2(::google::protobuf::uint32 value) {
  set_has_winvalue2();
  winvalue2_ = value;
}

// repeated .com.cfg.vo.HidenAward HidenAwards = 21;
inline int WarMapCfg::hidenawards_size() const {
  return hidenawards_.size();
}
inline void WarMapCfg::clear_hidenawards() {
  hidenawards_.Clear();
}
inline const ::com::cfg::vo::HidenAward& WarMapCfg::hidenawards(int index) const {
  return hidenawards_.Get(index);
}
inline ::com::cfg::vo::HidenAward* WarMapCfg::mutable_hidenawards(int index) {
  return hidenawards_.Mutable(index);
}
inline ::com::cfg::vo::HidenAward* WarMapCfg::add_hidenawards() {
  return hidenawards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::HidenAward >&
WarMapCfg::hidenawards() const {
  return hidenawards_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::HidenAward >*
WarMapCfg::mutable_hidenawards() {
  return &hidenawards_;
}

// repeated uint32 StarCondition = 22;
inline int WarMapCfg::starcondition_size() const {
  return starcondition_.size();
}
inline void WarMapCfg::clear_starcondition() {
  starcondition_.Clear();
}
inline ::google::protobuf::uint32 WarMapCfg::starcondition(int index) const {
  return starcondition_.Get(index);
}
inline void WarMapCfg::set_starcondition(int index, ::google::protobuf::uint32 value) {
  starcondition_.Set(index, value);
}
inline void WarMapCfg::add_starcondition(::google::protobuf::uint32 value) {
  starcondition_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
WarMapCfg::starcondition() const {
  return starcondition_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
WarMapCfg::mutable_starcondition() {
  return &starcondition_;
}

// -------------------------------------------------------------------

// WarMapCfgSet

// repeated .com.cfg.vo.WarMapCfg warMapCfg = 1;
inline int WarMapCfgSet::warmapcfg_size() const {
  return warmapcfg_.size();
}
inline void WarMapCfgSet::clear_warmapcfg() {
  warmapcfg_.Clear();
}
inline const ::com::cfg::vo::WarMapCfg& WarMapCfgSet::warmapcfg(int index) const {
  return warmapcfg_.Get(index);
}
inline ::com::cfg::vo::WarMapCfg* WarMapCfgSet::mutable_warmapcfg(int index) {
  return warmapcfg_.Mutable(index);
}
inline ::com::cfg::vo::WarMapCfg* WarMapCfgSet::add_warmapcfg() {
  return warmapcfg_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::WarMapCfg >&
WarMapCfgSet::warmapcfg() const {
  return warmapcfg_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::cfg::vo::WarMapCfg >*
WarMapCfgSet::mutable_warmapcfg() {
  return &warmapcfg_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vo
}  // namespace cfg
}  // namespace com

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_WarMapCfg_2eproto__INCLUDED
