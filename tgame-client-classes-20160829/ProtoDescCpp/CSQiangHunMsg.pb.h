// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSQiangHunMsg.proto

#ifndef PROTOBUF_CSQiangHunMsg_2eproto__INCLUDED
#define PROTOBUF_CSQiangHunMsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MsgBase.pb.h"
#include "ShareByClient.pb.h"
// @@protoc_insertion_point(includes)

namespace vmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CSQiangHunMsg_2eproto();
void protobuf_AssignDesc_CSQiangHunMsg_2eproto();
void protobuf_ShutdownFile_CSQiangHunMsg_2eproto();

class CSQiangHunElmt;
class CSQiangHunInfo;
class CSQiangHunLayerQueryRqst;
class CSQiangHunFlopRqst;
class CSQiangHunRequest;
class CSQiangHunRespond;

// ===================================================================

class CSQiangHunElmt : public ::google::protobuf::MessageLite {
 public:
  CSQiangHunElmt();
  virtual ~CSQiangHunElmt();

  CSQiangHunElmt(const CSQiangHunElmt& from);

  inline CSQiangHunElmt& operator=(const CSQiangHunElmt& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSQiangHunElmt& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQiangHunElmt* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQiangHunElmt* other);

  // implements Message ----------------------------------------------

  CSQiangHunElmt* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQiangHunElmt& from);
  void MergeFrom(const CSQiangHunElmt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 IsKey = 1;
  inline bool has_iskey() const;
  inline void clear_iskey();
  static const int kIsKeyFieldNumber = 1;
  inline ::google::protobuf::uint32 iskey() const;
  inline void set_iskey(::google::protobuf::uint32 value);

  // required uint32 Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 CfgID = 3;
  inline bool has_cfgid() const;
  inline void clear_cfgid();
  static const int kCfgIDFieldNumber = 3;
  inline ::google::protobuf::uint32 cfgid() const;
  inline void set_cfgid(::google::protobuf::uint32 value);

  // required uint32 Cnt = 4;
  inline bool has_cnt() const;
  inline void clear_cnt();
  static const int kCntFieldNumber = 4;
  inline ::google::protobuf::uint32 cnt() const;
  inline void set_cnt(::google::protobuf::uint32 value);

  // required uint32 Pos = 5;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 5;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSQiangHunElmt)
 private:
  inline void set_has_iskey();
  inline void clear_has_iskey();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_cfgid();
  inline void clear_has_cfgid();
  inline void set_has_cnt();
  inline void clear_has_cnt();
  inline void set_has_pos();
  inline void clear_has_pos();

  ::google::protobuf::uint32 iskey_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 cfgid_;
  ::google::protobuf::uint32 cnt_;
  ::google::protobuf::uint32 pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSQiangHunMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSQiangHunMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSQiangHunMsg_2eproto();
  friend void protobuf_ShutdownFile_CSQiangHunMsg_2eproto();

  void InitAsDefaultInstance();
  static CSQiangHunElmt* default_instance_;
};
// -------------------------------------------------------------------

class CSQiangHunInfo : public ::google::protobuf::MessageLite {
 public:
  CSQiangHunInfo();
  virtual ~CSQiangHunInfo();

  CSQiangHunInfo(const CSQiangHunInfo& from);

  inline CSQiangHunInfo& operator=(const CSQiangHunInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSQiangHunInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQiangHunInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQiangHunInfo* other);

  // implements Message ----------------------------------------------

  CSQiangHunInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQiangHunInfo& from);
  void MergeFrom(const CSQiangHunInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Layer = 1;
  inline bool has_layer() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 1;
  inline ::google::protobuf::uint32 layer() const;
  inline void set_layer(::google::protobuf::uint32 value);

  // required uint32 MaxLayer = 2;
  inline bool has_maxlayer() const;
  inline void clear_maxlayer();
  static const int kMaxLayerFieldNumber = 2;
  inline ::google::protobuf::uint32 maxlayer() const;
  inline void set_maxlayer(::google::protobuf::uint32 value);

  // repeated .vmsg.CSQiangHunElmt Elmts = 3;
  inline int elmts_size() const;
  inline void clear_elmts();
  static const int kElmtsFieldNumber = 3;
  inline const ::vmsg::CSQiangHunElmt& elmts(int index) const;
  inline ::vmsg::CSQiangHunElmt* mutable_elmts(int index);
  inline ::vmsg::CSQiangHunElmt* add_elmts();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSQiangHunElmt >&
      elmts() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSQiangHunElmt >*
      mutable_elmts();

  // required uint32 NextCost = 4;
  inline bool has_nextcost() const;
  inline void clear_nextcost();
  static const int kNextCostFieldNumber = 4;
  inline ::google::protobuf::uint32 nextcost() const;
  inline void set_nextcost(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSQiangHunInfo)
 private:
  inline void set_has_layer();
  inline void clear_has_layer();
  inline void set_has_maxlayer();
  inline void clear_has_maxlayer();
  inline void set_has_nextcost();
  inline void clear_has_nextcost();

  ::google::protobuf::uint32 layer_;
  ::google::protobuf::uint32 maxlayer_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSQiangHunElmt > elmts_;
  ::google::protobuf::uint32 nextcost_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSQiangHunMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSQiangHunMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSQiangHunMsg_2eproto();
  friend void protobuf_ShutdownFile_CSQiangHunMsg_2eproto();

  void InitAsDefaultInstance();
  static CSQiangHunInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSQiangHunLayerQueryRqst : public ::google::protobuf::MessageLite {
 public:
  CSQiangHunLayerQueryRqst();
  virtual ~CSQiangHunLayerQueryRqst();

  CSQiangHunLayerQueryRqst(const CSQiangHunLayerQueryRqst& from);

  inline CSQiangHunLayerQueryRqst& operator=(const CSQiangHunLayerQueryRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSQiangHunLayerQueryRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQiangHunLayerQueryRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQiangHunLayerQueryRqst* other);

  // implements Message ----------------------------------------------

  CSQiangHunLayerQueryRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQiangHunLayerQueryRqst& from);
  void MergeFrom(const CSQiangHunLayerQueryRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Layer = 1;
  inline bool has_layer() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 1;
  inline ::google::protobuf::uint32 layer() const;
  inline void set_layer(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSQiangHunLayerQueryRqst)
 private:
  inline void set_has_layer();
  inline void clear_has_layer();

  ::google::protobuf::uint32 layer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSQiangHunMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSQiangHunMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSQiangHunMsg_2eproto();
  friend void protobuf_ShutdownFile_CSQiangHunMsg_2eproto();

  void InitAsDefaultInstance();
  static CSQiangHunLayerQueryRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSQiangHunFlopRqst : public ::google::protobuf::MessageLite {
 public:
  CSQiangHunFlopRqst();
  virtual ~CSQiangHunFlopRqst();

  CSQiangHunFlopRqst(const CSQiangHunFlopRqst& from);

  inline CSQiangHunFlopRqst& operator=(const CSQiangHunFlopRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSQiangHunFlopRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQiangHunFlopRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQiangHunFlopRqst* other);

  // implements Message ----------------------------------------------

  CSQiangHunFlopRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQiangHunFlopRqst& from);
  void MergeFrom(const CSQiangHunFlopRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline ::google::protobuf::uint32 pos() const;
  inline void set_pos(::google::protobuf::uint32 value);

  // required uint32 Layer = 2;
  inline bool has_layer() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 2;
  inline ::google::protobuf::uint32 layer() const;
  inline void set_layer(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSQiangHunFlopRqst)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_layer();
  inline void clear_has_layer();

  ::google::protobuf::uint32 pos_;
  ::google::protobuf::uint32 layer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSQiangHunMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSQiangHunMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSQiangHunMsg_2eproto();
  friend void protobuf_ShutdownFile_CSQiangHunMsg_2eproto();

  void InitAsDefaultInstance();
  static CSQiangHunFlopRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSQiangHunRequest : public ::google::protobuf::MessageLite {
 public:
  CSQiangHunRequest();
  virtual ~CSQiangHunRequest();

  CSQiangHunRequest(const CSQiangHunRequest& from);

  inline CSQiangHunRequest& operator=(const CSQiangHunRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSQiangHunRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQiangHunRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQiangHunRequest* other);

  // implements Message ----------------------------------------------

  CSQiangHunRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQiangHunRequest& from);
  void MergeFrom(const CSQiangHunRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSQiangHunLayerQueryRqst QueryLayer_Rqst = 1;
  inline bool has_querylayer_rqst() const;
  inline void clear_querylayer_rqst();
  static const int kQueryLayerRqstFieldNumber = 1;
  inline const ::vmsg::CSQiangHunLayerQueryRqst& querylayer_rqst() const;
  inline ::vmsg::CSQiangHunLayerQueryRqst* mutable_querylayer_rqst();
  inline ::vmsg::CSQiangHunLayerQueryRqst* release_querylayer_rqst();
  inline void set_allocated_querylayer_rqst(::vmsg::CSQiangHunLayerQueryRqst* querylayer_rqst);

  // optional .vmsg.CSQiangHunFlopRqst Flop_Rqst = 2;
  inline bool has_flop_rqst() const;
  inline void clear_flop_rqst();
  static const int kFlopRqstFieldNumber = 2;
  inline const ::vmsg::CSQiangHunFlopRqst& flop_rqst() const;
  inline ::vmsg::CSQiangHunFlopRqst* mutable_flop_rqst();
  inline ::vmsg::CSQiangHunFlopRqst* release_flop_rqst();
  inline void set_allocated_flop_rqst(::vmsg::CSQiangHunFlopRqst* flop_rqst);

  // @@protoc_insertion_point(class_scope:vmsg.CSQiangHunRequest)
 private:
  inline void set_has_querylayer_rqst();
  inline void clear_has_querylayer_rqst();
  inline void set_has_flop_rqst();
  inline void clear_has_flop_rqst();

  ::vmsg::CSQiangHunLayerQueryRqst* querylayer_rqst_;
  ::vmsg::CSQiangHunFlopRqst* flop_rqst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSQiangHunMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSQiangHunMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSQiangHunMsg_2eproto();
  friend void protobuf_ShutdownFile_CSQiangHunMsg_2eproto();

  void InitAsDefaultInstance();
  static CSQiangHunRequest* default_instance_;
};
// -------------------------------------------------------------------

class CSQiangHunRespond : public ::google::protobuf::MessageLite {
 public:
  CSQiangHunRespond();
  virtual ~CSQiangHunRespond();

  CSQiangHunRespond(const CSQiangHunRespond& from);

  inline CSQiangHunRespond& operator=(const CSQiangHunRespond& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSQiangHunRespond& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQiangHunRespond* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQiangHunRespond* other);

  // implements Message ----------------------------------------------

  CSQiangHunRespond* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQiangHunRespond& from);
  void MergeFrom(const CSQiangHunRespond& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSQiangHunInfo QueryQiangHun_Rsp = 1;
  inline bool has_queryqianghun_rsp() const;
  inline void clear_queryqianghun_rsp();
  static const int kQueryQiangHunRspFieldNumber = 1;
  inline const ::vmsg::CSQiangHunInfo& queryqianghun_rsp() const;
  inline ::vmsg::CSQiangHunInfo* mutable_queryqianghun_rsp();
  inline ::vmsg::CSQiangHunInfo* release_queryqianghun_rsp();
  inline void set_allocated_queryqianghun_rsp(::vmsg::CSQiangHunInfo* queryqianghun_rsp);

  // optional .vmsg.CSQiangHunInfo QueryLayer_Rsp = 2;
  inline bool has_querylayer_rsp() const;
  inline void clear_querylayer_rsp();
  static const int kQueryLayerRspFieldNumber = 2;
  inline const ::vmsg::CSQiangHunInfo& querylayer_rsp() const;
  inline ::vmsg::CSQiangHunInfo* mutable_querylayer_rsp();
  inline ::vmsg::CSQiangHunInfo* release_querylayer_rsp();
  inline void set_allocated_querylayer_rsp(::vmsg::CSQiangHunInfo* querylayer_rsp);

  // optional .vmsg.CSQiangHunInfo Flop_Rsp = 3;
  inline bool has_flop_rsp() const;
  inline void clear_flop_rsp();
  static const int kFlopRspFieldNumber = 3;
  inline const ::vmsg::CSQiangHunInfo& flop_rsp() const;
  inline ::vmsg::CSQiangHunInfo* mutable_flop_rsp();
  inline ::vmsg::CSQiangHunInfo* release_flop_rsp();
  inline void set_allocated_flop_rsp(::vmsg::CSQiangHunInfo* flop_rsp);

  // @@protoc_insertion_point(class_scope:vmsg.CSQiangHunRespond)
 private:
  inline void set_has_queryqianghun_rsp();
  inline void clear_has_queryqianghun_rsp();
  inline void set_has_querylayer_rsp();
  inline void clear_has_querylayer_rsp();
  inline void set_has_flop_rsp();
  inline void clear_has_flop_rsp();

  ::vmsg::CSQiangHunInfo* queryqianghun_rsp_;
  ::vmsg::CSQiangHunInfo* querylayer_rsp_;
  ::vmsg::CSQiangHunInfo* flop_rsp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSQiangHunMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSQiangHunMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSQiangHunMsg_2eproto();
  friend void protobuf_ShutdownFile_CSQiangHunMsg_2eproto();

  void InitAsDefaultInstance();
  static CSQiangHunRespond* default_instance_;
};
// ===================================================================


// ===================================================================

// CSQiangHunElmt

// required uint32 IsKey = 1;
inline bool CSQiangHunElmt::has_iskey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSQiangHunElmt::set_has_iskey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSQiangHunElmt::clear_has_iskey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSQiangHunElmt::clear_iskey() {
  iskey_ = 0u;
  clear_has_iskey();
}
inline ::google::protobuf::uint32 CSQiangHunElmt::iskey() const {
  return iskey_;
}
inline void CSQiangHunElmt::set_iskey(::google::protobuf::uint32 value) {
  set_has_iskey();
  iskey_ = value;
}

// required uint32 Type = 2;
inline bool CSQiangHunElmt::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSQiangHunElmt::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSQiangHunElmt::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSQiangHunElmt::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSQiangHunElmt::type() const {
  return type_;
}
inline void CSQiangHunElmt::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required uint32 CfgID = 3;
inline bool CSQiangHunElmt::has_cfgid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSQiangHunElmt::set_has_cfgid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSQiangHunElmt::clear_has_cfgid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSQiangHunElmt::clear_cfgid() {
  cfgid_ = 0u;
  clear_has_cfgid();
}
inline ::google::protobuf::uint32 CSQiangHunElmt::cfgid() const {
  return cfgid_;
}
inline void CSQiangHunElmt::set_cfgid(::google::protobuf::uint32 value) {
  set_has_cfgid();
  cfgid_ = value;
}

// required uint32 Cnt = 4;
inline bool CSQiangHunElmt::has_cnt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSQiangHunElmt::set_has_cnt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSQiangHunElmt::clear_has_cnt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSQiangHunElmt::clear_cnt() {
  cnt_ = 0u;
  clear_has_cnt();
}
inline ::google::protobuf::uint32 CSQiangHunElmt::cnt() const {
  return cnt_;
}
inline void CSQiangHunElmt::set_cnt(::google::protobuf::uint32 value) {
  set_has_cnt();
  cnt_ = value;
}

// required uint32 Pos = 5;
inline bool CSQiangHunElmt::has_pos() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSQiangHunElmt::set_has_pos() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSQiangHunElmt::clear_has_pos() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSQiangHunElmt::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 CSQiangHunElmt::pos() const {
  return pos_;
}
inline void CSQiangHunElmt::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// -------------------------------------------------------------------

// CSQiangHunInfo

// required uint32 Layer = 1;
inline bool CSQiangHunInfo::has_layer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSQiangHunInfo::set_has_layer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSQiangHunInfo::clear_has_layer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSQiangHunInfo::clear_layer() {
  layer_ = 0u;
  clear_has_layer();
}
inline ::google::protobuf::uint32 CSQiangHunInfo::layer() const {
  return layer_;
}
inline void CSQiangHunInfo::set_layer(::google::protobuf::uint32 value) {
  set_has_layer();
  layer_ = value;
}

// required uint32 MaxLayer = 2;
inline bool CSQiangHunInfo::has_maxlayer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSQiangHunInfo::set_has_maxlayer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSQiangHunInfo::clear_has_maxlayer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSQiangHunInfo::clear_maxlayer() {
  maxlayer_ = 0u;
  clear_has_maxlayer();
}
inline ::google::protobuf::uint32 CSQiangHunInfo::maxlayer() const {
  return maxlayer_;
}
inline void CSQiangHunInfo::set_maxlayer(::google::protobuf::uint32 value) {
  set_has_maxlayer();
  maxlayer_ = value;
}

// repeated .vmsg.CSQiangHunElmt Elmts = 3;
inline int CSQiangHunInfo::elmts_size() const {
  return elmts_.size();
}
inline void CSQiangHunInfo::clear_elmts() {
  elmts_.Clear();
}
inline const ::vmsg::CSQiangHunElmt& CSQiangHunInfo::elmts(int index) const {
  return elmts_.Get(index);
}
inline ::vmsg::CSQiangHunElmt* CSQiangHunInfo::mutable_elmts(int index) {
  return elmts_.Mutable(index);
}
inline ::vmsg::CSQiangHunElmt* CSQiangHunInfo::add_elmts() {
  return elmts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSQiangHunElmt >&
CSQiangHunInfo::elmts() const {
  return elmts_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSQiangHunElmt >*
CSQiangHunInfo::mutable_elmts() {
  return &elmts_;
}

// required uint32 NextCost = 4;
inline bool CSQiangHunInfo::has_nextcost() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSQiangHunInfo::set_has_nextcost() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSQiangHunInfo::clear_has_nextcost() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSQiangHunInfo::clear_nextcost() {
  nextcost_ = 0u;
  clear_has_nextcost();
}
inline ::google::protobuf::uint32 CSQiangHunInfo::nextcost() const {
  return nextcost_;
}
inline void CSQiangHunInfo::set_nextcost(::google::protobuf::uint32 value) {
  set_has_nextcost();
  nextcost_ = value;
}

// -------------------------------------------------------------------

// CSQiangHunLayerQueryRqst

// required uint32 Layer = 1;
inline bool CSQiangHunLayerQueryRqst::has_layer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSQiangHunLayerQueryRqst::set_has_layer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSQiangHunLayerQueryRqst::clear_has_layer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSQiangHunLayerQueryRqst::clear_layer() {
  layer_ = 0u;
  clear_has_layer();
}
inline ::google::protobuf::uint32 CSQiangHunLayerQueryRqst::layer() const {
  return layer_;
}
inline void CSQiangHunLayerQueryRqst::set_layer(::google::protobuf::uint32 value) {
  set_has_layer();
  layer_ = value;
}

// -------------------------------------------------------------------

// CSQiangHunFlopRqst

// required uint32 Pos = 1;
inline bool CSQiangHunFlopRqst::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSQiangHunFlopRqst::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSQiangHunFlopRqst::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSQiangHunFlopRqst::clear_pos() {
  pos_ = 0u;
  clear_has_pos();
}
inline ::google::protobuf::uint32 CSQiangHunFlopRqst::pos() const {
  return pos_;
}
inline void CSQiangHunFlopRqst::set_pos(::google::protobuf::uint32 value) {
  set_has_pos();
  pos_ = value;
}

// required uint32 Layer = 2;
inline bool CSQiangHunFlopRqst::has_layer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSQiangHunFlopRqst::set_has_layer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSQiangHunFlopRqst::clear_has_layer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSQiangHunFlopRqst::clear_layer() {
  layer_ = 0u;
  clear_has_layer();
}
inline ::google::protobuf::uint32 CSQiangHunFlopRqst::layer() const {
  return layer_;
}
inline void CSQiangHunFlopRqst::set_layer(::google::protobuf::uint32 value) {
  set_has_layer();
  layer_ = value;
}

// -------------------------------------------------------------------

// CSQiangHunRequest

// optional .vmsg.CSQiangHunLayerQueryRqst QueryLayer_Rqst = 1;
inline bool CSQiangHunRequest::has_querylayer_rqst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSQiangHunRequest::set_has_querylayer_rqst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSQiangHunRequest::clear_has_querylayer_rqst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSQiangHunRequest::clear_querylayer_rqst() {
  if (querylayer_rqst_ != NULL) querylayer_rqst_->::vmsg::CSQiangHunLayerQueryRqst::Clear();
  clear_has_querylayer_rqst();
}
inline const ::vmsg::CSQiangHunLayerQueryRqst& CSQiangHunRequest::querylayer_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return querylayer_rqst_ != NULL ? *querylayer_rqst_ : *default_instance().querylayer_rqst_;
#else
  return querylayer_rqst_ != NULL ? *querylayer_rqst_ : *default_instance_->querylayer_rqst_;
#endif
}
inline ::vmsg::CSQiangHunLayerQueryRqst* CSQiangHunRequest::mutable_querylayer_rqst() {
  set_has_querylayer_rqst();
  if (querylayer_rqst_ == NULL) querylayer_rqst_ = new ::vmsg::CSQiangHunLayerQueryRqst;
  return querylayer_rqst_;
}
inline ::vmsg::CSQiangHunLayerQueryRqst* CSQiangHunRequest::release_querylayer_rqst() {
  clear_has_querylayer_rqst();
  ::vmsg::CSQiangHunLayerQueryRqst* temp = querylayer_rqst_;
  querylayer_rqst_ = NULL;
  return temp;
}
inline void CSQiangHunRequest::set_allocated_querylayer_rqst(::vmsg::CSQiangHunLayerQueryRqst* querylayer_rqst) {
  delete querylayer_rqst_;
  querylayer_rqst_ = querylayer_rqst;
  if (querylayer_rqst) {
    set_has_querylayer_rqst();
  } else {
    clear_has_querylayer_rqst();
  }
}

// optional .vmsg.CSQiangHunFlopRqst Flop_Rqst = 2;
inline bool CSQiangHunRequest::has_flop_rqst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSQiangHunRequest::set_has_flop_rqst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSQiangHunRequest::clear_has_flop_rqst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSQiangHunRequest::clear_flop_rqst() {
  if (flop_rqst_ != NULL) flop_rqst_->::vmsg::CSQiangHunFlopRqst::Clear();
  clear_has_flop_rqst();
}
inline const ::vmsg::CSQiangHunFlopRqst& CSQiangHunRequest::flop_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return flop_rqst_ != NULL ? *flop_rqst_ : *default_instance().flop_rqst_;
#else
  return flop_rqst_ != NULL ? *flop_rqst_ : *default_instance_->flop_rqst_;
#endif
}
inline ::vmsg::CSQiangHunFlopRqst* CSQiangHunRequest::mutable_flop_rqst() {
  set_has_flop_rqst();
  if (flop_rqst_ == NULL) flop_rqst_ = new ::vmsg::CSQiangHunFlopRqst;
  return flop_rqst_;
}
inline ::vmsg::CSQiangHunFlopRqst* CSQiangHunRequest::release_flop_rqst() {
  clear_has_flop_rqst();
  ::vmsg::CSQiangHunFlopRqst* temp = flop_rqst_;
  flop_rqst_ = NULL;
  return temp;
}
inline void CSQiangHunRequest::set_allocated_flop_rqst(::vmsg::CSQiangHunFlopRqst* flop_rqst) {
  delete flop_rqst_;
  flop_rqst_ = flop_rqst;
  if (flop_rqst) {
    set_has_flop_rqst();
  } else {
    clear_has_flop_rqst();
  }
}

// -------------------------------------------------------------------

// CSQiangHunRespond

// optional .vmsg.CSQiangHunInfo QueryQiangHun_Rsp = 1;
inline bool CSQiangHunRespond::has_queryqianghun_rsp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSQiangHunRespond::set_has_queryqianghun_rsp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSQiangHunRespond::clear_has_queryqianghun_rsp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSQiangHunRespond::clear_queryqianghun_rsp() {
  if (queryqianghun_rsp_ != NULL) queryqianghun_rsp_->::vmsg::CSQiangHunInfo::Clear();
  clear_has_queryqianghun_rsp();
}
inline const ::vmsg::CSQiangHunInfo& CSQiangHunRespond::queryqianghun_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return queryqianghun_rsp_ != NULL ? *queryqianghun_rsp_ : *default_instance().queryqianghun_rsp_;
#else
  return queryqianghun_rsp_ != NULL ? *queryqianghun_rsp_ : *default_instance_->queryqianghun_rsp_;
#endif
}
inline ::vmsg::CSQiangHunInfo* CSQiangHunRespond::mutable_queryqianghun_rsp() {
  set_has_queryqianghun_rsp();
  if (queryqianghun_rsp_ == NULL) queryqianghun_rsp_ = new ::vmsg::CSQiangHunInfo;
  return queryqianghun_rsp_;
}
inline ::vmsg::CSQiangHunInfo* CSQiangHunRespond::release_queryqianghun_rsp() {
  clear_has_queryqianghun_rsp();
  ::vmsg::CSQiangHunInfo* temp = queryqianghun_rsp_;
  queryqianghun_rsp_ = NULL;
  return temp;
}
inline void CSQiangHunRespond::set_allocated_queryqianghun_rsp(::vmsg::CSQiangHunInfo* queryqianghun_rsp) {
  delete queryqianghun_rsp_;
  queryqianghun_rsp_ = queryqianghun_rsp;
  if (queryqianghun_rsp) {
    set_has_queryqianghun_rsp();
  } else {
    clear_has_queryqianghun_rsp();
  }
}

// optional .vmsg.CSQiangHunInfo QueryLayer_Rsp = 2;
inline bool CSQiangHunRespond::has_querylayer_rsp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSQiangHunRespond::set_has_querylayer_rsp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSQiangHunRespond::clear_has_querylayer_rsp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSQiangHunRespond::clear_querylayer_rsp() {
  if (querylayer_rsp_ != NULL) querylayer_rsp_->::vmsg::CSQiangHunInfo::Clear();
  clear_has_querylayer_rsp();
}
inline const ::vmsg::CSQiangHunInfo& CSQiangHunRespond::querylayer_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return querylayer_rsp_ != NULL ? *querylayer_rsp_ : *default_instance().querylayer_rsp_;
#else
  return querylayer_rsp_ != NULL ? *querylayer_rsp_ : *default_instance_->querylayer_rsp_;
#endif
}
inline ::vmsg::CSQiangHunInfo* CSQiangHunRespond::mutable_querylayer_rsp() {
  set_has_querylayer_rsp();
  if (querylayer_rsp_ == NULL) querylayer_rsp_ = new ::vmsg::CSQiangHunInfo;
  return querylayer_rsp_;
}
inline ::vmsg::CSQiangHunInfo* CSQiangHunRespond::release_querylayer_rsp() {
  clear_has_querylayer_rsp();
  ::vmsg::CSQiangHunInfo* temp = querylayer_rsp_;
  querylayer_rsp_ = NULL;
  return temp;
}
inline void CSQiangHunRespond::set_allocated_querylayer_rsp(::vmsg::CSQiangHunInfo* querylayer_rsp) {
  delete querylayer_rsp_;
  querylayer_rsp_ = querylayer_rsp;
  if (querylayer_rsp) {
    set_has_querylayer_rsp();
  } else {
    clear_has_querylayer_rsp();
  }
}

// optional .vmsg.CSQiangHunInfo Flop_Rsp = 3;
inline bool CSQiangHunRespond::has_flop_rsp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSQiangHunRespond::set_has_flop_rsp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSQiangHunRespond::clear_has_flop_rsp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSQiangHunRespond::clear_flop_rsp() {
  if (flop_rsp_ != NULL) flop_rsp_->::vmsg::CSQiangHunInfo::Clear();
  clear_has_flop_rsp();
}
inline const ::vmsg::CSQiangHunInfo& CSQiangHunRespond::flop_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return flop_rsp_ != NULL ? *flop_rsp_ : *default_instance().flop_rsp_;
#else
  return flop_rsp_ != NULL ? *flop_rsp_ : *default_instance_->flop_rsp_;
#endif
}
inline ::vmsg::CSQiangHunInfo* CSQiangHunRespond::mutable_flop_rsp() {
  set_has_flop_rsp();
  if (flop_rsp_ == NULL) flop_rsp_ = new ::vmsg::CSQiangHunInfo;
  return flop_rsp_;
}
inline ::vmsg::CSQiangHunInfo* CSQiangHunRespond::release_flop_rsp() {
  clear_has_flop_rsp();
  ::vmsg::CSQiangHunInfo* temp = flop_rsp_;
  flop_rsp_ = NULL;
  return temp;
}
inline void CSQiangHunRespond::set_allocated_flop_rsp(::vmsg::CSQiangHunInfo* flop_rsp) {
  delete flop_rsp_;
  flop_rsp_ = flop_rsp;
  if (flop_rsp) {
    set_has_flop_rsp();
  } else {
    clear_has_flop_rsp();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CSQiangHunMsg_2eproto__INCLUDED
