// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSWarMapMsg.proto

#ifndef PROTOBUF_CSWarMapMsg_2eproto__INCLUDED
#define PROTOBUF_CSWarMapMsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MsgBase.pb.h"
#include "CSEquipItemMsg.pb.h"
#include "CSBagMsg.pb.h"
// @@protoc_insertion_point(includes)

namespace vmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CSWarMapMsg_2eproto();
void protobuf_AssignDesc_CSWarMapMsg_2eproto();
void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

class CSWarMapQueryRqst;
class CSWarMapHidenAwardElmt;
class CSStarAwardElmt;
class CSWarStarAward;
class CSWarMapInfo;
class CSWarMapQueryRsp;
class CSWarMapStartRqst;
class CSWarMapDropInfo;
class CSWarMapStartRsp;
class CSKillMonsterInfo;
class CSWarMapEndRqst;
class CSWarMapEndRsp;
class CSWarMapCardRqst;
class CSWarMapCardRsp;
class CSSweepWarRqst;
class CSSweepAward;
class CSSweepWarRsp;
class CSQueryEliteWarMapRqst;
class CSEliteWarInfo;
class CSResetEliteWarMapRqst;
class CSStartEliteWarMapRqst;
class CSStartEliteWarMapRsp;
class CSEndEliteWarMapRqst;
class CSEliteAward;
class CSEndEliteWarMapRsp;
class CSSweepEliteWarRqst;
class CSSweepEliteWarRsp;
class CSDailyInstanceElmt;
class CSQueryDailyInstanceRsp;
class CSDailyInstancePassRqst;
class CSDailyInstancePassRsp;
class CSReliveRqst;
class CSReliveRsp;
class CSBuyBulletRqst;
class CSBuyBulletRsp;
class CSBuyInstanceRqst;
class CSBuyInstanceRsp;
class CSWarmapStarAwardRqst;
class CSWarmapStarAwardRsp;
class CSWarMapRequest;
class CSWarMapRespond;

// ===================================================================

class CSWarMapQueryRqst : public ::google::protobuf::MessageLite {
 public:
  CSWarMapQueryRqst();
  virtual ~CSWarMapQueryRqst();

  CSWarMapQueryRqst(const CSWarMapQueryRqst& from);

  inline CSWarMapQueryRqst& operator=(const CSWarMapQueryRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWarMapQueryRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWarMapQueryRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWarMapQueryRqst* other);

  // implements Message ----------------------------------------------

  CSWarMapQueryRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWarMapQueryRqst& from);
  void MergeFrom(const CSWarMapQueryRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 FromId = 1;
  inline bool has_fromid() const;
  inline void clear_fromid();
  static const int kFromIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fromid() const;
  inline void set_fromid(::google::protobuf::uint32 value);

  // required uint32 ToId = 2;
  inline bool has_toid() const;
  inline void clear_toid();
  static const int kToIdFieldNumber = 2;
  inline ::google::protobuf::uint32 toid() const;
  inline void set_toid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSWarMapQueryRqst)
 private:
  inline void set_has_fromid();
  inline void clear_has_fromid();
  inline void set_has_toid();
  inline void clear_has_toid();

  ::google::protobuf::uint32 fromid_;
  ::google::protobuf::uint32 toid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWarMapQueryRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSWarMapHidenAwardElmt : public ::google::protobuf::MessageLite {
 public:
  CSWarMapHidenAwardElmt();
  virtual ~CSWarMapHidenAwardElmt();

  CSWarMapHidenAwardElmt(const CSWarMapHidenAwardElmt& from);

  inline CSWarMapHidenAwardElmt& operator=(const CSWarMapHidenAwardElmt& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWarMapHidenAwardElmt& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWarMapHidenAwardElmt* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWarMapHidenAwardElmt* other);

  // implements Message ----------------------------------------------

  CSWarMapHidenAwardElmt* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWarMapHidenAwardElmt& from);
  void MergeFrom(const CSWarMapHidenAwardElmt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 PackageID = 1;
  inline bool has_packageid() const;
  inline void clear_packageid();
  static const int kPackageIDFieldNumber = 1;
  inline ::google::protobuf::uint32 packageid() const;
  inline void set_packageid(::google::protobuf::uint32 value);

  // required uint32 PacakceStatus = 2;
  inline bool has_pacakcestatus() const;
  inline void clear_pacakcestatus();
  static const int kPacakceStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 pacakcestatus() const;
  inline void set_pacakcestatus(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSWarMapHidenAwardElmt)
 private:
  inline void set_has_packageid();
  inline void clear_has_packageid();
  inline void set_has_pacakcestatus();
  inline void clear_has_pacakcestatus();

  ::google::protobuf::uint32 packageid_;
  ::google::protobuf::uint32 pacakcestatus_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWarMapHidenAwardElmt* default_instance_;
};
// -------------------------------------------------------------------

class CSStarAwardElmt : public ::google::protobuf::MessageLite {
 public:
  CSStarAwardElmt();
  virtual ~CSStarAwardElmt();

  CSStarAwardElmt(const CSStarAwardElmt& from);

  inline CSStarAwardElmt& operator=(const CSStarAwardElmt& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSStarAwardElmt& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSStarAwardElmt* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSStarAwardElmt* other);

  // implements Message ----------------------------------------------

  CSStarAwardElmt* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSStarAwardElmt& from);
  void MergeFrom(const CSStarAwardElmt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 StarCnt = 1;
  inline bool has_starcnt() const;
  inline void clear_starcnt();
  static const int kStarCntFieldNumber = 1;
  inline ::google::protobuf::uint32 starcnt() const;
  inline void set_starcnt(::google::protobuf::uint32 value);

  // required uint32 StarAward = 2;
  inline bool has_staraward() const;
  inline void clear_staraward();
  static const int kStarAwardFieldNumber = 2;
  inline ::google::protobuf::uint32 staraward() const;
  inline void set_staraward(::google::protobuf::uint32 value);

  // required uint32 ClaimStatus = 3;
  inline bool has_claimstatus() const;
  inline void clear_claimstatus();
  static const int kClaimStatusFieldNumber = 3;
  inline ::google::protobuf::uint32 claimstatus() const;
  inline void set_claimstatus(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSStarAwardElmt)
 private:
  inline void set_has_starcnt();
  inline void clear_has_starcnt();
  inline void set_has_staraward();
  inline void clear_has_staraward();
  inline void set_has_claimstatus();
  inline void clear_has_claimstatus();

  ::google::protobuf::uint32 starcnt_;
  ::google::protobuf::uint32 staraward_;
  ::google::protobuf::uint32 claimstatus_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSStarAwardElmt* default_instance_;
};
// -------------------------------------------------------------------

class CSWarStarAward : public ::google::protobuf::MessageLite {
 public:
  CSWarStarAward();
  virtual ~CSWarStarAward();

  CSWarStarAward(const CSWarStarAward& from);

  inline CSWarStarAward& operator=(const CSWarStarAward& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWarStarAward& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWarStarAward* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWarStarAward* other);

  // implements Message ----------------------------------------------

  CSWarStarAward* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWarStarAward& from);
  void MergeFrom(const CSWarStarAward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSStarAwardElmt StarAwards = 1;
  inline int starawards_size() const;
  inline void clear_starawards();
  static const int kStarAwardsFieldNumber = 1;
  inline const ::vmsg::CSStarAwardElmt& starawards(int index) const;
  inline ::vmsg::CSStarAwardElmt* mutable_starawards(int index);
  inline ::vmsg::CSStarAwardElmt* add_starawards();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSStarAwardElmt >&
      starawards() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSStarAwardElmt >*
      mutable_starawards();

  // required uint32 TotalStarCnt = 2;
  inline bool has_totalstarcnt() const;
  inline void clear_totalstarcnt();
  static const int kTotalStarCntFieldNumber = 2;
  inline ::google::protobuf::uint32 totalstarcnt() const;
  inline void set_totalstarcnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSWarStarAward)
 private:
  inline void set_has_totalstarcnt();
  inline void clear_has_totalstarcnt();

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSStarAwardElmt > starawards_;
  ::google::protobuf::uint32 totalstarcnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWarStarAward* default_instance_;
};
// -------------------------------------------------------------------

class CSWarMapInfo : public ::google::protobuf::MessageLite {
 public:
  CSWarMapInfo();
  virtual ~CSWarMapInfo();

  CSWarMapInfo(const CSWarMapInfo& from);

  inline CSWarMapInfo& operator=(const CSWarMapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWarMapInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWarMapInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWarMapInfo* other);

  // implements Message ----------------------------------------------

  CSWarMapInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWarMapInfo& from);
  void MergeFrom(const CSWarMapInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Score = 1;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 1;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // required uint32 FightCnt = 2;
  inline bool has_fightcnt() const;
  inline void clear_fightcnt();
  static const int kFightCntFieldNumber = 2;
  inline ::google::protobuf::uint32 fightcnt() const;
  inline void set_fightcnt(::google::protobuf::uint32 value);

  // required uint32 BoughtCnt = 3;
  inline bool has_boughtcnt() const;
  inline void clear_boughtcnt();
  static const int kBoughtCntFieldNumber = 3;
  inline ::google::protobuf::uint32 boughtcnt() const;
  inline void set_boughtcnt(::google::protobuf::uint32 value);

  // required uint32 TotalCnt = 4;
  inline bool has_totalcnt() const;
  inline void clear_totalcnt();
  static const int kTotalCntFieldNumber = 4;
  inline ::google::protobuf::uint32 totalcnt() const;
  inline void set_totalcnt(::google::protobuf::uint32 value);

  // repeated .vmsg.CSWarMapHidenAwardElmt HidenAwards = 5;
  inline int hidenawards_size() const;
  inline void clear_hidenawards();
  static const int kHidenAwardsFieldNumber = 5;
  inline const ::vmsg::CSWarMapHidenAwardElmt& hidenawards(int index) const;
  inline ::vmsg::CSWarMapHidenAwardElmt* mutable_hidenawards(int index);
  inline ::vmsg::CSWarMapHidenAwardElmt* add_hidenawards();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSWarMapHidenAwardElmt >&
      hidenawards() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSWarMapHidenAwardElmt >*
      mutable_hidenawards();

  // @@protoc_insertion_point(class_scope:vmsg.CSWarMapInfo)
 private:
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_fightcnt();
  inline void clear_has_fightcnt();
  inline void set_has_boughtcnt();
  inline void clear_has_boughtcnt();
  inline void set_has_totalcnt();
  inline void clear_has_totalcnt();

  ::google::protobuf::uint32 score_;
  ::google::protobuf::uint32 fightcnt_;
  ::google::protobuf::uint32 boughtcnt_;
  ::google::protobuf::uint32 totalcnt_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSWarMapHidenAwardElmt > hidenawards_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWarMapInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSWarMapQueryRsp : public ::google::protobuf::MessageLite {
 public:
  CSWarMapQueryRsp();
  virtual ~CSWarMapQueryRsp();

  CSWarMapQueryRsp(const CSWarMapQueryRsp& from);

  inline CSWarMapQueryRsp& operator=(const CSWarMapQueryRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWarMapQueryRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWarMapQueryRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWarMapQueryRsp* other);

  // implements Message ----------------------------------------------

  CSWarMapQueryRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWarMapQueryRsp& from);
  void MergeFrom(const CSWarMapQueryRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 FromId = 1;
  inline bool has_fromid() const;
  inline void clear_fromid();
  static const int kFromIdFieldNumber = 1;
  inline ::google::protobuf::uint32 fromid() const;
  inline void set_fromid(::google::protobuf::uint32 value);

  // required uint32 ToId = 2;
  inline bool has_toid() const;
  inline void clear_toid();
  static const int kToIdFieldNumber = 2;
  inline ::google::protobuf::uint32 toid() const;
  inline void set_toid(::google::protobuf::uint32 value);

  // repeated .vmsg.CSWarMapInfo Infos = 3;
  inline int infos_size() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 3;
  inline const ::vmsg::CSWarMapInfo& infos(int index) const;
  inline ::vmsg::CSWarMapInfo* mutable_infos(int index);
  inline ::vmsg::CSWarMapInfo* add_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSWarMapInfo >&
      infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSWarMapInfo >*
      mutable_infos();

  // required uint32 NewestWarMapID = 4;
  inline bool has_newestwarmapid() const;
  inline void clear_newestwarmapid();
  static const int kNewestWarMapIDFieldNumber = 4;
  inline ::google::protobuf::uint32 newestwarmapid() const;
  inline void set_newestwarmapid(::google::protobuf::uint32 value);

  // repeated .vmsg.CSWeapon InBattleWeapons = 5;
  inline int inbattleweapons_size() const;
  inline void clear_inbattleweapons();
  static const int kInBattleWeaponsFieldNumber = 5;
  inline const ::vmsg::CSWeapon& inbattleweapons(int index) const;
  inline ::vmsg::CSWeapon* mutable_inbattleweapons(int index);
  inline ::vmsg::CSWeapon* add_inbattleweapons();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSWeapon >&
      inbattleweapons() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSWeapon >*
      mutable_inbattleweapons();

  // repeated .vmsg.CSWarStarAward WarStarAwards = 6;
  inline int warstarawards_size() const;
  inline void clear_warstarawards();
  static const int kWarStarAwardsFieldNumber = 6;
  inline const ::vmsg::CSWarStarAward& warstarawards(int index) const;
  inline ::vmsg::CSWarStarAward* mutable_warstarawards(int index);
  inline ::vmsg::CSWarStarAward* add_warstarawards();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSWarStarAward >&
      warstarawards() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSWarStarAward >*
      mutable_warstarawards();

  // @@protoc_insertion_point(class_scope:vmsg.CSWarMapQueryRsp)
 private:
  inline void set_has_fromid();
  inline void clear_has_fromid();
  inline void set_has_toid();
  inline void clear_has_toid();
  inline void set_has_newestwarmapid();
  inline void clear_has_newestwarmapid();

  ::google::protobuf::uint32 fromid_;
  ::google::protobuf::uint32 toid_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSWarMapInfo > infos_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSWeapon > inbattleweapons_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSWarStarAward > warstarawards_;
  ::google::protobuf::uint32 newestwarmapid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWarMapQueryRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSWarMapStartRqst : public ::google::protobuf::MessageLite {
 public:
  CSWarMapStartRqst();
  virtual ~CSWarMapStartRqst();

  CSWarMapStartRqst(const CSWarMapStartRqst& from);

  inline CSWarMapStartRqst& operator=(const CSWarMapStartRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWarMapStartRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWarMapStartRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWarMapStartRqst* other);

  // implements Message ----------------------------------------------

  CSWarMapStartRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWarMapStartRqst& from);
  void MergeFrom(const CSWarMapStartRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 WarMapId = 1;
  inline bool has_warmapid() const;
  inline void clear_warmapid();
  static const int kWarMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 warmapid() const;
  inline void set_warmapid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSWarMapStartRqst)
 private:
  inline void set_has_warmapid();
  inline void clear_has_warmapid();

  ::google::protobuf::uint32 warmapid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWarMapStartRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSWarMapDropInfo : public ::google::protobuf::MessageLite {
 public:
  CSWarMapDropInfo();
  virtual ~CSWarMapDropInfo();

  CSWarMapDropInfo(const CSWarMapDropInfo& from);

  inline CSWarMapDropInfo& operator=(const CSWarMapDropInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWarMapDropInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWarMapDropInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWarMapDropInfo* other);

  // implements Message ----------------------------------------------

  CSWarMapDropInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWarMapDropInfo& from);
  void MergeFrom(const CSWarMapDropInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 DropCnt = 2;
  inline bool has_dropcnt() const;
  inline void clear_dropcnt();
  static const int kDropCntFieldNumber = 2;
  inline ::google::protobuf::uint32 dropcnt() const;
  inline void set_dropcnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSWarMapDropInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_dropcnt();
  inline void clear_has_dropcnt();

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 dropcnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWarMapDropInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSWarMapStartRsp : public ::google::protobuf::MessageLite {
 public:
  CSWarMapStartRsp();
  virtual ~CSWarMapStartRsp();

  CSWarMapStartRsp(const CSWarMapStartRsp& from);

  inline CSWarMapStartRsp& operator=(const CSWarMapStartRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWarMapStartRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWarMapStartRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWarMapStartRsp* other);

  // implements Message ----------------------------------------------

  CSWarMapStartRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWarMapStartRsp& from);
  void MergeFrom(const CSWarMapStartRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 WarMapId = 1;
  inline bool has_warmapid() const;
  inline void clear_warmapid();
  static const int kWarMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 warmapid() const;
  inline void set_warmapid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSWarMapStartRsp)
 private:
  inline void set_has_warmapid();
  inline void clear_has_warmapid();

  ::google::protobuf::uint32 warmapid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWarMapStartRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSKillMonsterInfo : public ::google::protobuf::MessageLite {
 public:
  CSKillMonsterInfo();
  virtual ~CSKillMonsterInfo();

  CSKillMonsterInfo(const CSKillMonsterInfo& from);

  inline CSKillMonsterInfo& operator=(const CSKillMonsterInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSKillMonsterInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSKillMonsterInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSKillMonsterInfo* other);

  // implements Message ----------------------------------------------

  CSKillMonsterInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSKillMonsterInfo& from);
  void MergeFrom(const CSKillMonsterInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 MonsterID = 1;
  inline bool has_monsterid() const;
  inline void clear_monsterid();
  static const int kMonsterIDFieldNumber = 1;
  inline ::google::protobuf::uint32 monsterid() const;
  inline void set_monsterid(::google::protobuf::uint32 value);

  // required uint32 MonsterCnt = 2;
  inline bool has_monstercnt() const;
  inline void clear_monstercnt();
  static const int kMonsterCntFieldNumber = 2;
  inline ::google::protobuf::uint32 monstercnt() const;
  inline void set_monstercnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSKillMonsterInfo)
 private:
  inline void set_has_monsterid();
  inline void clear_has_monsterid();
  inline void set_has_monstercnt();
  inline void clear_has_monstercnt();

  ::google::protobuf::uint32 monsterid_;
  ::google::protobuf::uint32 monstercnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSKillMonsterInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSWarMapEndRqst : public ::google::protobuf::MessageLite {
 public:
  CSWarMapEndRqst();
  virtual ~CSWarMapEndRqst();

  CSWarMapEndRqst(const CSWarMapEndRqst& from);

  inline CSWarMapEndRqst& operator=(const CSWarMapEndRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWarMapEndRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWarMapEndRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWarMapEndRqst* other);

  // implements Message ----------------------------------------------

  CSWarMapEndRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWarMapEndRqst& from);
  void MergeFrom(const CSWarMapEndRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 WarMapId = 1;
  inline bool has_warmapid() const;
  inline void clear_warmapid();
  static const int kWarMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 warmapid() const;
  inline void set_warmapid(::google::protobuf::uint32 value);

  // repeated .vmsg.CSKillMonsterInfo MonsterInfos = 5;
  inline int monsterinfos_size() const;
  inline void clear_monsterinfos();
  static const int kMonsterInfosFieldNumber = 5;
  inline const ::vmsg::CSKillMonsterInfo& monsterinfos(int index) const;
  inline ::vmsg::CSKillMonsterInfo* mutable_monsterinfos(int index);
  inline ::vmsg::CSKillMonsterInfo* add_monsterinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSKillMonsterInfo >&
      monsterinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSKillMonsterInfo >*
      mutable_monsterinfos();

  // required uint32 BossID = 6;
  inline bool has_bossid() const;
  inline void clear_bossid();
  static const int kBossIDFieldNumber = 6;
  inline ::google::protobuf::uint32 bossid() const;
  inline void set_bossid(::google::protobuf::uint32 value);

  // required uint32 EvolutionUseCnt = 7;
  inline bool has_evolutionusecnt() const;
  inline void clear_evolutionusecnt();
  static const int kEvolutionUseCntFieldNumber = 7;
  inline ::google::protobuf::uint32 evolutionusecnt() const;
  inline void set_evolutionusecnt(::google::protobuf::uint32 value);

  // required uint32 Score = 8;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 8;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // repeated uint32 HidenAwardCell = 9;
  inline int hidenawardcell_size() const;
  inline void clear_hidenawardcell();
  static const int kHidenAwardCellFieldNumber = 9;
  inline ::google::protobuf::uint32 hidenawardcell(int index) const;
  inline void set_hidenawardcell(int index, ::google::protobuf::uint32 value);
  inline void add_hidenawardcell(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      hidenawardcell() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_hidenawardcell();

  // @@protoc_insertion_point(class_scope:vmsg.CSWarMapEndRqst)
 private:
  inline void set_has_warmapid();
  inline void clear_has_warmapid();
  inline void set_has_bossid();
  inline void clear_has_bossid();
  inline void set_has_evolutionusecnt();
  inline void clear_has_evolutionusecnt();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSKillMonsterInfo > monsterinfos_;
  ::google::protobuf::uint32 warmapid_;
  ::google::protobuf::uint32 bossid_;
  ::google::protobuf::uint32 evolutionusecnt_;
  ::google::protobuf::uint32 score_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > hidenawardcell_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWarMapEndRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSWarMapEndRsp : public ::google::protobuf::MessageLite {
 public:
  CSWarMapEndRsp();
  virtual ~CSWarMapEndRsp();

  CSWarMapEndRsp(const CSWarMapEndRsp& from);

  inline CSWarMapEndRsp& operator=(const CSWarMapEndRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWarMapEndRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWarMapEndRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWarMapEndRsp* other);

  // implements Message ----------------------------------------------

  CSWarMapEndRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWarMapEndRsp& from);
  void MergeFrom(const CSWarMapEndRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSAwardElement PackAwards = 1;
  inline int packawards_size() const;
  inline void clear_packawards();
  static const int kPackAwardsFieldNumber = 1;
  inline const ::vmsg::CSAwardElement& packawards(int index) const;
  inline ::vmsg::CSAwardElement* mutable_packawards(int index);
  inline ::vmsg::CSAwardElement* add_packawards();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >&
      packawards() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >*
      mutable_packawards();

  // required uint32 AwardCoin = 2;
  inline bool has_awardcoin() const;
  inline void clear_awardcoin();
  static const int kAwardCoinFieldNumber = 2;
  inline ::google::protobuf::uint32 awardcoin() const;
  inline void set_awardcoin(::google::protobuf::uint32 value);

  // required uint32 AwardExp = 3;
  inline bool has_awardexp() const;
  inline void clear_awardexp();
  static const int kAwardExpFieldNumber = 3;
  inline ::google::protobuf::uint32 awardexp() const;
  inline void set_awardexp(::google::protobuf::uint32 value);

  // repeated .vmsg.CSAwardElement HidenAwards = 4;
  inline int hidenawards_size() const;
  inline void clear_hidenawards();
  static const int kHidenAwardsFieldNumber = 4;
  inline const ::vmsg::CSAwardElement& hidenawards(int index) const;
  inline ::vmsg::CSAwardElement* mutable_hidenawards(int index);
  inline ::vmsg::CSAwardElement* add_hidenawards();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >&
      hidenawards() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >*
      mutable_hidenawards();

  // @@protoc_insertion_point(class_scope:vmsg.CSWarMapEndRsp)
 private:
  inline void set_has_awardcoin();
  inline void clear_has_awardcoin();
  inline void set_has_awardexp();
  inline void clear_has_awardexp();

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement > packawards_;
  ::google::protobuf::uint32 awardcoin_;
  ::google::protobuf::uint32 awardexp_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement > hidenawards_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWarMapEndRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSWarMapCardRqst : public ::google::protobuf::MessageLite {
 public:
  CSWarMapCardRqst();
  virtual ~CSWarMapCardRqst();

  CSWarMapCardRqst(const CSWarMapCardRqst& from);

  inline CSWarMapCardRqst& operator=(const CSWarMapCardRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWarMapCardRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWarMapCardRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWarMapCardRqst* other);

  // implements Message ----------------------------------------------

  CSWarMapCardRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWarMapCardRqst& from);
  void MergeFrom(const CSWarMapCardRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 WarMapId = 1;
  inline bool has_warmapid() const;
  inline void clear_warmapid();
  static const int kWarMapIdFieldNumber = 1;
  inline ::google::protobuf::uint32 warmapid() const;
  inline void set_warmapid(::google::protobuf::uint32 value);

  // required uint32 IsFree = 2;
  inline bool has_isfree() const;
  inline void clear_isfree();
  static const int kIsFreeFieldNumber = 2;
  inline ::google::protobuf::uint32 isfree() const;
  inline void set_isfree(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSWarMapCardRqst)
 private:
  inline void set_has_warmapid();
  inline void clear_has_warmapid();
  inline void set_has_isfree();
  inline void clear_has_isfree();

  ::google::protobuf::uint32 warmapid_;
  ::google::protobuf::uint32 isfree_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWarMapCardRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSWarMapCardRsp : public ::google::protobuf::MessageLite {
 public:
  CSWarMapCardRsp();
  virtual ~CSWarMapCardRsp();

  CSWarMapCardRsp(const CSWarMapCardRsp& from);

  inline CSWarMapCardRsp& operator=(const CSWarMapCardRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWarMapCardRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWarMapCardRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWarMapCardRsp* other);

  // implements Message ----------------------------------------------

  CSWarMapCardRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWarMapCardRsp& from);
  void MergeFrom(const CSWarMapCardRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 IsFree = 1;
  inline bool has_isfree() const;
  inline void clear_isfree();
  static const int kIsFreeFieldNumber = 1;
  inline ::google::protobuf::uint32 isfree() const;
  inline void set_isfree(::google::protobuf::uint32 value);

  // required uint32 AwardType = 2;
  inline bool has_awardtype() const;
  inline void clear_awardtype();
  static const int kAwardTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 awardtype() const;
  inline void set_awardtype(::google::protobuf::uint32 value);

  // required uint32 AwardID = 3;
  inline bool has_awardid() const;
  inline void clear_awardid();
  static const int kAwardIDFieldNumber = 3;
  inline ::google::protobuf::uint32 awardid() const;
  inline void set_awardid(::google::protobuf::uint32 value);

  // required uint32 AwardCnt = 4;
  inline bool has_awardcnt() const;
  inline void clear_awardcnt();
  static const int kAwardCntFieldNumber = 4;
  inline ::google::protobuf::uint32 awardcnt() const;
  inline void set_awardcnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSWarMapCardRsp)
 private:
  inline void set_has_isfree();
  inline void clear_has_isfree();
  inline void set_has_awardtype();
  inline void clear_has_awardtype();
  inline void set_has_awardid();
  inline void clear_has_awardid();
  inline void set_has_awardcnt();
  inline void clear_has_awardcnt();

  ::google::protobuf::uint32 isfree_;
  ::google::protobuf::uint32 awardtype_;
  ::google::protobuf::uint32 awardid_;
  ::google::protobuf::uint32 awardcnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWarMapCardRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSSweepWarRqst : public ::google::protobuf::MessageLite {
 public:
  CSSweepWarRqst();
  virtual ~CSSweepWarRqst();

  CSSweepWarRqst(const CSSweepWarRqst& from);

  inline CSSweepWarRqst& operator=(const CSSweepWarRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSSweepWarRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSweepWarRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSweepWarRqst* other);

  // implements Message ----------------------------------------------

  CSSweepWarRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSweepWarRqst& from);
  void MergeFrom(const CSSweepWarRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 WarMapID = 1;
  inline bool has_warmapid() const;
  inline void clear_warmapid();
  static const int kWarMapIDFieldNumber = 1;
  inline ::google::protobuf::uint32 warmapid() const;
  inline void set_warmapid(::google::protobuf::uint32 value);

  // required uint32 SweepRound = 2;
  inline bool has_sweepround() const;
  inline void clear_sweepround();
  static const int kSweepRoundFieldNumber = 2;
  inline ::google::protobuf::uint32 sweepround() const;
  inline void set_sweepround(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSSweepWarRqst)
 private:
  inline void set_has_warmapid();
  inline void clear_has_warmapid();
  inline void set_has_sweepround();
  inline void clear_has_sweepround();

  ::google::protobuf::uint32 warmapid_;
  ::google::protobuf::uint32 sweepround_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSSweepWarRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSSweepAward : public ::google::protobuf::MessageLite {
 public:
  CSSweepAward();
  virtual ~CSSweepAward();

  CSSweepAward(const CSSweepAward& from);

  inline CSSweepAward& operator=(const CSSweepAward& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSSweepAward& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSweepAward* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSweepAward* other);

  // implements Message ----------------------------------------------

  CSSweepAward* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSweepAward& from);
  void MergeFrom(const CSSweepAward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSAwardElement Award = 1;
  inline int award_size() const;
  inline void clear_award();
  static const int kAwardFieldNumber = 1;
  inline const ::vmsg::CSAwardElement& award(int index) const;
  inline ::vmsg::CSAwardElement* mutable_award(int index);
  inline ::vmsg::CSAwardElement* add_award();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >&
      award() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >*
      mutable_award();

  // required uint32 Exp = 2;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 2;
  inline ::google::protobuf::uint32 exp() const;
  inline void set_exp(::google::protobuf::uint32 value);

  // required uint32 Coin = 3;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 3;
  inline ::google::protobuf::uint32 coin() const;
  inline void set_coin(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSSweepAward)
 private:
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_coin();
  inline void clear_has_coin();

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement > award_;
  ::google::protobuf::uint32 exp_;
  ::google::protobuf::uint32 coin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSSweepAward* default_instance_;
};
// -------------------------------------------------------------------

class CSSweepWarRsp : public ::google::protobuf::MessageLite {
 public:
  CSSweepWarRsp();
  virtual ~CSSweepWarRsp();

  CSSweepWarRsp(const CSSweepWarRsp& from);

  inline CSSweepWarRsp& operator=(const CSSweepWarRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSSweepWarRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSweepWarRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSweepWarRsp* other);

  // implements Message ----------------------------------------------

  CSSweepWarRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSweepWarRsp& from);
  void MergeFrom(const CSSweepWarRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSSweepAward AwardLst = 1;
  inline int awardlst_size() const;
  inline void clear_awardlst();
  static const int kAwardLstFieldNumber = 1;
  inline const ::vmsg::CSSweepAward& awardlst(int index) const;
  inline ::vmsg::CSSweepAward* mutable_awardlst(int index);
  inline ::vmsg::CSSweepAward* add_awardlst();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSSweepAward >&
      awardlst() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSSweepAward >*
      mutable_awardlst();

  // required uint32 ErrorNo = 2;
  inline bool has_errorno() const;
  inline void clear_errorno();
  static const int kErrorNoFieldNumber = 2;
  inline ::google::protobuf::uint32 errorno() const;
  inline void set_errorno(::google::protobuf::uint32 value);

  // required .vmsg.CSBagInfo BagInfo = 3;
  inline bool has_baginfo() const;
  inline void clear_baginfo();
  static const int kBagInfoFieldNumber = 3;
  inline const ::vmsg::CSBagInfo& baginfo() const;
  inline ::vmsg::CSBagInfo* mutable_baginfo();
  inline ::vmsg::CSBagInfo* release_baginfo();
  inline void set_allocated_baginfo(::vmsg::CSBagInfo* baginfo);

  // @@protoc_insertion_point(class_scope:vmsg.CSSweepWarRsp)
 private:
  inline void set_has_errorno();
  inline void clear_has_errorno();
  inline void set_has_baginfo();
  inline void clear_has_baginfo();

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSSweepAward > awardlst_;
  ::vmsg::CSBagInfo* baginfo_;
  ::google::protobuf::uint32 errorno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSSweepWarRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSQueryEliteWarMapRqst : public ::google::protobuf::MessageLite {
 public:
  CSQueryEliteWarMapRqst();
  virtual ~CSQueryEliteWarMapRqst();

  CSQueryEliteWarMapRqst(const CSQueryEliteWarMapRqst& from);

  inline CSQueryEliteWarMapRqst& operator=(const CSQueryEliteWarMapRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSQueryEliteWarMapRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQueryEliteWarMapRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQueryEliteWarMapRqst* other);

  // implements Message ----------------------------------------------

  CSQueryEliteWarMapRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQueryEliteWarMapRqst& from);
  void MergeFrom(const CSQueryEliteWarMapRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 EliteWarID = 1;
  inline bool has_elitewarid() const;
  inline void clear_elitewarid();
  static const int kEliteWarIDFieldNumber = 1;
  inline ::google::protobuf::uint32 elitewarid() const;
  inline void set_elitewarid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSQueryEliteWarMapRqst)
 private:
  inline void set_has_elitewarid();
  inline void clear_has_elitewarid();

  ::google::protobuf::uint32 elitewarid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSQueryEliteWarMapRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSEliteWarInfo : public ::google::protobuf::MessageLite {
 public:
  CSEliteWarInfo();
  virtual ~CSEliteWarInfo();

  CSEliteWarInfo(const CSEliteWarInfo& from);

  inline CSEliteWarInfo& operator=(const CSEliteWarInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEliteWarInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEliteWarInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEliteWarInfo* other);

  // implements Message ----------------------------------------------

  CSEliteWarInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEliteWarInfo& from);
  void MergeFrom(const CSEliteWarInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 EliteWarID = 1;
  inline bool has_elitewarid() const;
  inline void clear_elitewarid();
  static const int kEliteWarIDFieldNumber = 1;
  inline ::google::protobuf::uint32 elitewarid() const;
  inline void set_elitewarid(::google::protobuf::uint32 value);

  // repeated uint32 FightMapIDs = 2;
  inline int fightmapids_size() const;
  inline void clear_fightmapids();
  static const int kFightMapIDsFieldNumber = 2;
  inline ::google::protobuf::uint32 fightmapids(int index) const;
  inline void set_fightmapids(int index, ::google::protobuf::uint32 value);
  inline void add_fightmapids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      fightmapids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_fightmapids();

  // required uint32 RemainResetCnt = 3;
  inline bool has_remainresetcnt() const;
  inline void clear_remainresetcnt();
  static const int kRemainResetCntFieldNumber = 3;
  inline ::google::protobuf::uint32 remainresetcnt() const;
  inline void set_remainresetcnt(::google::protobuf::uint32 value);

  // required uint32 MaxEliteWarMapID = 4;
  inline bool has_maxelitewarmapid() const;
  inline void clear_maxelitewarmapid();
  static const int kMaxEliteWarMapIDFieldNumber = 4;
  inline ::google::protobuf::uint32 maxelitewarmapid() const;
  inline void set_maxelitewarmapid(::google::protobuf::uint32 value);

  // required uint32 ResetCost = 5;
  inline bool has_resetcost() const;
  inline void clear_resetcost();
  static const int kResetCostFieldNumber = 5;
  inline ::google::protobuf::uint32 resetcost() const;
  inline void set_resetcost(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSEliteWarInfo)
 private:
  inline void set_has_elitewarid();
  inline void clear_has_elitewarid();
  inline void set_has_remainresetcnt();
  inline void clear_has_remainresetcnt();
  inline void set_has_maxelitewarmapid();
  inline void clear_has_maxelitewarmapid();
  inline void set_has_resetcost();
  inline void clear_has_resetcost();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > fightmapids_;
  ::google::protobuf::uint32 elitewarid_;
  ::google::protobuf::uint32 remainresetcnt_;
  ::google::protobuf::uint32 maxelitewarmapid_;
  ::google::protobuf::uint32 resetcost_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEliteWarInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSResetEliteWarMapRqst : public ::google::protobuf::MessageLite {
 public:
  CSResetEliteWarMapRqst();
  virtual ~CSResetEliteWarMapRqst();

  CSResetEliteWarMapRqst(const CSResetEliteWarMapRqst& from);

  inline CSResetEliteWarMapRqst& operator=(const CSResetEliteWarMapRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSResetEliteWarMapRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSResetEliteWarMapRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSResetEliteWarMapRqst* other);

  // implements Message ----------------------------------------------

  CSResetEliteWarMapRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSResetEliteWarMapRqst& from);
  void MergeFrom(const CSResetEliteWarMapRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 EliteWarID = 1;
  inline bool has_elitewarid() const;
  inline void clear_elitewarid();
  static const int kEliteWarIDFieldNumber = 1;
  inline ::google::protobuf::uint32 elitewarid() const;
  inline void set_elitewarid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSResetEliteWarMapRqst)
 private:
  inline void set_has_elitewarid();
  inline void clear_has_elitewarid();

  ::google::protobuf::uint32 elitewarid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSResetEliteWarMapRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSStartEliteWarMapRqst : public ::google::protobuf::MessageLite {
 public:
  CSStartEliteWarMapRqst();
  virtual ~CSStartEliteWarMapRqst();

  CSStartEliteWarMapRqst(const CSStartEliteWarMapRqst& from);

  inline CSStartEliteWarMapRqst& operator=(const CSStartEliteWarMapRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSStartEliteWarMapRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSStartEliteWarMapRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSStartEliteWarMapRqst* other);

  // implements Message ----------------------------------------------

  CSStartEliteWarMapRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSStartEliteWarMapRqst& from);
  void MergeFrom(const CSStartEliteWarMapRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 EliteWarMapID = 1;
  inline bool has_elitewarmapid() const;
  inline void clear_elitewarmapid();
  static const int kEliteWarMapIDFieldNumber = 1;
  inline ::google::protobuf::uint32 elitewarmapid() const;
  inline void set_elitewarmapid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSStartEliteWarMapRqst)
 private:
  inline void set_has_elitewarmapid();
  inline void clear_has_elitewarmapid();

  ::google::protobuf::uint32 elitewarmapid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSStartEliteWarMapRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSStartEliteWarMapRsp : public ::google::protobuf::MessageLite {
 public:
  CSStartEliteWarMapRsp();
  virtual ~CSStartEliteWarMapRsp();

  CSStartEliteWarMapRsp(const CSStartEliteWarMapRsp& from);

  inline CSStartEliteWarMapRsp& operator=(const CSStartEliteWarMapRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSStartEliteWarMapRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSStartEliteWarMapRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSStartEliteWarMapRsp* other);

  // implements Message ----------------------------------------------

  CSStartEliteWarMapRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSStartEliteWarMapRsp& from);
  void MergeFrom(const CSStartEliteWarMapRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 EliteWarMapID = 1;
  inline bool has_elitewarmapid() const;
  inline void clear_elitewarmapid();
  static const int kEliteWarMapIDFieldNumber = 1;
  inline ::google::protobuf::uint32 elitewarmapid() const;
  inline void set_elitewarmapid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSStartEliteWarMapRsp)
 private:
  inline void set_has_elitewarmapid();
  inline void clear_has_elitewarmapid();

  ::google::protobuf::uint32 elitewarmapid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSStartEliteWarMapRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSEndEliteWarMapRqst : public ::google::protobuf::MessageLite {
 public:
  CSEndEliteWarMapRqst();
  virtual ~CSEndEliteWarMapRqst();

  CSEndEliteWarMapRqst(const CSEndEliteWarMapRqst& from);

  inline CSEndEliteWarMapRqst& operator=(const CSEndEliteWarMapRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEndEliteWarMapRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEndEliteWarMapRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEndEliteWarMapRqst* other);

  // implements Message ----------------------------------------------

  CSEndEliteWarMapRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEndEliteWarMapRqst& from);
  void MergeFrom(const CSEndEliteWarMapRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 EliteWarMapID = 1;
  inline bool has_elitewarmapid() const;
  inline void clear_elitewarmapid();
  static const int kEliteWarMapIDFieldNumber = 1;
  inline ::google::protobuf::uint32 elitewarmapid() const;
  inline void set_elitewarmapid(::google::protobuf::uint32 value);

  // required uint32 EvolutionUseCnt = 2;
  inline bool has_evolutionusecnt() const;
  inline void clear_evolutionusecnt();
  static const int kEvolutionUseCntFieldNumber = 2;
  inline ::google::protobuf::uint32 evolutionusecnt() const;
  inline void set_evolutionusecnt(::google::protobuf::uint32 value);

  // required uint32 Score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSEndEliteWarMapRqst)
 private:
  inline void set_has_elitewarmapid();
  inline void clear_has_elitewarmapid();
  inline void set_has_evolutionusecnt();
  inline void clear_has_evolutionusecnt();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::uint32 elitewarmapid_;
  ::google::protobuf::uint32 evolutionusecnt_;
  ::google::protobuf::uint32 score_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEndEliteWarMapRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSEliteAward : public ::google::protobuf::MessageLite {
 public:
  CSEliteAward();
  virtual ~CSEliteAward();

  CSEliteAward(const CSEliteAward& from);

  inline CSEliteAward& operator=(const CSEliteAward& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEliteAward& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEliteAward* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEliteAward* other);

  // implements Message ----------------------------------------------

  CSEliteAward* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEliteAward& from);
  void MergeFrom(const CSEliteAward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 EliteWarMapID = 1;
  inline bool has_elitewarmapid() const;
  inline void clear_elitewarmapid();
  static const int kEliteWarMapIDFieldNumber = 1;
  inline ::google::protobuf::uint32 elitewarmapid() const;
  inline void set_elitewarmapid(::google::protobuf::uint32 value);

  // repeated .vmsg.CSAwardElement Award = 2;
  inline int award_size() const;
  inline void clear_award();
  static const int kAwardFieldNumber = 2;
  inline const ::vmsg::CSAwardElement& award(int index) const;
  inline ::vmsg::CSAwardElement* mutable_award(int index);
  inline ::vmsg::CSAwardElement* add_award();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >&
      award() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >*
      mutable_award();

  // @@protoc_insertion_point(class_scope:vmsg.CSEliteAward)
 private:
  inline void set_has_elitewarmapid();
  inline void clear_has_elitewarmapid();

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement > award_;
  ::google::protobuf::uint32 elitewarmapid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEliteAward* default_instance_;
};
// -------------------------------------------------------------------

class CSEndEliteWarMapRsp : public ::google::protobuf::MessageLite {
 public:
  CSEndEliteWarMapRsp();
  virtual ~CSEndEliteWarMapRsp();

  CSEndEliteWarMapRsp(const CSEndEliteWarMapRsp& from);

  inline CSEndEliteWarMapRsp& operator=(const CSEndEliteWarMapRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEndEliteWarMapRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEndEliteWarMapRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEndEliteWarMapRsp* other);

  // implements Message ----------------------------------------------

  CSEndEliteWarMapRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEndEliteWarMapRsp& from);
  void MergeFrom(const CSEndEliteWarMapRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSEliteAward EliteAward = 1;
  inline bool has_eliteaward() const;
  inline void clear_eliteaward();
  static const int kEliteAwardFieldNumber = 1;
  inline const ::vmsg::CSEliteAward& eliteaward() const;
  inline ::vmsg::CSEliteAward* mutable_eliteaward();
  inline ::vmsg::CSEliteAward* release_eliteaward();
  inline void set_allocated_eliteaward(::vmsg::CSEliteAward* eliteaward);

  // @@protoc_insertion_point(class_scope:vmsg.CSEndEliteWarMapRsp)
 private:
  inline void set_has_eliteaward();
  inline void clear_has_eliteaward();

  ::vmsg::CSEliteAward* eliteaward_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEndEliteWarMapRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSSweepEliteWarRqst : public ::google::protobuf::MessageLite {
 public:
  CSSweepEliteWarRqst();
  virtual ~CSSweepEliteWarRqst();

  CSSweepEliteWarRqst(const CSSweepEliteWarRqst& from);

  inline CSSweepEliteWarRqst& operator=(const CSSweepEliteWarRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSSweepEliteWarRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSweepEliteWarRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSweepEliteWarRqst* other);

  // implements Message ----------------------------------------------

  CSSweepEliteWarRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSweepEliteWarRqst& from);
  void MergeFrom(const CSSweepEliteWarRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 EliteWarID = 1;
  inline bool has_elitewarid() const;
  inline void clear_elitewarid();
  static const int kEliteWarIDFieldNumber = 1;
  inline ::google::protobuf::uint32 elitewarid() const;
  inline void set_elitewarid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSSweepEliteWarRqst)
 private:
  inline void set_has_elitewarid();
  inline void clear_has_elitewarid();

  ::google::protobuf::uint32 elitewarid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSSweepEliteWarRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSSweepEliteWarRsp : public ::google::protobuf::MessageLite {
 public:
  CSSweepEliteWarRsp();
  virtual ~CSSweepEliteWarRsp();

  CSSweepEliteWarRsp(const CSSweepEliteWarRsp& from);

  inline CSSweepEliteWarRsp& operator=(const CSSweepEliteWarRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSSweepEliteWarRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSweepEliteWarRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSweepEliteWarRsp* other);

  // implements Message ----------------------------------------------

  CSSweepEliteWarRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSweepEliteWarRsp& from);
  void MergeFrom(const CSSweepEliteWarRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSEliteWarInfo Info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::vmsg::CSEliteWarInfo& info() const;
  inline ::vmsg::CSEliteWarInfo* mutable_info();
  inline ::vmsg::CSEliteWarInfo* release_info();
  inline void set_allocated_info(::vmsg::CSEliteWarInfo* info);

  // repeated .vmsg.CSEliteAward AwardList = 2;
  inline int awardlist_size() const;
  inline void clear_awardlist();
  static const int kAwardListFieldNumber = 2;
  inline const ::vmsg::CSEliteAward& awardlist(int index) const;
  inline ::vmsg::CSEliteAward* mutable_awardlist(int index);
  inline ::vmsg::CSEliteAward* add_awardlist();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSEliteAward >&
      awardlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSEliteAward >*
      mutable_awardlist();

  // optional int32 ErrorNo = 3;
  inline bool has_errorno() const;
  inline void clear_errorno();
  static const int kErrorNoFieldNumber = 3;
  inline ::google::protobuf::int32 errorno() const;
  inline void set_errorno(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSSweepEliteWarRsp)
 private:
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_errorno();
  inline void clear_has_errorno();

  ::vmsg::CSEliteWarInfo* info_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSEliteAward > awardlist_;
  ::google::protobuf::int32 errorno_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSSweepEliteWarRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSDailyInstanceElmt : public ::google::protobuf::MessageLite {
 public:
  CSDailyInstanceElmt();
  virtual ~CSDailyInstanceElmt();

  CSDailyInstanceElmt(const CSDailyInstanceElmt& from);

  inline CSDailyInstanceElmt& operator=(const CSDailyInstanceElmt& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSDailyInstanceElmt& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDailyInstanceElmt* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDailyInstanceElmt* other);

  // implements Message ----------------------------------------------

  CSDailyInstanceElmt* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDailyInstanceElmt& from);
  void MergeFrom(const CSDailyInstanceElmt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline ::google::protobuf::uint32 key() const;
  inline void set_key(::google::protobuf::uint32 value);

  // required uint32 ChallengeCnt = 2;
  inline bool has_challengecnt() const;
  inline void clear_challengecnt();
  static const int kChallengeCntFieldNumber = 2;
  inline ::google::protobuf::uint32 challengecnt() const;
  inline void set_challengecnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSDailyInstanceElmt)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_challengecnt();
  inline void clear_has_challengecnt();

  ::google::protobuf::uint32 key_;
  ::google::protobuf::uint32 challengecnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSDailyInstanceElmt* default_instance_;
};
// -------------------------------------------------------------------

class CSQueryDailyInstanceRsp : public ::google::protobuf::MessageLite {
 public:
  CSQueryDailyInstanceRsp();
  virtual ~CSQueryDailyInstanceRsp();

  CSQueryDailyInstanceRsp(const CSQueryDailyInstanceRsp& from);

  inline CSQueryDailyInstanceRsp& operator=(const CSQueryDailyInstanceRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSQueryDailyInstanceRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQueryDailyInstanceRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQueryDailyInstanceRsp* other);

  // implements Message ----------------------------------------------

  CSQueryDailyInstanceRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQueryDailyInstanceRsp& from);
  void MergeFrom(const CSQueryDailyInstanceRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSDailyInstanceElmt Instances = 1;
  inline int instances_size() const;
  inline void clear_instances();
  static const int kInstancesFieldNumber = 1;
  inline const ::vmsg::CSDailyInstanceElmt& instances(int index) const;
  inline ::vmsg::CSDailyInstanceElmt* mutable_instances(int index);
  inline ::vmsg::CSDailyInstanceElmt* add_instances();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSDailyInstanceElmt >&
      instances() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSDailyInstanceElmt >*
      mutable_instances();

  // @@protoc_insertion_point(class_scope:vmsg.CSQueryDailyInstanceRsp)
 private:

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSDailyInstanceElmt > instances_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSQueryDailyInstanceRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSDailyInstancePassRqst : public ::google::protobuf::MessageLite {
 public:
  CSDailyInstancePassRqst();
  virtual ~CSDailyInstancePassRqst();

  CSDailyInstancePassRqst(const CSDailyInstancePassRqst& from);

  inline CSDailyInstancePassRqst& operator=(const CSDailyInstancePassRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSDailyInstancePassRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDailyInstancePassRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDailyInstancePassRqst* other);

  // implements Message ----------------------------------------------

  CSDailyInstancePassRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDailyInstancePassRqst& from);
  void MergeFrom(const CSDailyInstancePassRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 PassLvl = 1;
  inline bool has_passlvl() const;
  inline void clear_passlvl();
  static const int kPassLvlFieldNumber = 1;
  inline ::google::protobuf::uint32 passlvl() const;
  inline void set_passlvl(::google::protobuf::uint32 value);

  // required uint32 Key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline ::google::protobuf::uint32 key() const;
  inline void set_key(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSDailyInstancePassRqst)
 private:
  inline void set_has_passlvl();
  inline void clear_has_passlvl();
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::uint32 passlvl_;
  ::google::protobuf::uint32 key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSDailyInstancePassRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSDailyInstancePassRsp : public ::google::protobuf::MessageLite {
 public:
  CSDailyInstancePassRsp();
  virtual ~CSDailyInstancePassRsp();

  CSDailyInstancePassRsp(const CSDailyInstancePassRsp& from);

  inline CSDailyInstancePassRsp& operator=(const CSDailyInstancePassRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSDailyInstancePassRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDailyInstancePassRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDailyInstancePassRsp* other);

  // implements Message ----------------------------------------------

  CSDailyInstancePassRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDailyInstancePassRsp& from);
  void MergeFrom(const CSDailyInstancePassRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSDailyInstanceElmt Instances = 1;
  inline int instances_size() const;
  inline void clear_instances();
  static const int kInstancesFieldNumber = 1;
  inline const ::vmsg::CSDailyInstanceElmt& instances(int index) const;
  inline ::vmsg::CSDailyInstanceElmt* mutable_instances(int index);
  inline ::vmsg::CSDailyInstanceElmt* add_instances();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSDailyInstanceElmt >&
      instances() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSDailyInstanceElmt >*
      mutable_instances();

  // repeated .vmsg.CSAwardElement AwardLst = 2;
  inline int awardlst_size() const;
  inline void clear_awardlst();
  static const int kAwardLstFieldNumber = 2;
  inline const ::vmsg::CSAwardElement& awardlst(int index) const;
  inline ::vmsg::CSAwardElement* mutable_awardlst(int index);
  inline ::vmsg::CSAwardElement* add_awardlst();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >&
      awardlst() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >*
      mutable_awardlst();

  // @@protoc_insertion_point(class_scope:vmsg.CSDailyInstancePassRsp)
 private:

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSDailyInstanceElmt > instances_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement > awardlst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSDailyInstancePassRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSReliveRqst : public ::google::protobuf::MessageLite {
 public:
  CSReliveRqst();
  virtual ~CSReliveRqst();

  CSReliveRqst(const CSReliveRqst& from);

  inline CSReliveRqst& operator=(const CSReliveRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSReliveRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSReliveRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSReliveRqst* other);

  // implements Message ----------------------------------------------

  CSReliveRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSReliveRqst& from);
  void MergeFrom(const CSReliveRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 IsUseItem = 1;
  inline bool has_isuseitem() const;
  inline void clear_isuseitem();
  static const int kIsUseItemFieldNumber = 1;
  inline ::google::protobuf::int32 isuseitem() const;
  inline void set_isuseitem(::google::protobuf::int32 value);

  // optional int32 ItemID = 2;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIDFieldNumber = 2;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 ItemBagIdx = 3;
  inline bool has_itembagidx() const;
  inline void clear_itembagidx();
  static const int kItemBagIdxFieldNumber = 3;
  inline ::google::protobuf::int32 itembagidx() const;
  inline void set_itembagidx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSReliveRqst)
 private:
  inline void set_has_isuseitem();
  inline void clear_has_isuseitem();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_itembagidx();
  inline void clear_has_itembagidx();

  ::google::protobuf::int32 isuseitem_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 itembagidx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSReliveRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSReliveRsp : public ::google::protobuf::MessageLite {
 public:
  CSReliveRsp();
  virtual ~CSReliveRsp();

  CSReliveRsp(const CSReliveRsp& from);

  inline CSReliveRsp& operator=(const CSReliveRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSReliveRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSReliveRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSReliveRsp* other);

  // implements Message ----------------------------------------------

  CSReliveRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSReliveRsp& from);
  void MergeFrom(const CSReliveRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSBagInfo BagInfo = 1;
  inline bool has_baginfo() const;
  inline void clear_baginfo();
  static const int kBagInfoFieldNumber = 1;
  inline const ::vmsg::CSBagInfo& baginfo() const;
  inline ::vmsg::CSBagInfo* mutable_baginfo();
  inline ::vmsg::CSBagInfo* release_baginfo();
  inline void set_allocated_baginfo(::vmsg::CSBagInfo* baginfo);

  // required uint32 NextReliveCost = 2;
  inline bool has_nextrelivecost() const;
  inline void clear_nextrelivecost();
  static const int kNextReliveCostFieldNumber = 2;
  inline ::google::protobuf::uint32 nextrelivecost() const;
  inline void set_nextrelivecost(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSReliveRsp)
 private:
  inline void set_has_baginfo();
  inline void clear_has_baginfo();
  inline void set_has_nextrelivecost();
  inline void clear_has_nextrelivecost();

  ::vmsg::CSBagInfo* baginfo_;
  ::google::protobuf::uint32 nextrelivecost_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSReliveRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSBuyBulletRqst : public ::google::protobuf::MessageLite {
 public:
  CSBuyBulletRqst();
  virtual ~CSBuyBulletRqst();

  CSBuyBulletRqst(const CSBuyBulletRqst& from);

  inline CSBuyBulletRqst& operator=(const CSBuyBulletRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBuyBulletRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBuyBulletRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBuyBulletRqst* other);

  // implements Message ----------------------------------------------

  CSBuyBulletRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBuyBulletRqst& from);
  void MergeFrom(const CSBuyBulletRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 IsUseItem = 1;
  inline bool has_isuseitem() const;
  inline void clear_isuseitem();
  static const int kIsUseItemFieldNumber = 1;
  inline ::google::protobuf::int32 isuseitem() const;
  inline void set_isuseitem(::google::protobuf::int32 value);

  // optional int32 ItemID = 2;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIDFieldNumber = 2;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 ItemBagIdx = 3;
  inline bool has_itembagidx() const;
  inline void clear_itembagidx();
  static const int kItemBagIdxFieldNumber = 3;
  inline ::google::protobuf::int32 itembagidx() const;
  inline void set_itembagidx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSBuyBulletRqst)
 private:
  inline void set_has_isuseitem();
  inline void clear_has_isuseitem();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_itembagidx();
  inline void clear_has_itembagidx();

  ::google::protobuf::int32 isuseitem_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 itembagidx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBuyBulletRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSBuyBulletRsp : public ::google::protobuf::MessageLite {
 public:
  CSBuyBulletRsp();
  virtual ~CSBuyBulletRsp();

  CSBuyBulletRsp(const CSBuyBulletRsp& from);

  inline CSBuyBulletRsp& operator=(const CSBuyBulletRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBuyBulletRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBuyBulletRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBuyBulletRsp* other);

  // implements Message ----------------------------------------------

  CSBuyBulletRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBuyBulletRsp& from);
  void MergeFrom(const CSBuyBulletRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSBagInfo BagInfo = 1;
  inline bool has_baginfo() const;
  inline void clear_baginfo();
  static const int kBagInfoFieldNumber = 1;
  inline const ::vmsg::CSBagInfo& baginfo() const;
  inline ::vmsg::CSBagInfo* mutable_baginfo();
  inline ::vmsg::CSBagInfo* release_baginfo();
  inline void set_allocated_baginfo(::vmsg::CSBagInfo* baginfo);

  // required uint32 NextBulletCost = 2;
  inline bool has_nextbulletcost() const;
  inline void clear_nextbulletcost();
  static const int kNextBulletCostFieldNumber = 2;
  inline ::google::protobuf::uint32 nextbulletcost() const;
  inline void set_nextbulletcost(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSBuyBulletRsp)
 private:
  inline void set_has_baginfo();
  inline void clear_has_baginfo();
  inline void set_has_nextbulletcost();
  inline void clear_has_nextbulletcost();

  ::vmsg::CSBagInfo* baginfo_;
  ::google::protobuf::uint32 nextbulletcost_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBuyBulletRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSBuyInstanceRqst : public ::google::protobuf::MessageLite {
 public:
  CSBuyInstanceRqst();
  virtual ~CSBuyInstanceRqst();

  CSBuyInstanceRqst(const CSBuyInstanceRqst& from);

  inline CSBuyInstanceRqst& operator=(const CSBuyInstanceRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBuyInstanceRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBuyInstanceRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBuyInstanceRqst* other);

  // implements Message ----------------------------------------------

  CSBuyInstanceRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBuyInstanceRqst& from);
  void MergeFrom(const CSBuyInstanceRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // required uint32 WarID = 2;
  inline bool has_warid() const;
  inline void clear_warid();
  static const int kWarIDFieldNumber = 2;
  inline ::google::protobuf::uint32 warid() const;
  inline void set_warid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSBuyInstanceRqst)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_warid();
  inline void clear_has_warid();

  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 warid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBuyInstanceRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSBuyInstanceRsp : public ::google::protobuf::MessageLite {
 public:
  CSBuyInstanceRsp();
  virtual ~CSBuyInstanceRsp();

  CSBuyInstanceRsp(const CSBuyInstanceRsp& from);

  inline CSBuyInstanceRsp& operator=(const CSBuyInstanceRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBuyInstanceRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBuyInstanceRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBuyInstanceRsp* other);

  // implements Message ----------------------------------------------

  CSBuyInstanceRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBuyInstanceRsp& from);
  void MergeFrom(const CSBuyInstanceRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 WarID = 1;
  inline bool has_warid() const;
  inline void clear_warid();
  static const int kWarIDFieldNumber = 1;
  inline ::google::protobuf::uint32 warid() const;
  inline void set_warid(::google::protobuf::uint32 value);

  // required uint32 TotalCnt = 2;
  inline bool has_totalcnt() const;
  inline void clear_totalcnt();
  static const int kTotalCntFieldNumber = 2;
  inline ::google::protobuf::uint32 totalcnt() const;
  inline void set_totalcnt(::google::protobuf::uint32 value);

  // required uint32 UsedCnt = 3;
  inline bool has_usedcnt() const;
  inline void clear_usedcnt();
  static const int kUsedCntFieldNumber = 3;
  inline ::google::protobuf::uint32 usedcnt() const;
  inline void set_usedcnt(::google::protobuf::uint32 value);

  // required uint32 BoughtCnt = 4;
  inline bool has_boughtcnt() const;
  inline void clear_boughtcnt();
  static const int kBoughtCntFieldNumber = 4;
  inline ::google::protobuf::uint32 boughtcnt() const;
  inline void set_boughtcnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSBuyInstanceRsp)
 private:
  inline void set_has_warid();
  inline void clear_has_warid();
  inline void set_has_totalcnt();
  inline void clear_has_totalcnt();
  inline void set_has_usedcnt();
  inline void clear_has_usedcnt();
  inline void set_has_boughtcnt();
  inline void clear_has_boughtcnt();

  ::google::protobuf::uint32 warid_;
  ::google::protobuf::uint32 totalcnt_;
  ::google::protobuf::uint32 usedcnt_;
  ::google::protobuf::uint32 boughtcnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBuyInstanceRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSWarmapStarAwardRqst : public ::google::protobuf::MessageLite {
 public:
  CSWarmapStarAwardRqst();
  virtual ~CSWarmapStarAwardRqst();

  CSWarmapStarAwardRqst(const CSWarmapStarAwardRqst& from);

  inline CSWarmapStarAwardRqst& operator=(const CSWarmapStarAwardRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWarmapStarAwardRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWarmapStarAwardRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWarmapStarAwardRqst* other);

  // implements Message ----------------------------------------------

  CSWarmapStarAwardRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWarmapStarAwardRqst& from);
  void MergeFrom(const CSWarmapStarAwardRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 WarID = 1;
  inline bool has_warid() const;
  inline void clear_warid();
  static const int kWarIDFieldNumber = 1;
  inline ::google::protobuf::uint32 warid() const;
  inline void set_warid(::google::protobuf::uint32 value);

  // required uint32 StarCnt = 2;
  inline bool has_starcnt() const;
  inline void clear_starcnt();
  static const int kStarCntFieldNumber = 2;
  inline ::google::protobuf::uint32 starcnt() const;
  inline void set_starcnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSWarmapStarAwardRqst)
 private:
  inline void set_has_warid();
  inline void clear_has_warid();
  inline void set_has_starcnt();
  inline void clear_has_starcnt();

  ::google::protobuf::uint32 warid_;
  ::google::protobuf::uint32 starcnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWarmapStarAwardRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSWarmapStarAwardRsp : public ::google::protobuf::MessageLite {
 public:
  CSWarmapStarAwardRsp();
  virtual ~CSWarmapStarAwardRsp();

  CSWarmapStarAwardRsp(const CSWarmapStarAwardRsp& from);

  inline CSWarmapStarAwardRsp& operator=(const CSWarmapStarAwardRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWarmapStarAwardRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWarmapStarAwardRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWarmapStarAwardRsp* other);

  // implements Message ----------------------------------------------

  CSWarmapStarAwardRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWarmapStarAwardRsp& from);
  void MergeFrom(const CSWarmapStarAwardRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSAwardElement Award = 1;
  inline int award_size() const;
  inline void clear_award();
  static const int kAwardFieldNumber = 1;
  inline const ::vmsg::CSAwardElement& award(int index) const;
  inline ::vmsg::CSAwardElement* mutable_award(int index);
  inline ::vmsg::CSAwardElement* add_award();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >&
      award() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >*
      mutable_award();

  // repeated .vmsg.CSWarStarAward WarStarAwards = 2;
  inline int warstarawards_size() const;
  inline void clear_warstarawards();
  static const int kWarStarAwardsFieldNumber = 2;
  inline const ::vmsg::CSWarStarAward& warstarawards(int index) const;
  inline ::vmsg::CSWarStarAward* mutable_warstarawards(int index);
  inline ::vmsg::CSWarStarAward* add_warstarawards();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSWarStarAward >&
      warstarawards() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSWarStarAward >*
      mutable_warstarawards();

  // @@protoc_insertion_point(class_scope:vmsg.CSWarmapStarAwardRsp)
 private:

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement > award_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSWarStarAward > warstarawards_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWarmapStarAwardRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSWarMapRequest : public ::google::protobuf::MessageLite {
 public:
  CSWarMapRequest();
  virtual ~CSWarMapRequest();

  CSWarMapRequest(const CSWarMapRequest& from);

  inline CSWarMapRequest& operator=(const CSWarMapRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWarMapRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWarMapRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWarMapRequest* other);

  // implements Message ----------------------------------------------

  CSWarMapRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWarMapRequest& from);
  void MergeFrom(const CSWarMapRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSWarMapQueryRqst WarMapQuery_Rqst = 1;
  inline bool has_warmapquery_rqst() const;
  inline void clear_warmapquery_rqst();
  static const int kWarMapQueryRqstFieldNumber = 1;
  inline const ::vmsg::CSWarMapQueryRqst& warmapquery_rqst() const;
  inline ::vmsg::CSWarMapQueryRqst* mutable_warmapquery_rqst();
  inline ::vmsg::CSWarMapQueryRqst* release_warmapquery_rqst();
  inline void set_allocated_warmapquery_rqst(::vmsg::CSWarMapQueryRqst* warmapquery_rqst);

  // optional .vmsg.CSWarMapStartRqst WarMapStart_Rqst = 2;
  inline bool has_warmapstart_rqst() const;
  inline void clear_warmapstart_rqst();
  static const int kWarMapStartRqstFieldNumber = 2;
  inline const ::vmsg::CSWarMapStartRqst& warmapstart_rqst() const;
  inline ::vmsg::CSWarMapStartRqst* mutable_warmapstart_rqst();
  inline ::vmsg::CSWarMapStartRqst* release_warmapstart_rqst();
  inline void set_allocated_warmapstart_rqst(::vmsg::CSWarMapStartRqst* warmapstart_rqst);

  // optional .vmsg.CSWarMapEndRqst WarMapEnd_Rqst = 3;
  inline bool has_warmapend_rqst() const;
  inline void clear_warmapend_rqst();
  static const int kWarMapEndRqstFieldNumber = 3;
  inline const ::vmsg::CSWarMapEndRqst& warmapend_rqst() const;
  inline ::vmsg::CSWarMapEndRqst* mutable_warmapend_rqst();
  inline ::vmsg::CSWarMapEndRqst* release_warmapend_rqst();
  inline void set_allocated_warmapend_rqst(::vmsg::CSWarMapEndRqst* warmapend_rqst);

  // optional .vmsg.CSWarMapCardRqst WarMapCard_Rqst = 4;
  inline bool has_warmapcard_rqst() const;
  inline void clear_warmapcard_rqst();
  static const int kWarMapCardRqstFieldNumber = 4;
  inline const ::vmsg::CSWarMapCardRqst& warmapcard_rqst() const;
  inline ::vmsg::CSWarMapCardRqst* mutable_warmapcard_rqst();
  inline ::vmsg::CSWarMapCardRqst* release_warmapcard_rqst();
  inline void set_allocated_warmapcard_rqst(::vmsg::CSWarMapCardRqst* warmapcard_rqst);

  // optional .vmsg.CSSweepWarRqst SweepWar_Rqst = 5;
  inline bool has_sweepwar_rqst() const;
  inline void clear_sweepwar_rqst();
  static const int kSweepWarRqstFieldNumber = 5;
  inline const ::vmsg::CSSweepWarRqst& sweepwar_rqst() const;
  inline ::vmsg::CSSweepWarRqst* mutable_sweepwar_rqst();
  inline ::vmsg::CSSweepWarRqst* release_sweepwar_rqst();
  inline void set_allocated_sweepwar_rqst(::vmsg::CSSweepWarRqst* sweepwar_rqst);

  // optional .vmsg.CSQueryEliteWarMapRqst QueryEliteWarMap_Rqst = 6;
  inline bool has_queryelitewarmap_rqst() const;
  inline void clear_queryelitewarmap_rqst();
  static const int kQueryEliteWarMapRqstFieldNumber = 6;
  inline const ::vmsg::CSQueryEliteWarMapRqst& queryelitewarmap_rqst() const;
  inline ::vmsg::CSQueryEliteWarMapRqst* mutable_queryelitewarmap_rqst();
  inline ::vmsg::CSQueryEliteWarMapRqst* release_queryelitewarmap_rqst();
  inline void set_allocated_queryelitewarmap_rqst(::vmsg::CSQueryEliteWarMapRqst* queryelitewarmap_rqst);

  // optional .vmsg.CSResetEliteWarMapRqst ResetEliteWarMap_Rqst = 7;
  inline bool has_resetelitewarmap_rqst() const;
  inline void clear_resetelitewarmap_rqst();
  static const int kResetEliteWarMapRqstFieldNumber = 7;
  inline const ::vmsg::CSResetEliteWarMapRqst& resetelitewarmap_rqst() const;
  inline ::vmsg::CSResetEliteWarMapRqst* mutable_resetelitewarmap_rqst();
  inline ::vmsg::CSResetEliteWarMapRqst* release_resetelitewarmap_rqst();
  inline void set_allocated_resetelitewarmap_rqst(::vmsg::CSResetEliteWarMapRqst* resetelitewarmap_rqst);

  // optional .vmsg.CSStartEliteWarMapRqst StartEliteWarMap_Rqst = 8;
  inline bool has_startelitewarmap_rqst() const;
  inline void clear_startelitewarmap_rqst();
  static const int kStartEliteWarMapRqstFieldNumber = 8;
  inline const ::vmsg::CSStartEliteWarMapRqst& startelitewarmap_rqst() const;
  inline ::vmsg::CSStartEliteWarMapRqst* mutable_startelitewarmap_rqst();
  inline ::vmsg::CSStartEliteWarMapRqst* release_startelitewarmap_rqst();
  inline void set_allocated_startelitewarmap_rqst(::vmsg::CSStartEliteWarMapRqst* startelitewarmap_rqst);

  // optional .vmsg.CSEndEliteWarMapRqst EndEliteWarMap_Rqst = 9;
  inline bool has_endelitewarmap_rqst() const;
  inline void clear_endelitewarmap_rqst();
  static const int kEndEliteWarMapRqstFieldNumber = 9;
  inline const ::vmsg::CSEndEliteWarMapRqst& endelitewarmap_rqst() const;
  inline ::vmsg::CSEndEliteWarMapRqst* mutable_endelitewarmap_rqst();
  inline ::vmsg::CSEndEliteWarMapRqst* release_endelitewarmap_rqst();
  inline void set_allocated_endelitewarmap_rqst(::vmsg::CSEndEliteWarMapRqst* endelitewarmap_rqst);

  // optional .vmsg.CSSweepEliteWarRqst SweepEliteWarMap_Rqst = 10;
  inline bool has_sweepelitewarmap_rqst() const;
  inline void clear_sweepelitewarmap_rqst();
  static const int kSweepEliteWarMapRqstFieldNumber = 10;
  inline const ::vmsg::CSSweepEliteWarRqst& sweepelitewarmap_rqst() const;
  inline ::vmsg::CSSweepEliteWarRqst* mutable_sweepelitewarmap_rqst();
  inline ::vmsg::CSSweepEliteWarRqst* release_sweepelitewarmap_rqst();
  inline void set_allocated_sweepelitewarmap_rqst(::vmsg::CSSweepEliteWarRqst* sweepelitewarmap_rqst);

  // optional .vmsg.CSDailyInstancePassRqst PassDailyInstance_Rqst = 11;
  inline bool has_passdailyinstance_rqst() const;
  inline void clear_passdailyinstance_rqst();
  static const int kPassDailyInstanceRqstFieldNumber = 11;
  inline const ::vmsg::CSDailyInstancePassRqst& passdailyinstance_rqst() const;
  inline ::vmsg::CSDailyInstancePassRqst* mutable_passdailyinstance_rqst();
  inline ::vmsg::CSDailyInstancePassRqst* release_passdailyinstance_rqst();
  inline void set_allocated_passdailyinstance_rqst(::vmsg::CSDailyInstancePassRqst* passdailyinstance_rqst);

  // optional .vmsg.CSReliveRqst Relive_Rqst = 12;
  inline bool has_relive_rqst() const;
  inline void clear_relive_rqst();
  static const int kReliveRqstFieldNumber = 12;
  inline const ::vmsg::CSReliveRqst& relive_rqst() const;
  inline ::vmsg::CSReliveRqst* mutable_relive_rqst();
  inline ::vmsg::CSReliveRqst* release_relive_rqst();
  inline void set_allocated_relive_rqst(::vmsg::CSReliveRqst* relive_rqst);

  // optional .vmsg.CSBuyBulletRqst BuyBullet_Rqst = 13;
  inline bool has_buybullet_rqst() const;
  inline void clear_buybullet_rqst();
  static const int kBuyBulletRqstFieldNumber = 13;
  inline const ::vmsg::CSBuyBulletRqst& buybullet_rqst() const;
  inline ::vmsg::CSBuyBulletRqst* mutable_buybullet_rqst();
  inline ::vmsg::CSBuyBulletRqst* release_buybullet_rqst();
  inline void set_allocated_buybullet_rqst(::vmsg::CSBuyBulletRqst* buybullet_rqst);

  // optional .vmsg.CSBuyInstanceRqst BuyInstance_Rqst = 14;
  inline bool has_buyinstance_rqst() const;
  inline void clear_buyinstance_rqst();
  static const int kBuyInstanceRqstFieldNumber = 14;
  inline const ::vmsg::CSBuyInstanceRqst& buyinstance_rqst() const;
  inline ::vmsg::CSBuyInstanceRqst* mutable_buyinstance_rqst();
  inline ::vmsg::CSBuyInstanceRqst* release_buyinstance_rqst();
  inline void set_allocated_buyinstance_rqst(::vmsg::CSBuyInstanceRqst* buyinstance_rqst);

  // optional .vmsg.CSWarmapStarAwardRqst ClaimStarAward_Rqst = 15;
  inline bool has_claimstaraward_rqst() const;
  inline void clear_claimstaraward_rqst();
  static const int kClaimStarAwardRqstFieldNumber = 15;
  inline const ::vmsg::CSWarmapStarAwardRqst& claimstaraward_rqst() const;
  inline ::vmsg::CSWarmapStarAwardRqst* mutable_claimstaraward_rqst();
  inline ::vmsg::CSWarmapStarAwardRqst* release_claimstaraward_rqst();
  inline void set_allocated_claimstaraward_rqst(::vmsg::CSWarmapStarAwardRqst* claimstaraward_rqst);

  // @@protoc_insertion_point(class_scope:vmsg.CSWarMapRequest)
 private:
  inline void set_has_warmapquery_rqst();
  inline void clear_has_warmapquery_rqst();
  inline void set_has_warmapstart_rqst();
  inline void clear_has_warmapstart_rqst();
  inline void set_has_warmapend_rqst();
  inline void clear_has_warmapend_rqst();
  inline void set_has_warmapcard_rqst();
  inline void clear_has_warmapcard_rqst();
  inline void set_has_sweepwar_rqst();
  inline void clear_has_sweepwar_rqst();
  inline void set_has_queryelitewarmap_rqst();
  inline void clear_has_queryelitewarmap_rqst();
  inline void set_has_resetelitewarmap_rqst();
  inline void clear_has_resetelitewarmap_rqst();
  inline void set_has_startelitewarmap_rqst();
  inline void clear_has_startelitewarmap_rqst();
  inline void set_has_endelitewarmap_rqst();
  inline void clear_has_endelitewarmap_rqst();
  inline void set_has_sweepelitewarmap_rqst();
  inline void clear_has_sweepelitewarmap_rqst();
  inline void set_has_passdailyinstance_rqst();
  inline void clear_has_passdailyinstance_rqst();
  inline void set_has_relive_rqst();
  inline void clear_has_relive_rqst();
  inline void set_has_buybullet_rqst();
  inline void clear_has_buybullet_rqst();
  inline void set_has_buyinstance_rqst();
  inline void clear_has_buyinstance_rqst();
  inline void set_has_claimstaraward_rqst();
  inline void clear_has_claimstaraward_rqst();

  ::vmsg::CSWarMapQueryRqst* warmapquery_rqst_;
  ::vmsg::CSWarMapStartRqst* warmapstart_rqst_;
  ::vmsg::CSWarMapEndRqst* warmapend_rqst_;
  ::vmsg::CSWarMapCardRqst* warmapcard_rqst_;
  ::vmsg::CSSweepWarRqst* sweepwar_rqst_;
  ::vmsg::CSQueryEliteWarMapRqst* queryelitewarmap_rqst_;
  ::vmsg::CSResetEliteWarMapRqst* resetelitewarmap_rqst_;
  ::vmsg::CSStartEliteWarMapRqst* startelitewarmap_rqst_;
  ::vmsg::CSEndEliteWarMapRqst* endelitewarmap_rqst_;
  ::vmsg::CSSweepEliteWarRqst* sweepelitewarmap_rqst_;
  ::vmsg::CSDailyInstancePassRqst* passdailyinstance_rqst_;
  ::vmsg::CSReliveRqst* relive_rqst_;
  ::vmsg::CSBuyBulletRqst* buybullet_rqst_;
  ::vmsg::CSBuyInstanceRqst* buyinstance_rqst_;
  ::vmsg::CSWarmapStarAwardRqst* claimstaraward_rqst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWarMapRequest* default_instance_;
};
// -------------------------------------------------------------------

class CSWarMapRespond : public ::google::protobuf::MessageLite {
 public:
  CSWarMapRespond();
  virtual ~CSWarMapRespond();

  CSWarMapRespond(const CSWarMapRespond& from);

  inline CSWarMapRespond& operator=(const CSWarMapRespond& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWarMapRespond& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWarMapRespond* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWarMapRespond* other);

  // implements Message ----------------------------------------------

  CSWarMapRespond* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWarMapRespond& from);
  void MergeFrom(const CSWarMapRespond& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSWarMapQueryRsp WarMapQuery_Rsp = 1;
  inline bool has_warmapquery_rsp() const;
  inline void clear_warmapquery_rsp();
  static const int kWarMapQueryRspFieldNumber = 1;
  inline const ::vmsg::CSWarMapQueryRsp& warmapquery_rsp() const;
  inline ::vmsg::CSWarMapQueryRsp* mutable_warmapquery_rsp();
  inline ::vmsg::CSWarMapQueryRsp* release_warmapquery_rsp();
  inline void set_allocated_warmapquery_rsp(::vmsg::CSWarMapQueryRsp* warmapquery_rsp);

  // optional .vmsg.CSWarMapStartRsp WarMapStart_Rsp = 2;
  inline bool has_warmapstart_rsp() const;
  inline void clear_warmapstart_rsp();
  static const int kWarMapStartRspFieldNumber = 2;
  inline const ::vmsg::CSWarMapStartRsp& warmapstart_rsp() const;
  inline ::vmsg::CSWarMapStartRsp* mutable_warmapstart_rsp();
  inline ::vmsg::CSWarMapStartRsp* release_warmapstart_rsp();
  inline void set_allocated_warmapstart_rsp(::vmsg::CSWarMapStartRsp* warmapstart_rsp);

  // optional .vmsg.CSWarMapEndRsp WarMapEnd_Rsp = 3;
  inline bool has_warmapend_rsp() const;
  inline void clear_warmapend_rsp();
  static const int kWarMapEndRspFieldNumber = 3;
  inline const ::vmsg::CSWarMapEndRsp& warmapend_rsp() const;
  inline ::vmsg::CSWarMapEndRsp* mutable_warmapend_rsp();
  inline ::vmsg::CSWarMapEndRsp* release_warmapend_rsp();
  inline void set_allocated_warmapend_rsp(::vmsg::CSWarMapEndRsp* warmapend_rsp);

  // optional .vmsg.CSWarMapCardRsp WarMapCard_Rsp = 4;
  inline bool has_warmapcard_rsp() const;
  inline void clear_warmapcard_rsp();
  static const int kWarMapCardRspFieldNumber = 4;
  inline const ::vmsg::CSWarMapCardRsp& warmapcard_rsp() const;
  inline ::vmsg::CSWarMapCardRsp* mutable_warmapcard_rsp();
  inline ::vmsg::CSWarMapCardRsp* release_warmapcard_rsp();
  inline void set_allocated_warmapcard_rsp(::vmsg::CSWarMapCardRsp* warmapcard_rsp);

  // optional .vmsg.CSSweepWarRsp SweepWar_Rsp = 5;
  inline bool has_sweepwar_rsp() const;
  inline void clear_sweepwar_rsp();
  static const int kSweepWarRspFieldNumber = 5;
  inline const ::vmsg::CSSweepWarRsp& sweepwar_rsp() const;
  inline ::vmsg::CSSweepWarRsp* mutable_sweepwar_rsp();
  inline ::vmsg::CSSweepWarRsp* release_sweepwar_rsp();
  inline void set_allocated_sweepwar_rsp(::vmsg::CSSweepWarRsp* sweepwar_rsp);

  // optional .vmsg.CSEliteWarInfo QueryEliteWarMap_Rsp = 6;
  inline bool has_queryelitewarmap_rsp() const;
  inline void clear_queryelitewarmap_rsp();
  static const int kQueryEliteWarMapRspFieldNumber = 6;
  inline const ::vmsg::CSEliteWarInfo& queryelitewarmap_rsp() const;
  inline ::vmsg::CSEliteWarInfo* mutable_queryelitewarmap_rsp();
  inline ::vmsg::CSEliteWarInfo* release_queryelitewarmap_rsp();
  inline void set_allocated_queryelitewarmap_rsp(::vmsg::CSEliteWarInfo* queryelitewarmap_rsp);

  // optional .vmsg.CSEliteWarInfo ResetEliteWarMap_Rsp = 7;
  inline bool has_resetelitewarmap_rsp() const;
  inline void clear_resetelitewarmap_rsp();
  static const int kResetEliteWarMapRspFieldNumber = 7;
  inline const ::vmsg::CSEliteWarInfo& resetelitewarmap_rsp() const;
  inline ::vmsg::CSEliteWarInfo* mutable_resetelitewarmap_rsp();
  inline ::vmsg::CSEliteWarInfo* release_resetelitewarmap_rsp();
  inline void set_allocated_resetelitewarmap_rsp(::vmsg::CSEliteWarInfo* resetelitewarmap_rsp);

  // optional .vmsg.CSStartEliteWarMapRsp StartEliteWarMap_Rsp = 8;
  inline bool has_startelitewarmap_rsp() const;
  inline void clear_startelitewarmap_rsp();
  static const int kStartEliteWarMapRspFieldNumber = 8;
  inline const ::vmsg::CSStartEliteWarMapRsp& startelitewarmap_rsp() const;
  inline ::vmsg::CSStartEliteWarMapRsp* mutable_startelitewarmap_rsp();
  inline ::vmsg::CSStartEliteWarMapRsp* release_startelitewarmap_rsp();
  inline void set_allocated_startelitewarmap_rsp(::vmsg::CSStartEliteWarMapRsp* startelitewarmap_rsp);

  // optional .vmsg.CSEndEliteWarMapRsp EndEliteWarMap_Rsp = 9;
  inline bool has_endelitewarmap_rsp() const;
  inline void clear_endelitewarmap_rsp();
  static const int kEndEliteWarMapRspFieldNumber = 9;
  inline const ::vmsg::CSEndEliteWarMapRsp& endelitewarmap_rsp() const;
  inline ::vmsg::CSEndEliteWarMapRsp* mutable_endelitewarmap_rsp();
  inline ::vmsg::CSEndEliteWarMapRsp* release_endelitewarmap_rsp();
  inline void set_allocated_endelitewarmap_rsp(::vmsg::CSEndEliteWarMapRsp* endelitewarmap_rsp);

  // optional .vmsg.CSSweepEliteWarRsp SweepEliteWar_Rsp = 10;
  inline bool has_sweepelitewar_rsp() const;
  inline void clear_sweepelitewar_rsp();
  static const int kSweepEliteWarRspFieldNumber = 10;
  inline const ::vmsg::CSSweepEliteWarRsp& sweepelitewar_rsp() const;
  inline ::vmsg::CSSweepEliteWarRsp* mutable_sweepelitewar_rsp();
  inline ::vmsg::CSSweepEliteWarRsp* release_sweepelitewar_rsp();
  inline void set_allocated_sweepelitewar_rsp(::vmsg::CSSweepEliteWarRsp* sweepelitewar_rsp);

  // optional .vmsg.CSQueryDailyInstanceRsp QueryDailyInstance_Rsp = 11;
  inline bool has_querydailyinstance_rsp() const;
  inline void clear_querydailyinstance_rsp();
  static const int kQueryDailyInstanceRspFieldNumber = 11;
  inline const ::vmsg::CSQueryDailyInstanceRsp& querydailyinstance_rsp() const;
  inline ::vmsg::CSQueryDailyInstanceRsp* mutable_querydailyinstance_rsp();
  inline ::vmsg::CSQueryDailyInstanceRsp* release_querydailyinstance_rsp();
  inline void set_allocated_querydailyinstance_rsp(::vmsg::CSQueryDailyInstanceRsp* querydailyinstance_rsp);

  // optional .vmsg.CSDailyInstancePassRsp PassDailyInstance_Rsp = 12;
  inline bool has_passdailyinstance_rsp() const;
  inline void clear_passdailyinstance_rsp();
  static const int kPassDailyInstanceRspFieldNumber = 12;
  inline const ::vmsg::CSDailyInstancePassRsp& passdailyinstance_rsp() const;
  inline ::vmsg::CSDailyInstancePassRsp* mutable_passdailyinstance_rsp();
  inline ::vmsg::CSDailyInstancePassRsp* release_passdailyinstance_rsp();
  inline void set_allocated_passdailyinstance_rsp(::vmsg::CSDailyInstancePassRsp* passdailyinstance_rsp);

  // optional .vmsg.CSReliveRsp Relive_Rsp = 13;
  inline bool has_relive_rsp() const;
  inline void clear_relive_rsp();
  static const int kReliveRspFieldNumber = 13;
  inline const ::vmsg::CSReliveRsp& relive_rsp() const;
  inline ::vmsg::CSReliveRsp* mutable_relive_rsp();
  inline ::vmsg::CSReliveRsp* release_relive_rsp();
  inline void set_allocated_relive_rsp(::vmsg::CSReliveRsp* relive_rsp);

  // optional .vmsg.CSBuyBulletRsp BuyBullet_Rsp = 14;
  inline bool has_buybullet_rsp() const;
  inline void clear_buybullet_rsp();
  static const int kBuyBulletRspFieldNumber = 14;
  inline const ::vmsg::CSBuyBulletRsp& buybullet_rsp() const;
  inline ::vmsg::CSBuyBulletRsp* mutable_buybullet_rsp();
  inline ::vmsg::CSBuyBulletRsp* release_buybullet_rsp();
  inline void set_allocated_buybullet_rsp(::vmsg::CSBuyBulletRsp* buybullet_rsp);

  // optional .vmsg.CSBuyInstanceRsp BuyInstance_Rsp = 15;
  inline bool has_buyinstance_rsp() const;
  inline void clear_buyinstance_rsp();
  static const int kBuyInstanceRspFieldNumber = 15;
  inline const ::vmsg::CSBuyInstanceRsp& buyinstance_rsp() const;
  inline ::vmsg::CSBuyInstanceRsp* mutable_buyinstance_rsp();
  inline ::vmsg::CSBuyInstanceRsp* release_buyinstance_rsp();
  inline void set_allocated_buyinstance_rsp(::vmsg::CSBuyInstanceRsp* buyinstance_rsp);

  // optional .vmsg.CSWarmapStarAwardRsp ClaimStarAward_Rsp = 16;
  inline bool has_claimstaraward_rsp() const;
  inline void clear_claimstaraward_rsp();
  static const int kClaimStarAwardRspFieldNumber = 16;
  inline const ::vmsg::CSWarmapStarAwardRsp& claimstaraward_rsp() const;
  inline ::vmsg::CSWarmapStarAwardRsp* mutable_claimstaraward_rsp();
  inline ::vmsg::CSWarmapStarAwardRsp* release_claimstaraward_rsp();
  inline void set_allocated_claimstaraward_rsp(::vmsg::CSWarmapStarAwardRsp* claimstaraward_rsp);

  // @@protoc_insertion_point(class_scope:vmsg.CSWarMapRespond)
 private:
  inline void set_has_warmapquery_rsp();
  inline void clear_has_warmapquery_rsp();
  inline void set_has_warmapstart_rsp();
  inline void clear_has_warmapstart_rsp();
  inline void set_has_warmapend_rsp();
  inline void clear_has_warmapend_rsp();
  inline void set_has_warmapcard_rsp();
  inline void clear_has_warmapcard_rsp();
  inline void set_has_sweepwar_rsp();
  inline void clear_has_sweepwar_rsp();
  inline void set_has_queryelitewarmap_rsp();
  inline void clear_has_queryelitewarmap_rsp();
  inline void set_has_resetelitewarmap_rsp();
  inline void clear_has_resetelitewarmap_rsp();
  inline void set_has_startelitewarmap_rsp();
  inline void clear_has_startelitewarmap_rsp();
  inline void set_has_endelitewarmap_rsp();
  inline void clear_has_endelitewarmap_rsp();
  inline void set_has_sweepelitewar_rsp();
  inline void clear_has_sweepelitewar_rsp();
  inline void set_has_querydailyinstance_rsp();
  inline void clear_has_querydailyinstance_rsp();
  inline void set_has_passdailyinstance_rsp();
  inline void clear_has_passdailyinstance_rsp();
  inline void set_has_relive_rsp();
  inline void clear_has_relive_rsp();
  inline void set_has_buybullet_rsp();
  inline void clear_has_buybullet_rsp();
  inline void set_has_buyinstance_rsp();
  inline void clear_has_buyinstance_rsp();
  inline void set_has_claimstaraward_rsp();
  inline void clear_has_claimstaraward_rsp();

  ::vmsg::CSWarMapQueryRsp* warmapquery_rsp_;
  ::vmsg::CSWarMapStartRsp* warmapstart_rsp_;
  ::vmsg::CSWarMapEndRsp* warmapend_rsp_;
  ::vmsg::CSWarMapCardRsp* warmapcard_rsp_;
  ::vmsg::CSSweepWarRsp* sweepwar_rsp_;
  ::vmsg::CSEliteWarInfo* queryelitewarmap_rsp_;
  ::vmsg::CSEliteWarInfo* resetelitewarmap_rsp_;
  ::vmsg::CSStartEliteWarMapRsp* startelitewarmap_rsp_;
  ::vmsg::CSEndEliteWarMapRsp* endelitewarmap_rsp_;
  ::vmsg::CSSweepEliteWarRsp* sweepelitewar_rsp_;
  ::vmsg::CSQueryDailyInstanceRsp* querydailyinstance_rsp_;
  ::vmsg::CSDailyInstancePassRsp* passdailyinstance_rsp_;
  ::vmsg::CSReliveRsp* relive_rsp_;
  ::vmsg::CSBuyBulletRsp* buybullet_rsp_;
  ::vmsg::CSBuyInstanceRsp* buyinstance_rsp_;
  ::vmsg::CSWarmapStarAwardRsp* claimstaraward_rsp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWarMapMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWarMapMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWarMapMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWarMapRespond* default_instance_;
};
// ===================================================================


// ===================================================================

// CSWarMapQueryRqst

// required uint32 FromId = 1;
inline bool CSWarMapQueryRqst::has_fromid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWarMapQueryRqst::set_has_fromid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWarMapQueryRqst::clear_has_fromid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWarMapQueryRqst::clear_fromid() {
  fromid_ = 0u;
  clear_has_fromid();
}
inline ::google::protobuf::uint32 CSWarMapQueryRqst::fromid() const {
  return fromid_;
}
inline void CSWarMapQueryRqst::set_fromid(::google::protobuf::uint32 value) {
  set_has_fromid();
  fromid_ = value;
}

// required uint32 ToId = 2;
inline bool CSWarMapQueryRqst::has_toid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWarMapQueryRqst::set_has_toid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWarMapQueryRqst::clear_has_toid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWarMapQueryRqst::clear_toid() {
  toid_ = 0u;
  clear_has_toid();
}
inline ::google::protobuf::uint32 CSWarMapQueryRqst::toid() const {
  return toid_;
}
inline void CSWarMapQueryRqst::set_toid(::google::protobuf::uint32 value) {
  set_has_toid();
  toid_ = value;
}

// -------------------------------------------------------------------

// CSWarMapHidenAwardElmt

// required uint32 PackageID = 1;
inline bool CSWarMapHidenAwardElmt::has_packageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWarMapHidenAwardElmt::set_has_packageid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWarMapHidenAwardElmt::clear_has_packageid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWarMapHidenAwardElmt::clear_packageid() {
  packageid_ = 0u;
  clear_has_packageid();
}
inline ::google::protobuf::uint32 CSWarMapHidenAwardElmt::packageid() const {
  return packageid_;
}
inline void CSWarMapHidenAwardElmt::set_packageid(::google::protobuf::uint32 value) {
  set_has_packageid();
  packageid_ = value;
}

// required uint32 PacakceStatus = 2;
inline bool CSWarMapHidenAwardElmt::has_pacakcestatus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWarMapHidenAwardElmt::set_has_pacakcestatus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWarMapHidenAwardElmt::clear_has_pacakcestatus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWarMapHidenAwardElmt::clear_pacakcestatus() {
  pacakcestatus_ = 0u;
  clear_has_pacakcestatus();
}
inline ::google::protobuf::uint32 CSWarMapHidenAwardElmt::pacakcestatus() const {
  return pacakcestatus_;
}
inline void CSWarMapHidenAwardElmt::set_pacakcestatus(::google::protobuf::uint32 value) {
  set_has_pacakcestatus();
  pacakcestatus_ = value;
}

// -------------------------------------------------------------------

// CSStarAwardElmt

// required uint32 StarCnt = 1;
inline bool CSStarAwardElmt::has_starcnt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSStarAwardElmt::set_has_starcnt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSStarAwardElmt::clear_has_starcnt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSStarAwardElmt::clear_starcnt() {
  starcnt_ = 0u;
  clear_has_starcnt();
}
inline ::google::protobuf::uint32 CSStarAwardElmt::starcnt() const {
  return starcnt_;
}
inline void CSStarAwardElmt::set_starcnt(::google::protobuf::uint32 value) {
  set_has_starcnt();
  starcnt_ = value;
}

// required uint32 StarAward = 2;
inline bool CSStarAwardElmt::has_staraward() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSStarAwardElmt::set_has_staraward() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSStarAwardElmt::clear_has_staraward() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSStarAwardElmt::clear_staraward() {
  staraward_ = 0u;
  clear_has_staraward();
}
inline ::google::protobuf::uint32 CSStarAwardElmt::staraward() const {
  return staraward_;
}
inline void CSStarAwardElmt::set_staraward(::google::protobuf::uint32 value) {
  set_has_staraward();
  staraward_ = value;
}

// required uint32 ClaimStatus = 3;
inline bool CSStarAwardElmt::has_claimstatus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSStarAwardElmt::set_has_claimstatus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSStarAwardElmt::clear_has_claimstatus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSStarAwardElmt::clear_claimstatus() {
  claimstatus_ = 0u;
  clear_has_claimstatus();
}
inline ::google::protobuf::uint32 CSStarAwardElmt::claimstatus() const {
  return claimstatus_;
}
inline void CSStarAwardElmt::set_claimstatus(::google::protobuf::uint32 value) {
  set_has_claimstatus();
  claimstatus_ = value;
}

// -------------------------------------------------------------------

// CSWarStarAward

// repeated .vmsg.CSStarAwardElmt StarAwards = 1;
inline int CSWarStarAward::starawards_size() const {
  return starawards_.size();
}
inline void CSWarStarAward::clear_starawards() {
  starawards_.Clear();
}
inline const ::vmsg::CSStarAwardElmt& CSWarStarAward::starawards(int index) const {
  return starawards_.Get(index);
}
inline ::vmsg::CSStarAwardElmt* CSWarStarAward::mutable_starawards(int index) {
  return starawards_.Mutable(index);
}
inline ::vmsg::CSStarAwardElmt* CSWarStarAward::add_starawards() {
  return starawards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSStarAwardElmt >&
CSWarStarAward::starawards() const {
  return starawards_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSStarAwardElmt >*
CSWarStarAward::mutable_starawards() {
  return &starawards_;
}

// required uint32 TotalStarCnt = 2;
inline bool CSWarStarAward::has_totalstarcnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWarStarAward::set_has_totalstarcnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWarStarAward::clear_has_totalstarcnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWarStarAward::clear_totalstarcnt() {
  totalstarcnt_ = 0u;
  clear_has_totalstarcnt();
}
inline ::google::protobuf::uint32 CSWarStarAward::totalstarcnt() const {
  return totalstarcnt_;
}
inline void CSWarStarAward::set_totalstarcnt(::google::protobuf::uint32 value) {
  set_has_totalstarcnt();
  totalstarcnt_ = value;
}

// -------------------------------------------------------------------

// CSWarMapInfo

// required uint32 Score = 1;
inline bool CSWarMapInfo::has_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWarMapInfo::set_has_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWarMapInfo::clear_has_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWarMapInfo::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 CSWarMapInfo::score() const {
  return score_;
}
inline void CSWarMapInfo::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
}

// required uint32 FightCnt = 2;
inline bool CSWarMapInfo::has_fightcnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWarMapInfo::set_has_fightcnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWarMapInfo::clear_has_fightcnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWarMapInfo::clear_fightcnt() {
  fightcnt_ = 0u;
  clear_has_fightcnt();
}
inline ::google::protobuf::uint32 CSWarMapInfo::fightcnt() const {
  return fightcnt_;
}
inline void CSWarMapInfo::set_fightcnt(::google::protobuf::uint32 value) {
  set_has_fightcnt();
  fightcnt_ = value;
}

// required uint32 BoughtCnt = 3;
inline bool CSWarMapInfo::has_boughtcnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSWarMapInfo::set_has_boughtcnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSWarMapInfo::clear_has_boughtcnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSWarMapInfo::clear_boughtcnt() {
  boughtcnt_ = 0u;
  clear_has_boughtcnt();
}
inline ::google::protobuf::uint32 CSWarMapInfo::boughtcnt() const {
  return boughtcnt_;
}
inline void CSWarMapInfo::set_boughtcnt(::google::protobuf::uint32 value) {
  set_has_boughtcnt();
  boughtcnt_ = value;
}

// required uint32 TotalCnt = 4;
inline bool CSWarMapInfo::has_totalcnt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSWarMapInfo::set_has_totalcnt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSWarMapInfo::clear_has_totalcnt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSWarMapInfo::clear_totalcnt() {
  totalcnt_ = 0u;
  clear_has_totalcnt();
}
inline ::google::protobuf::uint32 CSWarMapInfo::totalcnt() const {
  return totalcnt_;
}
inline void CSWarMapInfo::set_totalcnt(::google::protobuf::uint32 value) {
  set_has_totalcnt();
  totalcnt_ = value;
}

// repeated .vmsg.CSWarMapHidenAwardElmt HidenAwards = 5;
inline int CSWarMapInfo::hidenawards_size() const {
  return hidenawards_.size();
}
inline void CSWarMapInfo::clear_hidenawards() {
  hidenawards_.Clear();
}
inline const ::vmsg::CSWarMapHidenAwardElmt& CSWarMapInfo::hidenawards(int index) const {
  return hidenawards_.Get(index);
}
inline ::vmsg::CSWarMapHidenAwardElmt* CSWarMapInfo::mutable_hidenawards(int index) {
  return hidenawards_.Mutable(index);
}
inline ::vmsg::CSWarMapHidenAwardElmt* CSWarMapInfo::add_hidenawards() {
  return hidenawards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSWarMapHidenAwardElmt >&
CSWarMapInfo::hidenawards() const {
  return hidenawards_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSWarMapHidenAwardElmt >*
CSWarMapInfo::mutable_hidenawards() {
  return &hidenawards_;
}

// -------------------------------------------------------------------

// CSWarMapQueryRsp

// required uint32 FromId = 1;
inline bool CSWarMapQueryRsp::has_fromid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWarMapQueryRsp::set_has_fromid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWarMapQueryRsp::clear_has_fromid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWarMapQueryRsp::clear_fromid() {
  fromid_ = 0u;
  clear_has_fromid();
}
inline ::google::protobuf::uint32 CSWarMapQueryRsp::fromid() const {
  return fromid_;
}
inline void CSWarMapQueryRsp::set_fromid(::google::protobuf::uint32 value) {
  set_has_fromid();
  fromid_ = value;
}

// required uint32 ToId = 2;
inline bool CSWarMapQueryRsp::has_toid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWarMapQueryRsp::set_has_toid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWarMapQueryRsp::clear_has_toid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWarMapQueryRsp::clear_toid() {
  toid_ = 0u;
  clear_has_toid();
}
inline ::google::protobuf::uint32 CSWarMapQueryRsp::toid() const {
  return toid_;
}
inline void CSWarMapQueryRsp::set_toid(::google::protobuf::uint32 value) {
  set_has_toid();
  toid_ = value;
}

// repeated .vmsg.CSWarMapInfo Infos = 3;
inline int CSWarMapQueryRsp::infos_size() const {
  return infos_.size();
}
inline void CSWarMapQueryRsp::clear_infos() {
  infos_.Clear();
}
inline const ::vmsg::CSWarMapInfo& CSWarMapQueryRsp::infos(int index) const {
  return infos_.Get(index);
}
inline ::vmsg::CSWarMapInfo* CSWarMapQueryRsp::mutable_infos(int index) {
  return infos_.Mutable(index);
}
inline ::vmsg::CSWarMapInfo* CSWarMapQueryRsp::add_infos() {
  return infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSWarMapInfo >&
CSWarMapQueryRsp::infos() const {
  return infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSWarMapInfo >*
CSWarMapQueryRsp::mutable_infos() {
  return &infos_;
}

// required uint32 NewestWarMapID = 4;
inline bool CSWarMapQueryRsp::has_newestwarmapid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSWarMapQueryRsp::set_has_newestwarmapid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSWarMapQueryRsp::clear_has_newestwarmapid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSWarMapQueryRsp::clear_newestwarmapid() {
  newestwarmapid_ = 0u;
  clear_has_newestwarmapid();
}
inline ::google::protobuf::uint32 CSWarMapQueryRsp::newestwarmapid() const {
  return newestwarmapid_;
}
inline void CSWarMapQueryRsp::set_newestwarmapid(::google::protobuf::uint32 value) {
  set_has_newestwarmapid();
  newestwarmapid_ = value;
}

// repeated .vmsg.CSWeapon InBattleWeapons = 5;
inline int CSWarMapQueryRsp::inbattleweapons_size() const {
  return inbattleweapons_.size();
}
inline void CSWarMapQueryRsp::clear_inbattleweapons() {
  inbattleweapons_.Clear();
}
inline const ::vmsg::CSWeapon& CSWarMapQueryRsp::inbattleweapons(int index) const {
  return inbattleweapons_.Get(index);
}
inline ::vmsg::CSWeapon* CSWarMapQueryRsp::mutable_inbattleweapons(int index) {
  return inbattleweapons_.Mutable(index);
}
inline ::vmsg::CSWeapon* CSWarMapQueryRsp::add_inbattleweapons() {
  return inbattleweapons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSWeapon >&
CSWarMapQueryRsp::inbattleweapons() const {
  return inbattleweapons_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSWeapon >*
CSWarMapQueryRsp::mutable_inbattleweapons() {
  return &inbattleweapons_;
}

// repeated .vmsg.CSWarStarAward WarStarAwards = 6;
inline int CSWarMapQueryRsp::warstarawards_size() const {
  return warstarawards_.size();
}
inline void CSWarMapQueryRsp::clear_warstarawards() {
  warstarawards_.Clear();
}
inline const ::vmsg::CSWarStarAward& CSWarMapQueryRsp::warstarawards(int index) const {
  return warstarawards_.Get(index);
}
inline ::vmsg::CSWarStarAward* CSWarMapQueryRsp::mutable_warstarawards(int index) {
  return warstarawards_.Mutable(index);
}
inline ::vmsg::CSWarStarAward* CSWarMapQueryRsp::add_warstarawards() {
  return warstarawards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSWarStarAward >&
CSWarMapQueryRsp::warstarawards() const {
  return warstarawards_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSWarStarAward >*
CSWarMapQueryRsp::mutable_warstarawards() {
  return &warstarawards_;
}

// -------------------------------------------------------------------

// CSWarMapStartRqst

// required uint32 WarMapId = 1;
inline bool CSWarMapStartRqst::has_warmapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWarMapStartRqst::set_has_warmapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWarMapStartRqst::clear_has_warmapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWarMapStartRqst::clear_warmapid() {
  warmapid_ = 0u;
  clear_has_warmapid();
}
inline ::google::protobuf::uint32 CSWarMapStartRqst::warmapid() const {
  return warmapid_;
}
inline void CSWarMapStartRqst::set_warmapid(::google::protobuf::uint32 value) {
  set_has_warmapid();
  warmapid_ = value;
}

// -------------------------------------------------------------------

// CSWarMapDropInfo

// required uint32 Id = 1;
inline bool CSWarMapDropInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWarMapDropInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWarMapDropInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWarMapDropInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSWarMapDropInfo::id() const {
  return id_;
}
inline void CSWarMapDropInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 DropCnt = 2;
inline bool CSWarMapDropInfo::has_dropcnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWarMapDropInfo::set_has_dropcnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWarMapDropInfo::clear_has_dropcnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWarMapDropInfo::clear_dropcnt() {
  dropcnt_ = 0u;
  clear_has_dropcnt();
}
inline ::google::protobuf::uint32 CSWarMapDropInfo::dropcnt() const {
  return dropcnt_;
}
inline void CSWarMapDropInfo::set_dropcnt(::google::protobuf::uint32 value) {
  set_has_dropcnt();
  dropcnt_ = value;
}

// -------------------------------------------------------------------

// CSWarMapStartRsp

// required uint32 WarMapId = 1;
inline bool CSWarMapStartRsp::has_warmapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWarMapStartRsp::set_has_warmapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWarMapStartRsp::clear_has_warmapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWarMapStartRsp::clear_warmapid() {
  warmapid_ = 0u;
  clear_has_warmapid();
}
inline ::google::protobuf::uint32 CSWarMapStartRsp::warmapid() const {
  return warmapid_;
}
inline void CSWarMapStartRsp::set_warmapid(::google::protobuf::uint32 value) {
  set_has_warmapid();
  warmapid_ = value;
}

// -------------------------------------------------------------------

// CSKillMonsterInfo

// required uint32 MonsterID = 1;
inline bool CSKillMonsterInfo::has_monsterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSKillMonsterInfo::set_has_monsterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSKillMonsterInfo::clear_has_monsterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSKillMonsterInfo::clear_monsterid() {
  monsterid_ = 0u;
  clear_has_monsterid();
}
inline ::google::protobuf::uint32 CSKillMonsterInfo::monsterid() const {
  return monsterid_;
}
inline void CSKillMonsterInfo::set_monsterid(::google::protobuf::uint32 value) {
  set_has_monsterid();
  monsterid_ = value;
}

// required uint32 MonsterCnt = 2;
inline bool CSKillMonsterInfo::has_monstercnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSKillMonsterInfo::set_has_monstercnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSKillMonsterInfo::clear_has_monstercnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSKillMonsterInfo::clear_monstercnt() {
  monstercnt_ = 0u;
  clear_has_monstercnt();
}
inline ::google::protobuf::uint32 CSKillMonsterInfo::monstercnt() const {
  return monstercnt_;
}
inline void CSKillMonsterInfo::set_monstercnt(::google::protobuf::uint32 value) {
  set_has_monstercnt();
  monstercnt_ = value;
}

// -------------------------------------------------------------------

// CSWarMapEndRqst

// required uint32 WarMapId = 1;
inline bool CSWarMapEndRqst::has_warmapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWarMapEndRqst::set_has_warmapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWarMapEndRqst::clear_has_warmapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWarMapEndRqst::clear_warmapid() {
  warmapid_ = 0u;
  clear_has_warmapid();
}
inline ::google::protobuf::uint32 CSWarMapEndRqst::warmapid() const {
  return warmapid_;
}
inline void CSWarMapEndRqst::set_warmapid(::google::protobuf::uint32 value) {
  set_has_warmapid();
  warmapid_ = value;
}

// repeated .vmsg.CSKillMonsterInfo MonsterInfos = 5;
inline int CSWarMapEndRqst::monsterinfos_size() const {
  return monsterinfos_.size();
}
inline void CSWarMapEndRqst::clear_monsterinfos() {
  monsterinfos_.Clear();
}
inline const ::vmsg::CSKillMonsterInfo& CSWarMapEndRqst::monsterinfos(int index) const {
  return monsterinfos_.Get(index);
}
inline ::vmsg::CSKillMonsterInfo* CSWarMapEndRqst::mutable_monsterinfos(int index) {
  return monsterinfos_.Mutable(index);
}
inline ::vmsg::CSKillMonsterInfo* CSWarMapEndRqst::add_monsterinfos() {
  return monsterinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSKillMonsterInfo >&
CSWarMapEndRqst::monsterinfos() const {
  return monsterinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSKillMonsterInfo >*
CSWarMapEndRqst::mutable_monsterinfos() {
  return &monsterinfos_;
}

// required uint32 BossID = 6;
inline bool CSWarMapEndRqst::has_bossid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSWarMapEndRqst::set_has_bossid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSWarMapEndRqst::clear_has_bossid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSWarMapEndRqst::clear_bossid() {
  bossid_ = 0u;
  clear_has_bossid();
}
inline ::google::protobuf::uint32 CSWarMapEndRqst::bossid() const {
  return bossid_;
}
inline void CSWarMapEndRqst::set_bossid(::google::protobuf::uint32 value) {
  set_has_bossid();
  bossid_ = value;
}

// required uint32 EvolutionUseCnt = 7;
inline bool CSWarMapEndRqst::has_evolutionusecnt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSWarMapEndRqst::set_has_evolutionusecnt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSWarMapEndRqst::clear_has_evolutionusecnt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSWarMapEndRqst::clear_evolutionusecnt() {
  evolutionusecnt_ = 0u;
  clear_has_evolutionusecnt();
}
inline ::google::protobuf::uint32 CSWarMapEndRqst::evolutionusecnt() const {
  return evolutionusecnt_;
}
inline void CSWarMapEndRqst::set_evolutionusecnt(::google::protobuf::uint32 value) {
  set_has_evolutionusecnt();
  evolutionusecnt_ = value;
}

// required uint32 Score = 8;
inline bool CSWarMapEndRqst::has_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSWarMapEndRqst::set_has_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSWarMapEndRqst::clear_has_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSWarMapEndRqst::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 CSWarMapEndRqst::score() const {
  return score_;
}
inline void CSWarMapEndRqst::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
}

// repeated uint32 HidenAwardCell = 9;
inline int CSWarMapEndRqst::hidenawardcell_size() const {
  return hidenawardcell_.size();
}
inline void CSWarMapEndRqst::clear_hidenawardcell() {
  hidenawardcell_.Clear();
}
inline ::google::protobuf::uint32 CSWarMapEndRqst::hidenawardcell(int index) const {
  return hidenawardcell_.Get(index);
}
inline void CSWarMapEndRqst::set_hidenawardcell(int index, ::google::protobuf::uint32 value) {
  hidenawardcell_.Set(index, value);
}
inline void CSWarMapEndRqst::add_hidenawardcell(::google::protobuf::uint32 value) {
  hidenawardcell_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSWarMapEndRqst::hidenawardcell() const {
  return hidenawardcell_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSWarMapEndRqst::mutable_hidenawardcell() {
  return &hidenawardcell_;
}

// -------------------------------------------------------------------

// CSWarMapEndRsp

// repeated .vmsg.CSAwardElement PackAwards = 1;
inline int CSWarMapEndRsp::packawards_size() const {
  return packawards_.size();
}
inline void CSWarMapEndRsp::clear_packawards() {
  packawards_.Clear();
}
inline const ::vmsg::CSAwardElement& CSWarMapEndRsp::packawards(int index) const {
  return packawards_.Get(index);
}
inline ::vmsg::CSAwardElement* CSWarMapEndRsp::mutable_packawards(int index) {
  return packawards_.Mutable(index);
}
inline ::vmsg::CSAwardElement* CSWarMapEndRsp::add_packawards() {
  return packawards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >&
CSWarMapEndRsp::packawards() const {
  return packawards_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >*
CSWarMapEndRsp::mutable_packawards() {
  return &packawards_;
}

// required uint32 AwardCoin = 2;
inline bool CSWarMapEndRsp::has_awardcoin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWarMapEndRsp::set_has_awardcoin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWarMapEndRsp::clear_has_awardcoin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWarMapEndRsp::clear_awardcoin() {
  awardcoin_ = 0u;
  clear_has_awardcoin();
}
inline ::google::protobuf::uint32 CSWarMapEndRsp::awardcoin() const {
  return awardcoin_;
}
inline void CSWarMapEndRsp::set_awardcoin(::google::protobuf::uint32 value) {
  set_has_awardcoin();
  awardcoin_ = value;
}

// required uint32 AwardExp = 3;
inline bool CSWarMapEndRsp::has_awardexp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSWarMapEndRsp::set_has_awardexp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSWarMapEndRsp::clear_has_awardexp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSWarMapEndRsp::clear_awardexp() {
  awardexp_ = 0u;
  clear_has_awardexp();
}
inline ::google::protobuf::uint32 CSWarMapEndRsp::awardexp() const {
  return awardexp_;
}
inline void CSWarMapEndRsp::set_awardexp(::google::protobuf::uint32 value) {
  set_has_awardexp();
  awardexp_ = value;
}

// repeated .vmsg.CSAwardElement HidenAwards = 4;
inline int CSWarMapEndRsp::hidenawards_size() const {
  return hidenawards_.size();
}
inline void CSWarMapEndRsp::clear_hidenawards() {
  hidenawards_.Clear();
}
inline const ::vmsg::CSAwardElement& CSWarMapEndRsp::hidenawards(int index) const {
  return hidenawards_.Get(index);
}
inline ::vmsg::CSAwardElement* CSWarMapEndRsp::mutable_hidenawards(int index) {
  return hidenawards_.Mutable(index);
}
inline ::vmsg::CSAwardElement* CSWarMapEndRsp::add_hidenawards() {
  return hidenawards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >&
CSWarMapEndRsp::hidenawards() const {
  return hidenawards_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >*
CSWarMapEndRsp::mutable_hidenawards() {
  return &hidenawards_;
}

// -------------------------------------------------------------------

// CSWarMapCardRqst

// required uint32 WarMapId = 1;
inline bool CSWarMapCardRqst::has_warmapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWarMapCardRqst::set_has_warmapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWarMapCardRqst::clear_has_warmapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWarMapCardRqst::clear_warmapid() {
  warmapid_ = 0u;
  clear_has_warmapid();
}
inline ::google::protobuf::uint32 CSWarMapCardRqst::warmapid() const {
  return warmapid_;
}
inline void CSWarMapCardRqst::set_warmapid(::google::protobuf::uint32 value) {
  set_has_warmapid();
  warmapid_ = value;
}

// required uint32 IsFree = 2;
inline bool CSWarMapCardRqst::has_isfree() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWarMapCardRqst::set_has_isfree() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWarMapCardRqst::clear_has_isfree() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWarMapCardRqst::clear_isfree() {
  isfree_ = 0u;
  clear_has_isfree();
}
inline ::google::protobuf::uint32 CSWarMapCardRqst::isfree() const {
  return isfree_;
}
inline void CSWarMapCardRqst::set_isfree(::google::protobuf::uint32 value) {
  set_has_isfree();
  isfree_ = value;
}

// -------------------------------------------------------------------

// CSWarMapCardRsp

// required uint32 IsFree = 1;
inline bool CSWarMapCardRsp::has_isfree() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWarMapCardRsp::set_has_isfree() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWarMapCardRsp::clear_has_isfree() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWarMapCardRsp::clear_isfree() {
  isfree_ = 0u;
  clear_has_isfree();
}
inline ::google::protobuf::uint32 CSWarMapCardRsp::isfree() const {
  return isfree_;
}
inline void CSWarMapCardRsp::set_isfree(::google::protobuf::uint32 value) {
  set_has_isfree();
  isfree_ = value;
}

// required uint32 AwardType = 2;
inline bool CSWarMapCardRsp::has_awardtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWarMapCardRsp::set_has_awardtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWarMapCardRsp::clear_has_awardtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWarMapCardRsp::clear_awardtype() {
  awardtype_ = 0u;
  clear_has_awardtype();
}
inline ::google::protobuf::uint32 CSWarMapCardRsp::awardtype() const {
  return awardtype_;
}
inline void CSWarMapCardRsp::set_awardtype(::google::protobuf::uint32 value) {
  set_has_awardtype();
  awardtype_ = value;
}

// required uint32 AwardID = 3;
inline bool CSWarMapCardRsp::has_awardid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSWarMapCardRsp::set_has_awardid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSWarMapCardRsp::clear_has_awardid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSWarMapCardRsp::clear_awardid() {
  awardid_ = 0u;
  clear_has_awardid();
}
inline ::google::protobuf::uint32 CSWarMapCardRsp::awardid() const {
  return awardid_;
}
inline void CSWarMapCardRsp::set_awardid(::google::protobuf::uint32 value) {
  set_has_awardid();
  awardid_ = value;
}

// required uint32 AwardCnt = 4;
inline bool CSWarMapCardRsp::has_awardcnt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSWarMapCardRsp::set_has_awardcnt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSWarMapCardRsp::clear_has_awardcnt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSWarMapCardRsp::clear_awardcnt() {
  awardcnt_ = 0u;
  clear_has_awardcnt();
}
inline ::google::protobuf::uint32 CSWarMapCardRsp::awardcnt() const {
  return awardcnt_;
}
inline void CSWarMapCardRsp::set_awardcnt(::google::protobuf::uint32 value) {
  set_has_awardcnt();
  awardcnt_ = value;
}

// -------------------------------------------------------------------

// CSSweepWarRqst

// required uint32 WarMapID = 1;
inline bool CSSweepWarRqst::has_warmapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSweepWarRqst::set_has_warmapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSweepWarRqst::clear_has_warmapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSweepWarRqst::clear_warmapid() {
  warmapid_ = 0u;
  clear_has_warmapid();
}
inline ::google::protobuf::uint32 CSSweepWarRqst::warmapid() const {
  return warmapid_;
}
inline void CSSweepWarRqst::set_warmapid(::google::protobuf::uint32 value) {
  set_has_warmapid();
  warmapid_ = value;
}

// required uint32 SweepRound = 2;
inline bool CSSweepWarRqst::has_sweepround() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSSweepWarRqst::set_has_sweepround() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSSweepWarRqst::clear_has_sweepround() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSSweepWarRqst::clear_sweepround() {
  sweepround_ = 0u;
  clear_has_sweepround();
}
inline ::google::protobuf::uint32 CSSweepWarRqst::sweepround() const {
  return sweepround_;
}
inline void CSSweepWarRqst::set_sweepround(::google::protobuf::uint32 value) {
  set_has_sweepround();
  sweepround_ = value;
}

// -------------------------------------------------------------------

// CSSweepAward

// repeated .vmsg.CSAwardElement Award = 1;
inline int CSSweepAward::award_size() const {
  return award_.size();
}
inline void CSSweepAward::clear_award() {
  award_.Clear();
}
inline const ::vmsg::CSAwardElement& CSSweepAward::award(int index) const {
  return award_.Get(index);
}
inline ::vmsg::CSAwardElement* CSSweepAward::mutable_award(int index) {
  return award_.Mutable(index);
}
inline ::vmsg::CSAwardElement* CSSweepAward::add_award() {
  return award_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >&
CSSweepAward::award() const {
  return award_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >*
CSSweepAward::mutable_award() {
  return &award_;
}

// required uint32 Exp = 2;
inline bool CSSweepAward::has_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSSweepAward::set_has_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSSweepAward::clear_has_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSSweepAward::clear_exp() {
  exp_ = 0u;
  clear_has_exp();
}
inline ::google::protobuf::uint32 CSSweepAward::exp() const {
  return exp_;
}
inline void CSSweepAward::set_exp(::google::protobuf::uint32 value) {
  set_has_exp();
  exp_ = value;
}

// required uint32 Coin = 3;
inline bool CSSweepAward::has_coin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSSweepAward::set_has_coin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSSweepAward::clear_has_coin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSSweepAward::clear_coin() {
  coin_ = 0u;
  clear_has_coin();
}
inline ::google::protobuf::uint32 CSSweepAward::coin() const {
  return coin_;
}
inline void CSSweepAward::set_coin(::google::protobuf::uint32 value) {
  set_has_coin();
  coin_ = value;
}

// -------------------------------------------------------------------

// CSSweepWarRsp

// repeated .vmsg.CSSweepAward AwardLst = 1;
inline int CSSweepWarRsp::awardlst_size() const {
  return awardlst_.size();
}
inline void CSSweepWarRsp::clear_awardlst() {
  awardlst_.Clear();
}
inline const ::vmsg::CSSweepAward& CSSweepWarRsp::awardlst(int index) const {
  return awardlst_.Get(index);
}
inline ::vmsg::CSSweepAward* CSSweepWarRsp::mutable_awardlst(int index) {
  return awardlst_.Mutable(index);
}
inline ::vmsg::CSSweepAward* CSSweepWarRsp::add_awardlst() {
  return awardlst_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSSweepAward >&
CSSweepWarRsp::awardlst() const {
  return awardlst_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSSweepAward >*
CSSweepWarRsp::mutable_awardlst() {
  return &awardlst_;
}

// required uint32 ErrorNo = 2;
inline bool CSSweepWarRsp::has_errorno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSSweepWarRsp::set_has_errorno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSSweepWarRsp::clear_has_errorno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSSweepWarRsp::clear_errorno() {
  errorno_ = 0u;
  clear_has_errorno();
}
inline ::google::protobuf::uint32 CSSweepWarRsp::errorno() const {
  return errorno_;
}
inline void CSSweepWarRsp::set_errorno(::google::protobuf::uint32 value) {
  set_has_errorno();
  errorno_ = value;
}

// required .vmsg.CSBagInfo BagInfo = 3;
inline bool CSSweepWarRsp::has_baginfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSSweepWarRsp::set_has_baginfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSSweepWarRsp::clear_has_baginfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSSweepWarRsp::clear_baginfo() {
  if (baginfo_ != NULL) baginfo_->::vmsg::CSBagInfo::Clear();
  clear_has_baginfo();
}
inline const ::vmsg::CSBagInfo& CSSweepWarRsp::baginfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return baginfo_ != NULL ? *baginfo_ : *default_instance().baginfo_;
#else
  return baginfo_ != NULL ? *baginfo_ : *default_instance_->baginfo_;
#endif
}
inline ::vmsg::CSBagInfo* CSSweepWarRsp::mutable_baginfo() {
  set_has_baginfo();
  if (baginfo_ == NULL) baginfo_ = new ::vmsg::CSBagInfo;
  return baginfo_;
}
inline ::vmsg::CSBagInfo* CSSweepWarRsp::release_baginfo() {
  clear_has_baginfo();
  ::vmsg::CSBagInfo* temp = baginfo_;
  baginfo_ = NULL;
  return temp;
}
inline void CSSweepWarRsp::set_allocated_baginfo(::vmsg::CSBagInfo* baginfo) {
  delete baginfo_;
  baginfo_ = baginfo;
  if (baginfo) {
    set_has_baginfo();
  } else {
    clear_has_baginfo();
  }
}

// -------------------------------------------------------------------

// CSQueryEliteWarMapRqst

// required uint32 EliteWarID = 1;
inline bool CSQueryEliteWarMapRqst::has_elitewarid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSQueryEliteWarMapRqst::set_has_elitewarid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSQueryEliteWarMapRqst::clear_has_elitewarid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSQueryEliteWarMapRqst::clear_elitewarid() {
  elitewarid_ = 0u;
  clear_has_elitewarid();
}
inline ::google::protobuf::uint32 CSQueryEliteWarMapRqst::elitewarid() const {
  return elitewarid_;
}
inline void CSQueryEliteWarMapRqst::set_elitewarid(::google::protobuf::uint32 value) {
  set_has_elitewarid();
  elitewarid_ = value;
}

// -------------------------------------------------------------------

// CSEliteWarInfo

// required uint32 EliteWarID = 1;
inline bool CSEliteWarInfo::has_elitewarid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEliteWarInfo::set_has_elitewarid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEliteWarInfo::clear_has_elitewarid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEliteWarInfo::clear_elitewarid() {
  elitewarid_ = 0u;
  clear_has_elitewarid();
}
inline ::google::protobuf::uint32 CSEliteWarInfo::elitewarid() const {
  return elitewarid_;
}
inline void CSEliteWarInfo::set_elitewarid(::google::protobuf::uint32 value) {
  set_has_elitewarid();
  elitewarid_ = value;
}

// repeated uint32 FightMapIDs = 2;
inline int CSEliteWarInfo::fightmapids_size() const {
  return fightmapids_.size();
}
inline void CSEliteWarInfo::clear_fightmapids() {
  fightmapids_.Clear();
}
inline ::google::protobuf::uint32 CSEliteWarInfo::fightmapids(int index) const {
  return fightmapids_.Get(index);
}
inline void CSEliteWarInfo::set_fightmapids(int index, ::google::protobuf::uint32 value) {
  fightmapids_.Set(index, value);
}
inline void CSEliteWarInfo::add_fightmapids(::google::protobuf::uint32 value) {
  fightmapids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSEliteWarInfo::fightmapids() const {
  return fightmapids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSEliteWarInfo::mutable_fightmapids() {
  return &fightmapids_;
}

// required uint32 RemainResetCnt = 3;
inline bool CSEliteWarInfo::has_remainresetcnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSEliteWarInfo::set_has_remainresetcnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSEliteWarInfo::clear_has_remainresetcnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSEliteWarInfo::clear_remainresetcnt() {
  remainresetcnt_ = 0u;
  clear_has_remainresetcnt();
}
inline ::google::protobuf::uint32 CSEliteWarInfo::remainresetcnt() const {
  return remainresetcnt_;
}
inline void CSEliteWarInfo::set_remainresetcnt(::google::protobuf::uint32 value) {
  set_has_remainresetcnt();
  remainresetcnt_ = value;
}

// required uint32 MaxEliteWarMapID = 4;
inline bool CSEliteWarInfo::has_maxelitewarmapid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSEliteWarInfo::set_has_maxelitewarmapid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSEliteWarInfo::clear_has_maxelitewarmapid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSEliteWarInfo::clear_maxelitewarmapid() {
  maxelitewarmapid_ = 0u;
  clear_has_maxelitewarmapid();
}
inline ::google::protobuf::uint32 CSEliteWarInfo::maxelitewarmapid() const {
  return maxelitewarmapid_;
}
inline void CSEliteWarInfo::set_maxelitewarmapid(::google::protobuf::uint32 value) {
  set_has_maxelitewarmapid();
  maxelitewarmapid_ = value;
}

// required uint32 ResetCost = 5;
inline bool CSEliteWarInfo::has_resetcost() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSEliteWarInfo::set_has_resetcost() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSEliteWarInfo::clear_has_resetcost() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSEliteWarInfo::clear_resetcost() {
  resetcost_ = 0u;
  clear_has_resetcost();
}
inline ::google::protobuf::uint32 CSEliteWarInfo::resetcost() const {
  return resetcost_;
}
inline void CSEliteWarInfo::set_resetcost(::google::protobuf::uint32 value) {
  set_has_resetcost();
  resetcost_ = value;
}

// -------------------------------------------------------------------

// CSResetEliteWarMapRqst

// required uint32 EliteWarID = 1;
inline bool CSResetEliteWarMapRqst::has_elitewarid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSResetEliteWarMapRqst::set_has_elitewarid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSResetEliteWarMapRqst::clear_has_elitewarid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSResetEliteWarMapRqst::clear_elitewarid() {
  elitewarid_ = 0u;
  clear_has_elitewarid();
}
inline ::google::protobuf::uint32 CSResetEliteWarMapRqst::elitewarid() const {
  return elitewarid_;
}
inline void CSResetEliteWarMapRqst::set_elitewarid(::google::protobuf::uint32 value) {
  set_has_elitewarid();
  elitewarid_ = value;
}

// -------------------------------------------------------------------

// CSStartEliteWarMapRqst

// required uint32 EliteWarMapID = 1;
inline bool CSStartEliteWarMapRqst::has_elitewarmapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSStartEliteWarMapRqst::set_has_elitewarmapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSStartEliteWarMapRqst::clear_has_elitewarmapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSStartEliteWarMapRqst::clear_elitewarmapid() {
  elitewarmapid_ = 0u;
  clear_has_elitewarmapid();
}
inline ::google::protobuf::uint32 CSStartEliteWarMapRqst::elitewarmapid() const {
  return elitewarmapid_;
}
inline void CSStartEliteWarMapRqst::set_elitewarmapid(::google::protobuf::uint32 value) {
  set_has_elitewarmapid();
  elitewarmapid_ = value;
}

// -------------------------------------------------------------------

// CSStartEliteWarMapRsp

// required uint32 EliteWarMapID = 1;
inline bool CSStartEliteWarMapRsp::has_elitewarmapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSStartEliteWarMapRsp::set_has_elitewarmapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSStartEliteWarMapRsp::clear_has_elitewarmapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSStartEliteWarMapRsp::clear_elitewarmapid() {
  elitewarmapid_ = 0u;
  clear_has_elitewarmapid();
}
inline ::google::protobuf::uint32 CSStartEliteWarMapRsp::elitewarmapid() const {
  return elitewarmapid_;
}
inline void CSStartEliteWarMapRsp::set_elitewarmapid(::google::protobuf::uint32 value) {
  set_has_elitewarmapid();
  elitewarmapid_ = value;
}

// -------------------------------------------------------------------

// CSEndEliteWarMapRqst

// required uint32 EliteWarMapID = 1;
inline bool CSEndEliteWarMapRqst::has_elitewarmapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEndEliteWarMapRqst::set_has_elitewarmapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEndEliteWarMapRqst::clear_has_elitewarmapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEndEliteWarMapRqst::clear_elitewarmapid() {
  elitewarmapid_ = 0u;
  clear_has_elitewarmapid();
}
inline ::google::protobuf::uint32 CSEndEliteWarMapRqst::elitewarmapid() const {
  return elitewarmapid_;
}
inline void CSEndEliteWarMapRqst::set_elitewarmapid(::google::protobuf::uint32 value) {
  set_has_elitewarmapid();
  elitewarmapid_ = value;
}

// required uint32 EvolutionUseCnt = 2;
inline bool CSEndEliteWarMapRqst::has_evolutionusecnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSEndEliteWarMapRqst::set_has_evolutionusecnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSEndEliteWarMapRqst::clear_has_evolutionusecnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSEndEliteWarMapRqst::clear_evolutionusecnt() {
  evolutionusecnt_ = 0u;
  clear_has_evolutionusecnt();
}
inline ::google::protobuf::uint32 CSEndEliteWarMapRqst::evolutionusecnt() const {
  return evolutionusecnt_;
}
inline void CSEndEliteWarMapRqst::set_evolutionusecnt(::google::protobuf::uint32 value) {
  set_has_evolutionusecnt();
  evolutionusecnt_ = value;
}

// required uint32 Score = 3;
inline bool CSEndEliteWarMapRqst::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSEndEliteWarMapRqst::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSEndEliteWarMapRqst::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSEndEliteWarMapRqst::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 CSEndEliteWarMapRqst::score() const {
  return score_;
}
inline void CSEndEliteWarMapRqst::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
}

// -------------------------------------------------------------------

// CSEliteAward

// required uint32 EliteWarMapID = 1;
inline bool CSEliteAward::has_elitewarmapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEliteAward::set_has_elitewarmapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEliteAward::clear_has_elitewarmapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEliteAward::clear_elitewarmapid() {
  elitewarmapid_ = 0u;
  clear_has_elitewarmapid();
}
inline ::google::protobuf::uint32 CSEliteAward::elitewarmapid() const {
  return elitewarmapid_;
}
inline void CSEliteAward::set_elitewarmapid(::google::protobuf::uint32 value) {
  set_has_elitewarmapid();
  elitewarmapid_ = value;
}

// repeated .vmsg.CSAwardElement Award = 2;
inline int CSEliteAward::award_size() const {
  return award_.size();
}
inline void CSEliteAward::clear_award() {
  award_.Clear();
}
inline const ::vmsg::CSAwardElement& CSEliteAward::award(int index) const {
  return award_.Get(index);
}
inline ::vmsg::CSAwardElement* CSEliteAward::mutable_award(int index) {
  return award_.Mutable(index);
}
inline ::vmsg::CSAwardElement* CSEliteAward::add_award() {
  return award_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >&
CSEliteAward::award() const {
  return award_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >*
CSEliteAward::mutable_award() {
  return &award_;
}

// -------------------------------------------------------------------

// CSEndEliteWarMapRsp

// required .vmsg.CSEliteAward EliteAward = 1;
inline bool CSEndEliteWarMapRsp::has_eliteaward() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEndEliteWarMapRsp::set_has_eliteaward() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEndEliteWarMapRsp::clear_has_eliteaward() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEndEliteWarMapRsp::clear_eliteaward() {
  if (eliteaward_ != NULL) eliteaward_->::vmsg::CSEliteAward::Clear();
  clear_has_eliteaward();
}
inline const ::vmsg::CSEliteAward& CSEndEliteWarMapRsp::eliteaward() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return eliteaward_ != NULL ? *eliteaward_ : *default_instance().eliteaward_;
#else
  return eliteaward_ != NULL ? *eliteaward_ : *default_instance_->eliteaward_;
#endif
}
inline ::vmsg::CSEliteAward* CSEndEliteWarMapRsp::mutable_eliteaward() {
  set_has_eliteaward();
  if (eliteaward_ == NULL) eliteaward_ = new ::vmsg::CSEliteAward;
  return eliteaward_;
}
inline ::vmsg::CSEliteAward* CSEndEliteWarMapRsp::release_eliteaward() {
  clear_has_eliteaward();
  ::vmsg::CSEliteAward* temp = eliteaward_;
  eliteaward_ = NULL;
  return temp;
}
inline void CSEndEliteWarMapRsp::set_allocated_eliteaward(::vmsg::CSEliteAward* eliteaward) {
  delete eliteaward_;
  eliteaward_ = eliteaward;
  if (eliteaward) {
    set_has_eliteaward();
  } else {
    clear_has_eliteaward();
  }
}

// -------------------------------------------------------------------

// CSSweepEliteWarRqst

// required uint32 EliteWarID = 1;
inline bool CSSweepEliteWarRqst::has_elitewarid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSweepEliteWarRqst::set_has_elitewarid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSweepEliteWarRqst::clear_has_elitewarid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSweepEliteWarRqst::clear_elitewarid() {
  elitewarid_ = 0u;
  clear_has_elitewarid();
}
inline ::google::protobuf::uint32 CSSweepEliteWarRqst::elitewarid() const {
  return elitewarid_;
}
inline void CSSweepEliteWarRqst::set_elitewarid(::google::protobuf::uint32 value) {
  set_has_elitewarid();
  elitewarid_ = value;
}

// -------------------------------------------------------------------

// CSSweepEliteWarRsp

// required .vmsg.CSEliteWarInfo Info = 1;
inline bool CSSweepEliteWarRsp::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSweepEliteWarRsp::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSweepEliteWarRsp::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSweepEliteWarRsp::clear_info() {
  if (info_ != NULL) info_->::vmsg::CSEliteWarInfo::Clear();
  clear_has_info();
}
inline const ::vmsg::CSEliteWarInfo& CSSweepEliteWarRsp::info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return info_ != NULL ? *info_ : *default_instance().info_;
#else
  return info_ != NULL ? *info_ : *default_instance_->info_;
#endif
}
inline ::vmsg::CSEliteWarInfo* CSSweepEliteWarRsp::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::vmsg::CSEliteWarInfo;
  return info_;
}
inline ::vmsg::CSEliteWarInfo* CSSweepEliteWarRsp::release_info() {
  clear_has_info();
  ::vmsg::CSEliteWarInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void CSSweepEliteWarRsp::set_allocated_info(::vmsg::CSEliteWarInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// repeated .vmsg.CSEliteAward AwardList = 2;
inline int CSSweepEliteWarRsp::awardlist_size() const {
  return awardlist_.size();
}
inline void CSSweepEliteWarRsp::clear_awardlist() {
  awardlist_.Clear();
}
inline const ::vmsg::CSEliteAward& CSSweepEliteWarRsp::awardlist(int index) const {
  return awardlist_.Get(index);
}
inline ::vmsg::CSEliteAward* CSSweepEliteWarRsp::mutable_awardlist(int index) {
  return awardlist_.Mutable(index);
}
inline ::vmsg::CSEliteAward* CSSweepEliteWarRsp::add_awardlist() {
  return awardlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSEliteAward >&
CSSweepEliteWarRsp::awardlist() const {
  return awardlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSEliteAward >*
CSSweepEliteWarRsp::mutable_awardlist() {
  return &awardlist_;
}

// optional int32 ErrorNo = 3;
inline bool CSSweepEliteWarRsp::has_errorno() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSSweepEliteWarRsp::set_has_errorno() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSSweepEliteWarRsp::clear_has_errorno() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSSweepEliteWarRsp::clear_errorno() {
  errorno_ = 0;
  clear_has_errorno();
}
inline ::google::protobuf::int32 CSSweepEliteWarRsp::errorno() const {
  return errorno_;
}
inline void CSSweepEliteWarRsp::set_errorno(::google::protobuf::int32 value) {
  set_has_errorno();
  errorno_ = value;
}

// -------------------------------------------------------------------

// CSDailyInstanceElmt

// required uint32 Key = 1;
inline bool CSDailyInstanceElmt::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDailyInstanceElmt::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDailyInstanceElmt::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDailyInstanceElmt::clear_key() {
  key_ = 0u;
  clear_has_key();
}
inline ::google::protobuf::uint32 CSDailyInstanceElmt::key() const {
  return key_;
}
inline void CSDailyInstanceElmt::set_key(::google::protobuf::uint32 value) {
  set_has_key();
  key_ = value;
}

// required uint32 ChallengeCnt = 2;
inline bool CSDailyInstanceElmt::has_challengecnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSDailyInstanceElmt::set_has_challengecnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSDailyInstanceElmt::clear_has_challengecnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSDailyInstanceElmt::clear_challengecnt() {
  challengecnt_ = 0u;
  clear_has_challengecnt();
}
inline ::google::protobuf::uint32 CSDailyInstanceElmt::challengecnt() const {
  return challengecnt_;
}
inline void CSDailyInstanceElmt::set_challengecnt(::google::protobuf::uint32 value) {
  set_has_challengecnt();
  challengecnt_ = value;
}

// -------------------------------------------------------------------

// CSQueryDailyInstanceRsp

// repeated .vmsg.CSDailyInstanceElmt Instances = 1;
inline int CSQueryDailyInstanceRsp::instances_size() const {
  return instances_.size();
}
inline void CSQueryDailyInstanceRsp::clear_instances() {
  instances_.Clear();
}
inline const ::vmsg::CSDailyInstanceElmt& CSQueryDailyInstanceRsp::instances(int index) const {
  return instances_.Get(index);
}
inline ::vmsg::CSDailyInstanceElmt* CSQueryDailyInstanceRsp::mutable_instances(int index) {
  return instances_.Mutable(index);
}
inline ::vmsg::CSDailyInstanceElmt* CSQueryDailyInstanceRsp::add_instances() {
  return instances_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSDailyInstanceElmt >&
CSQueryDailyInstanceRsp::instances() const {
  return instances_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSDailyInstanceElmt >*
CSQueryDailyInstanceRsp::mutable_instances() {
  return &instances_;
}

// -------------------------------------------------------------------

// CSDailyInstancePassRqst

// required uint32 PassLvl = 1;
inline bool CSDailyInstancePassRqst::has_passlvl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDailyInstancePassRqst::set_has_passlvl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDailyInstancePassRqst::clear_has_passlvl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDailyInstancePassRqst::clear_passlvl() {
  passlvl_ = 0u;
  clear_has_passlvl();
}
inline ::google::protobuf::uint32 CSDailyInstancePassRqst::passlvl() const {
  return passlvl_;
}
inline void CSDailyInstancePassRqst::set_passlvl(::google::protobuf::uint32 value) {
  set_has_passlvl();
  passlvl_ = value;
}

// required uint32 Key = 2;
inline bool CSDailyInstancePassRqst::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSDailyInstancePassRqst::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSDailyInstancePassRqst::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSDailyInstancePassRqst::clear_key() {
  key_ = 0u;
  clear_has_key();
}
inline ::google::protobuf::uint32 CSDailyInstancePassRqst::key() const {
  return key_;
}
inline void CSDailyInstancePassRqst::set_key(::google::protobuf::uint32 value) {
  set_has_key();
  key_ = value;
}

// -------------------------------------------------------------------

// CSDailyInstancePassRsp

// repeated .vmsg.CSDailyInstanceElmt Instances = 1;
inline int CSDailyInstancePassRsp::instances_size() const {
  return instances_.size();
}
inline void CSDailyInstancePassRsp::clear_instances() {
  instances_.Clear();
}
inline const ::vmsg::CSDailyInstanceElmt& CSDailyInstancePassRsp::instances(int index) const {
  return instances_.Get(index);
}
inline ::vmsg::CSDailyInstanceElmt* CSDailyInstancePassRsp::mutable_instances(int index) {
  return instances_.Mutable(index);
}
inline ::vmsg::CSDailyInstanceElmt* CSDailyInstancePassRsp::add_instances() {
  return instances_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSDailyInstanceElmt >&
CSDailyInstancePassRsp::instances() const {
  return instances_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSDailyInstanceElmt >*
CSDailyInstancePassRsp::mutable_instances() {
  return &instances_;
}

// repeated .vmsg.CSAwardElement AwardLst = 2;
inline int CSDailyInstancePassRsp::awardlst_size() const {
  return awardlst_.size();
}
inline void CSDailyInstancePassRsp::clear_awardlst() {
  awardlst_.Clear();
}
inline const ::vmsg::CSAwardElement& CSDailyInstancePassRsp::awardlst(int index) const {
  return awardlst_.Get(index);
}
inline ::vmsg::CSAwardElement* CSDailyInstancePassRsp::mutable_awardlst(int index) {
  return awardlst_.Mutable(index);
}
inline ::vmsg::CSAwardElement* CSDailyInstancePassRsp::add_awardlst() {
  return awardlst_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >&
CSDailyInstancePassRsp::awardlst() const {
  return awardlst_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >*
CSDailyInstancePassRsp::mutable_awardlst() {
  return &awardlst_;
}

// -------------------------------------------------------------------

// CSReliveRqst

// required int32 IsUseItem = 1;
inline bool CSReliveRqst::has_isuseitem() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSReliveRqst::set_has_isuseitem() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSReliveRqst::clear_has_isuseitem() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSReliveRqst::clear_isuseitem() {
  isuseitem_ = 0;
  clear_has_isuseitem();
}
inline ::google::protobuf::int32 CSReliveRqst::isuseitem() const {
  return isuseitem_;
}
inline void CSReliveRqst::set_isuseitem(::google::protobuf::int32 value) {
  set_has_isuseitem();
  isuseitem_ = value;
}

// optional int32 ItemID = 2;
inline bool CSReliveRqst::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSReliveRqst::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSReliveRqst::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSReliveRqst::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 CSReliveRqst::itemid() const {
  return itemid_;
}
inline void CSReliveRqst::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional int32 ItemBagIdx = 3;
inline bool CSReliveRqst::has_itembagidx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSReliveRqst::set_has_itembagidx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSReliveRqst::clear_has_itembagidx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSReliveRqst::clear_itembagidx() {
  itembagidx_ = 0;
  clear_has_itembagidx();
}
inline ::google::protobuf::int32 CSReliveRqst::itembagidx() const {
  return itembagidx_;
}
inline void CSReliveRqst::set_itembagidx(::google::protobuf::int32 value) {
  set_has_itembagidx();
  itembagidx_ = value;
}

// -------------------------------------------------------------------

// CSReliveRsp

// optional .vmsg.CSBagInfo BagInfo = 1;
inline bool CSReliveRsp::has_baginfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSReliveRsp::set_has_baginfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSReliveRsp::clear_has_baginfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSReliveRsp::clear_baginfo() {
  if (baginfo_ != NULL) baginfo_->::vmsg::CSBagInfo::Clear();
  clear_has_baginfo();
}
inline const ::vmsg::CSBagInfo& CSReliveRsp::baginfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return baginfo_ != NULL ? *baginfo_ : *default_instance().baginfo_;
#else
  return baginfo_ != NULL ? *baginfo_ : *default_instance_->baginfo_;
#endif
}
inline ::vmsg::CSBagInfo* CSReliveRsp::mutable_baginfo() {
  set_has_baginfo();
  if (baginfo_ == NULL) baginfo_ = new ::vmsg::CSBagInfo;
  return baginfo_;
}
inline ::vmsg::CSBagInfo* CSReliveRsp::release_baginfo() {
  clear_has_baginfo();
  ::vmsg::CSBagInfo* temp = baginfo_;
  baginfo_ = NULL;
  return temp;
}
inline void CSReliveRsp::set_allocated_baginfo(::vmsg::CSBagInfo* baginfo) {
  delete baginfo_;
  baginfo_ = baginfo;
  if (baginfo) {
    set_has_baginfo();
  } else {
    clear_has_baginfo();
  }
}

// required uint32 NextReliveCost = 2;
inline bool CSReliveRsp::has_nextrelivecost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSReliveRsp::set_has_nextrelivecost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSReliveRsp::clear_has_nextrelivecost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSReliveRsp::clear_nextrelivecost() {
  nextrelivecost_ = 0u;
  clear_has_nextrelivecost();
}
inline ::google::protobuf::uint32 CSReliveRsp::nextrelivecost() const {
  return nextrelivecost_;
}
inline void CSReliveRsp::set_nextrelivecost(::google::protobuf::uint32 value) {
  set_has_nextrelivecost();
  nextrelivecost_ = value;
}

// -------------------------------------------------------------------

// CSBuyBulletRqst

// required int32 IsUseItem = 1;
inline bool CSBuyBulletRqst::has_isuseitem() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBuyBulletRqst::set_has_isuseitem() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBuyBulletRqst::clear_has_isuseitem() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBuyBulletRqst::clear_isuseitem() {
  isuseitem_ = 0;
  clear_has_isuseitem();
}
inline ::google::protobuf::int32 CSBuyBulletRqst::isuseitem() const {
  return isuseitem_;
}
inline void CSBuyBulletRqst::set_isuseitem(::google::protobuf::int32 value) {
  set_has_isuseitem();
  isuseitem_ = value;
}

// optional int32 ItemID = 2;
inline bool CSBuyBulletRqst::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBuyBulletRqst::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBuyBulletRqst::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBuyBulletRqst::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 CSBuyBulletRqst::itemid() const {
  return itemid_;
}
inline void CSBuyBulletRqst::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional int32 ItemBagIdx = 3;
inline bool CSBuyBulletRqst::has_itembagidx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBuyBulletRqst::set_has_itembagidx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBuyBulletRqst::clear_has_itembagidx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBuyBulletRqst::clear_itembagidx() {
  itembagidx_ = 0;
  clear_has_itembagidx();
}
inline ::google::protobuf::int32 CSBuyBulletRqst::itembagidx() const {
  return itembagidx_;
}
inline void CSBuyBulletRqst::set_itembagidx(::google::protobuf::int32 value) {
  set_has_itembagidx();
  itembagidx_ = value;
}

// -------------------------------------------------------------------

// CSBuyBulletRsp

// optional .vmsg.CSBagInfo BagInfo = 1;
inline bool CSBuyBulletRsp::has_baginfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBuyBulletRsp::set_has_baginfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBuyBulletRsp::clear_has_baginfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBuyBulletRsp::clear_baginfo() {
  if (baginfo_ != NULL) baginfo_->::vmsg::CSBagInfo::Clear();
  clear_has_baginfo();
}
inline const ::vmsg::CSBagInfo& CSBuyBulletRsp::baginfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return baginfo_ != NULL ? *baginfo_ : *default_instance().baginfo_;
#else
  return baginfo_ != NULL ? *baginfo_ : *default_instance_->baginfo_;
#endif
}
inline ::vmsg::CSBagInfo* CSBuyBulletRsp::mutable_baginfo() {
  set_has_baginfo();
  if (baginfo_ == NULL) baginfo_ = new ::vmsg::CSBagInfo;
  return baginfo_;
}
inline ::vmsg::CSBagInfo* CSBuyBulletRsp::release_baginfo() {
  clear_has_baginfo();
  ::vmsg::CSBagInfo* temp = baginfo_;
  baginfo_ = NULL;
  return temp;
}
inline void CSBuyBulletRsp::set_allocated_baginfo(::vmsg::CSBagInfo* baginfo) {
  delete baginfo_;
  baginfo_ = baginfo;
  if (baginfo) {
    set_has_baginfo();
  } else {
    clear_has_baginfo();
  }
}

// required uint32 NextBulletCost = 2;
inline bool CSBuyBulletRsp::has_nextbulletcost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBuyBulletRsp::set_has_nextbulletcost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBuyBulletRsp::clear_has_nextbulletcost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBuyBulletRsp::clear_nextbulletcost() {
  nextbulletcost_ = 0u;
  clear_has_nextbulletcost();
}
inline ::google::protobuf::uint32 CSBuyBulletRsp::nextbulletcost() const {
  return nextbulletcost_;
}
inline void CSBuyBulletRsp::set_nextbulletcost(::google::protobuf::uint32 value) {
  set_has_nextbulletcost();
  nextbulletcost_ = value;
}

// -------------------------------------------------------------------

// CSBuyInstanceRqst

// required uint32 Count = 1;
inline bool CSBuyInstanceRqst::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBuyInstanceRqst::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBuyInstanceRqst::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBuyInstanceRqst::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CSBuyInstanceRqst::count() const {
  return count_;
}
inline void CSBuyInstanceRqst::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// required uint32 WarID = 2;
inline bool CSBuyInstanceRqst::has_warid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBuyInstanceRqst::set_has_warid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBuyInstanceRqst::clear_has_warid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBuyInstanceRqst::clear_warid() {
  warid_ = 0u;
  clear_has_warid();
}
inline ::google::protobuf::uint32 CSBuyInstanceRqst::warid() const {
  return warid_;
}
inline void CSBuyInstanceRqst::set_warid(::google::protobuf::uint32 value) {
  set_has_warid();
  warid_ = value;
}

// -------------------------------------------------------------------

// CSBuyInstanceRsp

// required uint32 WarID = 1;
inline bool CSBuyInstanceRsp::has_warid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBuyInstanceRsp::set_has_warid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBuyInstanceRsp::clear_has_warid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBuyInstanceRsp::clear_warid() {
  warid_ = 0u;
  clear_has_warid();
}
inline ::google::protobuf::uint32 CSBuyInstanceRsp::warid() const {
  return warid_;
}
inline void CSBuyInstanceRsp::set_warid(::google::protobuf::uint32 value) {
  set_has_warid();
  warid_ = value;
}

// required uint32 TotalCnt = 2;
inline bool CSBuyInstanceRsp::has_totalcnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBuyInstanceRsp::set_has_totalcnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBuyInstanceRsp::clear_has_totalcnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBuyInstanceRsp::clear_totalcnt() {
  totalcnt_ = 0u;
  clear_has_totalcnt();
}
inline ::google::protobuf::uint32 CSBuyInstanceRsp::totalcnt() const {
  return totalcnt_;
}
inline void CSBuyInstanceRsp::set_totalcnt(::google::protobuf::uint32 value) {
  set_has_totalcnt();
  totalcnt_ = value;
}

// required uint32 UsedCnt = 3;
inline bool CSBuyInstanceRsp::has_usedcnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBuyInstanceRsp::set_has_usedcnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBuyInstanceRsp::clear_has_usedcnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBuyInstanceRsp::clear_usedcnt() {
  usedcnt_ = 0u;
  clear_has_usedcnt();
}
inline ::google::protobuf::uint32 CSBuyInstanceRsp::usedcnt() const {
  return usedcnt_;
}
inline void CSBuyInstanceRsp::set_usedcnt(::google::protobuf::uint32 value) {
  set_has_usedcnt();
  usedcnt_ = value;
}

// required uint32 BoughtCnt = 4;
inline bool CSBuyInstanceRsp::has_boughtcnt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSBuyInstanceRsp::set_has_boughtcnt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSBuyInstanceRsp::clear_has_boughtcnt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSBuyInstanceRsp::clear_boughtcnt() {
  boughtcnt_ = 0u;
  clear_has_boughtcnt();
}
inline ::google::protobuf::uint32 CSBuyInstanceRsp::boughtcnt() const {
  return boughtcnt_;
}
inline void CSBuyInstanceRsp::set_boughtcnt(::google::protobuf::uint32 value) {
  set_has_boughtcnt();
  boughtcnt_ = value;
}

// -------------------------------------------------------------------

// CSWarmapStarAwardRqst

// required uint32 WarID = 1;
inline bool CSWarmapStarAwardRqst::has_warid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWarmapStarAwardRqst::set_has_warid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWarmapStarAwardRqst::clear_has_warid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWarmapStarAwardRqst::clear_warid() {
  warid_ = 0u;
  clear_has_warid();
}
inline ::google::protobuf::uint32 CSWarmapStarAwardRqst::warid() const {
  return warid_;
}
inline void CSWarmapStarAwardRqst::set_warid(::google::protobuf::uint32 value) {
  set_has_warid();
  warid_ = value;
}

// required uint32 StarCnt = 2;
inline bool CSWarmapStarAwardRqst::has_starcnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWarmapStarAwardRqst::set_has_starcnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWarmapStarAwardRqst::clear_has_starcnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWarmapStarAwardRqst::clear_starcnt() {
  starcnt_ = 0u;
  clear_has_starcnt();
}
inline ::google::protobuf::uint32 CSWarmapStarAwardRqst::starcnt() const {
  return starcnt_;
}
inline void CSWarmapStarAwardRqst::set_starcnt(::google::protobuf::uint32 value) {
  set_has_starcnt();
  starcnt_ = value;
}

// -------------------------------------------------------------------

// CSWarmapStarAwardRsp

// repeated .vmsg.CSAwardElement Award = 1;
inline int CSWarmapStarAwardRsp::award_size() const {
  return award_.size();
}
inline void CSWarmapStarAwardRsp::clear_award() {
  award_.Clear();
}
inline const ::vmsg::CSAwardElement& CSWarmapStarAwardRsp::award(int index) const {
  return award_.Get(index);
}
inline ::vmsg::CSAwardElement* CSWarmapStarAwardRsp::mutable_award(int index) {
  return award_.Mutable(index);
}
inline ::vmsg::CSAwardElement* CSWarmapStarAwardRsp::add_award() {
  return award_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >&
CSWarmapStarAwardRsp::award() const {
  return award_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >*
CSWarmapStarAwardRsp::mutable_award() {
  return &award_;
}

// repeated .vmsg.CSWarStarAward WarStarAwards = 2;
inline int CSWarmapStarAwardRsp::warstarawards_size() const {
  return warstarawards_.size();
}
inline void CSWarmapStarAwardRsp::clear_warstarawards() {
  warstarawards_.Clear();
}
inline const ::vmsg::CSWarStarAward& CSWarmapStarAwardRsp::warstarawards(int index) const {
  return warstarawards_.Get(index);
}
inline ::vmsg::CSWarStarAward* CSWarmapStarAwardRsp::mutable_warstarawards(int index) {
  return warstarawards_.Mutable(index);
}
inline ::vmsg::CSWarStarAward* CSWarmapStarAwardRsp::add_warstarawards() {
  return warstarawards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSWarStarAward >&
CSWarmapStarAwardRsp::warstarawards() const {
  return warstarawards_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSWarStarAward >*
CSWarmapStarAwardRsp::mutable_warstarawards() {
  return &warstarawards_;
}

// -------------------------------------------------------------------

// CSWarMapRequest

// optional .vmsg.CSWarMapQueryRqst WarMapQuery_Rqst = 1;
inline bool CSWarMapRequest::has_warmapquery_rqst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWarMapRequest::set_has_warmapquery_rqst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWarMapRequest::clear_has_warmapquery_rqst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWarMapRequest::clear_warmapquery_rqst() {
  if (warmapquery_rqst_ != NULL) warmapquery_rqst_->::vmsg::CSWarMapQueryRqst::Clear();
  clear_has_warmapquery_rqst();
}
inline const ::vmsg::CSWarMapQueryRqst& CSWarMapRequest::warmapquery_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return warmapquery_rqst_ != NULL ? *warmapquery_rqst_ : *default_instance().warmapquery_rqst_;
#else
  return warmapquery_rqst_ != NULL ? *warmapquery_rqst_ : *default_instance_->warmapquery_rqst_;
#endif
}
inline ::vmsg::CSWarMapQueryRqst* CSWarMapRequest::mutable_warmapquery_rqst() {
  set_has_warmapquery_rqst();
  if (warmapquery_rqst_ == NULL) warmapquery_rqst_ = new ::vmsg::CSWarMapQueryRqst;
  return warmapquery_rqst_;
}
inline ::vmsg::CSWarMapQueryRqst* CSWarMapRequest::release_warmapquery_rqst() {
  clear_has_warmapquery_rqst();
  ::vmsg::CSWarMapQueryRqst* temp = warmapquery_rqst_;
  warmapquery_rqst_ = NULL;
  return temp;
}
inline void CSWarMapRequest::set_allocated_warmapquery_rqst(::vmsg::CSWarMapQueryRqst* warmapquery_rqst) {
  delete warmapquery_rqst_;
  warmapquery_rqst_ = warmapquery_rqst;
  if (warmapquery_rqst) {
    set_has_warmapquery_rqst();
  } else {
    clear_has_warmapquery_rqst();
  }
}

// optional .vmsg.CSWarMapStartRqst WarMapStart_Rqst = 2;
inline bool CSWarMapRequest::has_warmapstart_rqst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWarMapRequest::set_has_warmapstart_rqst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWarMapRequest::clear_has_warmapstart_rqst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWarMapRequest::clear_warmapstart_rqst() {
  if (warmapstart_rqst_ != NULL) warmapstart_rqst_->::vmsg::CSWarMapStartRqst::Clear();
  clear_has_warmapstart_rqst();
}
inline const ::vmsg::CSWarMapStartRqst& CSWarMapRequest::warmapstart_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return warmapstart_rqst_ != NULL ? *warmapstart_rqst_ : *default_instance().warmapstart_rqst_;
#else
  return warmapstart_rqst_ != NULL ? *warmapstart_rqst_ : *default_instance_->warmapstart_rqst_;
#endif
}
inline ::vmsg::CSWarMapStartRqst* CSWarMapRequest::mutable_warmapstart_rqst() {
  set_has_warmapstart_rqst();
  if (warmapstart_rqst_ == NULL) warmapstart_rqst_ = new ::vmsg::CSWarMapStartRqst;
  return warmapstart_rqst_;
}
inline ::vmsg::CSWarMapStartRqst* CSWarMapRequest::release_warmapstart_rqst() {
  clear_has_warmapstart_rqst();
  ::vmsg::CSWarMapStartRqst* temp = warmapstart_rqst_;
  warmapstart_rqst_ = NULL;
  return temp;
}
inline void CSWarMapRequest::set_allocated_warmapstart_rqst(::vmsg::CSWarMapStartRqst* warmapstart_rqst) {
  delete warmapstart_rqst_;
  warmapstart_rqst_ = warmapstart_rqst;
  if (warmapstart_rqst) {
    set_has_warmapstart_rqst();
  } else {
    clear_has_warmapstart_rqst();
  }
}

// optional .vmsg.CSWarMapEndRqst WarMapEnd_Rqst = 3;
inline bool CSWarMapRequest::has_warmapend_rqst() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSWarMapRequest::set_has_warmapend_rqst() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSWarMapRequest::clear_has_warmapend_rqst() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSWarMapRequest::clear_warmapend_rqst() {
  if (warmapend_rqst_ != NULL) warmapend_rqst_->::vmsg::CSWarMapEndRqst::Clear();
  clear_has_warmapend_rqst();
}
inline const ::vmsg::CSWarMapEndRqst& CSWarMapRequest::warmapend_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return warmapend_rqst_ != NULL ? *warmapend_rqst_ : *default_instance().warmapend_rqst_;
#else
  return warmapend_rqst_ != NULL ? *warmapend_rqst_ : *default_instance_->warmapend_rqst_;
#endif
}
inline ::vmsg::CSWarMapEndRqst* CSWarMapRequest::mutable_warmapend_rqst() {
  set_has_warmapend_rqst();
  if (warmapend_rqst_ == NULL) warmapend_rqst_ = new ::vmsg::CSWarMapEndRqst;
  return warmapend_rqst_;
}
inline ::vmsg::CSWarMapEndRqst* CSWarMapRequest::release_warmapend_rqst() {
  clear_has_warmapend_rqst();
  ::vmsg::CSWarMapEndRqst* temp = warmapend_rqst_;
  warmapend_rqst_ = NULL;
  return temp;
}
inline void CSWarMapRequest::set_allocated_warmapend_rqst(::vmsg::CSWarMapEndRqst* warmapend_rqst) {
  delete warmapend_rqst_;
  warmapend_rqst_ = warmapend_rqst;
  if (warmapend_rqst) {
    set_has_warmapend_rqst();
  } else {
    clear_has_warmapend_rqst();
  }
}

// optional .vmsg.CSWarMapCardRqst WarMapCard_Rqst = 4;
inline bool CSWarMapRequest::has_warmapcard_rqst() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSWarMapRequest::set_has_warmapcard_rqst() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSWarMapRequest::clear_has_warmapcard_rqst() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSWarMapRequest::clear_warmapcard_rqst() {
  if (warmapcard_rqst_ != NULL) warmapcard_rqst_->::vmsg::CSWarMapCardRqst::Clear();
  clear_has_warmapcard_rqst();
}
inline const ::vmsg::CSWarMapCardRqst& CSWarMapRequest::warmapcard_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return warmapcard_rqst_ != NULL ? *warmapcard_rqst_ : *default_instance().warmapcard_rqst_;
#else
  return warmapcard_rqst_ != NULL ? *warmapcard_rqst_ : *default_instance_->warmapcard_rqst_;
#endif
}
inline ::vmsg::CSWarMapCardRqst* CSWarMapRequest::mutable_warmapcard_rqst() {
  set_has_warmapcard_rqst();
  if (warmapcard_rqst_ == NULL) warmapcard_rqst_ = new ::vmsg::CSWarMapCardRqst;
  return warmapcard_rqst_;
}
inline ::vmsg::CSWarMapCardRqst* CSWarMapRequest::release_warmapcard_rqst() {
  clear_has_warmapcard_rqst();
  ::vmsg::CSWarMapCardRqst* temp = warmapcard_rqst_;
  warmapcard_rqst_ = NULL;
  return temp;
}
inline void CSWarMapRequest::set_allocated_warmapcard_rqst(::vmsg::CSWarMapCardRqst* warmapcard_rqst) {
  delete warmapcard_rqst_;
  warmapcard_rqst_ = warmapcard_rqst;
  if (warmapcard_rqst) {
    set_has_warmapcard_rqst();
  } else {
    clear_has_warmapcard_rqst();
  }
}

// optional .vmsg.CSSweepWarRqst SweepWar_Rqst = 5;
inline bool CSWarMapRequest::has_sweepwar_rqst() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSWarMapRequest::set_has_sweepwar_rqst() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSWarMapRequest::clear_has_sweepwar_rqst() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSWarMapRequest::clear_sweepwar_rqst() {
  if (sweepwar_rqst_ != NULL) sweepwar_rqst_->::vmsg::CSSweepWarRqst::Clear();
  clear_has_sweepwar_rqst();
}
inline const ::vmsg::CSSweepWarRqst& CSWarMapRequest::sweepwar_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sweepwar_rqst_ != NULL ? *sweepwar_rqst_ : *default_instance().sweepwar_rqst_;
#else
  return sweepwar_rqst_ != NULL ? *sweepwar_rqst_ : *default_instance_->sweepwar_rqst_;
#endif
}
inline ::vmsg::CSSweepWarRqst* CSWarMapRequest::mutable_sweepwar_rqst() {
  set_has_sweepwar_rqst();
  if (sweepwar_rqst_ == NULL) sweepwar_rqst_ = new ::vmsg::CSSweepWarRqst;
  return sweepwar_rqst_;
}
inline ::vmsg::CSSweepWarRqst* CSWarMapRequest::release_sweepwar_rqst() {
  clear_has_sweepwar_rqst();
  ::vmsg::CSSweepWarRqst* temp = sweepwar_rqst_;
  sweepwar_rqst_ = NULL;
  return temp;
}
inline void CSWarMapRequest::set_allocated_sweepwar_rqst(::vmsg::CSSweepWarRqst* sweepwar_rqst) {
  delete sweepwar_rqst_;
  sweepwar_rqst_ = sweepwar_rqst;
  if (sweepwar_rqst) {
    set_has_sweepwar_rqst();
  } else {
    clear_has_sweepwar_rqst();
  }
}

// optional .vmsg.CSQueryEliteWarMapRqst QueryEliteWarMap_Rqst = 6;
inline bool CSWarMapRequest::has_queryelitewarmap_rqst() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSWarMapRequest::set_has_queryelitewarmap_rqst() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSWarMapRequest::clear_has_queryelitewarmap_rqst() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSWarMapRequest::clear_queryelitewarmap_rqst() {
  if (queryelitewarmap_rqst_ != NULL) queryelitewarmap_rqst_->::vmsg::CSQueryEliteWarMapRqst::Clear();
  clear_has_queryelitewarmap_rqst();
}
inline const ::vmsg::CSQueryEliteWarMapRqst& CSWarMapRequest::queryelitewarmap_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return queryelitewarmap_rqst_ != NULL ? *queryelitewarmap_rqst_ : *default_instance().queryelitewarmap_rqst_;
#else
  return queryelitewarmap_rqst_ != NULL ? *queryelitewarmap_rqst_ : *default_instance_->queryelitewarmap_rqst_;
#endif
}
inline ::vmsg::CSQueryEliteWarMapRqst* CSWarMapRequest::mutable_queryelitewarmap_rqst() {
  set_has_queryelitewarmap_rqst();
  if (queryelitewarmap_rqst_ == NULL) queryelitewarmap_rqst_ = new ::vmsg::CSQueryEliteWarMapRqst;
  return queryelitewarmap_rqst_;
}
inline ::vmsg::CSQueryEliteWarMapRqst* CSWarMapRequest::release_queryelitewarmap_rqst() {
  clear_has_queryelitewarmap_rqst();
  ::vmsg::CSQueryEliteWarMapRqst* temp = queryelitewarmap_rqst_;
  queryelitewarmap_rqst_ = NULL;
  return temp;
}
inline void CSWarMapRequest::set_allocated_queryelitewarmap_rqst(::vmsg::CSQueryEliteWarMapRqst* queryelitewarmap_rqst) {
  delete queryelitewarmap_rqst_;
  queryelitewarmap_rqst_ = queryelitewarmap_rqst;
  if (queryelitewarmap_rqst) {
    set_has_queryelitewarmap_rqst();
  } else {
    clear_has_queryelitewarmap_rqst();
  }
}

// optional .vmsg.CSResetEliteWarMapRqst ResetEliteWarMap_Rqst = 7;
inline bool CSWarMapRequest::has_resetelitewarmap_rqst() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSWarMapRequest::set_has_resetelitewarmap_rqst() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSWarMapRequest::clear_has_resetelitewarmap_rqst() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSWarMapRequest::clear_resetelitewarmap_rqst() {
  if (resetelitewarmap_rqst_ != NULL) resetelitewarmap_rqst_->::vmsg::CSResetEliteWarMapRqst::Clear();
  clear_has_resetelitewarmap_rqst();
}
inline const ::vmsg::CSResetEliteWarMapRqst& CSWarMapRequest::resetelitewarmap_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return resetelitewarmap_rqst_ != NULL ? *resetelitewarmap_rqst_ : *default_instance().resetelitewarmap_rqst_;
#else
  return resetelitewarmap_rqst_ != NULL ? *resetelitewarmap_rqst_ : *default_instance_->resetelitewarmap_rqst_;
#endif
}
inline ::vmsg::CSResetEliteWarMapRqst* CSWarMapRequest::mutable_resetelitewarmap_rqst() {
  set_has_resetelitewarmap_rqst();
  if (resetelitewarmap_rqst_ == NULL) resetelitewarmap_rqst_ = new ::vmsg::CSResetEliteWarMapRqst;
  return resetelitewarmap_rqst_;
}
inline ::vmsg::CSResetEliteWarMapRqst* CSWarMapRequest::release_resetelitewarmap_rqst() {
  clear_has_resetelitewarmap_rqst();
  ::vmsg::CSResetEliteWarMapRqst* temp = resetelitewarmap_rqst_;
  resetelitewarmap_rqst_ = NULL;
  return temp;
}
inline void CSWarMapRequest::set_allocated_resetelitewarmap_rqst(::vmsg::CSResetEliteWarMapRqst* resetelitewarmap_rqst) {
  delete resetelitewarmap_rqst_;
  resetelitewarmap_rqst_ = resetelitewarmap_rqst;
  if (resetelitewarmap_rqst) {
    set_has_resetelitewarmap_rqst();
  } else {
    clear_has_resetelitewarmap_rqst();
  }
}

// optional .vmsg.CSStartEliteWarMapRqst StartEliteWarMap_Rqst = 8;
inline bool CSWarMapRequest::has_startelitewarmap_rqst() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSWarMapRequest::set_has_startelitewarmap_rqst() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSWarMapRequest::clear_has_startelitewarmap_rqst() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSWarMapRequest::clear_startelitewarmap_rqst() {
  if (startelitewarmap_rqst_ != NULL) startelitewarmap_rqst_->::vmsg::CSStartEliteWarMapRqst::Clear();
  clear_has_startelitewarmap_rqst();
}
inline const ::vmsg::CSStartEliteWarMapRqst& CSWarMapRequest::startelitewarmap_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return startelitewarmap_rqst_ != NULL ? *startelitewarmap_rqst_ : *default_instance().startelitewarmap_rqst_;
#else
  return startelitewarmap_rqst_ != NULL ? *startelitewarmap_rqst_ : *default_instance_->startelitewarmap_rqst_;
#endif
}
inline ::vmsg::CSStartEliteWarMapRqst* CSWarMapRequest::mutable_startelitewarmap_rqst() {
  set_has_startelitewarmap_rqst();
  if (startelitewarmap_rqst_ == NULL) startelitewarmap_rqst_ = new ::vmsg::CSStartEliteWarMapRqst;
  return startelitewarmap_rqst_;
}
inline ::vmsg::CSStartEliteWarMapRqst* CSWarMapRequest::release_startelitewarmap_rqst() {
  clear_has_startelitewarmap_rqst();
  ::vmsg::CSStartEliteWarMapRqst* temp = startelitewarmap_rqst_;
  startelitewarmap_rqst_ = NULL;
  return temp;
}
inline void CSWarMapRequest::set_allocated_startelitewarmap_rqst(::vmsg::CSStartEliteWarMapRqst* startelitewarmap_rqst) {
  delete startelitewarmap_rqst_;
  startelitewarmap_rqst_ = startelitewarmap_rqst;
  if (startelitewarmap_rqst) {
    set_has_startelitewarmap_rqst();
  } else {
    clear_has_startelitewarmap_rqst();
  }
}

// optional .vmsg.CSEndEliteWarMapRqst EndEliteWarMap_Rqst = 9;
inline bool CSWarMapRequest::has_endelitewarmap_rqst() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSWarMapRequest::set_has_endelitewarmap_rqst() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSWarMapRequest::clear_has_endelitewarmap_rqst() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSWarMapRequest::clear_endelitewarmap_rqst() {
  if (endelitewarmap_rqst_ != NULL) endelitewarmap_rqst_->::vmsg::CSEndEliteWarMapRqst::Clear();
  clear_has_endelitewarmap_rqst();
}
inline const ::vmsg::CSEndEliteWarMapRqst& CSWarMapRequest::endelitewarmap_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return endelitewarmap_rqst_ != NULL ? *endelitewarmap_rqst_ : *default_instance().endelitewarmap_rqst_;
#else
  return endelitewarmap_rqst_ != NULL ? *endelitewarmap_rqst_ : *default_instance_->endelitewarmap_rqst_;
#endif
}
inline ::vmsg::CSEndEliteWarMapRqst* CSWarMapRequest::mutable_endelitewarmap_rqst() {
  set_has_endelitewarmap_rqst();
  if (endelitewarmap_rqst_ == NULL) endelitewarmap_rqst_ = new ::vmsg::CSEndEliteWarMapRqst;
  return endelitewarmap_rqst_;
}
inline ::vmsg::CSEndEliteWarMapRqst* CSWarMapRequest::release_endelitewarmap_rqst() {
  clear_has_endelitewarmap_rqst();
  ::vmsg::CSEndEliteWarMapRqst* temp = endelitewarmap_rqst_;
  endelitewarmap_rqst_ = NULL;
  return temp;
}
inline void CSWarMapRequest::set_allocated_endelitewarmap_rqst(::vmsg::CSEndEliteWarMapRqst* endelitewarmap_rqst) {
  delete endelitewarmap_rqst_;
  endelitewarmap_rqst_ = endelitewarmap_rqst;
  if (endelitewarmap_rqst) {
    set_has_endelitewarmap_rqst();
  } else {
    clear_has_endelitewarmap_rqst();
  }
}

// optional .vmsg.CSSweepEliteWarRqst SweepEliteWarMap_Rqst = 10;
inline bool CSWarMapRequest::has_sweepelitewarmap_rqst() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CSWarMapRequest::set_has_sweepelitewarmap_rqst() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CSWarMapRequest::clear_has_sweepelitewarmap_rqst() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CSWarMapRequest::clear_sweepelitewarmap_rqst() {
  if (sweepelitewarmap_rqst_ != NULL) sweepelitewarmap_rqst_->::vmsg::CSSweepEliteWarRqst::Clear();
  clear_has_sweepelitewarmap_rqst();
}
inline const ::vmsg::CSSweepEliteWarRqst& CSWarMapRequest::sweepelitewarmap_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sweepelitewarmap_rqst_ != NULL ? *sweepelitewarmap_rqst_ : *default_instance().sweepelitewarmap_rqst_;
#else
  return sweepelitewarmap_rqst_ != NULL ? *sweepelitewarmap_rqst_ : *default_instance_->sweepelitewarmap_rqst_;
#endif
}
inline ::vmsg::CSSweepEliteWarRqst* CSWarMapRequest::mutable_sweepelitewarmap_rqst() {
  set_has_sweepelitewarmap_rqst();
  if (sweepelitewarmap_rqst_ == NULL) sweepelitewarmap_rqst_ = new ::vmsg::CSSweepEliteWarRqst;
  return sweepelitewarmap_rqst_;
}
inline ::vmsg::CSSweepEliteWarRqst* CSWarMapRequest::release_sweepelitewarmap_rqst() {
  clear_has_sweepelitewarmap_rqst();
  ::vmsg::CSSweepEliteWarRqst* temp = sweepelitewarmap_rqst_;
  sweepelitewarmap_rqst_ = NULL;
  return temp;
}
inline void CSWarMapRequest::set_allocated_sweepelitewarmap_rqst(::vmsg::CSSweepEliteWarRqst* sweepelitewarmap_rqst) {
  delete sweepelitewarmap_rqst_;
  sweepelitewarmap_rqst_ = sweepelitewarmap_rqst;
  if (sweepelitewarmap_rqst) {
    set_has_sweepelitewarmap_rqst();
  } else {
    clear_has_sweepelitewarmap_rqst();
  }
}

// optional .vmsg.CSDailyInstancePassRqst PassDailyInstance_Rqst = 11;
inline bool CSWarMapRequest::has_passdailyinstance_rqst() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CSWarMapRequest::set_has_passdailyinstance_rqst() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CSWarMapRequest::clear_has_passdailyinstance_rqst() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CSWarMapRequest::clear_passdailyinstance_rqst() {
  if (passdailyinstance_rqst_ != NULL) passdailyinstance_rqst_->::vmsg::CSDailyInstancePassRqst::Clear();
  clear_has_passdailyinstance_rqst();
}
inline const ::vmsg::CSDailyInstancePassRqst& CSWarMapRequest::passdailyinstance_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return passdailyinstance_rqst_ != NULL ? *passdailyinstance_rqst_ : *default_instance().passdailyinstance_rqst_;
#else
  return passdailyinstance_rqst_ != NULL ? *passdailyinstance_rqst_ : *default_instance_->passdailyinstance_rqst_;
#endif
}
inline ::vmsg::CSDailyInstancePassRqst* CSWarMapRequest::mutable_passdailyinstance_rqst() {
  set_has_passdailyinstance_rqst();
  if (passdailyinstance_rqst_ == NULL) passdailyinstance_rqst_ = new ::vmsg::CSDailyInstancePassRqst;
  return passdailyinstance_rqst_;
}
inline ::vmsg::CSDailyInstancePassRqst* CSWarMapRequest::release_passdailyinstance_rqst() {
  clear_has_passdailyinstance_rqst();
  ::vmsg::CSDailyInstancePassRqst* temp = passdailyinstance_rqst_;
  passdailyinstance_rqst_ = NULL;
  return temp;
}
inline void CSWarMapRequest::set_allocated_passdailyinstance_rqst(::vmsg::CSDailyInstancePassRqst* passdailyinstance_rqst) {
  delete passdailyinstance_rqst_;
  passdailyinstance_rqst_ = passdailyinstance_rqst;
  if (passdailyinstance_rqst) {
    set_has_passdailyinstance_rqst();
  } else {
    clear_has_passdailyinstance_rqst();
  }
}

// optional .vmsg.CSReliveRqst Relive_Rqst = 12;
inline bool CSWarMapRequest::has_relive_rqst() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CSWarMapRequest::set_has_relive_rqst() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CSWarMapRequest::clear_has_relive_rqst() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CSWarMapRequest::clear_relive_rqst() {
  if (relive_rqst_ != NULL) relive_rqst_->::vmsg::CSReliveRqst::Clear();
  clear_has_relive_rqst();
}
inline const ::vmsg::CSReliveRqst& CSWarMapRequest::relive_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return relive_rqst_ != NULL ? *relive_rqst_ : *default_instance().relive_rqst_;
#else
  return relive_rqst_ != NULL ? *relive_rqst_ : *default_instance_->relive_rqst_;
#endif
}
inline ::vmsg::CSReliveRqst* CSWarMapRequest::mutable_relive_rqst() {
  set_has_relive_rqst();
  if (relive_rqst_ == NULL) relive_rqst_ = new ::vmsg::CSReliveRqst;
  return relive_rqst_;
}
inline ::vmsg::CSReliveRqst* CSWarMapRequest::release_relive_rqst() {
  clear_has_relive_rqst();
  ::vmsg::CSReliveRqst* temp = relive_rqst_;
  relive_rqst_ = NULL;
  return temp;
}
inline void CSWarMapRequest::set_allocated_relive_rqst(::vmsg::CSReliveRqst* relive_rqst) {
  delete relive_rqst_;
  relive_rqst_ = relive_rqst;
  if (relive_rqst) {
    set_has_relive_rqst();
  } else {
    clear_has_relive_rqst();
  }
}

// optional .vmsg.CSBuyBulletRqst BuyBullet_Rqst = 13;
inline bool CSWarMapRequest::has_buybullet_rqst() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CSWarMapRequest::set_has_buybullet_rqst() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CSWarMapRequest::clear_has_buybullet_rqst() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CSWarMapRequest::clear_buybullet_rqst() {
  if (buybullet_rqst_ != NULL) buybullet_rqst_->::vmsg::CSBuyBulletRqst::Clear();
  clear_has_buybullet_rqst();
}
inline const ::vmsg::CSBuyBulletRqst& CSWarMapRequest::buybullet_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return buybullet_rqst_ != NULL ? *buybullet_rqst_ : *default_instance().buybullet_rqst_;
#else
  return buybullet_rqst_ != NULL ? *buybullet_rqst_ : *default_instance_->buybullet_rqst_;
#endif
}
inline ::vmsg::CSBuyBulletRqst* CSWarMapRequest::mutable_buybullet_rqst() {
  set_has_buybullet_rqst();
  if (buybullet_rqst_ == NULL) buybullet_rqst_ = new ::vmsg::CSBuyBulletRqst;
  return buybullet_rqst_;
}
inline ::vmsg::CSBuyBulletRqst* CSWarMapRequest::release_buybullet_rqst() {
  clear_has_buybullet_rqst();
  ::vmsg::CSBuyBulletRqst* temp = buybullet_rqst_;
  buybullet_rqst_ = NULL;
  return temp;
}
inline void CSWarMapRequest::set_allocated_buybullet_rqst(::vmsg::CSBuyBulletRqst* buybullet_rqst) {
  delete buybullet_rqst_;
  buybullet_rqst_ = buybullet_rqst;
  if (buybullet_rqst) {
    set_has_buybullet_rqst();
  } else {
    clear_has_buybullet_rqst();
  }
}

// optional .vmsg.CSBuyInstanceRqst BuyInstance_Rqst = 14;
inline bool CSWarMapRequest::has_buyinstance_rqst() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CSWarMapRequest::set_has_buyinstance_rqst() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CSWarMapRequest::clear_has_buyinstance_rqst() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CSWarMapRequest::clear_buyinstance_rqst() {
  if (buyinstance_rqst_ != NULL) buyinstance_rqst_->::vmsg::CSBuyInstanceRqst::Clear();
  clear_has_buyinstance_rqst();
}
inline const ::vmsg::CSBuyInstanceRqst& CSWarMapRequest::buyinstance_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return buyinstance_rqst_ != NULL ? *buyinstance_rqst_ : *default_instance().buyinstance_rqst_;
#else
  return buyinstance_rqst_ != NULL ? *buyinstance_rqst_ : *default_instance_->buyinstance_rqst_;
#endif
}
inline ::vmsg::CSBuyInstanceRqst* CSWarMapRequest::mutable_buyinstance_rqst() {
  set_has_buyinstance_rqst();
  if (buyinstance_rqst_ == NULL) buyinstance_rqst_ = new ::vmsg::CSBuyInstanceRqst;
  return buyinstance_rqst_;
}
inline ::vmsg::CSBuyInstanceRqst* CSWarMapRequest::release_buyinstance_rqst() {
  clear_has_buyinstance_rqst();
  ::vmsg::CSBuyInstanceRqst* temp = buyinstance_rqst_;
  buyinstance_rqst_ = NULL;
  return temp;
}
inline void CSWarMapRequest::set_allocated_buyinstance_rqst(::vmsg::CSBuyInstanceRqst* buyinstance_rqst) {
  delete buyinstance_rqst_;
  buyinstance_rqst_ = buyinstance_rqst;
  if (buyinstance_rqst) {
    set_has_buyinstance_rqst();
  } else {
    clear_has_buyinstance_rqst();
  }
}

// optional .vmsg.CSWarmapStarAwardRqst ClaimStarAward_Rqst = 15;
inline bool CSWarMapRequest::has_claimstaraward_rqst() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CSWarMapRequest::set_has_claimstaraward_rqst() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CSWarMapRequest::clear_has_claimstaraward_rqst() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CSWarMapRequest::clear_claimstaraward_rqst() {
  if (claimstaraward_rqst_ != NULL) claimstaraward_rqst_->::vmsg::CSWarmapStarAwardRqst::Clear();
  clear_has_claimstaraward_rqst();
}
inline const ::vmsg::CSWarmapStarAwardRqst& CSWarMapRequest::claimstaraward_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return claimstaraward_rqst_ != NULL ? *claimstaraward_rqst_ : *default_instance().claimstaraward_rqst_;
#else
  return claimstaraward_rqst_ != NULL ? *claimstaraward_rqst_ : *default_instance_->claimstaraward_rqst_;
#endif
}
inline ::vmsg::CSWarmapStarAwardRqst* CSWarMapRequest::mutable_claimstaraward_rqst() {
  set_has_claimstaraward_rqst();
  if (claimstaraward_rqst_ == NULL) claimstaraward_rqst_ = new ::vmsg::CSWarmapStarAwardRqst;
  return claimstaraward_rqst_;
}
inline ::vmsg::CSWarmapStarAwardRqst* CSWarMapRequest::release_claimstaraward_rqst() {
  clear_has_claimstaraward_rqst();
  ::vmsg::CSWarmapStarAwardRqst* temp = claimstaraward_rqst_;
  claimstaraward_rqst_ = NULL;
  return temp;
}
inline void CSWarMapRequest::set_allocated_claimstaraward_rqst(::vmsg::CSWarmapStarAwardRqst* claimstaraward_rqst) {
  delete claimstaraward_rqst_;
  claimstaraward_rqst_ = claimstaraward_rqst;
  if (claimstaraward_rqst) {
    set_has_claimstaraward_rqst();
  } else {
    clear_has_claimstaraward_rqst();
  }
}

// -------------------------------------------------------------------

// CSWarMapRespond

// optional .vmsg.CSWarMapQueryRsp WarMapQuery_Rsp = 1;
inline bool CSWarMapRespond::has_warmapquery_rsp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWarMapRespond::set_has_warmapquery_rsp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWarMapRespond::clear_has_warmapquery_rsp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWarMapRespond::clear_warmapquery_rsp() {
  if (warmapquery_rsp_ != NULL) warmapquery_rsp_->::vmsg::CSWarMapQueryRsp::Clear();
  clear_has_warmapquery_rsp();
}
inline const ::vmsg::CSWarMapQueryRsp& CSWarMapRespond::warmapquery_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return warmapquery_rsp_ != NULL ? *warmapquery_rsp_ : *default_instance().warmapquery_rsp_;
#else
  return warmapquery_rsp_ != NULL ? *warmapquery_rsp_ : *default_instance_->warmapquery_rsp_;
#endif
}
inline ::vmsg::CSWarMapQueryRsp* CSWarMapRespond::mutable_warmapquery_rsp() {
  set_has_warmapquery_rsp();
  if (warmapquery_rsp_ == NULL) warmapquery_rsp_ = new ::vmsg::CSWarMapQueryRsp;
  return warmapquery_rsp_;
}
inline ::vmsg::CSWarMapQueryRsp* CSWarMapRespond::release_warmapquery_rsp() {
  clear_has_warmapquery_rsp();
  ::vmsg::CSWarMapQueryRsp* temp = warmapquery_rsp_;
  warmapquery_rsp_ = NULL;
  return temp;
}
inline void CSWarMapRespond::set_allocated_warmapquery_rsp(::vmsg::CSWarMapQueryRsp* warmapquery_rsp) {
  delete warmapquery_rsp_;
  warmapquery_rsp_ = warmapquery_rsp;
  if (warmapquery_rsp) {
    set_has_warmapquery_rsp();
  } else {
    clear_has_warmapquery_rsp();
  }
}

// optional .vmsg.CSWarMapStartRsp WarMapStart_Rsp = 2;
inline bool CSWarMapRespond::has_warmapstart_rsp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWarMapRespond::set_has_warmapstart_rsp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWarMapRespond::clear_has_warmapstart_rsp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWarMapRespond::clear_warmapstart_rsp() {
  if (warmapstart_rsp_ != NULL) warmapstart_rsp_->::vmsg::CSWarMapStartRsp::Clear();
  clear_has_warmapstart_rsp();
}
inline const ::vmsg::CSWarMapStartRsp& CSWarMapRespond::warmapstart_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return warmapstart_rsp_ != NULL ? *warmapstart_rsp_ : *default_instance().warmapstart_rsp_;
#else
  return warmapstart_rsp_ != NULL ? *warmapstart_rsp_ : *default_instance_->warmapstart_rsp_;
#endif
}
inline ::vmsg::CSWarMapStartRsp* CSWarMapRespond::mutable_warmapstart_rsp() {
  set_has_warmapstart_rsp();
  if (warmapstart_rsp_ == NULL) warmapstart_rsp_ = new ::vmsg::CSWarMapStartRsp;
  return warmapstart_rsp_;
}
inline ::vmsg::CSWarMapStartRsp* CSWarMapRespond::release_warmapstart_rsp() {
  clear_has_warmapstart_rsp();
  ::vmsg::CSWarMapStartRsp* temp = warmapstart_rsp_;
  warmapstart_rsp_ = NULL;
  return temp;
}
inline void CSWarMapRespond::set_allocated_warmapstart_rsp(::vmsg::CSWarMapStartRsp* warmapstart_rsp) {
  delete warmapstart_rsp_;
  warmapstart_rsp_ = warmapstart_rsp;
  if (warmapstart_rsp) {
    set_has_warmapstart_rsp();
  } else {
    clear_has_warmapstart_rsp();
  }
}

// optional .vmsg.CSWarMapEndRsp WarMapEnd_Rsp = 3;
inline bool CSWarMapRespond::has_warmapend_rsp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSWarMapRespond::set_has_warmapend_rsp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSWarMapRespond::clear_has_warmapend_rsp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSWarMapRespond::clear_warmapend_rsp() {
  if (warmapend_rsp_ != NULL) warmapend_rsp_->::vmsg::CSWarMapEndRsp::Clear();
  clear_has_warmapend_rsp();
}
inline const ::vmsg::CSWarMapEndRsp& CSWarMapRespond::warmapend_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return warmapend_rsp_ != NULL ? *warmapend_rsp_ : *default_instance().warmapend_rsp_;
#else
  return warmapend_rsp_ != NULL ? *warmapend_rsp_ : *default_instance_->warmapend_rsp_;
#endif
}
inline ::vmsg::CSWarMapEndRsp* CSWarMapRespond::mutable_warmapend_rsp() {
  set_has_warmapend_rsp();
  if (warmapend_rsp_ == NULL) warmapend_rsp_ = new ::vmsg::CSWarMapEndRsp;
  return warmapend_rsp_;
}
inline ::vmsg::CSWarMapEndRsp* CSWarMapRespond::release_warmapend_rsp() {
  clear_has_warmapend_rsp();
  ::vmsg::CSWarMapEndRsp* temp = warmapend_rsp_;
  warmapend_rsp_ = NULL;
  return temp;
}
inline void CSWarMapRespond::set_allocated_warmapend_rsp(::vmsg::CSWarMapEndRsp* warmapend_rsp) {
  delete warmapend_rsp_;
  warmapend_rsp_ = warmapend_rsp;
  if (warmapend_rsp) {
    set_has_warmapend_rsp();
  } else {
    clear_has_warmapend_rsp();
  }
}

// optional .vmsg.CSWarMapCardRsp WarMapCard_Rsp = 4;
inline bool CSWarMapRespond::has_warmapcard_rsp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSWarMapRespond::set_has_warmapcard_rsp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSWarMapRespond::clear_has_warmapcard_rsp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSWarMapRespond::clear_warmapcard_rsp() {
  if (warmapcard_rsp_ != NULL) warmapcard_rsp_->::vmsg::CSWarMapCardRsp::Clear();
  clear_has_warmapcard_rsp();
}
inline const ::vmsg::CSWarMapCardRsp& CSWarMapRespond::warmapcard_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return warmapcard_rsp_ != NULL ? *warmapcard_rsp_ : *default_instance().warmapcard_rsp_;
#else
  return warmapcard_rsp_ != NULL ? *warmapcard_rsp_ : *default_instance_->warmapcard_rsp_;
#endif
}
inline ::vmsg::CSWarMapCardRsp* CSWarMapRespond::mutable_warmapcard_rsp() {
  set_has_warmapcard_rsp();
  if (warmapcard_rsp_ == NULL) warmapcard_rsp_ = new ::vmsg::CSWarMapCardRsp;
  return warmapcard_rsp_;
}
inline ::vmsg::CSWarMapCardRsp* CSWarMapRespond::release_warmapcard_rsp() {
  clear_has_warmapcard_rsp();
  ::vmsg::CSWarMapCardRsp* temp = warmapcard_rsp_;
  warmapcard_rsp_ = NULL;
  return temp;
}
inline void CSWarMapRespond::set_allocated_warmapcard_rsp(::vmsg::CSWarMapCardRsp* warmapcard_rsp) {
  delete warmapcard_rsp_;
  warmapcard_rsp_ = warmapcard_rsp;
  if (warmapcard_rsp) {
    set_has_warmapcard_rsp();
  } else {
    clear_has_warmapcard_rsp();
  }
}

// optional .vmsg.CSSweepWarRsp SweepWar_Rsp = 5;
inline bool CSWarMapRespond::has_sweepwar_rsp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSWarMapRespond::set_has_sweepwar_rsp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSWarMapRespond::clear_has_sweepwar_rsp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSWarMapRespond::clear_sweepwar_rsp() {
  if (sweepwar_rsp_ != NULL) sweepwar_rsp_->::vmsg::CSSweepWarRsp::Clear();
  clear_has_sweepwar_rsp();
}
inline const ::vmsg::CSSweepWarRsp& CSWarMapRespond::sweepwar_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sweepwar_rsp_ != NULL ? *sweepwar_rsp_ : *default_instance().sweepwar_rsp_;
#else
  return sweepwar_rsp_ != NULL ? *sweepwar_rsp_ : *default_instance_->sweepwar_rsp_;
#endif
}
inline ::vmsg::CSSweepWarRsp* CSWarMapRespond::mutable_sweepwar_rsp() {
  set_has_sweepwar_rsp();
  if (sweepwar_rsp_ == NULL) sweepwar_rsp_ = new ::vmsg::CSSweepWarRsp;
  return sweepwar_rsp_;
}
inline ::vmsg::CSSweepWarRsp* CSWarMapRespond::release_sweepwar_rsp() {
  clear_has_sweepwar_rsp();
  ::vmsg::CSSweepWarRsp* temp = sweepwar_rsp_;
  sweepwar_rsp_ = NULL;
  return temp;
}
inline void CSWarMapRespond::set_allocated_sweepwar_rsp(::vmsg::CSSweepWarRsp* sweepwar_rsp) {
  delete sweepwar_rsp_;
  sweepwar_rsp_ = sweepwar_rsp;
  if (sweepwar_rsp) {
    set_has_sweepwar_rsp();
  } else {
    clear_has_sweepwar_rsp();
  }
}

// optional .vmsg.CSEliteWarInfo QueryEliteWarMap_Rsp = 6;
inline bool CSWarMapRespond::has_queryelitewarmap_rsp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSWarMapRespond::set_has_queryelitewarmap_rsp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSWarMapRespond::clear_has_queryelitewarmap_rsp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSWarMapRespond::clear_queryelitewarmap_rsp() {
  if (queryelitewarmap_rsp_ != NULL) queryelitewarmap_rsp_->::vmsg::CSEliteWarInfo::Clear();
  clear_has_queryelitewarmap_rsp();
}
inline const ::vmsg::CSEliteWarInfo& CSWarMapRespond::queryelitewarmap_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return queryelitewarmap_rsp_ != NULL ? *queryelitewarmap_rsp_ : *default_instance().queryelitewarmap_rsp_;
#else
  return queryelitewarmap_rsp_ != NULL ? *queryelitewarmap_rsp_ : *default_instance_->queryelitewarmap_rsp_;
#endif
}
inline ::vmsg::CSEliteWarInfo* CSWarMapRespond::mutable_queryelitewarmap_rsp() {
  set_has_queryelitewarmap_rsp();
  if (queryelitewarmap_rsp_ == NULL) queryelitewarmap_rsp_ = new ::vmsg::CSEliteWarInfo;
  return queryelitewarmap_rsp_;
}
inline ::vmsg::CSEliteWarInfo* CSWarMapRespond::release_queryelitewarmap_rsp() {
  clear_has_queryelitewarmap_rsp();
  ::vmsg::CSEliteWarInfo* temp = queryelitewarmap_rsp_;
  queryelitewarmap_rsp_ = NULL;
  return temp;
}
inline void CSWarMapRespond::set_allocated_queryelitewarmap_rsp(::vmsg::CSEliteWarInfo* queryelitewarmap_rsp) {
  delete queryelitewarmap_rsp_;
  queryelitewarmap_rsp_ = queryelitewarmap_rsp;
  if (queryelitewarmap_rsp) {
    set_has_queryelitewarmap_rsp();
  } else {
    clear_has_queryelitewarmap_rsp();
  }
}

// optional .vmsg.CSEliteWarInfo ResetEliteWarMap_Rsp = 7;
inline bool CSWarMapRespond::has_resetelitewarmap_rsp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSWarMapRespond::set_has_resetelitewarmap_rsp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSWarMapRespond::clear_has_resetelitewarmap_rsp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSWarMapRespond::clear_resetelitewarmap_rsp() {
  if (resetelitewarmap_rsp_ != NULL) resetelitewarmap_rsp_->::vmsg::CSEliteWarInfo::Clear();
  clear_has_resetelitewarmap_rsp();
}
inline const ::vmsg::CSEliteWarInfo& CSWarMapRespond::resetelitewarmap_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return resetelitewarmap_rsp_ != NULL ? *resetelitewarmap_rsp_ : *default_instance().resetelitewarmap_rsp_;
#else
  return resetelitewarmap_rsp_ != NULL ? *resetelitewarmap_rsp_ : *default_instance_->resetelitewarmap_rsp_;
#endif
}
inline ::vmsg::CSEliteWarInfo* CSWarMapRespond::mutable_resetelitewarmap_rsp() {
  set_has_resetelitewarmap_rsp();
  if (resetelitewarmap_rsp_ == NULL) resetelitewarmap_rsp_ = new ::vmsg::CSEliteWarInfo;
  return resetelitewarmap_rsp_;
}
inline ::vmsg::CSEliteWarInfo* CSWarMapRespond::release_resetelitewarmap_rsp() {
  clear_has_resetelitewarmap_rsp();
  ::vmsg::CSEliteWarInfo* temp = resetelitewarmap_rsp_;
  resetelitewarmap_rsp_ = NULL;
  return temp;
}
inline void CSWarMapRespond::set_allocated_resetelitewarmap_rsp(::vmsg::CSEliteWarInfo* resetelitewarmap_rsp) {
  delete resetelitewarmap_rsp_;
  resetelitewarmap_rsp_ = resetelitewarmap_rsp;
  if (resetelitewarmap_rsp) {
    set_has_resetelitewarmap_rsp();
  } else {
    clear_has_resetelitewarmap_rsp();
  }
}

// optional .vmsg.CSStartEliteWarMapRsp StartEliteWarMap_Rsp = 8;
inline bool CSWarMapRespond::has_startelitewarmap_rsp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSWarMapRespond::set_has_startelitewarmap_rsp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSWarMapRespond::clear_has_startelitewarmap_rsp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSWarMapRespond::clear_startelitewarmap_rsp() {
  if (startelitewarmap_rsp_ != NULL) startelitewarmap_rsp_->::vmsg::CSStartEliteWarMapRsp::Clear();
  clear_has_startelitewarmap_rsp();
}
inline const ::vmsg::CSStartEliteWarMapRsp& CSWarMapRespond::startelitewarmap_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return startelitewarmap_rsp_ != NULL ? *startelitewarmap_rsp_ : *default_instance().startelitewarmap_rsp_;
#else
  return startelitewarmap_rsp_ != NULL ? *startelitewarmap_rsp_ : *default_instance_->startelitewarmap_rsp_;
#endif
}
inline ::vmsg::CSStartEliteWarMapRsp* CSWarMapRespond::mutable_startelitewarmap_rsp() {
  set_has_startelitewarmap_rsp();
  if (startelitewarmap_rsp_ == NULL) startelitewarmap_rsp_ = new ::vmsg::CSStartEliteWarMapRsp;
  return startelitewarmap_rsp_;
}
inline ::vmsg::CSStartEliteWarMapRsp* CSWarMapRespond::release_startelitewarmap_rsp() {
  clear_has_startelitewarmap_rsp();
  ::vmsg::CSStartEliteWarMapRsp* temp = startelitewarmap_rsp_;
  startelitewarmap_rsp_ = NULL;
  return temp;
}
inline void CSWarMapRespond::set_allocated_startelitewarmap_rsp(::vmsg::CSStartEliteWarMapRsp* startelitewarmap_rsp) {
  delete startelitewarmap_rsp_;
  startelitewarmap_rsp_ = startelitewarmap_rsp;
  if (startelitewarmap_rsp) {
    set_has_startelitewarmap_rsp();
  } else {
    clear_has_startelitewarmap_rsp();
  }
}

// optional .vmsg.CSEndEliteWarMapRsp EndEliteWarMap_Rsp = 9;
inline bool CSWarMapRespond::has_endelitewarmap_rsp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSWarMapRespond::set_has_endelitewarmap_rsp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSWarMapRespond::clear_has_endelitewarmap_rsp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSWarMapRespond::clear_endelitewarmap_rsp() {
  if (endelitewarmap_rsp_ != NULL) endelitewarmap_rsp_->::vmsg::CSEndEliteWarMapRsp::Clear();
  clear_has_endelitewarmap_rsp();
}
inline const ::vmsg::CSEndEliteWarMapRsp& CSWarMapRespond::endelitewarmap_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return endelitewarmap_rsp_ != NULL ? *endelitewarmap_rsp_ : *default_instance().endelitewarmap_rsp_;
#else
  return endelitewarmap_rsp_ != NULL ? *endelitewarmap_rsp_ : *default_instance_->endelitewarmap_rsp_;
#endif
}
inline ::vmsg::CSEndEliteWarMapRsp* CSWarMapRespond::mutable_endelitewarmap_rsp() {
  set_has_endelitewarmap_rsp();
  if (endelitewarmap_rsp_ == NULL) endelitewarmap_rsp_ = new ::vmsg::CSEndEliteWarMapRsp;
  return endelitewarmap_rsp_;
}
inline ::vmsg::CSEndEliteWarMapRsp* CSWarMapRespond::release_endelitewarmap_rsp() {
  clear_has_endelitewarmap_rsp();
  ::vmsg::CSEndEliteWarMapRsp* temp = endelitewarmap_rsp_;
  endelitewarmap_rsp_ = NULL;
  return temp;
}
inline void CSWarMapRespond::set_allocated_endelitewarmap_rsp(::vmsg::CSEndEliteWarMapRsp* endelitewarmap_rsp) {
  delete endelitewarmap_rsp_;
  endelitewarmap_rsp_ = endelitewarmap_rsp;
  if (endelitewarmap_rsp) {
    set_has_endelitewarmap_rsp();
  } else {
    clear_has_endelitewarmap_rsp();
  }
}

// optional .vmsg.CSSweepEliteWarRsp SweepEliteWar_Rsp = 10;
inline bool CSWarMapRespond::has_sweepelitewar_rsp() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CSWarMapRespond::set_has_sweepelitewar_rsp() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CSWarMapRespond::clear_has_sweepelitewar_rsp() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CSWarMapRespond::clear_sweepelitewar_rsp() {
  if (sweepelitewar_rsp_ != NULL) sweepelitewar_rsp_->::vmsg::CSSweepEliteWarRsp::Clear();
  clear_has_sweepelitewar_rsp();
}
inline const ::vmsg::CSSweepEliteWarRsp& CSWarMapRespond::sweepelitewar_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sweepelitewar_rsp_ != NULL ? *sweepelitewar_rsp_ : *default_instance().sweepelitewar_rsp_;
#else
  return sweepelitewar_rsp_ != NULL ? *sweepelitewar_rsp_ : *default_instance_->sweepelitewar_rsp_;
#endif
}
inline ::vmsg::CSSweepEliteWarRsp* CSWarMapRespond::mutable_sweepelitewar_rsp() {
  set_has_sweepelitewar_rsp();
  if (sweepelitewar_rsp_ == NULL) sweepelitewar_rsp_ = new ::vmsg::CSSweepEliteWarRsp;
  return sweepelitewar_rsp_;
}
inline ::vmsg::CSSweepEliteWarRsp* CSWarMapRespond::release_sweepelitewar_rsp() {
  clear_has_sweepelitewar_rsp();
  ::vmsg::CSSweepEliteWarRsp* temp = sweepelitewar_rsp_;
  sweepelitewar_rsp_ = NULL;
  return temp;
}
inline void CSWarMapRespond::set_allocated_sweepelitewar_rsp(::vmsg::CSSweepEliteWarRsp* sweepelitewar_rsp) {
  delete sweepelitewar_rsp_;
  sweepelitewar_rsp_ = sweepelitewar_rsp;
  if (sweepelitewar_rsp) {
    set_has_sweepelitewar_rsp();
  } else {
    clear_has_sweepelitewar_rsp();
  }
}

// optional .vmsg.CSQueryDailyInstanceRsp QueryDailyInstance_Rsp = 11;
inline bool CSWarMapRespond::has_querydailyinstance_rsp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CSWarMapRespond::set_has_querydailyinstance_rsp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CSWarMapRespond::clear_has_querydailyinstance_rsp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CSWarMapRespond::clear_querydailyinstance_rsp() {
  if (querydailyinstance_rsp_ != NULL) querydailyinstance_rsp_->::vmsg::CSQueryDailyInstanceRsp::Clear();
  clear_has_querydailyinstance_rsp();
}
inline const ::vmsg::CSQueryDailyInstanceRsp& CSWarMapRespond::querydailyinstance_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return querydailyinstance_rsp_ != NULL ? *querydailyinstance_rsp_ : *default_instance().querydailyinstance_rsp_;
#else
  return querydailyinstance_rsp_ != NULL ? *querydailyinstance_rsp_ : *default_instance_->querydailyinstance_rsp_;
#endif
}
inline ::vmsg::CSQueryDailyInstanceRsp* CSWarMapRespond::mutable_querydailyinstance_rsp() {
  set_has_querydailyinstance_rsp();
  if (querydailyinstance_rsp_ == NULL) querydailyinstance_rsp_ = new ::vmsg::CSQueryDailyInstanceRsp;
  return querydailyinstance_rsp_;
}
inline ::vmsg::CSQueryDailyInstanceRsp* CSWarMapRespond::release_querydailyinstance_rsp() {
  clear_has_querydailyinstance_rsp();
  ::vmsg::CSQueryDailyInstanceRsp* temp = querydailyinstance_rsp_;
  querydailyinstance_rsp_ = NULL;
  return temp;
}
inline void CSWarMapRespond::set_allocated_querydailyinstance_rsp(::vmsg::CSQueryDailyInstanceRsp* querydailyinstance_rsp) {
  delete querydailyinstance_rsp_;
  querydailyinstance_rsp_ = querydailyinstance_rsp;
  if (querydailyinstance_rsp) {
    set_has_querydailyinstance_rsp();
  } else {
    clear_has_querydailyinstance_rsp();
  }
}

// optional .vmsg.CSDailyInstancePassRsp PassDailyInstance_Rsp = 12;
inline bool CSWarMapRespond::has_passdailyinstance_rsp() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CSWarMapRespond::set_has_passdailyinstance_rsp() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CSWarMapRespond::clear_has_passdailyinstance_rsp() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CSWarMapRespond::clear_passdailyinstance_rsp() {
  if (passdailyinstance_rsp_ != NULL) passdailyinstance_rsp_->::vmsg::CSDailyInstancePassRsp::Clear();
  clear_has_passdailyinstance_rsp();
}
inline const ::vmsg::CSDailyInstancePassRsp& CSWarMapRespond::passdailyinstance_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return passdailyinstance_rsp_ != NULL ? *passdailyinstance_rsp_ : *default_instance().passdailyinstance_rsp_;
#else
  return passdailyinstance_rsp_ != NULL ? *passdailyinstance_rsp_ : *default_instance_->passdailyinstance_rsp_;
#endif
}
inline ::vmsg::CSDailyInstancePassRsp* CSWarMapRespond::mutable_passdailyinstance_rsp() {
  set_has_passdailyinstance_rsp();
  if (passdailyinstance_rsp_ == NULL) passdailyinstance_rsp_ = new ::vmsg::CSDailyInstancePassRsp;
  return passdailyinstance_rsp_;
}
inline ::vmsg::CSDailyInstancePassRsp* CSWarMapRespond::release_passdailyinstance_rsp() {
  clear_has_passdailyinstance_rsp();
  ::vmsg::CSDailyInstancePassRsp* temp = passdailyinstance_rsp_;
  passdailyinstance_rsp_ = NULL;
  return temp;
}
inline void CSWarMapRespond::set_allocated_passdailyinstance_rsp(::vmsg::CSDailyInstancePassRsp* passdailyinstance_rsp) {
  delete passdailyinstance_rsp_;
  passdailyinstance_rsp_ = passdailyinstance_rsp;
  if (passdailyinstance_rsp) {
    set_has_passdailyinstance_rsp();
  } else {
    clear_has_passdailyinstance_rsp();
  }
}

// optional .vmsg.CSReliveRsp Relive_Rsp = 13;
inline bool CSWarMapRespond::has_relive_rsp() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CSWarMapRespond::set_has_relive_rsp() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CSWarMapRespond::clear_has_relive_rsp() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CSWarMapRespond::clear_relive_rsp() {
  if (relive_rsp_ != NULL) relive_rsp_->::vmsg::CSReliveRsp::Clear();
  clear_has_relive_rsp();
}
inline const ::vmsg::CSReliveRsp& CSWarMapRespond::relive_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return relive_rsp_ != NULL ? *relive_rsp_ : *default_instance().relive_rsp_;
#else
  return relive_rsp_ != NULL ? *relive_rsp_ : *default_instance_->relive_rsp_;
#endif
}
inline ::vmsg::CSReliveRsp* CSWarMapRespond::mutable_relive_rsp() {
  set_has_relive_rsp();
  if (relive_rsp_ == NULL) relive_rsp_ = new ::vmsg::CSReliveRsp;
  return relive_rsp_;
}
inline ::vmsg::CSReliveRsp* CSWarMapRespond::release_relive_rsp() {
  clear_has_relive_rsp();
  ::vmsg::CSReliveRsp* temp = relive_rsp_;
  relive_rsp_ = NULL;
  return temp;
}
inline void CSWarMapRespond::set_allocated_relive_rsp(::vmsg::CSReliveRsp* relive_rsp) {
  delete relive_rsp_;
  relive_rsp_ = relive_rsp;
  if (relive_rsp) {
    set_has_relive_rsp();
  } else {
    clear_has_relive_rsp();
  }
}

// optional .vmsg.CSBuyBulletRsp BuyBullet_Rsp = 14;
inline bool CSWarMapRespond::has_buybullet_rsp() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CSWarMapRespond::set_has_buybullet_rsp() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CSWarMapRespond::clear_has_buybullet_rsp() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CSWarMapRespond::clear_buybullet_rsp() {
  if (buybullet_rsp_ != NULL) buybullet_rsp_->::vmsg::CSBuyBulletRsp::Clear();
  clear_has_buybullet_rsp();
}
inline const ::vmsg::CSBuyBulletRsp& CSWarMapRespond::buybullet_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return buybullet_rsp_ != NULL ? *buybullet_rsp_ : *default_instance().buybullet_rsp_;
#else
  return buybullet_rsp_ != NULL ? *buybullet_rsp_ : *default_instance_->buybullet_rsp_;
#endif
}
inline ::vmsg::CSBuyBulletRsp* CSWarMapRespond::mutable_buybullet_rsp() {
  set_has_buybullet_rsp();
  if (buybullet_rsp_ == NULL) buybullet_rsp_ = new ::vmsg::CSBuyBulletRsp;
  return buybullet_rsp_;
}
inline ::vmsg::CSBuyBulletRsp* CSWarMapRespond::release_buybullet_rsp() {
  clear_has_buybullet_rsp();
  ::vmsg::CSBuyBulletRsp* temp = buybullet_rsp_;
  buybullet_rsp_ = NULL;
  return temp;
}
inline void CSWarMapRespond::set_allocated_buybullet_rsp(::vmsg::CSBuyBulletRsp* buybullet_rsp) {
  delete buybullet_rsp_;
  buybullet_rsp_ = buybullet_rsp;
  if (buybullet_rsp) {
    set_has_buybullet_rsp();
  } else {
    clear_has_buybullet_rsp();
  }
}

// optional .vmsg.CSBuyInstanceRsp BuyInstance_Rsp = 15;
inline bool CSWarMapRespond::has_buyinstance_rsp() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CSWarMapRespond::set_has_buyinstance_rsp() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CSWarMapRespond::clear_has_buyinstance_rsp() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CSWarMapRespond::clear_buyinstance_rsp() {
  if (buyinstance_rsp_ != NULL) buyinstance_rsp_->::vmsg::CSBuyInstanceRsp::Clear();
  clear_has_buyinstance_rsp();
}
inline const ::vmsg::CSBuyInstanceRsp& CSWarMapRespond::buyinstance_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return buyinstance_rsp_ != NULL ? *buyinstance_rsp_ : *default_instance().buyinstance_rsp_;
#else
  return buyinstance_rsp_ != NULL ? *buyinstance_rsp_ : *default_instance_->buyinstance_rsp_;
#endif
}
inline ::vmsg::CSBuyInstanceRsp* CSWarMapRespond::mutable_buyinstance_rsp() {
  set_has_buyinstance_rsp();
  if (buyinstance_rsp_ == NULL) buyinstance_rsp_ = new ::vmsg::CSBuyInstanceRsp;
  return buyinstance_rsp_;
}
inline ::vmsg::CSBuyInstanceRsp* CSWarMapRespond::release_buyinstance_rsp() {
  clear_has_buyinstance_rsp();
  ::vmsg::CSBuyInstanceRsp* temp = buyinstance_rsp_;
  buyinstance_rsp_ = NULL;
  return temp;
}
inline void CSWarMapRespond::set_allocated_buyinstance_rsp(::vmsg::CSBuyInstanceRsp* buyinstance_rsp) {
  delete buyinstance_rsp_;
  buyinstance_rsp_ = buyinstance_rsp;
  if (buyinstance_rsp) {
    set_has_buyinstance_rsp();
  } else {
    clear_has_buyinstance_rsp();
  }
}

// optional .vmsg.CSWarmapStarAwardRsp ClaimStarAward_Rsp = 16;
inline bool CSWarMapRespond::has_claimstaraward_rsp() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CSWarMapRespond::set_has_claimstaraward_rsp() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CSWarMapRespond::clear_has_claimstaraward_rsp() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CSWarMapRespond::clear_claimstaraward_rsp() {
  if (claimstaraward_rsp_ != NULL) claimstaraward_rsp_->::vmsg::CSWarmapStarAwardRsp::Clear();
  clear_has_claimstaraward_rsp();
}
inline const ::vmsg::CSWarmapStarAwardRsp& CSWarMapRespond::claimstaraward_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return claimstaraward_rsp_ != NULL ? *claimstaraward_rsp_ : *default_instance().claimstaraward_rsp_;
#else
  return claimstaraward_rsp_ != NULL ? *claimstaraward_rsp_ : *default_instance_->claimstaraward_rsp_;
#endif
}
inline ::vmsg::CSWarmapStarAwardRsp* CSWarMapRespond::mutable_claimstaraward_rsp() {
  set_has_claimstaraward_rsp();
  if (claimstaraward_rsp_ == NULL) claimstaraward_rsp_ = new ::vmsg::CSWarmapStarAwardRsp;
  return claimstaraward_rsp_;
}
inline ::vmsg::CSWarmapStarAwardRsp* CSWarMapRespond::release_claimstaraward_rsp() {
  clear_has_claimstaraward_rsp();
  ::vmsg::CSWarmapStarAwardRsp* temp = claimstaraward_rsp_;
  claimstaraward_rsp_ = NULL;
  return temp;
}
inline void CSWarMapRespond::set_allocated_claimstaraward_rsp(::vmsg::CSWarmapStarAwardRsp* claimstaraward_rsp) {
  delete claimstaraward_rsp_;
  claimstaraward_rsp_ = claimstaraward_rsp;
  if (claimstaraward_rsp) {
    set_has_claimstaraward_rsp();
  } else {
    clear_has_claimstaraward_rsp();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CSWarMapMsg_2eproto__INCLUDED
