// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSWeaponMsg.proto

#ifndef PROTOBUF_CSWeaponMsg_2eproto__INCLUDED
#define PROTOBUF_CSWeaponMsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MsgBase.pb.h"
#include "CSBagMsg.pb.h"
#include "CSEquipItemMsg.pb.h"
// @@protoc_insertion_point(includes)

namespace vmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CSWeaponMsg_2eproto();
void protobuf_AssignDesc_CSWeaponMsg_2eproto();
void protobuf_ShutdownFile_CSWeaponMsg_2eproto();

class CSWeaponBag;
class CSWeaponChangeRqst;
class CSWeaponLvUpConsume;
class CSWeaponLvUpRqst;
class CSWeaponStarStepRqst;
class CSWeaponRefitRqst;
class CSInbattleWeaponElmtBrief;
class CSWeaponInBattleRqst;
class CSWeaponInBattleRsp;
class CSWeaponLvUpRsp;
class CSWeaponRequest;
class CSWeaponRespond;

// ===================================================================

class CSWeaponBag : public ::google::protobuf::MessageLite {
 public:
  CSWeaponBag();
  virtual ~CSWeaponBag();

  CSWeaponBag(const CSWeaponBag& from);

  inline CSWeaponBag& operator=(const CSWeaponBag& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWeaponBag& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWeaponBag* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWeaponBag* other);

  // implements Message ----------------------------------------------

  CSWeaponBag* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWeaponBag& from);
  void MergeFrom(const CSWeaponBag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSWeapon Weapons = 1;
  inline int weapons_size() const;
  inline void clear_weapons();
  static const int kWeaponsFieldNumber = 1;
  inline const ::vmsg::CSWeapon& weapons(int index) const;
  inline ::vmsg::CSWeapon* mutable_weapons(int index);
  inline ::vmsg::CSWeapon* add_weapons();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSWeapon >&
      weapons() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSWeapon >*
      mutable_weapons();

  // required .vmsg.CSWeapon PlayerWeapon = 2;
  inline bool has_playerweapon() const;
  inline void clear_playerweapon();
  static const int kPlayerWeaponFieldNumber = 2;
  inline const ::vmsg::CSWeapon& playerweapon() const;
  inline ::vmsg::CSWeapon* mutable_playerweapon();
  inline ::vmsg::CSWeapon* release_playerweapon();
  inline void set_allocated_playerweapon(::vmsg::CSWeapon* playerweapon);

  // required uint32 Capacity = 3;
  inline bool has_capacity() const;
  inline void clear_capacity();
  static const int kCapacityFieldNumber = 3;
  inline ::google::protobuf::uint32 capacity() const;
  inline void set_capacity(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSWeaponBag)
 private:
  inline void set_has_playerweapon();
  inline void clear_has_playerweapon();
  inline void set_has_capacity();
  inline void clear_has_capacity();

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSWeapon > weapons_;
  ::vmsg::CSWeapon* playerweapon_;
  ::google::protobuf::uint32 capacity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWeaponMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWeaponMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWeaponBag* default_instance_;
};
// -------------------------------------------------------------------

class CSWeaponChangeRqst : public ::google::protobuf::MessageLite {
 public:
  CSWeaponChangeRqst();
  virtual ~CSWeaponChangeRqst();

  CSWeaponChangeRqst(const CSWeaponChangeRqst& from);

  inline CSWeaponChangeRqst& operator=(const CSWeaponChangeRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWeaponChangeRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWeaponChangeRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWeaponChangeRqst* other);

  // implements Message ----------------------------------------------

  CSWeaponChangeRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWeaponChangeRqst& from);
  void MergeFrom(const CSWeaponChangeRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 BagIdx = 1;
  inline bool has_bagidx() const;
  inline void clear_bagidx();
  static const int kBagIdxFieldNumber = 1;
  inline ::google::protobuf::int32 bagidx() const;
  inline void set_bagidx(::google::protobuf::int32 value);

  // required uint64 WeaponGUID = 2;
  inline bool has_weaponguid() const;
  inline void clear_weaponguid();
  static const int kWeaponGUIDFieldNumber = 2;
  inline ::google::protobuf::uint64 weaponguid() const;
  inline void set_weaponguid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSWeaponChangeRqst)
 private:
  inline void set_has_bagidx();
  inline void clear_has_bagidx();
  inline void set_has_weaponguid();
  inline void clear_has_weaponguid();

  ::google::protobuf::uint64 weaponguid_;
  ::google::protobuf::int32 bagidx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWeaponMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWeaponMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWeaponChangeRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSWeaponLvUpConsume : public ::google::protobuf::MessageLite {
 public:
  CSWeaponLvUpConsume();
  virtual ~CSWeaponLvUpConsume();

  CSWeaponLvUpConsume(const CSWeaponLvUpConsume& from);

  inline CSWeaponLvUpConsume& operator=(const CSWeaponLvUpConsume& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWeaponLvUpConsume& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWeaponLvUpConsume* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWeaponLvUpConsume* other);

  // implements Message ----------------------------------------------

  CSWeaponLvUpConsume* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWeaponLvUpConsume& from);
  void MergeFrom(const CSWeaponLvUpConsume& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint64 ID = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 2;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // required uint64 Cnt = 3;
  inline bool has_cnt() const;
  inline void clear_cnt();
  static const int kCntFieldNumber = 3;
  inline ::google::protobuf::uint64 cnt() const;
  inline void set_cnt(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSWeaponLvUpConsume)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_cnt();
  inline void clear_has_cnt();

  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint64 cnt_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWeaponMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWeaponMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWeaponLvUpConsume* default_instance_;
};
// -------------------------------------------------------------------

class CSWeaponLvUpRqst : public ::google::protobuf::MessageLite {
 public:
  CSWeaponLvUpRqst();
  virtual ~CSWeaponLvUpRqst();

  CSWeaponLvUpRqst(const CSWeaponLvUpRqst& from);

  inline CSWeaponLvUpRqst& operator=(const CSWeaponLvUpRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWeaponLvUpRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWeaponLvUpRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWeaponLvUpRqst* other);

  // implements Message ----------------------------------------------

  CSWeaponLvUpRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWeaponLvUpRqst& from);
  void MergeFrom(const CSWeaponLvUpRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 BagIdx = 1;
  inline bool has_bagidx() const;
  inline void clear_bagidx();
  static const int kBagIdxFieldNumber = 1;
  inline ::google::protobuf::int32 bagidx() const;
  inline void set_bagidx(::google::protobuf::int32 value);

  // required uint64 WeaponGUID = 2;
  inline bool has_weaponguid() const;
  inline void clear_weaponguid();
  static const int kWeaponGUIDFieldNumber = 2;
  inline ::google::protobuf::uint64 weaponguid() const;
  inline void set_weaponguid(::google::protobuf::uint64 value);

  // repeated .vmsg.CSWeaponLvUpConsume Consumes = 3;
  inline int consumes_size() const;
  inline void clear_consumes();
  static const int kConsumesFieldNumber = 3;
  inline const ::vmsg::CSWeaponLvUpConsume& consumes(int index) const;
  inline ::vmsg::CSWeaponLvUpConsume* mutable_consumes(int index);
  inline ::vmsg::CSWeaponLvUpConsume* add_consumes();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSWeaponLvUpConsume >&
      consumes() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSWeaponLvUpConsume >*
      mutable_consumes();

  // @@protoc_insertion_point(class_scope:vmsg.CSWeaponLvUpRqst)
 private:
  inline void set_has_bagidx();
  inline void clear_has_bagidx();
  inline void set_has_weaponguid();
  inline void clear_has_weaponguid();

  ::google::protobuf::uint64 weaponguid_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSWeaponLvUpConsume > consumes_;
  ::google::protobuf::int32 bagidx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWeaponMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWeaponMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWeaponLvUpRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSWeaponStarStepRqst : public ::google::protobuf::MessageLite {
 public:
  CSWeaponStarStepRqst();
  virtual ~CSWeaponStarStepRqst();

  CSWeaponStarStepRqst(const CSWeaponStarStepRqst& from);

  inline CSWeaponStarStepRqst& operator=(const CSWeaponStarStepRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWeaponStarStepRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWeaponStarStepRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWeaponStarStepRqst* other);

  // implements Message ----------------------------------------------

  CSWeaponStarStepRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWeaponStarStepRqst& from);
  void MergeFrom(const CSWeaponStarStepRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 BagIdx = 1;
  inline bool has_bagidx() const;
  inline void clear_bagidx();
  static const int kBagIdxFieldNumber = 1;
  inline ::google::protobuf::int32 bagidx() const;
  inline void set_bagidx(::google::protobuf::int32 value);

  // required uint64 WeaponGUID = 2;
  inline bool has_weaponguid() const;
  inline void clear_weaponguid();
  static const int kWeaponGUIDFieldNumber = 2;
  inline ::google::protobuf::uint64 weaponguid() const;
  inline void set_weaponguid(::google::protobuf::uint64 value);

  // repeated uint64 NeedWeaponGUIDs = 3;
  inline int needweaponguids_size() const;
  inline void clear_needweaponguids();
  static const int kNeedWeaponGUIDsFieldNumber = 3;
  inline ::google::protobuf::uint64 needweaponguids(int index) const;
  inline void set_needweaponguids(int index, ::google::protobuf::uint64 value);
  inline void add_needweaponguids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      needweaponguids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_needweaponguids();

  // @@protoc_insertion_point(class_scope:vmsg.CSWeaponStarStepRqst)
 private:
  inline void set_has_bagidx();
  inline void clear_has_bagidx();
  inline void set_has_weaponguid();
  inline void clear_has_weaponguid();

  ::google::protobuf::uint64 weaponguid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > needweaponguids_;
  ::google::protobuf::int32 bagidx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWeaponMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWeaponMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWeaponStarStepRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSWeaponRefitRqst : public ::google::protobuf::MessageLite {
 public:
  CSWeaponRefitRqst();
  virtual ~CSWeaponRefitRqst();

  CSWeaponRefitRqst(const CSWeaponRefitRqst& from);

  inline CSWeaponRefitRqst& operator=(const CSWeaponRefitRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWeaponRefitRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWeaponRefitRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWeaponRefitRqst* other);

  // implements Message ----------------------------------------------

  CSWeaponRefitRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWeaponRefitRqst& from);
  void MergeFrom(const CSWeaponRefitRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 BagIdx = 1;
  inline bool has_bagidx() const;
  inline void clear_bagidx();
  static const int kBagIdxFieldNumber = 1;
  inline ::google::protobuf::int32 bagidx() const;
  inline void set_bagidx(::google::protobuf::int32 value);

  // required uint64 WeaponGUID = 2;
  inline bool has_weaponguid() const;
  inline void clear_weaponguid();
  static const int kWeaponGUIDFieldNumber = 2;
  inline ::google::protobuf::uint64 weaponguid() const;
  inline void set_weaponguid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSWeaponRefitRqst)
 private:
  inline void set_has_bagidx();
  inline void clear_has_bagidx();
  inline void set_has_weaponguid();
  inline void clear_has_weaponguid();

  ::google::protobuf::uint64 weaponguid_;
  ::google::protobuf::int32 bagidx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWeaponMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWeaponMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWeaponRefitRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSInbattleWeaponElmtBrief : public ::google::protobuf::MessageLite {
 public:
  CSInbattleWeaponElmtBrief();
  virtual ~CSInbattleWeaponElmtBrief();

  CSInbattleWeaponElmtBrief(const CSInbattleWeaponElmtBrief& from);

  inline CSInbattleWeaponElmtBrief& operator=(const CSInbattleWeaponElmtBrief& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSInbattleWeaponElmtBrief& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSInbattleWeaponElmtBrief* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSInbattleWeaponElmtBrief* other);

  // implements Message ----------------------------------------------

  CSInbattleWeaponElmtBrief* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSInbattleWeaponElmtBrief& from);
  void MergeFrom(const CSInbattleWeaponElmtBrief& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 WeaponGUID = 1;
  inline bool has_weaponguid() const;
  inline void clear_weaponguid();
  static const int kWeaponGUIDFieldNumber = 1;
  inline ::google::protobuf::uint64 weaponguid() const;
  inline void set_weaponguid(::google::protobuf::uint64 value);

  // required int32 BagIdx = 2;
  inline bool has_bagidx() const;
  inline void clear_bagidx();
  static const int kBagIdxFieldNumber = 2;
  inline ::google::protobuf::int32 bagidx() const;
  inline void set_bagidx(::google::protobuf::int32 value);

  // required int32 ArrayIdx = 3;
  inline bool has_arrayidx() const;
  inline void clear_arrayidx();
  static const int kArrayIdxFieldNumber = 3;
  inline ::google::protobuf::int32 arrayidx() const;
  inline void set_arrayidx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSInbattleWeaponElmtBrief)
 private:
  inline void set_has_weaponguid();
  inline void clear_has_weaponguid();
  inline void set_has_bagidx();
  inline void clear_has_bagidx();
  inline void set_has_arrayidx();
  inline void clear_has_arrayidx();

  ::google::protobuf::uint64 weaponguid_;
  ::google::protobuf::int32 bagidx_;
  ::google::protobuf::int32 arrayidx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWeaponMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWeaponMsg_2eproto();

  void InitAsDefaultInstance();
  static CSInbattleWeaponElmtBrief* default_instance_;
};
// -------------------------------------------------------------------

class CSWeaponInBattleRqst : public ::google::protobuf::MessageLite {
 public:
  CSWeaponInBattleRqst();
  virtual ~CSWeaponInBattleRqst();

  CSWeaponInBattleRqst(const CSWeaponInBattleRqst& from);

  inline CSWeaponInBattleRqst& operator=(const CSWeaponInBattleRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWeaponInBattleRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWeaponInBattleRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWeaponInBattleRqst* other);

  // implements Message ----------------------------------------------

  CSWeaponInBattleRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWeaponInBattleRqst& from);
  void MergeFrom(const CSWeaponInBattleRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSInbattleWeaponElmtBrief OldWeapon = 1;
  inline bool has_oldweapon() const;
  inline void clear_oldweapon();
  static const int kOldWeaponFieldNumber = 1;
  inline const ::vmsg::CSInbattleWeaponElmtBrief& oldweapon() const;
  inline ::vmsg::CSInbattleWeaponElmtBrief* mutable_oldweapon();
  inline ::vmsg::CSInbattleWeaponElmtBrief* release_oldweapon();
  inline void set_allocated_oldweapon(::vmsg::CSInbattleWeaponElmtBrief* oldweapon);

  // optional .vmsg.CSInbattleWeaponElmtBrief NewWeapon = 2;
  inline bool has_newweapon() const;
  inline void clear_newweapon();
  static const int kNewWeaponFieldNumber = 2;
  inline const ::vmsg::CSInbattleWeaponElmtBrief& newweapon() const;
  inline ::vmsg::CSInbattleWeaponElmtBrief* mutable_newweapon();
  inline ::vmsg::CSInbattleWeaponElmtBrief* release_newweapon();
  inline void set_allocated_newweapon(::vmsg::CSInbattleWeaponElmtBrief* newweapon);

  // @@protoc_insertion_point(class_scope:vmsg.CSWeaponInBattleRqst)
 private:
  inline void set_has_oldweapon();
  inline void clear_has_oldweapon();
  inline void set_has_newweapon();
  inline void clear_has_newweapon();

  ::vmsg::CSInbattleWeaponElmtBrief* oldweapon_;
  ::vmsg::CSInbattleWeaponElmtBrief* newweapon_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWeaponMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWeaponMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWeaponInBattleRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSWeaponInBattleRsp : public ::google::protobuf::MessageLite {
 public:
  CSWeaponInBattleRsp();
  virtual ~CSWeaponInBattleRsp();

  CSWeaponInBattleRsp(const CSWeaponInBattleRsp& from);

  inline CSWeaponInBattleRsp& operator=(const CSWeaponInBattleRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWeaponInBattleRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWeaponInBattleRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWeaponInBattleRsp* other);

  // implements Message ----------------------------------------------

  CSWeaponInBattleRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWeaponInBattleRsp& from);
  void MergeFrom(const CSWeaponInBattleRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSWeapon EquippedWeapon = 1;
  inline bool has_equippedweapon() const;
  inline void clear_equippedweapon();
  static const int kEquippedWeaponFieldNumber = 1;
  inline const ::vmsg::CSWeapon& equippedweapon() const;
  inline ::vmsg::CSWeapon* mutable_equippedweapon();
  inline ::vmsg::CSWeapon* release_equippedweapon();
  inline void set_allocated_equippedweapon(::vmsg::CSWeapon* equippedweapon);

  // repeated .vmsg.CSInbattleWeaponElmt InBattleWeapons = 2;
  inline int inbattleweapons_size() const;
  inline void clear_inbattleweapons();
  static const int kInBattleWeaponsFieldNumber = 2;
  inline const ::vmsg::CSInbattleWeaponElmt& inbattleweapons(int index) const;
  inline ::vmsg::CSInbattleWeaponElmt* mutable_inbattleweapons(int index);
  inline ::vmsg::CSInbattleWeaponElmt* add_inbattleweapons();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSInbattleWeaponElmt >&
      inbattleweapons() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSInbattleWeaponElmt >*
      mutable_inbattleweapons();

  // required uint32 HPAddEff = 4;
  inline bool has_hpaddeff() const;
  inline void clear_hpaddeff();
  static const int kHPAddEffFieldNumber = 4;
  inline ::google::protobuf::uint32 hpaddeff() const;
  inline void set_hpaddeff(::google::protobuf::uint32 value);

  // required uint32 AtkAddEff = 5;
  inline bool has_atkaddeff() const;
  inline void clear_atkaddeff();
  static const int kAtkAddEffFieldNumber = 5;
  inline ::google::protobuf::uint32 atkaddeff() const;
  inline void set_atkaddeff(::google::protobuf::uint32 value);

  // required uint32 DefAddEff = 6;
  inline bool has_defaddeff() const;
  inline void clear_defaddeff();
  static const int kDefAddEffFieldNumber = 6;
  inline ::google::protobuf::uint32 defaddeff() const;
  inline void set_defaddeff(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSWeaponInBattleRsp)
 private:
  inline void set_has_equippedweapon();
  inline void clear_has_equippedweapon();
  inline void set_has_hpaddeff();
  inline void clear_has_hpaddeff();
  inline void set_has_atkaddeff();
  inline void clear_has_atkaddeff();
  inline void set_has_defaddeff();
  inline void clear_has_defaddeff();

  ::vmsg::CSWeapon* equippedweapon_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSInbattleWeaponElmt > inbattleweapons_;
  ::google::protobuf::uint32 hpaddeff_;
  ::google::protobuf::uint32 atkaddeff_;
  ::google::protobuf::uint32 defaddeff_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWeaponMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWeaponMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWeaponInBattleRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSWeaponLvUpRsp : public ::google::protobuf::MessageLite {
 public:
  CSWeaponLvUpRsp();
  virtual ~CSWeaponLvUpRsp();

  CSWeaponLvUpRsp(const CSWeaponLvUpRsp& from);

  inline CSWeaponLvUpRsp& operator=(const CSWeaponLvUpRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWeaponLvUpRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWeaponLvUpRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWeaponLvUpRsp* other);

  // implements Message ----------------------------------------------

  CSWeaponLvUpRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWeaponLvUpRsp& from);
  void MergeFrom(const CSWeaponLvUpRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSWeapon Weapon = 1;
  inline bool has_weapon() const;
  inline void clear_weapon();
  static const int kWeaponFieldNumber = 1;
  inline const ::vmsg::CSWeapon& weapon() const;
  inline ::vmsg::CSWeapon* mutable_weapon();
  inline ::vmsg::CSWeapon* release_weapon();
  inline void set_allocated_weapon(::vmsg::CSWeapon* weapon);

  // required .vmsg.CSBagInfo Bag = 2;
  inline bool has_bag() const;
  inline void clear_bag();
  static const int kBagFieldNumber = 2;
  inline const ::vmsg::CSBagInfo& bag() const;
  inline ::vmsg::CSBagInfo* mutable_bag();
  inline ::vmsg::CSBagInfo* release_bag();
  inline void set_allocated_bag(::vmsg::CSBagInfo* bag);

  // @@protoc_insertion_point(class_scope:vmsg.CSWeaponLvUpRsp)
 private:
  inline void set_has_weapon();
  inline void clear_has_weapon();
  inline void set_has_bag();
  inline void clear_has_bag();

  ::vmsg::CSWeapon* weapon_;
  ::vmsg::CSBagInfo* bag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWeaponMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWeaponMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWeaponLvUpRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSWeaponRequest : public ::google::protobuf::MessageLite {
 public:
  CSWeaponRequest();
  virtual ~CSWeaponRequest();

  CSWeaponRequest(const CSWeaponRequest& from);

  inline CSWeaponRequest& operator=(const CSWeaponRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWeaponRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWeaponRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWeaponRequest* other);

  // implements Message ----------------------------------------------

  CSWeaponRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWeaponRequest& from);
  void MergeFrom(const CSWeaponRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSWeaponChangeRqst WeaponChange_Rqst = 1;
  inline bool has_weaponchange_rqst() const;
  inline void clear_weaponchange_rqst();
  static const int kWeaponChangeRqstFieldNumber = 1;
  inline const ::vmsg::CSWeaponChangeRqst& weaponchange_rqst() const;
  inline ::vmsg::CSWeaponChangeRqst* mutable_weaponchange_rqst();
  inline ::vmsg::CSWeaponChangeRqst* release_weaponchange_rqst();
  inline void set_allocated_weaponchange_rqst(::vmsg::CSWeaponChangeRqst* weaponchange_rqst);

  // optional .vmsg.CSWeaponLvUpRqst WeaponLvUp_Rqst = 2;
  inline bool has_weaponlvup_rqst() const;
  inline void clear_weaponlvup_rqst();
  static const int kWeaponLvUpRqstFieldNumber = 2;
  inline const ::vmsg::CSWeaponLvUpRqst& weaponlvup_rqst() const;
  inline ::vmsg::CSWeaponLvUpRqst* mutable_weaponlvup_rqst();
  inline ::vmsg::CSWeaponLvUpRqst* release_weaponlvup_rqst();
  inline void set_allocated_weaponlvup_rqst(::vmsg::CSWeaponLvUpRqst* weaponlvup_rqst);

  // optional .vmsg.CSWeaponStarStepRqst WeaponStarStep_Rqst = 3;
  inline bool has_weaponstarstep_rqst() const;
  inline void clear_weaponstarstep_rqst();
  static const int kWeaponStarStepRqstFieldNumber = 3;
  inline const ::vmsg::CSWeaponStarStepRqst& weaponstarstep_rqst() const;
  inline ::vmsg::CSWeaponStarStepRqst* mutable_weaponstarstep_rqst();
  inline ::vmsg::CSWeaponStarStepRqst* release_weaponstarstep_rqst();
  inline void set_allocated_weaponstarstep_rqst(::vmsg::CSWeaponStarStepRqst* weaponstarstep_rqst);

  // optional .vmsg.CSWeaponRefitRqst WeaponRefit_Rqst = 4;
  inline bool has_weaponrefit_rqst() const;
  inline void clear_weaponrefit_rqst();
  static const int kWeaponRefitRqstFieldNumber = 4;
  inline const ::vmsg::CSWeaponRefitRqst& weaponrefit_rqst() const;
  inline ::vmsg::CSWeaponRefitRqst* mutable_weaponrefit_rqst();
  inline ::vmsg::CSWeaponRefitRqst* release_weaponrefit_rqst();
  inline void set_allocated_weaponrefit_rqst(::vmsg::CSWeaponRefitRqst* weaponrefit_rqst);

  // optional .vmsg.CSWeaponInBattleRqst ChangeWeaponInBattle_Rqst = 5;
  inline bool has_changeweaponinbattle_rqst() const;
  inline void clear_changeweaponinbattle_rqst();
  static const int kChangeWeaponInBattleRqstFieldNumber = 5;
  inline const ::vmsg::CSWeaponInBattleRqst& changeweaponinbattle_rqst() const;
  inline ::vmsg::CSWeaponInBattleRqst* mutable_changeweaponinbattle_rqst();
  inline ::vmsg::CSWeaponInBattleRqst* release_changeweaponinbattle_rqst();
  inline void set_allocated_changeweaponinbattle_rqst(::vmsg::CSWeaponInBattleRqst* changeweaponinbattle_rqst);

  // @@protoc_insertion_point(class_scope:vmsg.CSWeaponRequest)
 private:
  inline void set_has_weaponchange_rqst();
  inline void clear_has_weaponchange_rqst();
  inline void set_has_weaponlvup_rqst();
  inline void clear_has_weaponlvup_rqst();
  inline void set_has_weaponstarstep_rqst();
  inline void clear_has_weaponstarstep_rqst();
  inline void set_has_weaponrefit_rqst();
  inline void clear_has_weaponrefit_rqst();
  inline void set_has_changeweaponinbattle_rqst();
  inline void clear_has_changeweaponinbattle_rqst();

  ::vmsg::CSWeaponChangeRqst* weaponchange_rqst_;
  ::vmsg::CSWeaponLvUpRqst* weaponlvup_rqst_;
  ::vmsg::CSWeaponStarStepRqst* weaponstarstep_rqst_;
  ::vmsg::CSWeaponRefitRqst* weaponrefit_rqst_;
  ::vmsg::CSWeaponInBattleRqst* changeweaponinbattle_rqst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWeaponMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWeaponMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWeaponRequest* default_instance_;
};
// -------------------------------------------------------------------

class CSWeaponRespond : public ::google::protobuf::MessageLite {
 public:
  CSWeaponRespond();
  virtual ~CSWeaponRespond();

  CSWeaponRespond(const CSWeaponRespond& from);

  inline CSWeaponRespond& operator=(const CSWeaponRespond& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWeaponRespond& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWeaponRespond* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWeaponRespond* other);

  // implements Message ----------------------------------------------

  CSWeaponRespond* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWeaponRespond& from);
  void MergeFrom(const CSWeaponRespond& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSWeaponBag WeaponQueryBag_Rsp = 1;
  inline bool has_weaponquerybag_rsp() const;
  inline void clear_weaponquerybag_rsp();
  static const int kWeaponQueryBagRspFieldNumber = 1;
  inline const ::vmsg::CSWeaponBag& weaponquerybag_rsp() const;
  inline ::vmsg::CSWeaponBag* mutable_weaponquerybag_rsp();
  inline ::vmsg::CSWeaponBag* release_weaponquerybag_rsp();
  inline void set_allocated_weaponquerybag_rsp(::vmsg::CSWeaponBag* weaponquerybag_rsp);

  // optional .vmsg.CSWeaponBag WeaponChange_Rsp = 2;
  inline bool has_weaponchange_rsp() const;
  inline void clear_weaponchange_rsp();
  static const int kWeaponChangeRspFieldNumber = 2;
  inline const ::vmsg::CSWeaponBag& weaponchange_rsp() const;
  inline ::vmsg::CSWeaponBag* mutable_weaponchange_rsp();
  inline ::vmsg::CSWeaponBag* release_weaponchange_rsp();
  inline void set_allocated_weaponchange_rsp(::vmsg::CSWeaponBag* weaponchange_rsp);

  // optional .vmsg.CSWeaponLvUpRsp WeaponLvUp_Rsp = 3;
  inline bool has_weaponlvup_rsp() const;
  inline void clear_weaponlvup_rsp();
  static const int kWeaponLvUpRspFieldNumber = 3;
  inline const ::vmsg::CSWeaponLvUpRsp& weaponlvup_rsp() const;
  inline ::vmsg::CSWeaponLvUpRsp* mutable_weaponlvup_rsp();
  inline ::vmsg::CSWeaponLvUpRsp* release_weaponlvup_rsp();
  inline void set_allocated_weaponlvup_rsp(::vmsg::CSWeaponLvUpRsp* weaponlvup_rsp);

  // optional .vmsg.CSWeaponBag WeaponStarStep_Rsp = 4;
  inline bool has_weaponstarstep_rsp() const;
  inline void clear_weaponstarstep_rsp();
  static const int kWeaponStarStepRspFieldNumber = 4;
  inline const ::vmsg::CSWeaponBag& weaponstarstep_rsp() const;
  inline ::vmsg::CSWeaponBag* mutable_weaponstarstep_rsp();
  inline ::vmsg::CSWeaponBag* release_weaponstarstep_rsp();
  inline void set_allocated_weaponstarstep_rsp(::vmsg::CSWeaponBag* weaponstarstep_rsp);

  // optional .vmsg.CSWeaponBag WeaponRefit_Rsp = 5;
  inline bool has_weaponrefit_rsp() const;
  inline void clear_weaponrefit_rsp();
  static const int kWeaponRefitRspFieldNumber = 5;
  inline const ::vmsg::CSWeaponBag& weaponrefit_rsp() const;
  inline ::vmsg::CSWeaponBag* mutable_weaponrefit_rsp();
  inline ::vmsg::CSWeaponBag* release_weaponrefit_rsp();
  inline void set_allocated_weaponrefit_rsp(::vmsg::CSWeaponBag* weaponrefit_rsp);

  // optional .vmsg.CSWeaponInBattleRsp ChangeWeaponInBattle_Rsp = 6;
  inline bool has_changeweaponinbattle_rsp() const;
  inline void clear_changeweaponinbattle_rsp();
  static const int kChangeWeaponInBattleRspFieldNumber = 6;
  inline const ::vmsg::CSWeaponInBattleRsp& changeweaponinbattle_rsp() const;
  inline ::vmsg::CSWeaponInBattleRsp* mutable_changeweaponinbattle_rsp();
  inline ::vmsg::CSWeaponInBattleRsp* release_changeweaponinbattle_rsp();
  inline void set_allocated_changeweaponinbattle_rsp(::vmsg::CSWeaponInBattleRsp* changeweaponinbattle_rsp);

  // optional .vmsg.CSWeaponInBattleRsp QueryWeaponInBattle_Rsp = 7;
  inline bool has_queryweaponinbattle_rsp() const;
  inline void clear_queryweaponinbattle_rsp();
  static const int kQueryWeaponInBattleRspFieldNumber = 7;
  inline const ::vmsg::CSWeaponInBattleRsp& queryweaponinbattle_rsp() const;
  inline ::vmsg::CSWeaponInBattleRsp* mutable_queryweaponinbattle_rsp();
  inline ::vmsg::CSWeaponInBattleRsp* release_queryweaponinbattle_rsp();
  inline void set_allocated_queryweaponinbattle_rsp(::vmsg::CSWeaponInBattleRsp* queryweaponinbattle_rsp);

  // @@protoc_insertion_point(class_scope:vmsg.CSWeaponRespond)
 private:
  inline void set_has_weaponquerybag_rsp();
  inline void clear_has_weaponquerybag_rsp();
  inline void set_has_weaponchange_rsp();
  inline void clear_has_weaponchange_rsp();
  inline void set_has_weaponlvup_rsp();
  inline void clear_has_weaponlvup_rsp();
  inline void set_has_weaponstarstep_rsp();
  inline void clear_has_weaponstarstep_rsp();
  inline void set_has_weaponrefit_rsp();
  inline void clear_has_weaponrefit_rsp();
  inline void set_has_changeweaponinbattle_rsp();
  inline void clear_has_changeweaponinbattle_rsp();
  inline void set_has_queryweaponinbattle_rsp();
  inline void clear_has_queryweaponinbattle_rsp();

  ::vmsg::CSWeaponBag* weaponquerybag_rsp_;
  ::vmsg::CSWeaponBag* weaponchange_rsp_;
  ::vmsg::CSWeaponLvUpRsp* weaponlvup_rsp_;
  ::vmsg::CSWeaponBag* weaponstarstep_rsp_;
  ::vmsg::CSWeaponBag* weaponrefit_rsp_;
  ::vmsg::CSWeaponInBattleRsp* changeweaponinbattle_rsp_;
  ::vmsg::CSWeaponInBattleRsp* queryweaponinbattle_rsp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSWeaponMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSWeaponMsg_2eproto();
  friend void protobuf_ShutdownFile_CSWeaponMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWeaponRespond* default_instance_;
};
// ===================================================================


// ===================================================================

// CSWeaponBag

// repeated .vmsg.CSWeapon Weapons = 1;
inline int CSWeaponBag::weapons_size() const {
  return weapons_.size();
}
inline void CSWeaponBag::clear_weapons() {
  weapons_.Clear();
}
inline const ::vmsg::CSWeapon& CSWeaponBag::weapons(int index) const {
  return weapons_.Get(index);
}
inline ::vmsg::CSWeapon* CSWeaponBag::mutable_weapons(int index) {
  return weapons_.Mutable(index);
}
inline ::vmsg::CSWeapon* CSWeaponBag::add_weapons() {
  return weapons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSWeapon >&
CSWeaponBag::weapons() const {
  return weapons_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSWeapon >*
CSWeaponBag::mutable_weapons() {
  return &weapons_;
}

// required .vmsg.CSWeapon PlayerWeapon = 2;
inline bool CSWeaponBag::has_playerweapon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWeaponBag::set_has_playerweapon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWeaponBag::clear_has_playerweapon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWeaponBag::clear_playerweapon() {
  if (playerweapon_ != NULL) playerweapon_->::vmsg::CSWeapon::Clear();
  clear_has_playerweapon();
}
inline const ::vmsg::CSWeapon& CSWeaponBag::playerweapon() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerweapon_ != NULL ? *playerweapon_ : *default_instance().playerweapon_;
#else
  return playerweapon_ != NULL ? *playerweapon_ : *default_instance_->playerweapon_;
#endif
}
inline ::vmsg::CSWeapon* CSWeaponBag::mutable_playerweapon() {
  set_has_playerweapon();
  if (playerweapon_ == NULL) playerweapon_ = new ::vmsg::CSWeapon;
  return playerweapon_;
}
inline ::vmsg::CSWeapon* CSWeaponBag::release_playerweapon() {
  clear_has_playerweapon();
  ::vmsg::CSWeapon* temp = playerweapon_;
  playerweapon_ = NULL;
  return temp;
}
inline void CSWeaponBag::set_allocated_playerweapon(::vmsg::CSWeapon* playerweapon) {
  delete playerweapon_;
  playerweapon_ = playerweapon;
  if (playerweapon) {
    set_has_playerweapon();
  } else {
    clear_has_playerweapon();
  }
}

// required uint32 Capacity = 3;
inline bool CSWeaponBag::has_capacity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSWeaponBag::set_has_capacity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSWeaponBag::clear_has_capacity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSWeaponBag::clear_capacity() {
  capacity_ = 0u;
  clear_has_capacity();
}
inline ::google::protobuf::uint32 CSWeaponBag::capacity() const {
  return capacity_;
}
inline void CSWeaponBag::set_capacity(::google::protobuf::uint32 value) {
  set_has_capacity();
  capacity_ = value;
}

// -------------------------------------------------------------------

// CSWeaponChangeRqst

// required int32 BagIdx = 1;
inline bool CSWeaponChangeRqst::has_bagidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWeaponChangeRqst::set_has_bagidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWeaponChangeRqst::clear_has_bagidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWeaponChangeRqst::clear_bagidx() {
  bagidx_ = 0;
  clear_has_bagidx();
}
inline ::google::protobuf::int32 CSWeaponChangeRqst::bagidx() const {
  return bagidx_;
}
inline void CSWeaponChangeRqst::set_bagidx(::google::protobuf::int32 value) {
  set_has_bagidx();
  bagidx_ = value;
}

// required uint64 WeaponGUID = 2;
inline bool CSWeaponChangeRqst::has_weaponguid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWeaponChangeRqst::set_has_weaponguid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWeaponChangeRqst::clear_has_weaponguid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWeaponChangeRqst::clear_weaponguid() {
  weaponguid_ = GOOGLE_ULONGLONG(0);
  clear_has_weaponguid();
}
inline ::google::protobuf::uint64 CSWeaponChangeRqst::weaponguid() const {
  return weaponguid_;
}
inline void CSWeaponChangeRqst::set_weaponguid(::google::protobuf::uint64 value) {
  set_has_weaponguid();
  weaponguid_ = value;
}

// -------------------------------------------------------------------

// CSWeaponLvUpConsume

// required uint32 Type = 1;
inline bool CSWeaponLvUpConsume::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWeaponLvUpConsume::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWeaponLvUpConsume::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWeaponLvUpConsume::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSWeaponLvUpConsume::type() const {
  return type_;
}
inline void CSWeaponLvUpConsume::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required uint64 ID = 2;
inline bool CSWeaponLvUpConsume::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWeaponLvUpConsume::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWeaponLvUpConsume::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWeaponLvUpConsume::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 CSWeaponLvUpConsume::id() const {
  return id_;
}
inline void CSWeaponLvUpConsume::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// required uint64 Cnt = 3;
inline bool CSWeaponLvUpConsume::has_cnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSWeaponLvUpConsume::set_has_cnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSWeaponLvUpConsume::clear_has_cnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSWeaponLvUpConsume::clear_cnt() {
  cnt_ = GOOGLE_ULONGLONG(0);
  clear_has_cnt();
}
inline ::google::protobuf::uint64 CSWeaponLvUpConsume::cnt() const {
  return cnt_;
}
inline void CSWeaponLvUpConsume::set_cnt(::google::protobuf::uint64 value) {
  set_has_cnt();
  cnt_ = value;
}

// -------------------------------------------------------------------

// CSWeaponLvUpRqst

// required int32 BagIdx = 1;
inline bool CSWeaponLvUpRqst::has_bagidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWeaponLvUpRqst::set_has_bagidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWeaponLvUpRqst::clear_has_bagidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWeaponLvUpRqst::clear_bagidx() {
  bagidx_ = 0;
  clear_has_bagidx();
}
inline ::google::protobuf::int32 CSWeaponLvUpRqst::bagidx() const {
  return bagidx_;
}
inline void CSWeaponLvUpRqst::set_bagidx(::google::protobuf::int32 value) {
  set_has_bagidx();
  bagidx_ = value;
}

// required uint64 WeaponGUID = 2;
inline bool CSWeaponLvUpRqst::has_weaponguid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWeaponLvUpRqst::set_has_weaponguid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWeaponLvUpRqst::clear_has_weaponguid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWeaponLvUpRqst::clear_weaponguid() {
  weaponguid_ = GOOGLE_ULONGLONG(0);
  clear_has_weaponguid();
}
inline ::google::protobuf::uint64 CSWeaponLvUpRqst::weaponguid() const {
  return weaponguid_;
}
inline void CSWeaponLvUpRqst::set_weaponguid(::google::protobuf::uint64 value) {
  set_has_weaponguid();
  weaponguid_ = value;
}

// repeated .vmsg.CSWeaponLvUpConsume Consumes = 3;
inline int CSWeaponLvUpRqst::consumes_size() const {
  return consumes_.size();
}
inline void CSWeaponLvUpRqst::clear_consumes() {
  consumes_.Clear();
}
inline const ::vmsg::CSWeaponLvUpConsume& CSWeaponLvUpRqst::consumes(int index) const {
  return consumes_.Get(index);
}
inline ::vmsg::CSWeaponLvUpConsume* CSWeaponLvUpRqst::mutable_consumes(int index) {
  return consumes_.Mutable(index);
}
inline ::vmsg::CSWeaponLvUpConsume* CSWeaponLvUpRqst::add_consumes() {
  return consumes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSWeaponLvUpConsume >&
CSWeaponLvUpRqst::consumes() const {
  return consumes_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSWeaponLvUpConsume >*
CSWeaponLvUpRqst::mutable_consumes() {
  return &consumes_;
}

// -------------------------------------------------------------------

// CSWeaponStarStepRqst

// required int32 BagIdx = 1;
inline bool CSWeaponStarStepRqst::has_bagidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWeaponStarStepRqst::set_has_bagidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWeaponStarStepRqst::clear_has_bagidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWeaponStarStepRqst::clear_bagidx() {
  bagidx_ = 0;
  clear_has_bagidx();
}
inline ::google::protobuf::int32 CSWeaponStarStepRqst::bagidx() const {
  return bagidx_;
}
inline void CSWeaponStarStepRqst::set_bagidx(::google::protobuf::int32 value) {
  set_has_bagidx();
  bagidx_ = value;
}

// required uint64 WeaponGUID = 2;
inline bool CSWeaponStarStepRqst::has_weaponguid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWeaponStarStepRqst::set_has_weaponguid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWeaponStarStepRqst::clear_has_weaponguid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWeaponStarStepRqst::clear_weaponguid() {
  weaponguid_ = GOOGLE_ULONGLONG(0);
  clear_has_weaponguid();
}
inline ::google::protobuf::uint64 CSWeaponStarStepRqst::weaponguid() const {
  return weaponguid_;
}
inline void CSWeaponStarStepRqst::set_weaponguid(::google::protobuf::uint64 value) {
  set_has_weaponguid();
  weaponguid_ = value;
}

// repeated uint64 NeedWeaponGUIDs = 3;
inline int CSWeaponStarStepRqst::needweaponguids_size() const {
  return needweaponguids_.size();
}
inline void CSWeaponStarStepRqst::clear_needweaponguids() {
  needweaponguids_.Clear();
}
inline ::google::protobuf::uint64 CSWeaponStarStepRqst::needweaponguids(int index) const {
  return needweaponguids_.Get(index);
}
inline void CSWeaponStarStepRqst::set_needweaponguids(int index, ::google::protobuf::uint64 value) {
  needweaponguids_.Set(index, value);
}
inline void CSWeaponStarStepRqst::add_needweaponguids(::google::protobuf::uint64 value) {
  needweaponguids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CSWeaponStarStepRqst::needweaponguids() const {
  return needweaponguids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CSWeaponStarStepRqst::mutable_needweaponguids() {
  return &needweaponguids_;
}

// -------------------------------------------------------------------

// CSWeaponRefitRqst

// required int32 BagIdx = 1;
inline bool CSWeaponRefitRqst::has_bagidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWeaponRefitRqst::set_has_bagidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWeaponRefitRqst::clear_has_bagidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWeaponRefitRqst::clear_bagidx() {
  bagidx_ = 0;
  clear_has_bagidx();
}
inline ::google::protobuf::int32 CSWeaponRefitRqst::bagidx() const {
  return bagidx_;
}
inline void CSWeaponRefitRqst::set_bagidx(::google::protobuf::int32 value) {
  set_has_bagidx();
  bagidx_ = value;
}

// required uint64 WeaponGUID = 2;
inline bool CSWeaponRefitRqst::has_weaponguid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWeaponRefitRqst::set_has_weaponguid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWeaponRefitRqst::clear_has_weaponguid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWeaponRefitRqst::clear_weaponguid() {
  weaponguid_ = GOOGLE_ULONGLONG(0);
  clear_has_weaponguid();
}
inline ::google::protobuf::uint64 CSWeaponRefitRqst::weaponguid() const {
  return weaponguid_;
}
inline void CSWeaponRefitRqst::set_weaponguid(::google::protobuf::uint64 value) {
  set_has_weaponguid();
  weaponguid_ = value;
}

// -------------------------------------------------------------------

// CSInbattleWeaponElmtBrief

// required uint64 WeaponGUID = 1;
inline bool CSInbattleWeaponElmtBrief::has_weaponguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSInbattleWeaponElmtBrief::set_has_weaponguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSInbattleWeaponElmtBrief::clear_has_weaponguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSInbattleWeaponElmtBrief::clear_weaponguid() {
  weaponguid_ = GOOGLE_ULONGLONG(0);
  clear_has_weaponguid();
}
inline ::google::protobuf::uint64 CSInbattleWeaponElmtBrief::weaponguid() const {
  return weaponguid_;
}
inline void CSInbattleWeaponElmtBrief::set_weaponguid(::google::protobuf::uint64 value) {
  set_has_weaponguid();
  weaponguid_ = value;
}

// required int32 BagIdx = 2;
inline bool CSInbattleWeaponElmtBrief::has_bagidx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSInbattleWeaponElmtBrief::set_has_bagidx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSInbattleWeaponElmtBrief::clear_has_bagidx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSInbattleWeaponElmtBrief::clear_bagidx() {
  bagidx_ = 0;
  clear_has_bagidx();
}
inline ::google::protobuf::int32 CSInbattleWeaponElmtBrief::bagidx() const {
  return bagidx_;
}
inline void CSInbattleWeaponElmtBrief::set_bagidx(::google::protobuf::int32 value) {
  set_has_bagidx();
  bagidx_ = value;
}

// required int32 ArrayIdx = 3;
inline bool CSInbattleWeaponElmtBrief::has_arrayidx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSInbattleWeaponElmtBrief::set_has_arrayidx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSInbattleWeaponElmtBrief::clear_has_arrayidx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSInbattleWeaponElmtBrief::clear_arrayidx() {
  arrayidx_ = 0;
  clear_has_arrayidx();
}
inline ::google::protobuf::int32 CSInbattleWeaponElmtBrief::arrayidx() const {
  return arrayidx_;
}
inline void CSInbattleWeaponElmtBrief::set_arrayidx(::google::protobuf::int32 value) {
  set_has_arrayidx();
  arrayidx_ = value;
}

// -------------------------------------------------------------------

// CSWeaponInBattleRqst

// optional .vmsg.CSInbattleWeaponElmtBrief OldWeapon = 1;
inline bool CSWeaponInBattleRqst::has_oldweapon() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWeaponInBattleRqst::set_has_oldweapon() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWeaponInBattleRqst::clear_has_oldweapon() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWeaponInBattleRqst::clear_oldweapon() {
  if (oldweapon_ != NULL) oldweapon_->::vmsg::CSInbattleWeaponElmtBrief::Clear();
  clear_has_oldweapon();
}
inline const ::vmsg::CSInbattleWeaponElmtBrief& CSWeaponInBattleRqst::oldweapon() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return oldweapon_ != NULL ? *oldweapon_ : *default_instance().oldweapon_;
#else
  return oldweapon_ != NULL ? *oldweapon_ : *default_instance_->oldweapon_;
#endif
}
inline ::vmsg::CSInbattleWeaponElmtBrief* CSWeaponInBattleRqst::mutable_oldweapon() {
  set_has_oldweapon();
  if (oldweapon_ == NULL) oldweapon_ = new ::vmsg::CSInbattleWeaponElmtBrief;
  return oldweapon_;
}
inline ::vmsg::CSInbattleWeaponElmtBrief* CSWeaponInBattleRqst::release_oldweapon() {
  clear_has_oldweapon();
  ::vmsg::CSInbattleWeaponElmtBrief* temp = oldweapon_;
  oldweapon_ = NULL;
  return temp;
}
inline void CSWeaponInBattleRqst::set_allocated_oldweapon(::vmsg::CSInbattleWeaponElmtBrief* oldweapon) {
  delete oldweapon_;
  oldweapon_ = oldweapon;
  if (oldweapon) {
    set_has_oldweapon();
  } else {
    clear_has_oldweapon();
  }
}

// optional .vmsg.CSInbattleWeaponElmtBrief NewWeapon = 2;
inline bool CSWeaponInBattleRqst::has_newweapon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWeaponInBattleRqst::set_has_newweapon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWeaponInBattleRqst::clear_has_newweapon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWeaponInBattleRqst::clear_newweapon() {
  if (newweapon_ != NULL) newweapon_->::vmsg::CSInbattleWeaponElmtBrief::Clear();
  clear_has_newweapon();
}
inline const ::vmsg::CSInbattleWeaponElmtBrief& CSWeaponInBattleRqst::newweapon() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return newweapon_ != NULL ? *newweapon_ : *default_instance().newweapon_;
#else
  return newweapon_ != NULL ? *newweapon_ : *default_instance_->newweapon_;
#endif
}
inline ::vmsg::CSInbattleWeaponElmtBrief* CSWeaponInBattleRqst::mutable_newweapon() {
  set_has_newweapon();
  if (newweapon_ == NULL) newweapon_ = new ::vmsg::CSInbattleWeaponElmtBrief;
  return newweapon_;
}
inline ::vmsg::CSInbattleWeaponElmtBrief* CSWeaponInBattleRqst::release_newweapon() {
  clear_has_newweapon();
  ::vmsg::CSInbattleWeaponElmtBrief* temp = newweapon_;
  newweapon_ = NULL;
  return temp;
}
inline void CSWeaponInBattleRqst::set_allocated_newweapon(::vmsg::CSInbattleWeaponElmtBrief* newweapon) {
  delete newweapon_;
  newweapon_ = newweapon;
  if (newweapon) {
    set_has_newweapon();
  } else {
    clear_has_newweapon();
  }
}

// -------------------------------------------------------------------

// CSWeaponInBattleRsp

// required .vmsg.CSWeapon EquippedWeapon = 1;
inline bool CSWeaponInBattleRsp::has_equippedweapon() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWeaponInBattleRsp::set_has_equippedweapon() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWeaponInBattleRsp::clear_has_equippedweapon() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWeaponInBattleRsp::clear_equippedweapon() {
  if (equippedweapon_ != NULL) equippedweapon_->::vmsg::CSWeapon::Clear();
  clear_has_equippedweapon();
}
inline const ::vmsg::CSWeapon& CSWeaponInBattleRsp::equippedweapon() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equippedweapon_ != NULL ? *equippedweapon_ : *default_instance().equippedweapon_;
#else
  return equippedweapon_ != NULL ? *equippedweapon_ : *default_instance_->equippedweapon_;
#endif
}
inline ::vmsg::CSWeapon* CSWeaponInBattleRsp::mutable_equippedweapon() {
  set_has_equippedweapon();
  if (equippedweapon_ == NULL) equippedweapon_ = new ::vmsg::CSWeapon;
  return equippedweapon_;
}
inline ::vmsg::CSWeapon* CSWeaponInBattleRsp::release_equippedweapon() {
  clear_has_equippedweapon();
  ::vmsg::CSWeapon* temp = equippedweapon_;
  equippedweapon_ = NULL;
  return temp;
}
inline void CSWeaponInBattleRsp::set_allocated_equippedweapon(::vmsg::CSWeapon* equippedweapon) {
  delete equippedweapon_;
  equippedweapon_ = equippedweapon;
  if (equippedweapon) {
    set_has_equippedweapon();
  } else {
    clear_has_equippedweapon();
  }
}

// repeated .vmsg.CSInbattleWeaponElmt InBattleWeapons = 2;
inline int CSWeaponInBattleRsp::inbattleweapons_size() const {
  return inbattleweapons_.size();
}
inline void CSWeaponInBattleRsp::clear_inbattleweapons() {
  inbattleweapons_.Clear();
}
inline const ::vmsg::CSInbattleWeaponElmt& CSWeaponInBattleRsp::inbattleweapons(int index) const {
  return inbattleweapons_.Get(index);
}
inline ::vmsg::CSInbattleWeaponElmt* CSWeaponInBattleRsp::mutable_inbattleweapons(int index) {
  return inbattleweapons_.Mutable(index);
}
inline ::vmsg::CSInbattleWeaponElmt* CSWeaponInBattleRsp::add_inbattleweapons() {
  return inbattleweapons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSInbattleWeaponElmt >&
CSWeaponInBattleRsp::inbattleweapons() const {
  return inbattleweapons_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSInbattleWeaponElmt >*
CSWeaponInBattleRsp::mutable_inbattleweapons() {
  return &inbattleweapons_;
}

// required uint32 HPAddEff = 4;
inline bool CSWeaponInBattleRsp::has_hpaddeff() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSWeaponInBattleRsp::set_has_hpaddeff() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSWeaponInBattleRsp::clear_has_hpaddeff() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSWeaponInBattleRsp::clear_hpaddeff() {
  hpaddeff_ = 0u;
  clear_has_hpaddeff();
}
inline ::google::protobuf::uint32 CSWeaponInBattleRsp::hpaddeff() const {
  return hpaddeff_;
}
inline void CSWeaponInBattleRsp::set_hpaddeff(::google::protobuf::uint32 value) {
  set_has_hpaddeff();
  hpaddeff_ = value;
}

// required uint32 AtkAddEff = 5;
inline bool CSWeaponInBattleRsp::has_atkaddeff() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSWeaponInBattleRsp::set_has_atkaddeff() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSWeaponInBattleRsp::clear_has_atkaddeff() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSWeaponInBattleRsp::clear_atkaddeff() {
  atkaddeff_ = 0u;
  clear_has_atkaddeff();
}
inline ::google::protobuf::uint32 CSWeaponInBattleRsp::atkaddeff() const {
  return atkaddeff_;
}
inline void CSWeaponInBattleRsp::set_atkaddeff(::google::protobuf::uint32 value) {
  set_has_atkaddeff();
  atkaddeff_ = value;
}

// required uint32 DefAddEff = 6;
inline bool CSWeaponInBattleRsp::has_defaddeff() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSWeaponInBattleRsp::set_has_defaddeff() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSWeaponInBattleRsp::clear_has_defaddeff() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSWeaponInBattleRsp::clear_defaddeff() {
  defaddeff_ = 0u;
  clear_has_defaddeff();
}
inline ::google::protobuf::uint32 CSWeaponInBattleRsp::defaddeff() const {
  return defaddeff_;
}
inline void CSWeaponInBattleRsp::set_defaddeff(::google::protobuf::uint32 value) {
  set_has_defaddeff();
  defaddeff_ = value;
}

// -------------------------------------------------------------------

// CSWeaponLvUpRsp

// required .vmsg.CSWeapon Weapon = 1;
inline bool CSWeaponLvUpRsp::has_weapon() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWeaponLvUpRsp::set_has_weapon() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWeaponLvUpRsp::clear_has_weapon() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWeaponLvUpRsp::clear_weapon() {
  if (weapon_ != NULL) weapon_->::vmsg::CSWeapon::Clear();
  clear_has_weapon();
}
inline const ::vmsg::CSWeapon& CSWeaponLvUpRsp::weapon() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return weapon_ != NULL ? *weapon_ : *default_instance().weapon_;
#else
  return weapon_ != NULL ? *weapon_ : *default_instance_->weapon_;
#endif
}
inline ::vmsg::CSWeapon* CSWeaponLvUpRsp::mutable_weapon() {
  set_has_weapon();
  if (weapon_ == NULL) weapon_ = new ::vmsg::CSWeapon;
  return weapon_;
}
inline ::vmsg::CSWeapon* CSWeaponLvUpRsp::release_weapon() {
  clear_has_weapon();
  ::vmsg::CSWeapon* temp = weapon_;
  weapon_ = NULL;
  return temp;
}
inline void CSWeaponLvUpRsp::set_allocated_weapon(::vmsg::CSWeapon* weapon) {
  delete weapon_;
  weapon_ = weapon;
  if (weapon) {
    set_has_weapon();
  } else {
    clear_has_weapon();
  }
}

// required .vmsg.CSBagInfo Bag = 2;
inline bool CSWeaponLvUpRsp::has_bag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWeaponLvUpRsp::set_has_bag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWeaponLvUpRsp::clear_has_bag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWeaponLvUpRsp::clear_bag() {
  if (bag_ != NULL) bag_->::vmsg::CSBagInfo::Clear();
  clear_has_bag();
}
inline const ::vmsg::CSBagInfo& CSWeaponLvUpRsp::bag() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bag_ != NULL ? *bag_ : *default_instance().bag_;
#else
  return bag_ != NULL ? *bag_ : *default_instance_->bag_;
#endif
}
inline ::vmsg::CSBagInfo* CSWeaponLvUpRsp::mutable_bag() {
  set_has_bag();
  if (bag_ == NULL) bag_ = new ::vmsg::CSBagInfo;
  return bag_;
}
inline ::vmsg::CSBagInfo* CSWeaponLvUpRsp::release_bag() {
  clear_has_bag();
  ::vmsg::CSBagInfo* temp = bag_;
  bag_ = NULL;
  return temp;
}
inline void CSWeaponLvUpRsp::set_allocated_bag(::vmsg::CSBagInfo* bag) {
  delete bag_;
  bag_ = bag;
  if (bag) {
    set_has_bag();
  } else {
    clear_has_bag();
  }
}

// -------------------------------------------------------------------

// CSWeaponRequest

// optional .vmsg.CSWeaponChangeRqst WeaponChange_Rqst = 1;
inline bool CSWeaponRequest::has_weaponchange_rqst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWeaponRequest::set_has_weaponchange_rqst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWeaponRequest::clear_has_weaponchange_rqst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWeaponRequest::clear_weaponchange_rqst() {
  if (weaponchange_rqst_ != NULL) weaponchange_rqst_->::vmsg::CSWeaponChangeRqst::Clear();
  clear_has_weaponchange_rqst();
}
inline const ::vmsg::CSWeaponChangeRqst& CSWeaponRequest::weaponchange_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return weaponchange_rqst_ != NULL ? *weaponchange_rqst_ : *default_instance().weaponchange_rqst_;
#else
  return weaponchange_rqst_ != NULL ? *weaponchange_rqst_ : *default_instance_->weaponchange_rqst_;
#endif
}
inline ::vmsg::CSWeaponChangeRqst* CSWeaponRequest::mutable_weaponchange_rqst() {
  set_has_weaponchange_rqst();
  if (weaponchange_rqst_ == NULL) weaponchange_rqst_ = new ::vmsg::CSWeaponChangeRqst;
  return weaponchange_rqst_;
}
inline ::vmsg::CSWeaponChangeRqst* CSWeaponRequest::release_weaponchange_rqst() {
  clear_has_weaponchange_rqst();
  ::vmsg::CSWeaponChangeRqst* temp = weaponchange_rqst_;
  weaponchange_rqst_ = NULL;
  return temp;
}
inline void CSWeaponRequest::set_allocated_weaponchange_rqst(::vmsg::CSWeaponChangeRqst* weaponchange_rqst) {
  delete weaponchange_rqst_;
  weaponchange_rqst_ = weaponchange_rqst;
  if (weaponchange_rqst) {
    set_has_weaponchange_rqst();
  } else {
    clear_has_weaponchange_rqst();
  }
}

// optional .vmsg.CSWeaponLvUpRqst WeaponLvUp_Rqst = 2;
inline bool CSWeaponRequest::has_weaponlvup_rqst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWeaponRequest::set_has_weaponlvup_rqst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWeaponRequest::clear_has_weaponlvup_rqst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWeaponRequest::clear_weaponlvup_rqst() {
  if (weaponlvup_rqst_ != NULL) weaponlvup_rqst_->::vmsg::CSWeaponLvUpRqst::Clear();
  clear_has_weaponlvup_rqst();
}
inline const ::vmsg::CSWeaponLvUpRqst& CSWeaponRequest::weaponlvup_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return weaponlvup_rqst_ != NULL ? *weaponlvup_rqst_ : *default_instance().weaponlvup_rqst_;
#else
  return weaponlvup_rqst_ != NULL ? *weaponlvup_rqst_ : *default_instance_->weaponlvup_rqst_;
#endif
}
inline ::vmsg::CSWeaponLvUpRqst* CSWeaponRequest::mutable_weaponlvup_rqst() {
  set_has_weaponlvup_rqst();
  if (weaponlvup_rqst_ == NULL) weaponlvup_rqst_ = new ::vmsg::CSWeaponLvUpRqst;
  return weaponlvup_rqst_;
}
inline ::vmsg::CSWeaponLvUpRqst* CSWeaponRequest::release_weaponlvup_rqst() {
  clear_has_weaponlvup_rqst();
  ::vmsg::CSWeaponLvUpRqst* temp = weaponlvup_rqst_;
  weaponlvup_rqst_ = NULL;
  return temp;
}
inline void CSWeaponRequest::set_allocated_weaponlvup_rqst(::vmsg::CSWeaponLvUpRqst* weaponlvup_rqst) {
  delete weaponlvup_rqst_;
  weaponlvup_rqst_ = weaponlvup_rqst;
  if (weaponlvup_rqst) {
    set_has_weaponlvup_rqst();
  } else {
    clear_has_weaponlvup_rqst();
  }
}

// optional .vmsg.CSWeaponStarStepRqst WeaponStarStep_Rqst = 3;
inline bool CSWeaponRequest::has_weaponstarstep_rqst() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSWeaponRequest::set_has_weaponstarstep_rqst() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSWeaponRequest::clear_has_weaponstarstep_rqst() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSWeaponRequest::clear_weaponstarstep_rqst() {
  if (weaponstarstep_rqst_ != NULL) weaponstarstep_rqst_->::vmsg::CSWeaponStarStepRqst::Clear();
  clear_has_weaponstarstep_rqst();
}
inline const ::vmsg::CSWeaponStarStepRqst& CSWeaponRequest::weaponstarstep_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return weaponstarstep_rqst_ != NULL ? *weaponstarstep_rqst_ : *default_instance().weaponstarstep_rqst_;
#else
  return weaponstarstep_rqst_ != NULL ? *weaponstarstep_rqst_ : *default_instance_->weaponstarstep_rqst_;
#endif
}
inline ::vmsg::CSWeaponStarStepRqst* CSWeaponRequest::mutable_weaponstarstep_rqst() {
  set_has_weaponstarstep_rqst();
  if (weaponstarstep_rqst_ == NULL) weaponstarstep_rqst_ = new ::vmsg::CSWeaponStarStepRqst;
  return weaponstarstep_rqst_;
}
inline ::vmsg::CSWeaponStarStepRqst* CSWeaponRequest::release_weaponstarstep_rqst() {
  clear_has_weaponstarstep_rqst();
  ::vmsg::CSWeaponStarStepRqst* temp = weaponstarstep_rqst_;
  weaponstarstep_rqst_ = NULL;
  return temp;
}
inline void CSWeaponRequest::set_allocated_weaponstarstep_rqst(::vmsg::CSWeaponStarStepRqst* weaponstarstep_rqst) {
  delete weaponstarstep_rqst_;
  weaponstarstep_rqst_ = weaponstarstep_rqst;
  if (weaponstarstep_rqst) {
    set_has_weaponstarstep_rqst();
  } else {
    clear_has_weaponstarstep_rqst();
  }
}

// optional .vmsg.CSWeaponRefitRqst WeaponRefit_Rqst = 4;
inline bool CSWeaponRequest::has_weaponrefit_rqst() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSWeaponRequest::set_has_weaponrefit_rqst() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSWeaponRequest::clear_has_weaponrefit_rqst() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSWeaponRequest::clear_weaponrefit_rqst() {
  if (weaponrefit_rqst_ != NULL) weaponrefit_rqst_->::vmsg::CSWeaponRefitRqst::Clear();
  clear_has_weaponrefit_rqst();
}
inline const ::vmsg::CSWeaponRefitRqst& CSWeaponRequest::weaponrefit_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return weaponrefit_rqst_ != NULL ? *weaponrefit_rqst_ : *default_instance().weaponrefit_rqst_;
#else
  return weaponrefit_rqst_ != NULL ? *weaponrefit_rqst_ : *default_instance_->weaponrefit_rqst_;
#endif
}
inline ::vmsg::CSWeaponRefitRqst* CSWeaponRequest::mutable_weaponrefit_rqst() {
  set_has_weaponrefit_rqst();
  if (weaponrefit_rqst_ == NULL) weaponrefit_rqst_ = new ::vmsg::CSWeaponRefitRqst;
  return weaponrefit_rqst_;
}
inline ::vmsg::CSWeaponRefitRqst* CSWeaponRequest::release_weaponrefit_rqst() {
  clear_has_weaponrefit_rqst();
  ::vmsg::CSWeaponRefitRqst* temp = weaponrefit_rqst_;
  weaponrefit_rqst_ = NULL;
  return temp;
}
inline void CSWeaponRequest::set_allocated_weaponrefit_rqst(::vmsg::CSWeaponRefitRqst* weaponrefit_rqst) {
  delete weaponrefit_rqst_;
  weaponrefit_rqst_ = weaponrefit_rqst;
  if (weaponrefit_rqst) {
    set_has_weaponrefit_rqst();
  } else {
    clear_has_weaponrefit_rqst();
  }
}

// optional .vmsg.CSWeaponInBattleRqst ChangeWeaponInBattle_Rqst = 5;
inline bool CSWeaponRequest::has_changeweaponinbattle_rqst() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSWeaponRequest::set_has_changeweaponinbattle_rqst() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSWeaponRequest::clear_has_changeweaponinbattle_rqst() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSWeaponRequest::clear_changeweaponinbattle_rqst() {
  if (changeweaponinbattle_rqst_ != NULL) changeweaponinbattle_rqst_->::vmsg::CSWeaponInBattleRqst::Clear();
  clear_has_changeweaponinbattle_rqst();
}
inline const ::vmsg::CSWeaponInBattleRqst& CSWeaponRequest::changeweaponinbattle_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return changeweaponinbattle_rqst_ != NULL ? *changeweaponinbattle_rqst_ : *default_instance().changeweaponinbattle_rqst_;
#else
  return changeweaponinbattle_rqst_ != NULL ? *changeweaponinbattle_rqst_ : *default_instance_->changeweaponinbattle_rqst_;
#endif
}
inline ::vmsg::CSWeaponInBattleRqst* CSWeaponRequest::mutable_changeweaponinbattle_rqst() {
  set_has_changeweaponinbattle_rqst();
  if (changeweaponinbattle_rqst_ == NULL) changeweaponinbattle_rqst_ = new ::vmsg::CSWeaponInBattleRqst;
  return changeweaponinbattle_rqst_;
}
inline ::vmsg::CSWeaponInBattleRqst* CSWeaponRequest::release_changeweaponinbattle_rqst() {
  clear_has_changeweaponinbattle_rqst();
  ::vmsg::CSWeaponInBattleRqst* temp = changeweaponinbattle_rqst_;
  changeweaponinbattle_rqst_ = NULL;
  return temp;
}
inline void CSWeaponRequest::set_allocated_changeweaponinbattle_rqst(::vmsg::CSWeaponInBattleRqst* changeweaponinbattle_rqst) {
  delete changeweaponinbattle_rqst_;
  changeweaponinbattle_rqst_ = changeweaponinbattle_rqst;
  if (changeweaponinbattle_rqst) {
    set_has_changeweaponinbattle_rqst();
  } else {
    clear_has_changeweaponinbattle_rqst();
  }
}

// -------------------------------------------------------------------

// CSWeaponRespond

// optional .vmsg.CSWeaponBag WeaponQueryBag_Rsp = 1;
inline bool CSWeaponRespond::has_weaponquerybag_rsp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWeaponRespond::set_has_weaponquerybag_rsp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWeaponRespond::clear_has_weaponquerybag_rsp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWeaponRespond::clear_weaponquerybag_rsp() {
  if (weaponquerybag_rsp_ != NULL) weaponquerybag_rsp_->::vmsg::CSWeaponBag::Clear();
  clear_has_weaponquerybag_rsp();
}
inline const ::vmsg::CSWeaponBag& CSWeaponRespond::weaponquerybag_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return weaponquerybag_rsp_ != NULL ? *weaponquerybag_rsp_ : *default_instance().weaponquerybag_rsp_;
#else
  return weaponquerybag_rsp_ != NULL ? *weaponquerybag_rsp_ : *default_instance_->weaponquerybag_rsp_;
#endif
}
inline ::vmsg::CSWeaponBag* CSWeaponRespond::mutable_weaponquerybag_rsp() {
  set_has_weaponquerybag_rsp();
  if (weaponquerybag_rsp_ == NULL) weaponquerybag_rsp_ = new ::vmsg::CSWeaponBag;
  return weaponquerybag_rsp_;
}
inline ::vmsg::CSWeaponBag* CSWeaponRespond::release_weaponquerybag_rsp() {
  clear_has_weaponquerybag_rsp();
  ::vmsg::CSWeaponBag* temp = weaponquerybag_rsp_;
  weaponquerybag_rsp_ = NULL;
  return temp;
}
inline void CSWeaponRespond::set_allocated_weaponquerybag_rsp(::vmsg::CSWeaponBag* weaponquerybag_rsp) {
  delete weaponquerybag_rsp_;
  weaponquerybag_rsp_ = weaponquerybag_rsp;
  if (weaponquerybag_rsp) {
    set_has_weaponquerybag_rsp();
  } else {
    clear_has_weaponquerybag_rsp();
  }
}

// optional .vmsg.CSWeaponBag WeaponChange_Rsp = 2;
inline bool CSWeaponRespond::has_weaponchange_rsp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWeaponRespond::set_has_weaponchange_rsp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWeaponRespond::clear_has_weaponchange_rsp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWeaponRespond::clear_weaponchange_rsp() {
  if (weaponchange_rsp_ != NULL) weaponchange_rsp_->::vmsg::CSWeaponBag::Clear();
  clear_has_weaponchange_rsp();
}
inline const ::vmsg::CSWeaponBag& CSWeaponRespond::weaponchange_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return weaponchange_rsp_ != NULL ? *weaponchange_rsp_ : *default_instance().weaponchange_rsp_;
#else
  return weaponchange_rsp_ != NULL ? *weaponchange_rsp_ : *default_instance_->weaponchange_rsp_;
#endif
}
inline ::vmsg::CSWeaponBag* CSWeaponRespond::mutable_weaponchange_rsp() {
  set_has_weaponchange_rsp();
  if (weaponchange_rsp_ == NULL) weaponchange_rsp_ = new ::vmsg::CSWeaponBag;
  return weaponchange_rsp_;
}
inline ::vmsg::CSWeaponBag* CSWeaponRespond::release_weaponchange_rsp() {
  clear_has_weaponchange_rsp();
  ::vmsg::CSWeaponBag* temp = weaponchange_rsp_;
  weaponchange_rsp_ = NULL;
  return temp;
}
inline void CSWeaponRespond::set_allocated_weaponchange_rsp(::vmsg::CSWeaponBag* weaponchange_rsp) {
  delete weaponchange_rsp_;
  weaponchange_rsp_ = weaponchange_rsp;
  if (weaponchange_rsp) {
    set_has_weaponchange_rsp();
  } else {
    clear_has_weaponchange_rsp();
  }
}

// optional .vmsg.CSWeaponLvUpRsp WeaponLvUp_Rsp = 3;
inline bool CSWeaponRespond::has_weaponlvup_rsp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSWeaponRespond::set_has_weaponlvup_rsp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSWeaponRespond::clear_has_weaponlvup_rsp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSWeaponRespond::clear_weaponlvup_rsp() {
  if (weaponlvup_rsp_ != NULL) weaponlvup_rsp_->::vmsg::CSWeaponLvUpRsp::Clear();
  clear_has_weaponlvup_rsp();
}
inline const ::vmsg::CSWeaponLvUpRsp& CSWeaponRespond::weaponlvup_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return weaponlvup_rsp_ != NULL ? *weaponlvup_rsp_ : *default_instance().weaponlvup_rsp_;
#else
  return weaponlvup_rsp_ != NULL ? *weaponlvup_rsp_ : *default_instance_->weaponlvup_rsp_;
#endif
}
inline ::vmsg::CSWeaponLvUpRsp* CSWeaponRespond::mutable_weaponlvup_rsp() {
  set_has_weaponlvup_rsp();
  if (weaponlvup_rsp_ == NULL) weaponlvup_rsp_ = new ::vmsg::CSWeaponLvUpRsp;
  return weaponlvup_rsp_;
}
inline ::vmsg::CSWeaponLvUpRsp* CSWeaponRespond::release_weaponlvup_rsp() {
  clear_has_weaponlvup_rsp();
  ::vmsg::CSWeaponLvUpRsp* temp = weaponlvup_rsp_;
  weaponlvup_rsp_ = NULL;
  return temp;
}
inline void CSWeaponRespond::set_allocated_weaponlvup_rsp(::vmsg::CSWeaponLvUpRsp* weaponlvup_rsp) {
  delete weaponlvup_rsp_;
  weaponlvup_rsp_ = weaponlvup_rsp;
  if (weaponlvup_rsp) {
    set_has_weaponlvup_rsp();
  } else {
    clear_has_weaponlvup_rsp();
  }
}

// optional .vmsg.CSWeaponBag WeaponStarStep_Rsp = 4;
inline bool CSWeaponRespond::has_weaponstarstep_rsp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSWeaponRespond::set_has_weaponstarstep_rsp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSWeaponRespond::clear_has_weaponstarstep_rsp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSWeaponRespond::clear_weaponstarstep_rsp() {
  if (weaponstarstep_rsp_ != NULL) weaponstarstep_rsp_->::vmsg::CSWeaponBag::Clear();
  clear_has_weaponstarstep_rsp();
}
inline const ::vmsg::CSWeaponBag& CSWeaponRespond::weaponstarstep_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return weaponstarstep_rsp_ != NULL ? *weaponstarstep_rsp_ : *default_instance().weaponstarstep_rsp_;
#else
  return weaponstarstep_rsp_ != NULL ? *weaponstarstep_rsp_ : *default_instance_->weaponstarstep_rsp_;
#endif
}
inline ::vmsg::CSWeaponBag* CSWeaponRespond::mutable_weaponstarstep_rsp() {
  set_has_weaponstarstep_rsp();
  if (weaponstarstep_rsp_ == NULL) weaponstarstep_rsp_ = new ::vmsg::CSWeaponBag;
  return weaponstarstep_rsp_;
}
inline ::vmsg::CSWeaponBag* CSWeaponRespond::release_weaponstarstep_rsp() {
  clear_has_weaponstarstep_rsp();
  ::vmsg::CSWeaponBag* temp = weaponstarstep_rsp_;
  weaponstarstep_rsp_ = NULL;
  return temp;
}
inline void CSWeaponRespond::set_allocated_weaponstarstep_rsp(::vmsg::CSWeaponBag* weaponstarstep_rsp) {
  delete weaponstarstep_rsp_;
  weaponstarstep_rsp_ = weaponstarstep_rsp;
  if (weaponstarstep_rsp) {
    set_has_weaponstarstep_rsp();
  } else {
    clear_has_weaponstarstep_rsp();
  }
}

// optional .vmsg.CSWeaponBag WeaponRefit_Rsp = 5;
inline bool CSWeaponRespond::has_weaponrefit_rsp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSWeaponRespond::set_has_weaponrefit_rsp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSWeaponRespond::clear_has_weaponrefit_rsp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSWeaponRespond::clear_weaponrefit_rsp() {
  if (weaponrefit_rsp_ != NULL) weaponrefit_rsp_->::vmsg::CSWeaponBag::Clear();
  clear_has_weaponrefit_rsp();
}
inline const ::vmsg::CSWeaponBag& CSWeaponRespond::weaponrefit_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return weaponrefit_rsp_ != NULL ? *weaponrefit_rsp_ : *default_instance().weaponrefit_rsp_;
#else
  return weaponrefit_rsp_ != NULL ? *weaponrefit_rsp_ : *default_instance_->weaponrefit_rsp_;
#endif
}
inline ::vmsg::CSWeaponBag* CSWeaponRespond::mutable_weaponrefit_rsp() {
  set_has_weaponrefit_rsp();
  if (weaponrefit_rsp_ == NULL) weaponrefit_rsp_ = new ::vmsg::CSWeaponBag;
  return weaponrefit_rsp_;
}
inline ::vmsg::CSWeaponBag* CSWeaponRespond::release_weaponrefit_rsp() {
  clear_has_weaponrefit_rsp();
  ::vmsg::CSWeaponBag* temp = weaponrefit_rsp_;
  weaponrefit_rsp_ = NULL;
  return temp;
}
inline void CSWeaponRespond::set_allocated_weaponrefit_rsp(::vmsg::CSWeaponBag* weaponrefit_rsp) {
  delete weaponrefit_rsp_;
  weaponrefit_rsp_ = weaponrefit_rsp;
  if (weaponrefit_rsp) {
    set_has_weaponrefit_rsp();
  } else {
    clear_has_weaponrefit_rsp();
  }
}

// optional .vmsg.CSWeaponInBattleRsp ChangeWeaponInBattle_Rsp = 6;
inline bool CSWeaponRespond::has_changeweaponinbattle_rsp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSWeaponRespond::set_has_changeweaponinbattle_rsp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSWeaponRespond::clear_has_changeweaponinbattle_rsp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSWeaponRespond::clear_changeweaponinbattle_rsp() {
  if (changeweaponinbattle_rsp_ != NULL) changeweaponinbattle_rsp_->::vmsg::CSWeaponInBattleRsp::Clear();
  clear_has_changeweaponinbattle_rsp();
}
inline const ::vmsg::CSWeaponInBattleRsp& CSWeaponRespond::changeweaponinbattle_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return changeweaponinbattle_rsp_ != NULL ? *changeweaponinbattle_rsp_ : *default_instance().changeweaponinbattle_rsp_;
#else
  return changeweaponinbattle_rsp_ != NULL ? *changeweaponinbattle_rsp_ : *default_instance_->changeweaponinbattle_rsp_;
#endif
}
inline ::vmsg::CSWeaponInBattleRsp* CSWeaponRespond::mutable_changeweaponinbattle_rsp() {
  set_has_changeweaponinbattle_rsp();
  if (changeweaponinbattle_rsp_ == NULL) changeweaponinbattle_rsp_ = new ::vmsg::CSWeaponInBattleRsp;
  return changeweaponinbattle_rsp_;
}
inline ::vmsg::CSWeaponInBattleRsp* CSWeaponRespond::release_changeweaponinbattle_rsp() {
  clear_has_changeweaponinbattle_rsp();
  ::vmsg::CSWeaponInBattleRsp* temp = changeweaponinbattle_rsp_;
  changeweaponinbattle_rsp_ = NULL;
  return temp;
}
inline void CSWeaponRespond::set_allocated_changeweaponinbattle_rsp(::vmsg::CSWeaponInBattleRsp* changeweaponinbattle_rsp) {
  delete changeweaponinbattle_rsp_;
  changeweaponinbattle_rsp_ = changeweaponinbattle_rsp;
  if (changeweaponinbattle_rsp) {
    set_has_changeweaponinbattle_rsp();
  } else {
    clear_has_changeweaponinbattle_rsp();
  }
}

// optional .vmsg.CSWeaponInBattleRsp QueryWeaponInBattle_Rsp = 7;
inline bool CSWeaponRespond::has_queryweaponinbattle_rsp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSWeaponRespond::set_has_queryweaponinbattle_rsp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSWeaponRespond::clear_has_queryweaponinbattle_rsp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSWeaponRespond::clear_queryweaponinbattle_rsp() {
  if (queryweaponinbattle_rsp_ != NULL) queryweaponinbattle_rsp_->::vmsg::CSWeaponInBattleRsp::Clear();
  clear_has_queryweaponinbattle_rsp();
}
inline const ::vmsg::CSWeaponInBattleRsp& CSWeaponRespond::queryweaponinbattle_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return queryweaponinbattle_rsp_ != NULL ? *queryweaponinbattle_rsp_ : *default_instance().queryweaponinbattle_rsp_;
#else
  return queryweaponinbattle_rsp_ != NULL ? *queryweaponinbattle_rsp_ : *default_instance_->queryweaponinbattle_rsp_;
#endif
}
inline ::vmsg::CSWeaponInBattleRsp* CSWeaponRespond::mutable_queryweaponinbattle_rsp() {
  set_has_queryweaponinbattle_rsp();
  if (queryweaponinbattle_rsp_ == NULL) queryweaponinbattle_rsp_ = new ::vmsg::CSWeaponInBattleRsp;
  return queryweaponinbattle_rsp_;
}
inline ::vmsg::CSWeaponInBattleRsp* CSWeaponRespond::release_queryweaponinbattle_rsp() {
  clear_has_queryweaponinbattle_rsp();
  ::vmsg::CSWeaponInBattleRsp* temp = queryweaponinbattle_rsp_;
  queryweaponinbattle_rsp_ = NULL;
  return temp;
}
inline void CSWeaponRespond::set_allocated_queryweaponinbattle_rsp(::vmsg::CSWeaponInBattleRsp* queryweaponinbattle_rsp) {
  delete queryweaponinbattle_rsp_;
  queryweaponinbattle_rsp_ = queryweaponinbattle_rsp;
  if (queryweaponinbattle_rsp) {
    set_has_queryweaponinbattle_rsp();
  } else {
    clear_has_queryweaponinbattle_rsp();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CSWeaponMsg_2eproto__INCLUDED
