// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSBossChallengeMsg.proto

#ifndef PROTOBUF_CSBossChallengeMsg_2eproto__INCLUDED
#define PROTOBUF_CSBossChallengeMsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MsgBase.pb.h"
#include "ShareByClient.pb.h"
// @@protoc_insertion_point(includes)

namespace vmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CSBossChallengeMsg_2eproto();
void protobuf_AssignDesc_CSBossChallengeMsg_2eproto();
void protobuf_ShutdownFile_CSBossChallengeMsg_2eproto();

class CSAttendeeDamageElmt;
class CSBossChallengeInfo;
class CSSingleAttendeeDamageEvent;
class CSBossChallengeBigDamageReport;
class CSBossChallengeEnterEvent;
class CSBossChallengeDamageNotification;
class CSBossChallengeBossNotification;
class CSBossChallengeStateNotification;
class CSBossChallengeRqst;
class CSBossChallengeRsp;

// ===================================================================

class CSAttendeeDamageElmt : public ::google::protobuf::MessageLite {
 public:
  CSAttendeeDamageElmt();
  virtual ~CSAttendeeDamageElmt();

  CSAttendeeDamageElmt(const CSAttendeeDamageElmt& from);

  inline CSAttendeeDamageElmt& operator=(const CSAttendeeDamageElmt& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSAttendeeDamageElmt& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAttendeeDamageElmt* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAttendeeDamageElmt* other);

  // implements Message ----------------------------------------------

  CSAttendeeDamageElmt* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAttendeeDamageElmt& from);
  void MergeFrom(const CSAttendeeDamageElmt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required string Nick = 2;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 2;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // required uint32 Damage = 3;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 3;
  inline ::google::protobuf::uint32 damage() const;
  inline void set_damage(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSAttendeeDamageElmt)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_damage();
  inline void clear_has_damage();

  ::google::protobuf::uint64 uid_;
  ::std::string* nick_;
  ::google::protobuf::uint32 damage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBossChallengeMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBossChallengeMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBossChallengeMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBossChallengeMsg_2eproto();

  void InitAsDefaultInstance();
  static CSAttendeeDamageElmt* default_instance_;
};
// -------------------------------------------------------------------

class CSBossChallengeInfo : public ::google::protobuf::MessageLite {
 public:
  CSBossChallengeInfo();
  virtual ~CSBossChallengeInfo();

  CSBossChallengeInfo(const CSBossChallengeInfo& from);

  inline CSBossChallengeInfo& operator=(const CSBossChallengeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBossChallengeInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBossChallengeInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBossChallengeInfo* other);

  // implements Message ----------------------------------------------

  CSBossChallengeInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBossChallengeInfo& from);
  void MergeFrom(const CSBossChallengeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 StartTime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 starttime() const;
  inline void set_starttime(::google::protobuf::uint32 value);

  // required uint32 StopTime = 2;
  inline bool has_stoptime() const;
  inline void clear_stoptime();
  static const int kStopTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 stoptime() const;
  inline void set_stoptime(::google::protobuf::uint32 value);

  // required uint32 BossID = 3;
  inline bool has_bossid() const;
  inline void clear_bossid();
  static const int kBossIDFieldNumber = 3;
  inline ::google::protobuf::uint32 bossid() const;
  inline void set_bossid(::google::protobuf::uint32 value);

  // required uint64 BossCurHP = 4;
  inline bool has_bosscurhp() const;
  inline void clear_bosscurhp();
  static const int kBossCurHPFieldNumber = 4;
  inline ::google::protobuf::uint64 bosscurhp() const;
  inline void set_bosscurhp(::google::protobuf::uint64 value);

  // required uint64 BossTotalHp = 5;
  inline bool has_bosstotalhp() const;
  inline void clear_bosstotalhp();
  static const int kBossTotalHpFieldNumber = 5;
  inline ::google::protobuf::uint64 bosstotalhp() const;
  inline void set_bosstotalhp(::google::protobuf::uint64 value);

  // required uint64 State = 6;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 6;
  inline ::google::protobuf::uint64 state() const;
  inline void set_state(::google::protobuf::uint64 value);

  // repeated .vmsg.CSAttendeeDamageElmt TopChallengers = 7;
  inline int topchallengers_size() const;
  inline void clear_topchallengers();
  static const int kTopChallengersFieldNumber = 7;
  inline const ::vmsg::CSAttendeeDamageElmt& topchallengers(int index) const;
  inline ::vmsg::CSAttendeeDamageElmt* mutable_topchallengers(int index);
  inline ::vmsg::CSAttendeeDamageElmt* add_topchallengers();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAttendeeDamageElmt >&
      topchallengers() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAttendeeDamageElmt >*
      mutable_topchallengers();

  // required uint32 PrepareTime = 8;
  inline bool has_preparetime() const;
  inline void clear_preparetime();
  static const int kPrepareTimeFieldNumber = 8;
  inline ::google::protobuf::uint32 preparetime() const;
  inline void set_preparetime(::google::protobuf::uint32 value);

  // required uint32 BossLevel = 9;
  inline bool has_bosslevel() const;
  inline void clear_bosslevel();
  static const int kBossLevelFieldNumber = 9;
  inline ::google::protobuf::uint32 bosslevel() const;
  inline void set_bosslevel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSBossChallengeInfo)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_stoptime();
  inline void clear_has_stoptime();
  inline void set_has_bossid();
  inline void clear_has_bossid();
  inline void set_has_bosscurhp();
  inline void clear_has_bosscurhp();
  inline void set_has_bosstotalhp();
  inline void clear_has_bosstotalhp();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_preparetime();
  inline void clear_has_preparetime();
  inline void set_has_bosslevel();
  inline void clear_has_bosslevel();

  ::google::protobuf::uint32 starttime_;
  ::google::protobuf::uint32 stoptime_;
  ::google::protobuf::uint64 bosscurhp_;
  ::google::protobuf::uint64 bosstotalhp_;
  ::google::protobuf::uint32 bossid_;
  ::google::protobuf::uint32 preparetime_;
  ::google::protobuf::uint64 state_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSAttendeeDamageElmt > topchallengers_;
  ::google::protobuf::uint32 bosslevel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBossChallengeMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBossChallengeMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBossChallengeMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBossChallengeMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBossChallengeInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSSingleAttendeeDamageEvent : public ::google::protobuf::MessageLite {
 public:
  CSSingleAttendeeDamageEvent();
  virtual ~CSSingleAttendeeDamageEvent();

  CSSingleAttendeeDamageEvent(const CSSingleAttendeeDamageEvent& from);

  inline CSSingleAttendeeDamageEvent& operator=(const CSSingleAttendeeDamageEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSSingleAttendeeDamageEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSingleAttendeeDamageEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSingleAttendeeDamageEvent* other);

  // implements Message ----------------------------------------------

  CSSingleAttendeeDamageEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSingleAttendeeDamageEvent& from);
  void MergeFrom(const CSSingleAttendeeDamageEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required uint32 Damage = 2;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 2;
  inline ::google::protobuf::uint32 damage() const;
  inline void set_damage(::google::protobuf::uint32 value);

  // required uint32 SkillID = 3;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillIDFieldNumber = 3;
  inline ::google::protobuf::uint32 skillid() const;
  inline void set_skillid(::google::protobuf::uint32 value);

  // required string Nick = 4;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 4;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // @@protoc_insertion_point(class_scope:vmsg.CSSingleAttendeeDamageEvent)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_damage();
  inline void clear_has_damage();
  inline void set_has_skillid();
  inline void clear_has_skillid();
  inline void set_has_nick();
  inline void clear_has_nick();

  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint32 damage_;
  ::google::protobuf::uint32 skillid_;
  ::std::string* nick_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBossChallengeMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBossChallengeMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBossChallengeMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBossChallengeMsg_2eproto();

  void InitAsDefaultInstance();
  static CSSingleAttendeeDamageEvent* default_instance_;
};
// -------------------------------------------------------------------

class CSBossChallengeBigDamageReport : public ::google::protobuf::MessageLite {
 public:
  CSBossChallengeBigDamageReport();
  virtual ~CSBossChallengeBigDamageReport();

  CSBossChallengeBigDamageReport(const CSBossChallengeBigDamageReport& from);

  inline CSBossChallengeBigDamageReport& operator=(const CSBossChallengeBigDamageReport& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBossChallengeBigDamageReport& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBossChallengeBigDamageReport* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBossChallengeBigDamageReport* other);

  // implements Message ----------------------------------------------

  CSBossChallengeBigDamageReport* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBossChallengeBigDamageReport& from);
  void MergeFrom(const CSBossChallengeBigDamageReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSSingleAttendeeDamageEvent MyDamage = 1;
  inline bool has_mydamage() const;
  inline void clear_mydamage();
  static const int kMyDamageFieldNumber = 1;
  inline const ::vmsg::CSSingleAttendeeDamageEvent& mydamage() const;
  inline ::vmsg::CSSingleAttendeeDamageEvent* mutable_mydamage();
  inline ::vmsg::CSSingleAttendeeDamageEvent* release_mydamage();
  inline void set_allocated_mydamage(::vmsg::CSSingleAttendeeDamageEvent* mydamage);

  // @@protoc_insertion_point(class_scope:vmsg.CSBossChallengeBigDamageReport)
 private:
  inline void set_has_mydamage();
  inline void clear_has_mydamage();

  ::vmsg::CSSingleAttendeeDamageEvent* mydamage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBossChallengeMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBossChallengeMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBossChallengeMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBossChallengeMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBossChallengeBigDamageReport* default_instance_;
};
// -------------------------------------------------------------------

class CSBossChallengeEnterEvent : public ::google::protobuf::MessageLite {
 public:
  CSBossChallengeEnterEvent();
  virtual ~CSBossChallengeEnterEvent();

  CSBossChallengeEnterEvent(const CSBossChallengeEnterEvent& from);

  inline CSBossChallengeEnterEvent& operator=(const CSBossChallengeEnterEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBossChallengeEnterEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBossChallengeEnterEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBossChallengeEnterEvent* other);

  // implements Message ----------------------------------------------

  CSBossChallengeEnterEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBossChallengeEnterEvent& from);
  void MergeFrom(const CSBossChallengeEnterEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required string Nick = 2;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 2;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // @@protoc_insertion_point(class_scope:vmsg.CSBossChallengeEnterEvent)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_nick();
  inline void clear_has_nick();

  ::google::protobuf::uint64 uid_;
  ::std::string* nick_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBossChallengeMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBossChallengeMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBossChallengeMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBossChallengeMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBossChallengeEnterEvent* default_instance_;
};
// -------------------------------------------------------------------

class CSBossChallengeDamageNotification : public ::google::protobuf::MessageLite {
 public:
  CSBossChallengeDamageNotification();
  virtual ~CSBossChallengeDamageNotification();

  CSBossChallengeDamageNotification(const CSBossChallengeDamageNotification& from);

  inline CSBossChallengeDamageNotification& operator=(const CSBossChallengeDamageNotification& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBossChallengeDamageNotification& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBossChallengeDamageNotification* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBossChallengeDamageNotification* other);

  // implements Message ----------------------------------------------

  CSBossChallengeDamageNotification* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBossChallengeDamageNotification& from);
  void MergeFrom(const CSBossChallengeDamageNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 BossHp = 1;
  inline bool has_bosshp() const;
  inline void clear_bosshp();
  static const int kBossHpFieldNumber = 1;
  inline ::google::protobuf::uint64 bosshp() const;
  inline void set_bosshp(::google::protobuf::uint64 value);

  // repeated .vmsg.CSSingleAttendeeDamageEvent Damages = 2;
  inline int damages_size() const;
  inline void clear_damages();
  static const int kDamagesFieldNumber = 2;
  inline const ::vmsg::CSSingleAttendeeDamageEvent& damages(int index) const;
  inline ::vmsg::CSSingleAttendeeDamageEvent* mutable_damages(int index);
  inline ::vmsg::CSSingleAttendeeDamageEvent* add_damages();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSSingleAttendeeDamageEvent >&
      damages() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSSingleAttendeeDamageEvent >*
      mutable_damages();

  // repeated .vmsg.CSBossChallengeEnterEvent PlayerEntry = 3;
  inline int playerentry_size() const;
  inline void clear_playerentry();
  static const int kPlayerEntryFieldNumber = 3;
  inline const ::vmsg::CSBossChallengeEnterEvent& playerentry(int index) const;
  inline ::vmsg::CSBossChallengeEnterEvent* mutable_playerentry(int index);
  inline ::vmsg::CSBossChallengeEnterEvent* add_playerentry();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSBossChallengeEnterEvent >&
      playerentry() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSBossChallengeEnterEvent >*
      mutable_playerentry();

  // repeated .vmsg.CSAttendeeDamageElmt TopChallengers = 4;
  inline int topchallengers_size() const;
  inline void clear_topchallengers();
  static const int kTopChallengersFieldNumber = 4;
  inline const ::vmsg::CSAttendeeDamageElmt& topchallengers(int index) const;
  inline ::vmsg::CSAttendeeDamageElmt* mutable_topchallengers(int index);
  inline ::vmsg::CSAttendeeDamageElmt* add_topchallengers();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAttendeeDamageElmt >&
      topchallengers() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAttendeeDamageElmt >*
      mutable_topchallengers();

  // @@protoc_insertion_point(class_scope:vmsg.CSBossChallengeDamageNotification)
 private:
  inline void set_has_bosshp();
  inline void clear_has_bosshp();

  ::google::protobuf::uint64 bosshp_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSSingleAttendeeDamageEvent > damages_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSBossChallengeEnterEvent > playerentry_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSAttendeeDamageElmt > topchallengers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBossChallengeMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBossChallengeMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBossChallengeMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBossChallengeMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBossChallengeDamageNotification* default_instance_;
};
// -------------------------------------------------------------------

class CSBossChallengeBossNotification : public ::google::protobuf::MessageLite {
 public:
  CSBossChallengeBossNotification();
  virtual ~CSBossChallengeBossNotification();

  CSBossChallengeBossNotification(const CSBossChallengeBossNotification& from);

  inline CSBossChallengeBossNotification& operator=(const CSBossChallengeBossNotification& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBossChallengeBossNotification& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBossChallengeBossNotification* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBossChallengeBossNotification* other);

  // implements Message ----------------------------------------------

  CSBossChallengeBossNotification* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBossChallengeBossNotification& from);
  void MergeFrom(const CSBossChallengeBossNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 BossHp = 1;
  inline bool has_bosshp() const;
  inline void clear_bosshp();
  static const int kBossHpFieldNumber = 1;
  inline ::google::protobuf::uint64 bosshp() const;
  inline void set_bosshp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSBossChallengeBossNotification)
 private:
  inline void set_has_bosshp();
  inline void clear_has_bosshp();

  ::google::protobuf::uint64 bosshp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBossChallengeMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBossChallengeMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBossChallengeMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBossChallengeMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBossChallengeBossNotification* default_instance_;
};
// -------------------------------------------------------------------

class CSBossChallengeStateNotification : public ::google::protobuf::MessageLite {
 public:
  CSBossChallengeStateNotification();
  virtual ~CSBossChallengeStateNotification();

  CSBossChallengeStateNotification(const CSBossChallengeStateNotification& from);

  inline CSBossChallengeStateNotification& operator=(const CSBossChallengeStateNotification& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBossChallengeStateNotification& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBossChallengeStateNotification* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBossChallengeStateNotification* other);

  // implements Message ----------------------------------------------

  CSBossChallengeStateNotification* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBossChallengeStateNotification& from);
  void MergeFrom(const CSBossChallengeStateNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 State = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional string AdditionalMsg1 = 2;
  inline bool has_additionalmsg1() const;
  inline void clear_additionalmsg1();
  static const int kAdditionalMsg1FieldNumber = 2;
  inline const ::std::string& additionalmsg1() const;
  inline void set_additionalmsg1(const ::std::string& value);
  inline void set_additionalmsg1(const char* value);
  inline void set_additionalmsg1(const char* value, size_t size);
  inline ::std::string* mutable_additionalmsg1();
  inline ::std::string* release_additionalmsg1();
  inline void set_allocated_additionalmsg1(::std::string* additionalmsg1);

  // optional uint64 AdditionalParm1 = 3;
  inline bool has_additionalparm1() const;
  inline void clear_additionalparm1();
  static const int kAdditionalParm1FieldNumber = 3;
  inline ::google::protobuf::uint64 additionalparm1() const;
  inline void set_additionalparm1(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSBossChallengeStateNotification)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_additionalmsg1();
  inline void clear_has_additionalmsg1();
  inline void set_has_additionalparm1();
  inline void clear_has_additionalparm1();

  ::std::string* additionalmsg1_;
  ::google::protobuf::uint64 additionalparm1_;
  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBossChallengeMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBossChallengeMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBossChallengeMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBossChallengeMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBossChallengeStateNotification* default_instance_;
};
// -------------------------------------------------------------------

class CSBossChallengeRqst : public ::google::protobuf::MessageLite {
 public:
  CSBossChallengeRqst();
  virtual ~CSBossChallengeRqst();

  CSBossChallengeRqst(const CSBossChallengeRqst& from);

  inline CSBossChallengeRqst& operator=(const CSBossChallengeRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBossChallengeRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBossChallengeRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBossChallengeRqst* other);

  // implements Message ----------------------------------------------

  CSBossChallengeRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBossChallengeRqst& from);
  void MergeFrom(const CSBossChallengeRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSBossChallengeBigDamageReport DamageReport = 1;
  inline bool has_damagereport() const;
  inline void clear_damagereport();
  static const int kDamageReportFieldNumber = 1;
  inline const ::vmsg::CSBossChallengeBigDamageReport& damagereport() const;
  inline ::vmsg::CSBossChallengeBigDamageReport* mutable_damagereport();
  inline ::vmsg::CSBossChallengeBigDamageReport* release_damagereport();
  inline void set_allocated_damagereport(::vmsg::CSBossChallengeBigDamageReport* damagereport);

  // optional uint32 DelegateType = 2;
  inline bool has_delegatetype() const;
  inline void clear_delegatetype();
  static const int kDelegateTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 delegatetype() const;
  inline void set_delegatetype(::google::protobuf::uint32 value);

  // optional uint32 AttendOrLeave = 3;
  inline bool has_attendorleave() const;
  inline void clear_attendorleave();
  static const int kAttendOrLeaveFieldNumber = 3;
  inline ::google::protobuf::uint32 attendorleave() const;
  inline void set_attendorleave(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSBossChallengeRqst)
 private:
  inline void set_has_damagereport();
  inline void clear_has_damagereport();
  inline void set_has_delegatetype();
  inline void clear_has_delegatetype();
  inline void set_has_attendorleave();
  inline void clear_has_attendorleave();

  ::vmsg::CSBossChallengeBigDamageReport* damagereport_;
  ::google::protobuf::uint32 delegatetype_;
  ::google::protobuf::uint32 attendorleave_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBossChallengeMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBossChallengeMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBossChallengeMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBossChallengeMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBossChallengeRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSBossChallengeRsp : public ::google::protobuf::MessageLite {
 public:
  CSBossChallengeRsp();
  virtual ~CSBossChallengeRsp();

  CSBossChallengeRsp(const CSBossChallengeRsp& from);

  inline CSBossChallengeRsp& operator=(const CSBossChallengeRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBossChallengeRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBossChallengeRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBossChallengeRsp* other);

  // implements Message ----------------------------------------------

  CSBossChallengeRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBossChallengeRsp& from);
  void MergeFrom(const CSBossChallengeRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSBossChallengeInfo ChallengeInfo = 1;
  inline bool has_challengeinfo() const;
  inline void clear_challengeinfo();
  static const int kChallengeInfoFieldNumber = 1;
  inline const ::vmsg::CSBossChallengeInfo& challengeinfo() const;
  inline ::vmsg::CSBossChallengeInfo* mutable_challengeinfo();
  inline ::vmsg::CSBossChallengeInfo* release_challengeinfo();
  inline void set_allocated_challengeinfo(::vmsg::CSBossChallengeInfo* challengeinfo);

  // optional .vmsg.CSBossChallengeDamageNotification Damages = 2;
  inline bool has_damages() const;
  inline void clear_damages();
  static const int kDamagesFieldNumber = 2;
  inline const ::vmsg::CSBossChallengeDamageNotification& damages() const;
  inline ::vmsg::CSBossChallengeDamageNotification* mutable_damages();
  inline ::vmsg::CSBossChallengeDamageNotification* release_damages();
  inline void set_allocated_damages(::vmsg::CSBossChallengeDamageNotification* damages);

  // optional .vmsg.CSBossChallengeStateNotification BossChallengeStateNotify = 3;
  inline bool has_bosschallengestatenotify() const;
  inline void clear_bosschallengestatenotify();
  static const int kBossChallengeStateNotifyFieldNumber = 3;
  inline const ::vmsg::CSBossChallengeStateNotification& bosschallengestatenotify() const;
  inline ::vmsg::CSBossChallengeStateNotification* mutable_bosschallengestatenotify();
  inline ::vmsg::CSBossChallengeStateNotification* release_bosschallengestatenotify();
  inline void set_allocated_bosschallengestatenotify(::vmsg::CSBossChallengeStateNotification* bosschallengestatenotify);

  // optional uint32 DelegateType = 4;
  inline bool has_delegatetype() const;
  inline void clear_delegatetype();
  static const int kDelegateTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 delegatetype() const;
  inline void set_delegatetype(::google::protobuf::uint32 value);

  // optional uint32 AttendOrLeave = 5;
  inline bool has_attendorleave() const;
  inline void clear_attendorleave();
  static const int kAttendOrLeaveFieldNumber = 5;
  inline ::google::protobuf::uint32 attendorleave() const;
  inline void set_attendorleave(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSBossChallengeRsp)
 private:
  inline void set_has_challengeinfo();
  inline void clear_has_challengeinfo();
  inline void set_has_damages();
  inline void clear_has_damages();
  inline void set_has_bosschallengestatenotify();
  inline void clear_has_bosschallengestatenotify();
  inline void set_has_delegatetype();
  inline void clear_has_delegatetype();
  inline void set_has_attendorleave();
  inline void clear_has_attendorleave();

  ::vmsg::CSBossChallengeInfo* challengeinfo_;
  ::vmsg::CSBossChallengeDamageNotification* damages_;
  ::vmsg::CSBossChallengeStateNotification* bosschallengestatenotify_;
  ::google::protobuf::uint32 delegatetype_;
  ::google::protobuf::uint32 attendorleave_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBossChallengeMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBossChallengeMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBossChallengeMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBossChallengeMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBossChallengeRsp* default_instance_;
};
// ===================================================================


// ===================================================================

// CSAttendeeDamageElmt

// required uint64 Uid = 1;
inline bool CSAttendeeDamageElmt::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAttendeeDamageElmt::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAttendeeDamageElmt::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAttendeeDamageElmt::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 CSAttendeeDamageElmt::uid() const {
  return uid_;
}
inline void CSAttendeeDamageElmt::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// required string Nick = 2;
inline bool CSAttendeeDamageElmt::has_nick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSAttendeeDamageElmt::set_has_nick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSAttendeeDamageElmt::clear_has_nick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSAttendeeDamageElmt::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& CSAttendeeDamageElmt::nick() const {
  return *nick_;
}
inline void CSAttendeeDamageElmt::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void CSAttendeeDamageElmt::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void CSAttendeeDamageElmt::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSAttendeeDamageElmt::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* CSAttendeeDamageElmt::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSAttendeeDamageElmt::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 Damage = 3;
inline bool CSAttendeeDamageElmt::has_damage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSAttendeeDamageElmt::set_has_damage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSAttendeeDamageElmt::clear_has_damage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSAttendeeDamageElmt::clear_damage() {
  damage_ = 0u;
  clear_has_damage();
}
inline ::google::protobuf::uint32 CSAttendeeDamageElmt::damage() const {
  return damage_;
}
inline void CSAttendeeDamageElmt::set_damage(::google::protobuf::uint32 value) {
  set_has_damage();
  damage_ = value;
}

// -------------------------------------------------------------------

// CSBossChallengeInfo

// required uint32 StartTime = 1;
inline bool CSBossChallengeInfo::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBossChallengeInfo::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBossChallengeInfo::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBossChallengeInfo::clear_starttime() {
  starttime_ = 0u;
  clear_has_starttime();
}
inline ::google::protobuf::uint32 CSBossChallengeInfo::starttime() const {
  return starttime_;
}
inline void CSBossChallengeInfo::set_starttime(::google::protobuf::uint32 value) {
  set_has_starttime();
  starttime_ = value;
}

// required uint32 StopTime = 2;
inline bool CSBossChallengeInfo::has_stoptime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBossChallengeInfo::set_has_stoptime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBossChallengeInfo::clear_has_stoptime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBossChallengeInfo::clear_stoptime() {
  stoptime_ = 0u;
  clear_has_stoptime();
}
inline ::google::protobuf::uint32 CSBossChallengeInfo::stoptime() const {
  return stoptime_;
}
inline void CSBossChallengeInfo::set_stoptime(::google::protobuf::uint32 value) {
  set_has_stoptime();
  stoptime_ = value;
}

// required uint32 BossID = 3;
inline bool CSBossChallengeInfo::has_bossid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBossChallengeInfo::set_has_bossid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBossChallengeInfo::clear_has_bossid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBossChallengeInfo::clear_bossid() {
  bossid_ = 0u;
  clear_has_bossid();
}
inline ::google::protobuf::uint32 CSBossChallengeInfo::bossid() const {
  return bossid_;
}
inline void CSBossChallengeInfo::set_bossid(::google::protobuf::uint32 value) {
  set_has_bossid();
  bossid_ = value;
}

// required uint64 BossCurHP = 4;
inline bool CSBossChallengeInfo::has_bosscurhp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSBossChallengeInfo::set_has_bosscurhp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSBossChallengeInfo::clear_has_bosscurhp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSBossChallengeInfo::clear_bosscurhp() {
  bosscurhp_ = GOOGLE_ULONGLONG(0);
  clear_has_bosscurhp();
}
inline ::google::protobuf::uint64 CSBossChallengeInfo::bosscurhp() const {
  return bosscurhp_;
}
inline void CSBossChallengeInfo::set_bosscurhp(::google::protobuf::uint64 value) {
  set_has_bosscurhp();
  bosscurhp_ = value;
}

// required uint64 BossTotalHp = 5;
inline bool CSBossChallengeInfo::has_bosstotalhp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSBossChallengeInfo::set_has_bosstotalhp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSBossChallengeInfo::clear_has_bosstotalhp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSBossChallengeInfo::clear_bosstotalhp() {
  bosstotalhp_ = GOOGLE_ULONGLONG(0);
  clear_has_bosstotalhp();
}
inline ::google::protobuf::uint64 CSBossChallengeInfo::bosstotalhp() const {
  return bosstotalhp_;
}
inline void CSBossChallengeInfo::set_bosstotalhp(::google::protobuf::uint64 value) {
  set_has_bosstotalhp();
  bosstotalhp_ = value;
}

// required uint64 State = 6;
inline bool CSBossChallengeInfo::has_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSBossChallengeInfo::set_has_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSBossChallengeInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSBossChallengeInfo::clear_state() {
  state_ = GOOGLE_ULONGLONG(0);
  clear_has_state();
}
inline ::google::protobuf::uint64 CSBossChallengeInfo::state() const {
  return state_;
}
inline void CSBossChallengeInfo::set_state(::google::protobuf::uint64 value) {
  set_has_state();
  state_ = value;
}

// repeated .vmsg.CSAttendeeDamageElmt TopChallengers = 7;
inline int CSBossChallengeInfo::topchallengers_size() const {
  return topchallengers_.size();
}
inline void CSBossChallengeInfo::clear_topchallengers() {
  topchallengers_.Clear();
}
inline const ::vmsg::CSAttendeeDamageElmt& CSBossChallengeInfo::topchallengers(int index) const {
  return topchallengers_.Get(index);
}
inline ::vmsg::CSAttendeeDamageElmt* CSBossChallengeInfo::mutable_topchallengers(int index) {
  return topchallengers_.Mutable(index);
}
inline ::vmsg::CSAttendeeDamageElmt* CSBossChallengeInfo::add_topchallengers() {
  return topchallengers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAttendeeDamageElmt >&
CSBossChallengeInfo::topchallengers() const {
  return topchallengers_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAttendeeDamageElmt >*
CSBossChallengeInfo::mutable_topchallengers() {
  return &topchallengers_;
}

// required uint32 PrepareTime = 8;
inline bool CSBossChallengeInfo::has_preparetime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSBossChallengeInfo::set_has_preparetime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSBossChallengeInfo::clear_has_preparetime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSBossChallengeInfo::clear_preparetime() {
  preparetime_ = 0u;
  clear_has_preparetime();
}
inline ::google::protobuf::uint32 CSBossChallengeInfo::preparetime() const {
  return preparetime_;
}
inline void CSBossChallengeInfo::set_preparetime(::google::protobuf::uint32 value) {
  set_has_preparetime();
  preparetime_ = value;
}

// required uint32 BossLevel = 9;
inline bool CSBossChallengeInfo::has_bosslevel() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSBossChallengeInfo::set_has_bosslevel() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSBossChallengeInfo::clear_has_bosslevel() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSBossChallengeInfo::clear_bosslevel() {
  bosslevel_ = 0u;
  clear_has_bosslevel();
}
inline ::google::protobuf::uint32 CSBossChallengeInfo::bosslevel() const {
  return bosslevel_;
}
inline void CSBossChallengeInfo::set_bosslevel(::google::protobuf::uint32 value) {
  set_has_bosslevel();
  bosslevel_ = value;
}

// -------------------------------------------------------------------

// CSSingleAttendeeDamageEvent

// required uint64 Uid = 1;
inline bool CSSingleAttendeeDamageEvent::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSingleAttendeeDamageEvent::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSingleAttendeeDamageEvent::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSingleAttendeeDamageEvent::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 CSSingleAttendeeDamageEvent::uid() const {
  return uid_;
}
inline void CSSingleAttendeeDamageEvent::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// required uint32 Damage = 2;
inline bool CSSingleAttendeeDamageEvent::has_damage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSSingleAttendeeDamageEvent::set_has_damage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSSingleAttendeeDamageEvent::clear_has_damage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSSingleAttendeeDamageEvent::clear_damage() {
  damage_ = 0u;
  clear_has_damage();
}
inline ::google::protobuf::uint32 CSSingleAttendeeDamageEvent::damage() const {
  return damage_;
}
inline void CSSingleAttendeeDamageEvent::set_damage(::google::protobuf::uint32 value) {
  set_has_damage();
  damage_ = value;
}

// required uint32 SkillID = 3;
inline bool CSSingleAttendeeDamageEvent::has_skillid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSSingleAttendeeDamageEvent::set_has_skillid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSSingleAttendeeDamageEvent::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSSingleAttendeeDamageEvent::clear_skillid() {
  skillid_ = 0u;
  clear_has_skillid();
}
inline ::google::protobuf::uint32 CSSingleAttendeeDamageEvent::skillid() const {
  return skillid_;
}
inline void CSSingleAttendeeDamageEvent::set_skillid(::google::protobuf::uint32 value) {
  set_has_skillid();
  skillid_ = value;
}

// required string Nick = 4;
inline bool CSSingleAttendeeDamageEvent::has_nick() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSSingleAttendeeDamageEvent::set_has_nick() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSSingleAttendeeDamageEvent::clear_has_nick() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSSingleAttendeeDamageEvent::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& CSSingleAttendeeDamageEvent::nick() const {
  return *nick_;
}
inline void CSSingleAttendeeDamageEvent::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void CSSingleAttendeeDamageEvent::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void CSSingleAttendeeDamageEvent::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSSingleAttendeeDamageEvent::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* CSSingleAttendeeDamageEvent::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSSingleAttendeeDamageEvent::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSBossChallengeBigDamageReport

// required .vmsg.CSSingleAttendeeDamageEvent MyDamage = 1;
inline bool CSBossChallengeBigDamageReport::has_mydamage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBossChallengeBigDamageReport::set_has_mydamage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBossChallengeBigDamageReport::clear_has_mydamage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBossChallengeBigDamageReport::clear_mydamage() {
  if (mydamage_ != NULL) mydamage_->::vmsg::CSSingleAttendeeDamageEvent::Clear();
  clear_has_mydamage();
}
inline const ::vmsg::CSSingleAttendeeDamageEvent& CSBossChallengeBigDamageReport::mydamage() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return mydamage_ != NULL ? *mydamage_ : *default_instance().mydamage_;
#else
  return mydamage_ != NULL ? *mydamage_ : *default_instance_->mydamage_;
#endif
}
inline ::vmsg::CSSingleAttendeeDamageEvent* CSBossChallengeBigDamageReport::mutable_mydamage() {
  set_has_mydamage();
  if (mydamage_ == NULL) mydamage_ = new ::vmsg::CSSingleAttendeeDamageEvent;
  return mydamage_;
}
inline ::vmsg::CSSingleAttendeeDamageEvent* CSBossChallengeBigDamageReport::release_mydamage() {
  clear_has_mydamage();
  ::vmsg::CSSingleAttendeeDamageEvent* temp = mydamage_;
  mydamage_ = NULL;
  return temp;
}
inline void CSBossChallengeBigDamageReport::set_allocated_mydamage(::vmsg::CSSingleAttendeeDamageEvent* mydamage) {
  delete mydamage_;
  mydamage_ = mydamage;
  if (mydamage) {
    set_has_mydamage();
  } else {
    clear_has_mydamage();
  }
}

// -------------------------------------------------------------------

// CSBossChallengeEnterEvent

// required uint64 Uid = 1;
inline bool CSBossChallengeEnterEvent::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBossChallengeEnterEvent::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBossChallengeEnterEvent::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBossChallengeEnterEvent::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 CSBossChallengeEnterEvent::uid() const {
  return uid_;
}
inline void CSBossChallengeEnterEvent::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// required string Nick = 2;
inline bool CSBossChallengeEnterEvent::has_nick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBossChallengeEnterEvent::set_has_nick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBossChallengeEnterEvent::clear_has_nick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBossChallengeEnterEvent::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& CSBossChallengeEnterEvent::nick() const {
  return *nick_;
}
inline void CSBossChallengeEnterEvent::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void CSBossChallengeEnterEvent::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void CSBossChallengeEnterEvent::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSBossChallengeEnterEvent::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* CSBossChallengeEnterEvent::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSBossChallengeEnterEvent::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSBossChallengeDamageNotification

// required uint64 BossHp = 1;
inline bool CSBossChallengeDamageNotification::has_bosshp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBossChallengeDamageNotification::set_has_bosshp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBossChallengeDamageNotification::clear_has_bosshp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBossChallengeDamageNotification::clear_bosshp() {
  bosshp_ = GOOGLE_ULONGLONG(0);
  clear_has_bosshp();
}
inline ::google::protobuf::uint64 CSBossChallengeDamageNotification::bosshp() const {
  return bosshp_;
}
inline void CSBossChallengeDamageNotification::set_bosshp(::google::protobuf::uint64 value) {
  set_has_bosshp();
  bosshp_ = value;
}

// repeated .vmsg.CSSingleAttendeeDamageEvent Damages = 2;
inline int CSBossChallengeDamageNotification::damages_size() const {
  return damages_.size();
}
inline void CSBossChallengeDamageNotification::clear_damages() {
  damages_.Clear();
}
inline const ::vmsg::CSSingleAttendeeDamageEvent& CSBossChallengeDamageNotification::damages(int index) const {
  return damages_.Get(index);
}
inline ::vmsg::CSSingleAttendeeDamageEvent* CSBossChallengeDamageNotification::mutable_damages(int index) {
  return damages_.Mutable(index);
}
inline ::vmsg::CSSingleAttendeeDamageEvent* CSBossChallengeDamageNotification::add_damages() {
  return damages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSSingleAttendeeDamageEvent >&
CSBossChallengeDamageNotification::damages() const {
  return damages_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSSingleAttendeeDamageEvent >*
CSBossChallengeDamageNotification::mutable_damages() {
  return &damages_;
}

// repeated .vmsg.CSBossChallengeEnterEvent PlayerEntry = 3;
inline int CSBossChallengeDamageNotification::playerentry_size() const {
  return playerentry_.size();
}
inline void CSBossChallengeDamageNotification::clear_playerentry() {
  playerentry_.Clear();
}
inline const ::vmsg::CSBossChallengeEnterEvent& CSBossChallengeDamageNotification::playerentry(int index) const {
  return playerentry_.Get(index);
}
inline ::vmsg::CSBossChallengeEnterEvent* CSBossChallengeDamageNotification::mutable_playerentry(int index) {
  return playerentry_.Mutable(index);
}
inline ::vmsg::CSBossChallengeEnterEvent* CSBossChallengeDamageNotification::add_playerentry() {
  return playerentry_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSBossChallengeEnterEvent >&
CSBossChallengeDamageNotification::playerentry() const {
  return playerentry_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSBossChallengeEnterEvent >*
CSBossChallengeDamageNotification::mutable_playerentry() {
  return &playerentry_;
}

// repeated .vmsg.CSAttendeeDamageElmt TopChallengers = 4;
inline int CSBossChallengeDamageNotification::topchallengers_size() const {
  return topchallengers_.size();
}
inline void CSBossChallengeDamageNotification::clear_topchallengers() {
  topchallengers_.Clear();
}
inline const ::vmsg::CSAttendeeDamageElmt& CSBossChallengeDamageNotification::topchallengers(int index) const {
  return topchallengers_.Get(index);
}
inline ::vmsg::CSAttendeeDamageElmt* CSBossChallengeDamageNotification::mutable_topchallengers(int index) {
  return topchallengers_.Mutable(index);
}
inline ::vmsg::CSAttendeeDamageElmt* CSBossChallengeDamageNotification::add_topchallengers() {
  return topchallengers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAttendeeDamageElmt >&
CSBossChallengeDamageNotification::topchallengers() const {
  return topchallengers_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAttendeeDamageElmt >*
CSBossChallengeDamageNotification::mutable_topchallengers() {
  return &topchallengers_;
}

// -------------------------------------------------------------------

// CSBossChallengeBossNotification

// required uint64 BossHp = 1;
inline bool CSBossChallengeBossNotification::has_bosshp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBossChallengeBossNotification::set_has_bosshp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBossChallengeBossNotification::clear_has_bosshp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBossChallengeBossNotification::clear_bosshp() {
  bosshp_ = GOOGLE_ULONGLONG(0);
  clear_has_bosshp();
}
inline ::google::protobuf::uint64 CSBossChallengeBossNotification::bosshp() const {
  return bosshp_;
}
inline void CSBossChallengeBossNotification::set_bosshp(::google::protobuf::uint64 value) {
  set_has_bosshp();
  bosshp_ = value;
}

// -------------------------------------------------------------------

// CSBossChallengeStateNotification

// required uint32 State = 1;
inline bool CSBossChallengeStateNotification::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBossChallengeStateNotification::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBossChallengeStateNotification::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBossChallengeStateNotification::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 CSBossChallengeStateNotification::state() const {
  return state_;
}
inline void CSBossChallengeStateNotification::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// optional string AdditionalMsg1 = 2;
inline bool CSBossChallengeStateNotification::has_additionalmsg1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBossChallengeStateNotification::set_has_additionalmsg1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBossChallengeStateNotification::clear_has_additionalmsg1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBossChallengeStateNotification::clear_additionalmsg1() {
  if (additionalmsg1_ != &::google::protobuf::internal::kEmptyString) {
    additionalmsg1_->clear();
  }
  clear_has_additionalmsg1();
}
inline const ::std::string& CSBossChallengeStateNotification::additionalmsg1() const {
  return *additionalmsg1_;
}
inline void CSBossChallengeStateNotification::set_additionalmsg1(const ::std::string& value) {
  set_has_additionalmsg1();
  if (additionalmsg1_ == &::google::protobuf::internal::kEmptyString) {
    additionalmsg1_ = new ::std::string;
  }
  additionalmsg1_->assign(value);
}
inline void CSBossChallengeStateNotification::set_additionalmsg1(const char* value) {
  set_has_additionalmsg1();
  if (additionalmsg1_ == &::google::protobuf::internal::kEmptyString) {
    additionalmsg1_ = new ::std::string;
  }
  additionalmsg1_->assign(value);
}
inline void CSBossChallengeStateNotification::set_additionalmsg1(const char* value, size_t size) {
  set_has_additionalmsg1();
  if (additionalmsg1_ == &::google::protobuf::internal::kEmptyString) {
    additionalmsg1_ = new ::std::string;
  }
  additionalmsg1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSBossChallengeStateNotification::mutable_additionalmsg1() {
  set_has_additionalmsg1();
  if (additionalmsg1_ == &::google::protobuf::internal::kEmptyString) {
    additionalmsg1_ = new ::std::string;
  }
  return additionalmsg1_;
}
inline ::std::string* CSBossChallengeStateNotification::release_additionalmsg1() {
  clear_has_additionalmsg1();
  if (additionalmsg1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = additionalmsg1_;
    additionalmsg1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSBossChallengeStateNotification::set_allocated_additionalmsg1(::std::string* additionalmsg1) {
  if (additionalmsg1_ != &::google::protobuf::internal::kEmptyString) {
    delete additionalmsg1_;
  }
  if (additionalmsg1) {
    set_has_additionalmsg1();
    additionalmsg1_ = additionalmsg1;
  } else {
    clear_has_additionalmsg1();
    additionalmsg1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 AdditionalParm1 = 3;
inline bool CSBossChallengeStateNotification::has_additionalparm1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBossChallengeStateNotification::set_has_additionalparm1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBossChallengeStateNotification::clear_has_additionalparm1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBossChallengeStateNotification::clear_additionalparm1() {
  additionalparm1_ = GOOGLE_ULONGLONG(0);
  clear_has_additionalparm1();
}
inline ::google::protobuf::uint64 CSBossChallengeStateNotification::additionalparm1() const {
  return additionalparm1_;
}
inline void CSBossChallengeStateNotification::set_additionalparm1(::google::protobuf::uint64 value) {
  set_has_additionalparm1();
  additionalparm1_ = value;
}

// -------------------------------------------------------------------

// CSBossChallengeRqst

// optional .vmsg.CSBossChallengeBigDamageReport DamageReport = 1;
inline bool CSBossChallengeRqst::has_damagereport() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBossChallengeRqst::set_has_damagereport() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBossChallengeRqst::clear_has_damagereport() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBossChallengeRqst::clear_damagereport() {
  if (damagereport_ != NULL) damagereport_->::vmsg::CSBossChallengeBigDamageReport::Clear();
  clear_has_damagereport();
}
inline const ::vmsg::CSBossChallengeBigDamageReport& CSBossChallengeRqst::damagereport() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return damagereport_ != NULL ? *damagereport_ : *default_instance().damagereport_;
#else
  return damagereport_ != NULL ? *damagereport_ : *default_instance_->damagereport_;
#endif
}
inline ::vmsg::CSBossChallengeBigDamageReport* CSBossChallengeRqst::mutable_damagereport() {
  set_has_damagereport();
  if (damagereport_ == NULL) damagereport_ = new ::vmsg::CSBossChallengeBigDamageReport;
  return damagereport_;
}
inline ::vmsg::CSBossChallengeBigDamageReport* CSBossChallengeRqst::release_damagereport() {
  clear_has_damagereport();
  ::vmsg::CSBossChallengeBigDamageReport* temp = damagereport_;
  damagereport_ = NULL;
  return temp;
}
inline void CSBossChallengeRqst::set_allocated_damagereport(::vmsg::CSBossChallengeBigDamageReport* damagereport) {
  delete damagereport_;
  damagereport_ = damagereport;
  if (damagereport) {
    set_has_damagereport();
  } else {
    clear_has_damagereport();
  }
}

// optional uint32 DelegateType = 2;
inline bool CSBossChallengeRqst::has_delegatetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBossChallengeRqst::set_has_delegatetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBossChallengeRqst::clear_has_delegatetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBossChallengeRqst::clear_delegatetype() {
  delegatetype_ = 0u;
  clear_has_delegatetype();
}
inline ::google::protobuf::uint32 CSBossChallengeRqst::delegatetype() const {
  return delegatetype_;
}
inline void CSBossChallengeRqst::set_delegatetype(::google::protobuf::uint32 value) {
  set_has_delegatetype();
  delegatetype_ = value;
}

// optional uint32 AttendOrLeave = 3;
inline bool CSBossChallengeRqst::has_attendorleave() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBossChallengeRqst::set_has_attendorleave() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBossChallengeRqst::clear_has_attendorleave() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBossChallengeRqst::clear_attendorleave() {
  attendorleave_ = 0u;
  clear_has_attendorleave();
}
inline ::google::protobuf::uint32 CSBossChallengeRqst::attendorleave() const {
  return attendorleave_;
}
inline void CSBossChallengeRqst::set_attendorleave(::google::protobuf::uint32 value) {
  set_has_attendorleave();
  attendorleave_ = value;
}

// -------------------------------------------------------------------

// CSBossChallengeRsp

// optional .vmsg.CSBossChallengeInfo ChallengeInfo = 1;
inline bool CSBossChallengeRsp::has_challengeinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBossChallengeRsp::set_has_challengeinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBossChallengeRsp::clear_has_challengeinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBossChallengeRsp::clear_challengeinfo() {
  if (challengeinfo_ != NULL) challengeinfo_->::vmsg::CSBossChallengeInfo::Clear();
  clear_has_challengeinfo();
}
inline const ::vmsg::CSBossChallengeInfo& CSBossChallengeRsp::challengeinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return challengeinfo_ != NULL ? *challengeinfo_ : *default_instance().challengeinfo_;
#else
  return challengeinfo_ != NULL ? *challengeinfo_ : *default_instance_->challengeinfo_;
#endif
}
inline ::vmsg::CSBossChallengeInfo* CSBossChallengeRsp::mutable_challengeinfo() {
  set_has_challengeinfo();
  if (challengeinfo_ == NULL) challengeinfo_ = new ::vmsg::CSBossChallengeInfo;
  return challengeinfo_;
}
inline ::vmsg::CSBossChallengeInfo* CSBossChallengeRsp::release_challengeinfo() {
  clear_has_challengeinfo();
  ::vmsg::CSBossChallengeInfo* temp = challengeinfo_;
  challengeinfo_ = NULL;
  return temp;
}
inline void CSBossChallengeRsp::set_allocated_challengeinfo(::vmsg::CSBossChallengeInfo* challengeinfo) {
  delete challengeinfo_;
  challengeinfo_ = challengeinfo;
  if (challengeinfo) {
    set_has_challengeinfo();
  } else {
    clear_has_challengeinfo();
  }
}

// optional .vmsg.CSBossChallengeDamageNotification Damages = 2;
inline bool CSBossChallengeRsp::has_damages() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBossChallengeRsp::set_has_damages() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBossChallengeRsp::clear_has_damages() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBossChallengeRsp::clear_damages() {
  if (damages_ != NULL) damages_->::vmsg::CSBossChallengeDamageNotification::Clear();
  clear_has_damages();
}
inline const ::vmsg::CSBossChallengeDamageNotification& CSBossChallengeRsp::damages() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return damages_ != NULL ? *damages_ : *default_instance().damages_;
#else
  return damages_ != NULL ? *damages_ : *default_instance_->damages_;
#endif
}
inline ::vmsg::CSBossChallengeDamageNotification* CSBossChallengeRsp::mutable_damages() {
  set_has_damages();
  if (damages_ == NULL) damages_ = new ::vmsg::CSBossChallengeDamageNotification;
  return damages_;
}
inline ::vmsg::CSBossChallengeDamageNotification* CSBossChallengeRsp::release_damages() {
  clear_has_damages();
  ::vmsg::CSBossChallengeDamageNotification* temp = damages_;
  damages_ = NULL;
  return temp;
}
inline void CSBossChallengeRsp::set_allocated_damages(::vmsg::CSBossChallengeDamageNotification* damages) {
  delete damages_;
  damages_ = damages;
  if (damages) {
    set_has_damages();
  } else {
    clear_has_damages();
  }
}

// optional .vmsg.CSBossChallengeStateNotification BossChallengeStateNotify = 3;
inline bool CSBossChallengeRsp::has_bosschallengestatenotify() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBossChallengeRsp::set_has_bosschallengestatenotify() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBossChallengeRsp::clear_has_bosschallengestatenotify() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBossChallengeRsp::clear_bosschallengestatenotify() {
  if (bosschallengestatenotify_ != NULL) bosschallengestatenotify_->::vmsg::CSBossChallengeStateNotification::Clear();
  clear_has_bosschallengestatenotify();
}
inline const ::vmsg::CSBossChallengeStateNotification& CSBossChallengeRsp::bosschallengestatenotify() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bosschallengestatenotify_ != NULL ? *bosschallengestatenotify_ : *default_instance().bosschallengestatenotify_;
#else
  return bosschallengestatenotify_ != NULL ? *bosschallengestatenotify_ : *default_instance_->bosschallengestatenotify_;
#endif
}
inline ::vmsg::CSBossChallengeStateNotification* CSBossChallengeRsp::mutable_bosschallengestatenotify() {
  set_has_bosschallengestatenotify();
  if (bosschallengestatenotify_ == NULL) bosschallengestatenotify_ = new ::vmsg::CSBossChallengeStateNotification;
  return bosschallengestatenotify_;
}
inline ::vmsg::CSBossChallengeStateNotification* CSBossChallengeRsp::release_bosschallengestatenotify() {
  clear_has_bosschallengestatenotify();
  ::vmsg::CSBossChallengeStateNotification* temp = bosschallengestatenotify_;
  bosschallengestatenotify_ = NULL;
  return temp;
}
inline void CSBossChallengeRsp::set_allocated_bosschallengestatenotify(::vmsg::CSBossChallengeStateNotification* bosschallengestatenotify) {
  delete bosschallengestatenotify_;
  bosschallengestatenotify_ = bosschallengestatenotify;
  if (bosschallengestatenotify) {
    set_has_bosschallengestatenotify();
  } else {
    clear_has_bosschallengestatenotify();
  }
}

// optional uint32 DelegateType = 4;
inline bool CSBossChallengeRsp::has_delegatetype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSBossChallengeRsp::set_has_delegatetype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSBossChallengeRsp::clear_has_delegatetype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSBossChallengeRsp::clear_delegatetype() {
  delegatetype_ = 0u;
  clear_has_delegatetype();
}
inline ::google::protobuf::uint32 CSBossChallengeRsp::delegatetype() const {
  return delegatetype_;
}
inline void CSBossChallengeRsp::set_delegatetype(::google::protobuf::uint32 value) {
  set_has_delegatetype();
  delegatetype_ = value;
}

// optional uint32 AttendOrLeave = 5;
inline bool CSBossChallengeRsp::has_attendorleave() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSBossChallengeRsp::set_has_attendorleave() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSBossChallengeRsp::clear_has_attendorleave() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSBossChallengeRsp::clear_attendorleave() {
  attendorleave_ = 0u;
  clear_has_attendorleave();
}
inline ::google::protobuf::uint32 CSBossChallengeRsp::attendorleave() const {
  return attendorleave_;
}
inline void CSBossChallengeRsp::set_attendorleave(::google::protobuf::uint32 value) {
  set_has_attendorleave();
  attendorleave_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CSBossChallengeMsg_2eproto__INCLUDED
