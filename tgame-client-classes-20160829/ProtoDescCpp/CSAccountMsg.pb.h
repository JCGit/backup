// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSAccountMsg.proto

#ifndef PROTOBUF_CSAccountMsg_2eproto__INCLUDED
#define PROTOBUF_CSAccountMsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MsgBase.pb.h"
// @@protoc_insertion_point(includes)

namespace vmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CSAccountMsg_2eproto();
void protobuf_AssignDesc_CSAccountMsg_2eproto();
void protobuf_ShutdownFile_CSAccountMsg_2eproto();

class CSRegAccountRqst;
class CSRegAccountRsp;
class CSAccountAuthRqst;
class CSChangePasswordRqst;
class CSAccountRquest;
class CSAccountRespond;

// ===================================================================

class CSRegAccountRqst : public ::google::protobuf::MessageLite {
 public:
  CSRegAccountRqst();
  virtual ~CSRegAccountRqst();

  CSRegAccountRqst(const CSRegAccountRqst& from);

  inline CSRegAccountRqst& operator=(const CSRegAccountRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSRegAccountRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRegAccountRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRegAccountRqst* other);

  // implements Message ----------------------------------------------

  CSRegAccountRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRegAccountRqst& from);
  void MergeFrom(const CSRegAccountRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Email = 1;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 1;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // required string Password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:vmsg.CSRegAccountRqst)
 private:
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_password();
  inline void clear_has_password();

  ::std::string* email_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSAccountMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSAccountMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSAccountMsg_2eproto();
  friend void protobuf_ShutdownFile_CSAccountMsg_2eproto();

  void InitAsDefaultInstance();
  static CSRegAccountRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSRegAccountRsp : public ::google::protobuf::MessageLite {
 public:
  CSRegAccountRsp();
  virtual ~CSRegAccountRsp();

  CSRegAccountRsp(const CSRegAccountRsp& from);

  inline CSRegAccountRsp& operator=(const CSRegAccountRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSRegAccountRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRegAccountRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRegAccountRsp* other);

  // implements Message ----------------------------------------------

  CSRegAccountRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRegAccountRsp& from);
  void MergeFrom(const CSRegAccountRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSRegAccountRsp)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::uint32 uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSAccountMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSAccountMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSAccountMsg_2eproto();
  friend void protobuf_ShutdownFile_CSAccountMsg_2eproto();

  void InitAsDefaultInstance();
  static CSRegAccountRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSAccountAuthRqst : public ::google::protobuf::MessageLite {
 public:
  CSAccountAuthRqst();
  virtual ~CSAccountAuthRqst();

  CSAccountAuthRqst(const CSAccountAuthRqst& from);

  inline CSAccountAuthRqst& operator=(const CSAccountAuthRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSAccountAuthRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAccountAuthRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAccountAuthRqst* other);

  // implements Message ----------------------------------------------

  CSAccountAuthRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAccountAuthRqst& from);
  void MergeFrom(const CSAccountAuthRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Email = 1;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 1;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // required string Sign = 2;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 2;
  inline const ::std::string& sign() const;
  inline void set_sign(const ::std::string& value);
  inline void set_sign(const char* value);
  inline void set_sign(const char* value, size_t size);
  inline ::std::string* mutable_sign();
  inline ::std::string* release_sign();
  inline void set_allocated_sign(::std::string* sign);

  // @@protoc_insertion_point(class_scope:vmsg.CSAccountAuthRqst)
 private:
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_sign();
  inline void clear_has_sign();

  ::std::string* email_;
  ::std::string* sign_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSAccountMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSAccountMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSAccountMsg_2eproto();
  friend void protobuf_ShutdownFile_CSAccountMsg_2eproto();

  void InitAsDefaultInstance();
  static CSAccountAuthRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSChangePasswordRqst : public ::google::protobuf::MessageLite {
 public:
  CSChangePasswordRqst();
  virtual ~CSChangePasswordRqst();

  CSChangePasswordRqst(const CSChangePasswordRqst& from);

  inline CSChangePasswordRqst& operator=(const CSChangePasswordRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSChangePasswordRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChangePasswordRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChangePasswordRqst* other);

  // implements Message ----------------------------------------------

  CSChangePasswordRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChangePasswordRqst& from);
  void MergeFrom(const CSChangePasswordRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string AdminKey = 1;
  inline bool has_adminkey() const;
  inline void clear_adminkey();
  static const int kAdminKeyFieldNumber = 1;
  inline const ::std::string& adminkey() const;
  inline void set_adminkey(const ::std::string& value);
  inline void set_adminkey(const char* value);
  inline void set_adminkey(const char* value, size_t size);
  inline ::std::string* mutable_adminkey();
  inline ::std::string* release_adminkey();
  inline void set_allocated_adminkey(::std::string* adminkey);

  // required string Email = 2;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 2;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // required string NewPassord = 3;
  inline bool has_newpassord() const;
  inline void clear_newpassord();
  static const int kNewPassordFieldNumber = 3;
  inline const ::std::string& newpassord() const;
  inline void set_newpassord(const ::std::string& value);
  inline void set_newpassord(const char* value);
  inline void set_newpassord(const char* value, size_t size);
  inline ::std::string* mutable_newpassord();
  inline ::std::string* release_newpassord();
  inline void set_allocated_newpassord(::std::string* newpassord);

  // @@protoc_insertion_point(class_scope:vmsg.CSChangePasswordRqst)
 private:
  inline void set_has_adminkey();
  inline void clear_has_adminkey();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_newpassord();
  inline void clear_has_newpassord();

  ::std::string* adminkey_;
  ::std::string* email_;
  ::std::string* newpassord_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSAccountMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSAccountMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSAccountMsg_2eproto();
  friend void protobuf_ShutdownFile_CSAccountMsg_2eproto();

  void InitAsDefaultInstance();
  static CSChangePasswordRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSAccountRquest : public ::google::protobuf::MessageLite {
 public:
  CSAccountRquest();
  virtual ~CSAccountRquest();

  CSAccountRquest(const CSAccountRquest& from);

  inline CSAccountRquest& operator=(const CSAccountRquest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSAccountRquest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAccountRquest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAccountRquest* other);

  // implements Message ----------------------------------------------

  CSAccountRquest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAccountRquest& from);
  void MergeFrom(const CSAccountRquest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSRegAccountRqst RegAccount_Rqst = 1;
  inline bool has_regaccount_rqst() const;
  inline void clear_regaccount_rqst();
  static const int kRegAccountRqstFieldNumber = 1;
  inline const ::vmsg::CSRegAccountRqst& regaccount_rqst() const;
  inline ::vmsg::CSRegAccountRqst* mutable_regaccount_rqst();
  inline ::vmsg::CSRegAccountRqst* release_regaccount_rqst();
  inline void set_allocated_regaccount_rqst(::vmsg::CSRegAccountRqst* regaccount_rqst);

  // optional .vmsg.CSAccountAuthRqst AuthAccount_Rqst = 2;
  inline bool has_authaccount_rqst() const;
  inline void clear_authaccount_rqst();
  static const int kAuthAccountRqstFieldNumber = 2;
  inline const ::vmsg::CSAccountAuthRqst& authaccount_rqst() const;
  inline ::vmsg::CSAccountAuthRqst* mutable_authaccount_rqst();
  inline ::vmsg::CSAccountAuthRqst* release_authaccount_rqst();
  inline void set_allocated_authaccount_rqst(::vmsg::CSAccountAuthRqst* authaccount_rqst);

  // optional .vmsg.CSChangePasswordRqst ChangePassword_Rqst = 3;
  inline bool has_changepassword_rqst() const;
  inline void clear_changepassword_rqst();
  static const int kChangePasswordRqstFieldNumber = 3;
  inline const ::vmsg::CSChangePasswordRqst& changepassword_rqst() const;
  inline ::vmsg::CSChangePasswordRqst* mutable_changepassword_rqst();
  inline ::vmsg::CSChangePasswordRqst* release_changepassword_rqst();
  inline void set_allocated_changepassword_rqst(::vmsg::CSChangePasswordRqst* changepassword_rqst);

  // @@protoc_insertion_point(class_scope:vmsg.CSAccountRquest)
 private:
  inline void set_has_regaccount_rqst();
  inline void clear_has_regaccount_rqst();
  inline void set_has_authaccount_rqst();
  inline void clear_has_authaccount_rqst();
  inline void set_has_changepassword_rqst();
  inline void clear_has_changepassword_rqst();

  ::vmsg::CSRegAccountRqst* regaccount_rqst_;
  ::vmsg::CSAccountAuthRqst* authaccount_rqst_;
  ::vmsg::CSChangePasswordRqst* changepassword_rqst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSAccountMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSAccountMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSAccountMsg_2eproto();
  friend void protobuf_ShutdownFile_CSAccountMsg_2eproto();

  void InitAsDefaultInstance();
  static CSAccountRquest* default_instance_;
};
// -------------------------------------------------------------------

class CSAccountRespond : public ::google::protobuf::MessageLite {
 public:
  CSAccountRespond();
  virtual ~CSAccountRespond();

  CSAccountRespond(const CSAccountRespond& from);

  inline CSAccountRespond& operator=(const CSAccountRespond& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSAccountRespond& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAccountRespond* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAccountRespond* other);

  // implements Message ----------------------------------------------

  CSAccountRespond* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAccountRespond& from);
  void MergeFrom(const CSAccountRespond& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSRegAccountRsp RegAccount_Rsp = 1;
  inline bool has_regaccount_rsp() const;
  inline void clear_regaccount_rsp();
  static const int kRegAccountRspFieldNumber = 1;
  inline const ::vmsg::CSRegAccountRsp& regaccount_rsp() const;
  inline ::vmsg::CSRegAccountRsp* mutable_regaccount_rsp();
  inline ::vmsg::CSRegAccountRsp* release_regaccount_rsp();
  inline void set_allocated_regaccount_rsp(::vmsg::CSRegAccountRsp* regaccount_rsp);

  // @@protoc_insertion_point(class_scope:vmsg.CSAccountRespond)
 private:
  inline void set_has_regaccount_rsp();
  inline void clear_has_regaccount_rsp();

  ::vmsg::CSRegAccountRsp* regaccount_rsp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSAccountMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSAccountMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSAccountMsg_2eproto();
  friend void protobuf_ShutdownFile_CSAccountMsg_2eproto();

  void InitAsDefaultInstance();
  static CSAccountRespond* default_instance_;
};
// ===================================================================


// ===================================================================

// CSRegAccountRqst

// required string Email = 1;
inline bool CSRegAccountRqst::has_email() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRegAccountRqst::set_has_email() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRegAccountRqst::clear_has_email() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRegAccountRqst::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& CSRegAccountRqst::email() const {
  return *email_;
}
inline void CSRegAccountRqst::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void CSRegAccountRqst::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void CSRegAccountRqst::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSRegAccountRqst::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* CSRegAccountRqst::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSRegAccountRqst::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Password = 2;
inline bool CSRegAccountRqst::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRegAccountRqst::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRegAccountRqst::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRegAccountRqst::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& CSRegAccountRqst::password() const {
  return *password_;
}
inline void CSRegAccountRqst::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CSRegAccountRqst::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CSRegAccountRqst::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSRegAccountRqst::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* CSRegAccountRqst::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSRegAccountRqst::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSRegAccountRsp

// required uint32 Uid = 1;
inline bool CSRegAccountRsp::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRegAccountRsp::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRegAccountRsp::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRegAccountRsp::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 CSRegAccountRsp::uid() const {
  return uid_;
}
inline void CSRegAccountRsp::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
}

// -------------------------------------------------------------------

// CSAccountAuthRqst

// required string Email = 1;
inline bool CSAccountAuthRqst::has_email() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAccountAuthRqst::set_has_email() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAccountAuthRqst::clear_has_email() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAccountAuthRqst::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& CSAccountAuthRqst::email() const {
  return *email_;
}
inline void CSAccountAuthRqst::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void CSAccountAuthRqst::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void CSAccountAuthRqst::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSAccountAuthRqst::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* CSAccountAuthRqst::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSAccountAuthRqst::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Sign = 2;
inline bool CSAccountAuthRqst::has_sign() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSAccountAuthRqst::set_has_sign() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSAccountAuthRqst::clear_has_sign() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSAccountAuthRqst::clear_sign() {
  if (sign_ != &::google::protobuf::internal::kEmptyString) {
    sign_->clear();
  }
  clear_has_sign();
}
inline const ::std::string& CSAccountAuthRqst::sign() const {
  return *sign_;
}
inline void CSAccountAuthRqst::set_sign(const ::std::string& value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void CSAccountAuthRqst::set_sign(const char* value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void CSAccountAuthRqst::set_sign(const char* value, size_t size) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSAccountAuthRqst::mutable_sign() {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  return sign_;
}
inline ::std::string* CSAccountAuthRqst::release_sign() {
  clear_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sign_;
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSAccountAuthRqst::set_allocated_sign(::std::string* sign) {
  if (sign_ != &::google::protobuf::internal::kEmptyString) {
    delete sign_;
  }
  if (sign) {
    set_has_sign();
    sign_ = sign;
  } else {
    clear_has_sign();
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSChangePasswordRqst

// required string AdminKey = 1;
inline bool CSChangePasswordRqst::has_adminkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSChangePasswordRqst::set_has_adminkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSChangePasswordRqst::clear_has_adminkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSChangePasswordRqst::clear_adminkey() {
  if (adminkey_ != &::google::protobuf::internal::kEmptyString) {
    adminkey_->clear();
  }
  clear_has_adminkey();
}
inline const ::std::string& CSChangePasswordRqst::adminkey() const {
  return *adminkey_;
}
inline void CSChangePasswordRqst::set_adminkey(const ::std::string& value) {
  set_has_adminkey();
  if (adminkey_ == &::google::protobuf::internal::kEmptyString) {
    adminkey_ = new ::std::string;
  }
  adminkey_->assign(value);
}
inline void CSChangePasswordRqst::set_adminkey(const char* value) {
  set_has_adminkey();
  if (adminkey_ == &::google::protobuf::internal::kEmptyString) {
    adminkey_ = new ::std::string;
  }
  adminkey_->assign(value);
}
inline void CSChangePasswordRqst::set_adminkey(const char* value, size_t size) {
  set_has_adminkey();
  if (adminkey_ == &::google::protobuf::internal::kEmptyString) {
    adminkey_ = new ::std::string;
  }
  adminkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSChangePasswordRqst::mutable_adminkey() {
  set_has_adminkey();
  if (adminkey_ == &::google::protobuf::internal::kEmptyString) {
    adminkey_ = new ::std::string;
  }
  return adminkey_;
}
inline ::std::string* CSChangePasswordRqst::release_adminkey() {
  clear_has_adminkey();
  if (adminkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = adminkey_;
    adminkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSChangePasswordRqst::set_allocated_adminkey(::std::string* adminkey) {
  if (adminkey_ != &::google::protobuf::internal::kEmptyString) {
    delete adminkey_;
  }
  if (adminkey) {
    set_has_adminkey();
    adminkey_ = adminkey;
  } else {
    clear_has_adminkey();
    adminkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Email = 2;
inline bool CSChangePasswordRqst::has_email() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSChangePasswordRqst::set_has_email() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSChangePasswordRqst::clear_has_email() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSChangePasswordRqst::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& CSChangePasswordRqst::email() const {
  return *email_;
}
inline void CSChangePasswordRqst::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void CSChangePasswordRqst::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void CSChangePasswordRqst::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSChangePasswordRqst::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* CSChangePasswordRqst::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSChangePasswordRqst::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string NewPassord = 3;
inline bool CSChangePasswordRqst::has_newpassord() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSChangePasswordRqst::set_has_newpassord() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSChangePasswordRqst::clear_has_newpassord() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSChangePasswordRqst::clear_newpassord() {
  if (newpassord_ != &::google::protobuf::internal::kEmptyString) {
    newpassord_->clear();
  }
  clear_has_newpassord();
}
inline const ::std::string& CSChangePasswordRqst::newpassord() const {
  return *newpassord_;
}
inline void CSChangePasswordRqst::set_newpassord(const ::std::string& value) {
  set_has_newpassord();
  if (newpassord_ == &::google::protobuf::internal::kEmptyString) {
    newpassord_ = new ::std::string;
  }
  newpassord_->assign(value);
}
inline void CSChangePasswordRqst::set_newpassord(const char* value) {
  set_has_newpassord();
  if (newpassord_ == &::google::protobuf::internal::kEmptyString) {
    newpassord_ = new ::std::string;
  }
  newpassord_->assign(value);
}
inline void CSChangePasswordRqst::set_newpassord(const char* value, size_t size) {
  set_has_newpassord();
  if (newpassord_ == &::google::protobuf::internal::kEmptyString) {
    newpassord_ = new ::std::string;
  }
  newpassord_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSChangePasswordRqst::mutable_newpassord() {
  set_has_newpassord();
  if (newpassord_ == &::google::protobuf::internal::kEmptyString) {
    newpassord_ = new ::std::string;
  }
  return newpassord_;
}
inline ::std::string* CSChangePasswordRqst::release_newpassord() {
  clear_has_newpassord();
  if (newpassord_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newpassord_;
    newpassord_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSChangePasswordRqst::set_allocated_newpassord(::std::string* newpassord) {
  if (newpassord_ != &::google::protobuf::internal::kEmptyString) {
    delete newpassord_;
  }
  if (newpassord) {
    set_has_newpassord();
    newpassord_ = newpassord;
  } else {
    clear_has_newpassord();
    newpassord_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSAccountRquest

// optional .vmsg.CSRegAccountRqst RegAccount_Rqst = 1;
inline bool CSAccountRquest::has_regaccount_rqst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAccountRquest::set_has_regaccount_rqst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAccountRquest::clear_has_regaccount_rqst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAccountRquest::clear_regaccount_rqst() {
  if (regaccount_rqst_ != NULL) regaccount_rqst_->::vmsg::CSRegAccountRqst::Clear();
  clear_has_regaccount_rqst();
}
inline const ::vmsg::CSRegAccountRqst& CSAccountRquest::regaccount_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return regaccount_rqst_ != NULL ? *regaccount_rqst_ : *default_instance().regaccount_rqst_;
#else
  return regaccount_rqst_ != NULL ? *regaccount_rqst_ : *default_instance_->regaccount_rqst_;
#endif
}
inline ::vmsg::CSRegAccountRqst* CSAccountRquest::mutable_regaccount_rqst() {
  set_has_regaccount_rqst();
  if (regaccount_rqst_ == NULL) regaccount_rqst_ = new ::vmsg::CSRegAccountRqst;
  return regaccount_rqst_;
}
inline ::vmsg::CSRegAccountRqst* CSAccountRquest::release_regaccount_rqst() {
  clear_has_regaccount_rqst();
  ::vmsg::CSRegAccountRqst* temp = regaccount_rqst_;
  regaccount_rqst_ = NULL;
  return temp;
}
inline void CSAccountRquest::set_allocated_regaccount_rqst(::vmsg::CSRegAccountRqst* regaccount_rqst) {
  delete regaccount_rqst_;
  regaccount_rqst_ = regaccount_rqst;
  if (regaccount_rqst) {
    set_has_regaccount_rqst();
  } else {
    clear_has_regaccount_rqst();
  }
}

// optional .vmsg.CSAccountAuthRqst AuthAccount_Rqst = 2;
inline bool CSAccountRquest::has_authaccount_rqst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSAccountRquest::set_has_authaccount_rqst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSAccountRquest::clear_has_authaccount_rqst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSAccountRquest::clear_authaccount_rqst() {
  if (authaccount_rqst_ != NULL) authaccount_rqst_->::vmsg::CSAccountAuthRqst::Clear();
  clear_has_authaccount_rqst();
}
inline const ::vmsg::CSAccountAuthRqst& CSAccountRquest::authaccount_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return authaccount_rqst_ != NULL ? *authaccount_rqst_ : *default_instance().authaccount_rqst_;
#else
  return authaccount_rqst_ != NULL ? *authaccount_rqst_ : *default_instance_->authaccount_rqst_;
#endif
}
inline ::vmsg::CSAccountAuthRqst* CSAccountRquest::mutable_authaccount_rqst() {
  set_has_authaccount_rqst();
  if (authaccount_rqst_ == NULL) authaccount_rqst_ = new ::vmsg::CSAccountAuthRqst;
  return authaccount_rqst_;
}
inline ::vmsg::CSAccountAuthRqst* CSAccountRquest::release_authaccount_rqst() {
  clear_has_authaccount_rqst();
  ::vmsg::CSAccountAuthRqst* temp = authaccount_rqst_;
  authaccount_rqst_ = NULL;
  return temp;
}
inline void CSAccountRquest::set_allocated_authaccount_rqst(::vmsg::CSAccountAuthRqst* authaccount_rqst) {
  delete authaccount_rqst_;
  authaccount_rqst_ = authaccount_rqst;
  if (authaccount_rqst) {
    set_has_authaccount_rqst();
  } else {
    clear_has_authaccount_rqst();
  }
}

// optional .vmsg.CSChangePasswordRqst ChangePassword_Rqst = 3;
inline bool CSAccountRquest::has_changepassword_rqst() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSAccountRquest::set_has_changepassword_rqst() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSAccountRquest::clear_has_changepassword_rqst() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSAccountRquest::clear_changepassword_rqst() {
  if (changepassword_rqst_ != NULL) changepassword_rqst_->::vmsg::CSChangePasswordRqst::Clear();
  clear_has_changepassword_rqst();
}
inline const ::vmsg::CSChangePasswordRqst& CSAccountRquest::changepassword_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return changepassword_rqst_ != NULL ? *changepassword_rqst_ : *default_instance().changepassword_rqst_;
#else
  return changepassword_rqst_ != NULL ? *changepassword_rqst_ : *default_instance_->changepassword_rqst_;
#endif
}
inline ::vmsg::CSChangePasswordRqst* CSAccountRquest::mutable_changepassword_rqst() {
  set_has_changepassword_rqst();
  if (changepassword_rqst_ == NULL) changepassword_rqst_ = new ::vmsg::CSChangePasswordRqst;
  return changepassword_rqst_;
}
inline ::vmsg::CSChangePasswordRqst* CSAccountRquest::release_changepassword_rqst() {
  clear_has_changepassword_rqst();
  ::vmsg::CSChangePasswordRqst* temp = changepassword_rqst_;
  changepassword_rqst_ = NULL;
  return temp;
}
inline void CSAccountRquest::set_allocated_changepassword_rqst(::vmsg::CSChangePasswordRqst* changepassword_rqst) {
  delete changepassword_rqst_;
  changepassword_rqst_ = changepassword_rqst;
  if (changepassword_rqst) {
    set_has_changepassword_rqst();
  } else {
    clear_has_changepassword_rqst();
  }
}

// -------------------------------------------------------------------

// CSAccountRespond

// optional .vmsg.CSRegAccountRsp RegAccount_Rsp = 1;
inline bool CSAccountRespond::has_regaccount_rsp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAccountRespond::set_has_regaccount_rsp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAccountRespond::clear_has_regaccount_rsp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAccountRespond::clear_regaccount_rsp() {
  if (regaccount_rsp_ != NULL) regaccount_rsp_->::vmsg::CSRegAccountRsp::Clear();
  clear_has_regaccount_rsp();
}
inline const ::vmsg::CSRegAccountRsp& CSAccountRespond::regaccount_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return regaccount_rsp_ != NULL ? *regaccount_rsp_ : *default_instance().regaccount_rsp_;
#else
  return regaccount_rsp_ != NULL ? *regaccount_rsp_ : *default_instance_->regaccount_rsp_;
#endif
}
inline ::vmsg::CSRegAccountRsp* CSAccountRespond::mutable_regaccount_rsp() {
  set_has_regaccount_rsp();
  if (regaccount_rsp_ == NULL) regaccount_rsp_ = new ::vmsg::CSRegAccountRsp;
  return regaccount_rsp_;
}
inline ::vmsg::CSRegAccountRsp* CSAccountRespond::release_regaccount_rsp() {
  clear_has_regaccount_rsp();
  ::vmsg::CSRegAccountRsp* temp = regaccount_rsp_;
  regaccount_rsp_ = NULL;
  return temp;
}
inline void CSAccountRespond::set_allocated_regaccount_rsp(::vmsg::CSRegAccountRsp* regaccount_rsp) {
  delete regaccount_rsp_;
  regaccount_rsp_ = regaccount_rsp;
  if (regaccount_rsp) {
    set_has_regaccount_rsp();
  } else {
    clear_has_regaccount_rsp();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CSAccountMsg_2eproto__INCLUDED
