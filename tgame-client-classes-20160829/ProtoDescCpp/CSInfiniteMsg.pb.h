// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSInfiniteMsg.proto

#ifndef PROTOBUF_CSInfiniteMsg_2eproto__INCLUDED
#define PROTOBUF_CSInfiniteMsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MsgBase.pb.h"
#include "ShareByClient.pb.h"
#include "CSEquipItemMsg.pb.h"
// @@protoc_insertion_point(includes)

namespace vmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CSInfiniteMsg_2eproto();
void protobuf_AssignDesc_CSInfiniteMsg_2eproto();
void protobuf_ShutdownFile_CSInfiniteMsg_2eproto();

class CSInfiniteEndRqst;
class CSInfiniteBuyGenRqst;
class CSGen;
class CSInfiniteGenInfo;
class CSInfiniteEndRsp;
class CSNothingLandStartRqst;
class CSNothingLandEndRqst;
class CSNothingLandEndRsp;
class CSNothingLandHistoryRsp;
class CSInfiniteRequest;
class CSInfiniteRespond;

// ===================================================================

class CSInfiniteEndRqst : public ::google::protobuf::MessageLite {
 public:
  CSInfiniteEndRqst();
  virtual ~CSInfiniteEndRqst();

  CSInfiniteEndRqst(const CSInfiniteEndRqst& from);

  inline CSInfiniteEndRqst& operator=(const CSInfiniteEndRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSInfiniteEndRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSInfiniteEndRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSInfiniteEndRqst* other);

  // implements Message ----------------------------------------------

  CSInfiniteEndRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSInfiniteEndRqst& from);
  void MergeFrom(const CSInfiniteEndRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Score = 1;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 1;
  inline ::google::protobuf::uint64 score() const;
  inline void set_score(::google::protobuf::uint64 value);

  // required uint32 PackageCnt = 2;
  inline bool has_packagecnt() const;
  inline void clear_packagecnt();
  static const int kPackageCntFieldNumber = 2;
  inline ::google::protobuf::uint32 packagecnt() const;
  inline void set_packagecnt(::google::protobuf::uint32 value);

  // required uint32 WaveCnt = 3;
  inline bool has_wavecnt() const;
  inline void clear_wavecnt();
  static const int kWaveCntFieldNumber = 3;
  inline ::google::protobuf::uint32 wavecnt() const;
  inline void set_wavecnt(::google::protobuf::uint32 value);

  // repeated uint32 MonsterCnt = 4;
  inline int monstercnt_size() const;
  inline void clear_monstercnt();
  static const int kMonsterCntFieldNumber = 4;
  inline ::google::protobuf::uint32 monstercnt(int index) const;
  inline void set_monstercnt(int index, ::google::protobuf::uint32 value);
  inline void add_monstercnt(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      monstercnt() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_monstercnt();

  // required uint32 Coin = 5;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 5;
  inline ::google::protobuf::uint32 coin() const;
  inline void set_coin(::google::protobuf::uint32 value);

  // required uint32 EvolutionCnt = 6;
  inline bool has_evolutioncnt() const;
  inline void clear_evolutioncnt();
  static const int kEvolutionCntFieldNumber = 6;
  inline ::google::protobuf::uint32 evolutioncnt() const;
  inline void set_evolutioncnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSInfiniteEndRqst)
 private:
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_packagecnt();
  inline void clear_has_packagecnt();
  inline void set_has_wavecnt();
  inline void clear_has_wavecnt();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_evolutioncnt();
  inline void clear_has_evolutioncnt();

  ::google::protobuf::uint64 score_;
  ::google::protobuf::uint32 packagecnt_;
  ::google::protobuf::uint32 wavecnt_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > monstercnt_;
  ::google::protobuf::uint32 coin_;
  ::google::protobuf::uint32 evolutioncnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSInfiniteMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSInfiniteMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSInfiniteMsg_2eproto();
  friend void protobuf_ShutdownFile_CSInfiniteMsg_2eproto();

  void InitAsDefaultInstance();
  static CSInfiniteEndRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSInfiniteBuyGenRqst : public ::google::protobuf::MessageLite {
 public:
  CSInfiniteBuyGenRqst();
  virtual ~CSInfiniteBuyGenRqst();

  CSInfiniteBuyGenRqst(const CSInfiniteBuyGenRqst& from);

  inline CSInfiniteBuyGenRqst& operator=(const CSInfiniteBuyGenRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSInfiniteBuyGenRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSInfiniteBuyGenRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSInfiniteBuyGenRqst* other);

  // implements Message ----------------------------------------------

  CSInfiniteBuyGenRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSInfiniteBuyGenRqst& from);
  void MergeFrom(const CSInfiniteBuyGenRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Idx = 1;
  inline bool has_idx() const;
  inline void clear_idx();
  static const int kIdxFieldNumber = 1;
  inline ::google::protobuf::uint32 idx() const;
  inline void set_idx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSInfiniteBuyGenRqst)
 private:
  inline void set_has_idx();
  inline void clear_has_idx();

  ::google::protobuf::uint32 idx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSInfiniteMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSInfiniteMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSInfiniteMsg_2eproto();
  friend void protobuf_ShutdownFile_CSInfiniteMsg_2eproto();

  void InitAsDefaultInstance();
  static CSInfiniteBuyGenRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSGen : public ::google::protobuf::MessageLite {
 public:
  CSGen();
  virtual ~CSGen();

  CSGen(const CSGen& from);

  inline CSGen& operator=(const CSGen& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSGen& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGen* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGen* other);

  // implements Message ----------------------------------------------

  CSGen* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGen& from);
  void MergeFrom(const CSGen& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 Param1 = 3;
  inline bool has_param1() const;
  inline void clear_param1();
  static const int kParam1FieldNumber = 3;
  inline ::google::protobuf::uint32 param1() const;
  inline void set_param1(::google::protobuf::uint32 value);

  // required uint32 Param2 = 4;
  inline bool has_param2() const;
  inline void clear_param2();
  static const int kParam2FieldNumber = 4;
  inline ::google::protobuf::uint32 param2() const;
  inline void set_param2(::google::protobuf::uint32 value);

  // required uint32 Cnt = 5;
  inline bool has_cnt() const;
  inline void clear_cnt();
  static const int kCntFieldNumber = 5;
  inline ::google::protobuf::uint32 cnt() const;
  inline void set_cnt(::google::protobuf::uint32 value);

  // required uint32 CostCoin = 6;
  inline bool has_costcoin() const;
  inline void clear_costcoin();
  static const int kCostCoinFieldNumber = 6;
  inline ::google::protobuf::uint32 costcoin() const;
  inline void set_costcoin(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSGen)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_param1();
  inline void clear_has_param1();
  inline void set_has_param2();
  inline void clear_has_param2();
  inline void set_has_cnt();
  inline void clear_has_cnt();
  inline void set_has_costcoin();
  inline void clear_has_costcoin();

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 param1_;
  ::google::protobuf::uint32 param2_;
  ::google::protobuf::uint32 cnt_;
  ::google::protobuf::uint32 costcoin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSInfiniteMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSInfiniteMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSInfiniteMsg_2eproto();
  friend void protobuf_ShutdownFile_CSInfiniteMsg_2eproto();

  void InitAsDefaultInstance();
  static CSGen* default_instance_;
};
// -------------------------------------------------------------------

class CSInfiniteGenInfo : public ::google::protobuf::MessageLite {
 public:
  CSInfiniteGenInfo();
  virtual ~CSInfiniteGenInfo();

  CSInfiniteGenInfo(const CSInfiniteGenInfo& from);

  inline CSInfiniteGenInfo& operator=(const CSInfiniteGenInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSInfiniteGenInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSInfiniteGenInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSInfiniteGenInfo* other);

  // implements Message ----------------------------------------------

  CSInfiniteGenInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSInfiniteGenInfo& from);
  void MergeFrom(const CSInfiniteGenInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSGen Genlist = 1;
  inline int genlist_size() const;
  inline void clear_genlist();
  static const int kGenlistFieldNumber = 1;
  inline const ::vmsg::CSGen& genlist(int index) const;
  inline ::vmsg::CSGen* mutable_genlist(int index);
  inline ::vmsg::CSGen* add_genlist();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSGen >&
      genlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSGen >*
      mutable_genlist();

  // @@protoc_insertion_point(class_scope:vmsg.CSInfiniteGenInfo)
 private:

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSGen > genlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSInfiniteMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSInfiniteMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSInfiniteMsg_2eproto();
  friend void protobuf_ShutdownFile_CSInfiniteMsg_2eproto();

  void InitAsDefaultInstance();
  static CSInfiniteGenInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSInfiniteEndRsp : public ::google::protobuf::MessageLite {
 public:
  CSInfiniteEndRsp();
  virtual ~CSInfiniteEndRsp();

  CSInfiniteEndRsp(const CSInfiniteEndRsp& from);

  inline CSInfiniteEndRsp& operator=(const CSInfiniteEndRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSInfiniteEndRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSInfiniteEndRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSInfiniteEndRsp* other);

  // implements Message ----------------------------------------------

  CSInfiniteEndRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSInfiniteEndRsp& from);
  void MergeFrom(const CSInfiniteEndRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 MaxScore = 1;
  inline bool has_maxscore() const;
  inline void clear_maxscore();
  static const int kMaxScoreFieldNumber = 1;
  inline ::google::protobuf::uint64 maxscore() const;
  inline void set_maxscore(::google::protobuf::uint64 value);

  // repeated .vmsg.CSAwardElement AwardList = 2;
  inline int awardlist_size() const;
  inline void clear_awardlist();
  static const int kAwardListFieldNumber = 2;
  inline const ::vmsg::CSAwardElement& awardlist(int index) const;
  inline ::vmsg::CSAwardElement* mutable_awardlist(int index);
  inline ::vmsg::CSAwardElement* add_awardlist();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >&
      awardlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >*
      mutable_awardlist();

  // @@protoc_insertion_point(class_scope:vmsg.CSInfiniteEndRsp)
 private:
  inline void set_has_maxscore();
  inline void clear_has_maxscore();

  ::google::protobuf::uint64 maxscore_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement > awardlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSInfiniteMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSInfiniteMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSInfiniteMsg_2eproto();
  friend void protobuf_ShutdownFile_CSInfiniteMsg_2eproto();

  void InitAsDefaultInstance();
  static CSInfiniteEndRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSNothingLandStartRqst : public ::google::protobuf::MessageLite {
 public:
  CSNothingLandStartRqst();
  virtual ~CSNothingLandStartRqst();

  CSNothingLandStartRqst(const CSNothingLandStartRqst& from);

  inline CSNothingLandStartRqst& operator=(const CSNothingLandStartRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSNothingLandStartRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSNothingLandStartRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSNothingLandStartRqst* other);

  // implements Message ----------------------------------------------

  CSNothingLandStartRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSNothingLandStartRqst& from);
  void MergeFrom(const CSNothingLandStartRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 IsContinue = 1;
  inline bool has_iscontinue() const;
  inline void clear_iscontinue();
  static const int kIsContinueFieldNumber = 1;
  inline ::google::protobuf::uint32 iscontinue() const;
  inline void set_iscontinue(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSNothingLandStartRqst)
 private:
  inline void set_has_iscontinue();
  inline void clear_has_iscontinue();

  ::google::protobuf::uint32 iscontinue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSInfiniteMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSInfiniteMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSInfiniteMsg_2eproto();
  friend void protobuf_ShutdownFile_CSInfiniteMsg_2eproto();

  void InitAsDefaultInstance();
  static CSNothingLandStartRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSNothingLandEndRqst : public ::google::protobuf::MessageLite {
 public:
  CSNothingLandEndRqst();
  virtual ~CSNothingLandEndRqst();

  CSNothingLandEndRqst(const CSNothingLandEndRqst& from);

  inline CSNothingLandEndRqst& operator=(const CSNothingLandEndRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSNothingLandEndRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSNothingLandEndRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSNothingLandEndRqst* other);

  // implements Message ----------------------------------------------

  CSNothingLandEndRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSNothingLandEndRqst& from);
  void MergeFrom(const CSNothingLandEndRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Coin = 1;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 1;
  inline ::google::protobuf::uint32 coin() const;
  inline void set_coin(::google::protobuf::uint32 value);

  // repeated uint32 AwardFloor = 2;
  inline int awardfloor_size() const;
  inline void clear_awardfloor();
  static const int kAwardFloorFieldNumber = 2;
  inline ::google::protobuf::uint32 awardfloor(int index) const;
  inline void set_awardfloor(int index, ::google::protobuf::uint32 value);
  inline void add_awardfloor(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      awardfloor() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_awardfloor();

  // required uint32 Floor = 3;
  inline bool has_floor() const;
  inline void clear_floor();
  static const int kFloorFieldNumber = 3;
  inline ::google::protobuf::uint32 floor() const;
  inline void set_floor(::google::protobuf::uint32 value);

  // required uint32 Score = 4;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 4;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // required uint32 EvolutionCnt = 5;
  inline bool has_evolutioncnt() const;
  inline void clear_evolutioncnt();
  static const int kEvolutionCntFieldNumber = 5;
  inline ::google::protobuf::uint32 evolutioncnt() const;
  inline void set_evolutioncnt(::google::protobuf::uint32 value);

  // required uint32 FloorScore = 6;
  inline bool has_floorscore() const;
  inline void clear_floorscore();
  static const int kFloorScoreFieldNumber = 6;
  inline ::google::protobuf::uint32 floorscore() const;
  inline void set_floorscore(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSNothingLandEndRqst)
 private:
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_floor();
  inline void clear_has_floor();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_evolutioncnt();
  inline void clear_has_evolutioncnt();
  inline void set_has_floorscore();
  inline void clear_has_floorscore();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > awardfloor_;
  ::google::protobuf::uint32 coin_;
  ::google::protobuf::uint32 floor_;
  ::google::protobuf::uint32 score_;
  ::google::protobuf::uint32 evolutioncnt_;
  ::google::protobuf::uint32 floorscore_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSInfiniteMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSInfiniteMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSInfiniteMsg_2eproto();
  friend void protobuf_ShutdownFile_CSInfiniteMsg_2eproto();

  void InitAsDefaultInstance();
  static CSNothingLandEndRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSNothingLandEndRsp : public ::google::protobuf::MessageLite {
 public:
  CSNothingLandEndRsp();
  virtual ~CSNothingLandEndRsp();

  CSNothingLandEndRsp(const CSNothingLandEndRsp& from);

  inline CSNothingLandEndRsp& operator=(const CSNothingLandEndRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSNothingLandEndRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSNothingLandEndRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSNothingLandEndRsp* other);

  // implements Message ----------------------------------------------

  CSNothingLandEndRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSNothingLandEndRsp& from);
  void MergeFrom(const CSNothingLandEndRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSAwardElement AwardList = 1;
  inline int awardlist_size() const;
  inline void clear_awardlist();
  static const int kAwardListFieldNumber = 1;
  inline const ::vmsg::CSAwardElement& awardlist(int index) const;
  inline ::vmsg::CSAwardElement* mutable_awardlist(int index);
  inline ::vmsg::CSAwardElement* add_awardlist();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >&
      awardlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >*
      mutable_awardlist();

  // required uint32 MaxFloor = 2;
  inline bool has_maxfloor() const;
  inline void clear_maxfloor();
  static const int kMaxFloorFieldNumber = 2;
  inline ::google::protobuf::uint32 maxfloor() const;
  inline void set_maxfloor(::google::protobuf::uint32 value);

  // required uint32 MaxScore = 3;
  inline bool has_maxscore() const;
  inline void clear_maxscore();
  static const int kMaxScoreFieldNumber = 3;
  inline ::google::protobuf::uint32 maxscore() const;
  inline void set_maxscore(::google::protobuf::uint32 value);

  // required uint32 MaxFloorScore = 4;
  inline bool has_maxfloorscore() const;
  inline void clear_maxfloorscore();
  static const int kMaxFloorScoreFieldNumber = 4;
  inline ::google::protobuf::uint32 maxfloorscore() const;
  inline void set_maxfloorscore(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSNothingLandEndRsp)
 private:
  inline void set_has_maxfloor();
  inline void clear_has_maxfloor();
  inline void set_has_maxscore();
  inline void clear_has_maxscore();
  inline void set_has_maxfloorscore();
  inline void clear_has_maxfloorscore();

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement > awardlist_;
  ::google::protobuf::uint32 maxfloor_;
  ::google::protobuf::uint32 maxscore_;
  ::google::protobuf::uint32 maxfloorscore_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSInfiniteMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSInfiniteMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSInfiniteMsg_2eproto();
  friend void protobuf_ShutdownFile_CSInfiniteMsg_2eproto();

  void InitAsDefaultInstance();
  static CSNothingLandEndRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSNothingLandHistoryRsp : public ::google::protobuf::MessageLite {
 public:
  CSNothingLandHistoryRsp();
  virtual ~CSNothingLandHistoryRsp();

  CSNothingLandHistoryRsp(const CSNothingLandHistoryRsp& from);

  inline CSNothingLandHistoryRsp& operator=(const CSNothingLandHistoryRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSNothingLandHistoryRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSNothingLandHistoryRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSNothingLandHistoryRsp* other);

  // implements Message ----------------------------------------------

  CSNothingLandHistoryRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSNothingLandHistoryRsp& from);
  void MergeFrom(const CSNothingLandHistoryRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Coin = 1;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 1;
  inline ::google::protobuf::uint32 coin() const;
  inline void set_coin(::google::protobuf::uint32 value);

  // repeated uint32 AwardFloor = 2;
  inline int awardfloor_size() const;
  inline void clear_awardfloor();
  static const int kAwardFloorFieldNumber = 2;
  inline ::google::protobuf::uint32 awardfloor(int index) const;
  inline void set_awardfloor(int index, ::google::protobuf::uint32 value);
  inline void add_awardfloor(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      awardfloor() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_awardfloor();

  // required uint32 Floor = 3;
  inline bool has_floor() const;
  inline void clear_floor();
  static const int kFloorFieldNumber = 3;
  inline ::google::protobuf::uint32 floor() const;
  inline void set_floor(::google::protobuf::uint32 value);

  // required uint32 Score = 4;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 4;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // required uint32 EvolutionCnt = 5;
  inline bool has_evolutioncnt() const;
  inline void clear_evolutioncnt();
  static const int kEvolutionCntFieldNumber = 5;
  inline ::google::protobuf::uint32 evolutioncnt() const;
  inline void set_evolutioncnt(::google::protobuf::uint32 value);

  // required uint32 FloorScore = 6;
  inline bool has_floorscore() const;
  inline void clear_floorscore();
  static const int kFloorScoreFieldNumber = 6;
  inline ::google::protobuf::uint32 floorscore() const;
  inline void set_floorscore(::google::protobuf::uint32 value);

  // required uint32 BuyBulletCnt = 7;
  inline bool has_buybulletcnt() const;
  inline void clear_buybulletcnt();
  static const int kBuyBulletCntFieldNumber = 7;
  inline ::google::protobuf::uint32 buybulletcnt() const;
  inline void set_buybulletcnt(::google::protobuf::uint32 value);

  // required uint32 ReliveCnt = 8;
  inline bool has_relivecnt() const;
  inline void clear_relivecnt();
  static const int kReliveCntFieldNumber = 8;
  inline ::google::protobuf::uint32 relivecnt() const;
  inline void set_relivecnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSNothingLandHistoryRsp)
 private:
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_floor();
  inline void clear_has_floor();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_evolutioncnt();
  inline void clear_has_evolutioncnt();
  inline void set_has_floorscore();
  inline void clear_has_floorscore();
  inline void set_has_buybulletcnt();
  inline void clear_has_buybulletcnt();
  inline void set_has_relivecnt();
  inline void clear_has_relivecnt();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > awardfloor_;
  ::google::protobuf::uint32 coin_;
  ::google::protobuf::uint32 floor_;
  ::google::protobuf::uint32 score_;
  ::google::protobuf::uint32 evolutioncnt_;
  ::google::protobuf::uint32 floorscore_;
  ::google::protobuf::uint32 buybulletcnt_;
  ::google::protobuf::uint32 relivecnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSInfiniteMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSInfiniteMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSInfiniteMsg_2eproto();
  friend void protobuf_ShutdownFile_CSInfiniteMsg_2eproto();

  void InitAsDefaultInstance();
  static CSNothingLandHistoryRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSInfiniteRequest : public ::google::protobuf::MessageLite {
 public:
  CSInfiniteRequest();
  virtual ~CSInfiniteRequest();

  CSInfiniteRequest(const CSInfiniteRequest& from);

  inline CSInfiniteRequest& operator=(const CSInfiniteRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSInfiniteRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSInfiniteRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSInfiniteRequest* other);

  // implements Message ----------------------------------------------

  CSInfiniteRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSInfiniteRequest& from);
  void MergeFrom(const CSInfiniteRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSInfiniteEndRqst InfiniteEnd_Rqst = 1;
  inline bool has_infiniteend_rqst() const;
  inline void clear_infiniteend_rqst();
  static const int kInfiniteEndRqstFieldNumber = 1;
  inline const ::vmsg::CSInfiniteEndRqst& infiniteend_rqst() const;
  inline ::vmsg::CSInfiniteEndRqst* mutable_infiniteend_rqst();
  inline ::vmsg::CSInfiniteEndRqst* release_infiniteend_rqst();
  inline void set_allocated_infiniteend_rqst(::vmsg::CSInfiniteEndRqst* infiniteend_rqst);

  // optional .vmsg.CSInfiniteBuyGenRqst BuyGen_Rqst = 2;
  inline bool has_buygen_rqst() const;
  inline void clear_buygen_rqst();
  static const int kBuyGenRqstFieldNumber = 2;
  inline const ::vmsg::CSInfiniteBuyGenRqst& buygen_rqst() const;
  inline ::vmsg::CSInfiniteBuyGenRqst* mutable_buygen_rqst();
  inline ::vmsg::CSInfiniteBuyGenRqst* release_buygen_rqst();
  inline void set_allocated_buygen_rqst(::vmsg::CSInfiniteBuyGenRqst* buygen_rqst);

  // optional .vmsg.CSNothingLandStartRqst NothingLandStart_Rqst = 3;
  inline bool has_nothinglandstart_rqst() const;
  inline void clear_nothinglandstart_rqst();
  static const int kNothingLandStartRqstFieldNumber = 3;
  inline const ::vmsg::CSNothingLandStartRqst& nothinglandstart_rqst() const;
  inline ::vmsg::CSNothingLandStartRqst* mutable_nothinglandstart_rqst();
  inline ::vmsg::CSNothingLandStartRqst* release_nothinglandstart_rqst();
  inline void set_allocated_nothinglandstart_rqst(::vmsg::CSNothingLandStartRqst* nothinglandstart_rqst);

  // optional .vmsg.CSNothingLandEndRqst NothingLandEnd_Rqst = 4;
  inline bool has_nothinglandend_rqst() const;
  inline void clear_nothinglandend_rqst();
  static const int kNothingLandEndRqstFieldNumber = 4;
  inline const ::vmsg::CSNothingLandEndRqst& nothinglandend_rqst() const;
  inline ::vmsg::CSNothingLandEndRqst* mutable_nothinglandend_rqst();
  inline ::vmsg::CSNothingLandEndRqst* release_nothinglandend_rqst();
  inline void set_allocated_nothinglandend_rqst(::vmsg::CSNothingLandEndRqst* nothinglandend_rqst);

  // optional .vmsg.CSNothingLandEndRqst NothingLandMission_Report = 5;
  inline bool has_nothinglandmission_report() const;
  inline void clear_nothinglandmission_report();
  static const int kNothingLandMissionReportFieldNumber = 5;
  inline const ::vmsg::CSNothingLandEndRqst& nothinglandmission_report() const;
  inline ::vmsg::CSNothingLandEndRqst* mutable_nothinglandmission_report();
  inline ::vmsg::CSNothingLandEndRqst* release_nothinglandmission_report();
  inline void set_allocated_nothinglandmission_report(::vmsg::CSNothingLandEndRqst* nothinglandmission_report);

  // @@protoc_insertion_point(class_scope:vmsg.CSInfiniteRequest)
 private:
  inline void set_has_infiniteend_rqst();
  inline void clear_has_infiniteend_rqst();
  inline void set_has_buygen_rqst();
  inline void clear_has_buygen_rqst();
  inline void set_has_nothinglandstart_rqst();
  inline void clear_has_nothinglandstart_rqst();
  inline void set_has_nothinglandend_rqst();
  inline void clear_has_nothinglandend_rqst();
  inline void set_has_nothinglandmission_report();
  inline void clear_has_nothinglandmission_report();

  ::vmsg::CSInfiniteEndRqst* infiniteend_rqst_;
  ::vmsg::CSInfiniteBuyGenRqst* buygen_rqst_;
  ::vmsg::CSNothingLandStartRqst* nothinglandstart_rqst_;
  ::vmsg::CSNothingLandEndRqst* nothinglandend_rqst_;
  ::vmsg::CSNothingLandEndRqst* nothinglandmission_report_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSInfiniteMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSInfiniteMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSInfiniteMsg_2eproto();
  friend void protobuf_ShutdownFile_CSInfiniteMsg_2eproto();

  void InitAsDefaultInstance();
  static CSInfiniteRequest* default_instance_;
};
// -------------------------------------------------------------------

class CSInfiniteRespond : public ::google::protobuf::MessageLite {
 public:
  CSInfiniteRespond();
  virtual ~CSInfiniteRespond();

  CSInfiniteRespond(const CSInfiniteRespond& from);

  inline CSInfiniteRespond& operator=(const CSInfiniteRespond& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSInfiniteRespond& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSInfiniteRespond* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSInfiniteRespond* other);

  // implements Message ----------------------------------------------

  CSInfiniteRespond* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSInfiniteRespond& from);
  void MergeFrom(const CSInfiniteRespond& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSInfiniteEndRsp InfiniteEnd_Rsp = 1;
  inline bool has_infiniteend_rsp() const;
  inline void clear_infiniteend_rsp();
  static const int kInfiniteEndRspFieldNumber = 1;
  inline const ::vmsg::CSInfiniteEndRsp& infiniteend_rsp() const;
  inline ::vmsg::CSInfiniteEndRsp* mutable_infiniteend_rsp();
  inline ::vmsg::CSInfiniteEndRsp* release_infiniteend_rsp();
  inline void set_allocated_infiniteend_rsp(::vmsg::CSInfiniteEndRsp* infiniteend_rsp);

  // optional .vmsg.CSInfiniteGenInfo BuyGen_Rsp = 2;
  inline bool has_buygen_rsp() const;
  inline void clear_buygen_rsp();
  static const int kBuyGenRspFieldNumber = 2;
  inline const ::vmsg::CSInfiniteGenInfo& buygen_rsp() const;
  inline ::vmsg::CSInfiniteGenInfo* mutable_buygen_rsp();
  inline ::vmsg::CSInfiniteGenInfo* release_buygen_rsp();
  inline void set_allocated_buygen_rsp(::vmsg::CSInfiniteGenInfo* buygen_rsp);

  // optional .vmsg.CSInfiniteGenInfo InfiniteGenInfo_Rsp = 3;
  inline bool has_infinitegeninfo_rsp() const;
  inline void clear_infinitegeninfo_rsp();
  static const int kInfiniteGenInfoRspFieldNumber = 3;
  inline const ::vmsg::CSInfiniteGenInfo& infinitegeninfo_rsp() const;
  inline ::vmsg::CSInfiniteGenInfo* mutable_infinitegeninfo_rsp();
  inline ::vmsg::CSInfiniteGenInfo* release_infinitegeninfo_rsp();
  inline void set_allocated_infinitegeninfo_rsp(::vmsg::CSInfiniteGenInfo* infinitegeninfo_rsp);

  // optional .vmsg.CSNothingLandEndRsp NothingLandEnd_Rsp = 4;
  inline bool has_nothinglandend_rsp() const;
  inline void clear_nothinglandend_rsp();
  static const int kNothingLandEndRspFieldNumber = 4;
  inline const ::vmsg::CSNothingLandEndRsp& nothinglandend_rsp() const;
  inline ::vmsg::CSNothingLandEndRsp* mutable_nothinglandend_rsp();
  inline ::vmsg::CSNothingLandEndRsp* release_nothinglandend_rsp();
  inline void set_allocated_nothinglandend_rsp(::vmsg::CSNothingLandEndRsp* nothinglandend_rsp);

  // optional .vmsg.CSNothingLandHistoryRsp NothingLandHistory_Rsp = 5;
  inline bool has_nothinglandhistory_rsp() const;
  inline void clear_nothinglandhistory_rsp();
  static const int kNothingLandHistoryRspFieldNumber = 5;
  inline const ::vmsg::CSNothingLandHistoryRsp& nothinglandhistory_rsp() const;
  inline ::vmsg::CSNothingLandHistoryRsp* mutable_nothinglandhistory_rsp();
  inline ::vmsg::CSNothingLandHistoryRsp* release_nothinglandhistory_rsp();
  inline void set_allocated_nothinglandhistory_rsp(::vmsg::CSNothingLandHistoryRsp* nothinglandhistory_rsp);

  // @@protoc_insertion_point(class_scope:vmsg.CSInfiniteRespond)
 private:
  inline void set_has_infiniteend_rsp();
  inline void clear_has_infiniteend_rsp();
  inline void set_has_buygen_rsp();
  inline void clear_has_buygen_rsp();
  inline void set_has_infinitegeninfo_rsp();
  inline void clear_has_infinitegeninfo_rsp();
  inline void set_has_nothinglandend_rsp();
  inline void clear_has_nothinglandend_rsp();
  inline void set_has_nothinglandhistory_rsp();
  inline void clear_has_nothinglandhistory_rsp();

  ::vmsg::CSInfiniteEndRsp* infiniteend_rsp_;
  ::vmsg::CSInfiniteGenInfo* buygen_rsp_;
  ::vmsg::CSInfiniteGenInfo* infinitegeninfo_rsp_;
  ::vmsg::CSNothingLandEndRsp* nothinglandend_rsp_;
  ::vmsg::CSNothingLandHistoryRsp* nothinglandhistory_rsp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSInfiniteMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSInfiniteMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSInfiniteMsg_2eproto();
  friend void protobuf_ShutdownFile_CSInfiniteMsg_2eproto();

  void InitAsDefaultInstance();
  static CSInfiniteRespond* default_instance_;
};
// ===================================================================


// ===================================================================

// CSInfiniteEndRqst

// required uint64 Score = 1;
inline bool CSInfiniteEndRqst::has_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSInfiniteEndRqst::set_has_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSInfiniteEndRqst::clear_has_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSInfiniteEndRqst::clear_score() {
  score_ = GOOGLE_ULONGLONG(0);
  clear_has_score();
}
inline ::google::protobuf::uint64 CSInfiniteEndRqst::score() const {
  return score_;
}
inline void CSInfiniteEndRqst::set_score(::google::protobuf::uint64 value) {
  set_has_score();
  score_ = value;
}

// required uint32 PackageCnt = 2;
inline bool CSInfiniteEndRqst::has_packagecnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSInfiniteEndRqst::set_has_packagecnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSInfiniteEndRqst::clear_has_packagecnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSInfiniteEndRqst::clear_packagecnt() {
  packagecnt_ = 0u;
  clear_has_packagecnt();
}
inline ::google::protobuf::uint32 CSInfiniteEndRqst::packagecnt() const {
  return packagecnt_;
}
inline void CSInfiniteEndRqst::set_packagecnt(::google::protobuf::uint32 value) {
  set_has_packagecnt();
  packagecnt_ = value;
}

// required uint32 WaveCnt = 3;
inline bool CSInfiniteEndRqst::has_wavecnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSInfiniteEndRqst::set_has_wavecnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSInfiniteEndRqst::clear_has_wavecnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSInfiniteEndRqst::clear_wavecnt() {
  wavecnt_ = 0u;
  clear_has_wavecnt();
}
inline ::google::protobuf::uint32 CSInfiniteEndRqst::wavecnt() const {
  return wavecnt_;
}
inline void CSInfiniteEndRqst::set_wavecnt(::google::protobuf::uint32 value) {
  set_has_wavecnt();
  wavecnt_ = value;
}

// repeated uint32 MonsterCnt = 4;
inline int CSInfiniteEndRqst::monstercnt_size() const {
  return monstercnt_.size();
}
inline void CSInfiniteEndRqst::clear_monstercnt() {
  monstercnt_.Clear();
}
inline ::google::protobuf::uint32 CSInfiniteEndRqst::monstercnt(int index) const {
  return monstercnt_.Get(index);
}
inline void CSInfiniteEndRqst::set_monstercnt(int index, ::google::protobuf::uint32 value) {
  monstercnt_.Set(index, value);
}
inline void CSInfiniteEndRqst::add_monstercnt(::google::protobuf::uint32 value) {
  monstercnt_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSInfiniteEndRqst::monstercnt() const {
  return monstercnt_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSInfiniteEndRqst::mutable_monstercnt() {
  return &monstercnt_;
}

// required uint32 Coin = 5;
inline bool CSInfiniteEndRqst::has_coin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSInfiniteEndRqst::set_has_coin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSInfiniteEndRqst::clear_has_coin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSInfiniteEndRqst::clear_coin() {
  coin_ = 0u;
  clear_has_coin();
}
inline ::google::protobuf::uint32 CSInfiniteEndRqst::coin() const {
  return coin_;
}
inline void CSInfiniteEndRqst::set_coin(::google::protobuf::uint32 value) {
  set_has_coin();
  coin_ = value;
}

// required uint32 EvolutionCnt = 6;
inline bool CSInfiniteEndRqst::has_evolutioncnt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSInfiniteEndRqst::set_has_evolutioncnt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSInfiniteEndRqst::clear_has_evolutioncnt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSInfiniteEndRqst::clear_evolutioncnt() {
  evolutioncnt_ = 0u;
  clear_has_evolutioncnt();
}
inline ::google::protobuf::uint32 CSInfiniteEndRqst::evolutioncnt() const {
  return evolutioncnt_;
}
inline void CSInfiniteEndRqst::set_evolutioncnt(::google::protobuf::uint32 value) {
  set_has_evolutioncnt();
  evolutioncnt_ = value;
}

// -------------------------------------------------------------------

// CSInfiniteBuyGenRqst

// required uint32 Idx = 1;
inline bool CSInfiniteBuyGenRqst::has_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSInfiniteBuyGenRqst::set_has_idx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSInfiniteBuyGenRqst::clear_has_idx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSInfiniteBuyGenRqst::clear_idx() {
  idx_ = 0u;
  clear_has_idx();
}
inline ::google::protobuf::uint32 CSInfiniteBuyGenRqst::idx() const {
  return idx_;
}
inline void CSInfiniteBuyGenRqst::set_idx(::google::protobuf::uint32 value) {
  set_has_idx();
  idx_ = value;
}

// -------------------------------------------------------------------

// CSGen

// required uint32 Type = 2;
inline bool CSGen::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGen::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGen::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGen::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSGen::type() const {
  return type_;
}
inline void CSGen::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required uint32 Param1 = 3;
inline bool CSGen::has_param1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGen::set_has_param1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGen::clear_has_param1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGen::clear_param1() {
  param1_ = 0u;
  clear_has_param1();
}
inline ::google::protobuf::uint32 CSGen::param1() const {
  return param1_;
}
inline void CSGen::set_param1(::google::protobuf::uint32 value) {
  set_has_param1();
  param1_ = value;
}

// required uint32 Param2 = 4;
inline bool CSGen::has_param2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSGen::set_has_param2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSGen::clear_has_param2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSGen::clear_param2() {
  param2_ = 0u;
  clear_has_param2();
}
inline ::google::protobuf::uint32 CSGen::param2() const {
  return param2_;
}
inline void CSGen::set_param2(::google::protobuf::uint32 value) {
  set_has_param2();
  param2_ = value;
}

// required uint32 Cnt = 5;
inline bool CSGen::has_cnt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSGen::set_has_cnt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSGen::clear_has_cnt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSGen::clear_cnt() {
  cnt_ = 0u;
  clear_has_cnt();
}
inline ::google::protobuf::uint32 CSGen::cnt() const {
  return cnt_;
}
inline void CSGen::set_cnt(::google::protobuf::uint32 value) {
  set_has_cnt();
  cnt_ = value;
}

// required uint32 CostCoin = 6;
inline bool CSGen::has_costcoin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSGen::set_has_costcoin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSGen::clear_has_costcoin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSGen::clear_costcoin() {
  costcoin_ = 0u;
  clear_has_costcoin();
}
inline ::google::protobuf::uint32 CSGen::costcoin() const {
  return costcoin_;
}
inline void CSGen::set_costcoin(::google::protobuf::uint32 value) {
  set_has_costcoin();
  costcoin_ = value;
}

// -------------------------------------------------------------------

// CSInfiniteGenInfo

// repeated .vmsg.CSGen Genlist = 1;
inline int CSInfiniteGenInfo::genlist_size() const {
  return genlist_.size();
}
inline void CSInfiniteGenInfo::clear_genlist() {
  genlist_.Clear();
}
inline const ::vmsg::CSGen& CSInfiniteGenInfo::genlist(int index) const {
  return genlist_.Get(index);
}
inline ::vmsg::CSGen* CSInfiniteGenInfo::mutable_genlist(int index) {
  return genlist_.Mutable(index);
}
inline ::vmsg::CSGen* CSInfiniteGenInfo::add_genlist() {
  return genlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSGen >&
CSInfiniteGenInfo::genlist() const {
  return genlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSGen >*
CSInfiniteGenInfo::mutable_genlist() {
  return &genlist_;
}

// -------------------------------------------------------------------

// CSInfiniteEndRsp

// required uint64 MaxScore = 1;
inline bool CSInfiniteEndRsp::has_maxscore() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSInfiniteEndRsp::set_has_maxscore() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSInfiniteEndRsp::clear_has_maxscore() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSInfiniteEndRsp::clear_maxscore() {
  maxscore_ = GOOGLE_ULONGLONG(0);
  clear_has_maxscore();
}
inline ::google::protobuf::uint64 CSInfiniteEndRsp::maxscore() const {
  return maxscore_;
}
inline void CSInfiniteEndRsp::set_maxscore(::google::protobuf::uint64 value) {
  set_has_maxscore();
  maxscore_ = value;
}

// repeated .vmsg.CSAwardElement AwardList = 2;
inline int CSInfiniteEndRsp::awardlist_size() const {
  return awardlist_.size();
}
inline void CSInfiniteEndRsp::clear_awardlist() {
  awardlist_.Clear();
}
inline const ::vmsg::CSAwardElement& CSInfiniteEndRsp::awardlist(int index) const {
  return awardlist_.Get(index);
}
inline ::vmsg::CSAwardElement* CSInfiniteEndRsp::mutable_awardlist(int index) {
  return awardlist_.Mutable(index);
}
inline ::vmsg::CSAwardElement* CSInfiniteEndRsp::add_awardlist() {
  return awardlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >&
CSInfiniteEndRsp::awardlist() const {
  return awardlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >*
CSInfiniteEndRsp::mutable_awardlist() {
  return &awardlist_;
}

// -------------------------------------------------------------------

// CSNothingLandStartRqst

// required uint32 IsContinue = 1;
inline bool CSNothingLandStartRqst::has_iscontinue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSNothingLandStartRqst::set_has_iscontinue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSNothingLandStartRqst::clear_has_iscontinue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSNothingLandStartRqst::clear_iscontinue() {
  iscontinue_ = 0u;
  clear_has_iscontinue();
}
inline ::google::protobuf::uint32 CSNothingLandStartRqst::iscontinue() const {
  return iscontinue_;
}
inline void CSNothingLandStartRqst::set_iscontinue(::google::protobuf::uint32 value) {
  set_has_iscontinue();
  iscontinue_ = value;
}

// -------------------------------------------------------------------

// CSNothingLandEndRqst

// required uint32 Coin = 1;
inline bool CSNothingLandEndRqst::has_coin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSNothingLandEndRqst::set_has_coin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSNothingLandEndRqst::clear_has_coin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSNothingLandEndRqst::clear_coin() {
  coin_ = 0u;
  clear_has_coin();
}
inline ::google::protobuf::uint32 CSNothingLandEndRqst::coin() const {
  return coin_;
}
inline void CSNothingLandEndRqst::set_coin(::google::protobuf::uint32 value) {
  set_has_coin();
  coin_ = value;
}

// repeated uint32 AwardFloor = 2;
inline int CSNothingLandEndRqst::awardfloor_size() const {
  return awardfloor_.size();
}
inline void CSNothingLandEndRqst::clear_awardfloor() {
  awardfloor_.Clear();
}
inline ::google::protobuf::uint32 CSNothingLandEndRqst::awardfloor(int index) const {
  return awardfloor_.Get(index);
}
inline void CSNothingLandEndRqst::set_awardfloor(int index, ::google::protobuf::uint32 value) {
  awardfloor_.Set(index, value);
}
inline void CSNothingLandEndRqst::add_awardfloor(::google::protobuf::uint32 value) {
  awardfloor_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSNothingLandEndRqst::awardfloor() const {
  return awardfloor_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSNothingLandEndRqst::mutable_awardfloor() {
  return &awardfloor_;
}

// required uint32 Floor = 3;
inline bool CSNothingLandEndRqst::has_floor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSNothingLandEndRqst::set_has_floor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSNothingLandEndRqst::clear_has_floor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSNothingLandEndRqst::clear_floor() {
  floor_ = 0u;
  clear_has_floor();
}
inline ::google::protobuf::uint32 CSNothingLandEndRqst::floor() const {
  return floor_;
}
inline void CSNothingLandEndRqst::set_floor(::google::protobuf::uint32 value) {
  set_has_floor();
  floor_ = value;
}

// required uint32 Score = 4;
inline bool CSNothingLandEndRqst::has_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSNothingLandEndRqst::set_has_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSNothingLandEndRqst::clear_has_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSNothingLandEndRqst::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 CSNothingLandEndRqst::score() const {
  return score_;
}
inline void CSNothingLandEndRqst::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
}

// required uint32 EvolutionCnt = 5;
inline bool CSNothingLandEndRqst::has_evolutioncnt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSNothingLandEndRqst::set_has_evolutioncnt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSNothingLandEndRqst::clear_has_evolutioncnt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSNothingLandEndRqst::clear_evolutioncnt() {
  evolutioncnt_ = 0u;
  clear_has_evolutioncnt();
}
inline ::google::protobuf::uint32 CSNothingLandEndRqst::evolutioncnt() const {
  return evolutioncnt_;
}
inline void CSNothingLandEndRqst::set_evolutioncnt(::google::protobuf::uint32 value) {
  set_has_evolutioncnt();
  evolutioncnt_ = value;
}

// required uint32 FloorScore = 6;
inline bool CSNothingLandEndRqst::has_floorscore() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSNothingLandEndRqst::set_has_floorscore() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSNothingLandEndRqst::clear_has_floorscore() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSNothingLandEndRqst::clear_floorscore() {
  floorscore_ = 0u;
  clear_has_floorscore();
}
inline ::google::protobuf::uint32 CSNothingLandEndRqst::floorscore() const {
  return floorscore_;
}
inline void CSNothingLandEndRqst::set_floorscore(::google::protobuf::uint32 value) {
  set_has_floorscore();
  floorscore_ = value;
}

// -------------------------------------------------------------------

// CSNothingLandEndRsp

// repeated .vmsg.CSAwardElement AwardList = 1;
inline int CSNothingLandEndRsp::awardlist_size() const {
  return awardlist_.size();
}
inline void CSNothingLandEndRsp::clear_awardlist() {
  awardlist_.Clear();
}
inline const ::vmsg::CSAwardElement& CSNothingLandEndRsp::awardlist(int index) const {
  return awardlist_.Get(index);
}
inline ::vmsg::CSAwardElement* CSNothingLandEndRsp::mutable_awardlist(int index) {
  return awardlist_.Mutable(index);
}
inline ::vmsg::CSAwardElement* CSNothingLandEndRsp::add_awardlist() {
  return awardlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >&
CSNothingLandEndRsp::awardlist() const {
  return awardlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >*
CSNothingLandEndRsp::mutable_awardlist() {
  return &awardlist_;
}

// required uint32 MaxFloor = 2;
inline bool CSNothingLandEndRsp::has_maxfloor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSNothingLandEndRsp::set_has_maxfloor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSNothingLandEndRsp::clear_has_maxfloor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSNothingLandEndRsp::clear_maxfloor() {
  maxfloor_ = 0u;
  clear_has_maxfloor();
}
inline ::google::protobuf::uint32 CSNothingLandEndRsp::maxfloor() const {
  return maxfloor_;
}
inline void CSNothingLandEndRsp::set_maxfloor(::google::protobuf::uint32 value) {
  set_has_maxfloor();
  maxfloor_ = value;
}

// required uint32 MaxScore = 3;
inline bool CSNothingLandEndRsp::has_maxscore() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSNothingLandEndRsp::set_has_maxscore() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSNothingLandEndRsp::clear_has_maxscore() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSNothingLandEndRsp::clear_maxscore() {
  maxscore_ = 0u;
  clear_has_maxscore();
}
inline ::google::protobuf::uint32 CSNothingLandEndRsp::maxscore() const {
  return maxscore_;
}
inline void CSNothingLandEndRsp::set_maxscore(::google::protobuf::uint32 value) {
  set_has_maxscore();
  maxscore_ = value;
}

// required uint32 MaxFloorScore = 4;
inline bool CSNothingLandEndRsp::has_maxfloorscore() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSNothingLandEndRsp::set_has_maxfloorscore() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSNothingLandEndRsp::clear_has_maxfloorscore() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSNothingLandEndRsp::clear_maxfloorscore() {
  maxfloorscore_ = 0u;
  clear_has_maxfloorscore();
}
inline ::google::protobuf::uint32 CSNothingLandEndRsp::maxfloorscore() const {
  return maxfloorscore_;
}
inline void CSNothingLandEndRsp::set_maxfloorscore(::google::protobuf::uint32 value) {
  set_has_maxfloorscore();
  maxfloorscore_ = value;
}

// -------------------------------------------------------------------

// CSNothingLandHistoryRsp

// required uint32 Coin = 1;
inline bool CSNothingLandHistoryRsp::has_coin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSNothingLandHistoryRsp::set_has_coin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSNothingLandHistoryRsp::clear_has_coin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSNothingLandHistoryRsp::clear_coin() {
  coin_ = 0u;
  clear_has_coin();
}
inline ::google::protobuf::uint32 CSNothingLandHistoryRsp::coin() const {
  return coin_;
}
inline void CSNothingLandHistoryRsp::set_coin(::google::protobuf::uint32 value) {
  set_has_coin();
  coin_ = value;
}

// repeated uint32 AwardFloor = 2;
inline int CSNothingLandHistoryRsp::awardfloor_size() const {
  return awardfloor_.size();
}
inline void CSNothingLandHistoryRsp::clear_awardfloor() {
  awardfloor_.Clear();
}
inline ::google::protobuf::uint32 CSNothingLandHistoryRsp::awardfloor(int index) const {
  return awardfloor_.Get(index);
}
inline void CSNothingLandHistoryRsp::set_awardfloor(int index, ::google::protobuf::uint32 value) {
  awardfloor_.Set(index, value);
}
inline void CSNothingLandHistoryRsp::add_awardfloor(::google::protobuf::uint32 value) {
  awardfloor_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSNothingLandHistoryRsp::awardfloor() const {
  return awardfloor_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSNothingLandHistoryRsp::mutable_awardfloor() {
  return &awardfloor_;
}

// required uint32 Floor = 3;
inline bool CSNothingLandHistoryRsp::has_floor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSNothingLandHistoryRsp::set_has_floor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSNothingLandHistoryRsp::clear_has_floor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSNothingLandHistoryRsp::clear_floor() {
  floor_ = 0u;
  clear_has_floor();
}
inline ::google::protobuf::uint32 CSNothingLandHistoryRsp::floor() const {
  return floor_;
}
inline void CSNothingLandHistoryRsp::set_floor(::google::protobuf::uint32 value) {
  set_has_floor();
  floor_ = value;
}

// required uint32 Score = 4;
inline bool CSNothingLandHistoryRsp::has_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSNothingLandHistoryRsp::set_has_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSNothingLandHistoryRsp::clear_has_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSNothingLandHistoryRsp::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 CSNothingLandHistoryRsp::score() const {
  return score_;
}
inline void CSNothingLandHistoryRsp::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
}

// required uint32 EvolutionCnt = 5;
inline bool CSNothingLandHistoryRsp::has_evolutioncnt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSNothingLandHistoryRsp::set_has_evolutioncnt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSNothingLandHistoryRsp::clear_has_evolutioncnt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSNothingLandHistoryRsp::clear_evolutioncnt() {
  evolutioncnt_ = 0u;
  clear_has_evolutioncnt();
}
inline ::google::protobuf::uint32 CSNothingLandHistoryRsp::evolutioncnt() const {
  return evolutioncnt_;
}
inline void CSNothingLandHistoryRsp::set_evolutioncnt(::google::protobuf::uint32 value) {
  set_has_evolutioncnt();
  evolutioncnt_ = value;
}

// required uint32 FloorScore = 6;
inline bool CSNothingLandHistoryRsp::has_floorscore() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSNothingLandHistoryRsp::set_has_floorscore() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSNothingLandHistoryRsp::clear_has_floorscore() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSNothingLandHistoryRsp::clear_floorscore() {
  floorscore_ = 0u;
  clear_has_floorscore();
}
inline ::google::protobuf::uint32 CSNothingLandHistoryRsp::floorscore() const {
  return floorscore_;
}
inline void CSNothingLandHistoryRsp::set_floorscore(::google::protobuf::uint32 value) {
  set_has_floorscore();
  floorscore_ = value;
}

// required uint32 BuyBulletCnt = 7;
inline bool CSNothingLandHistoryRsp::has_buybulletcnt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSNothingLandHistoryRsp::set_has_buybulletcnt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSNothingLandHistoryRsp::clear_has_buybulletcnt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSNothingLandHistoryRsp::clear_buybulletcnt() {
  buybulletcnt_ = 0u;
  clear_has_buybulletcnt();
}
inline ::google::protobuf::uint32 CSNothingLandHistoryRsp::buybulletcnt() const {
  return buybulletcnt_;
}
inline void CSNothingLandHistoryRsp::set_buybulletcnt(::google::protobuf::uint32 value) {
  set_has_buybulletcnt();
  buybulletcnt_ = value;
}

// required uint32 ReliveCnt = 8;
inline bool CSNothingLandHistoryRsp::has_relivecnt() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSNothingLandHistoryRsp::set_has_relivecnt() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSNothingLandHistoryRsp::clear_has_relivecnt() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSNothingLandHistoryRsp::clear_relivecnt() {
  relivecnt_ = 0u;
  clear_has_relivecnt();
}
inline ::google::protobuf::uint32 CSNothingLandHistoryRsp::relivecnt() const {
  return relivecnt_;
}
inline void CSNothingLandHistoryRsp::set_relivecnt(::google::protobuf::uint32 value) {
  set_has_relivecnt();
  relivecnt_ = value;
}

// -------------------------------------------------------------------

// CSInfiniteRequest

// optional .vmsg.CSInfiniteEndRqst InfiniteEnd_Rqst = 1;
inline bool CSInfiniteRequest::has_infiniteend_rqst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSInfiniteRequest::set_has_infiniteend_rqst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSInfiniteRequest::clear_has_infiniteend_rqst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSInfiniteRequest::clear_infiniteend_rqst() {
  if (infiniteend_rqst_ != NULL) infiniteend_rqst_->::vmsg::CSInfiniteEndRqst::Clear();
  clear_has_infiniteend_rqst();
}
inline const ::vmsg::CSInfiniteEndRqst& CSInfiniteRequest::infiniteend_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return infiniteend_rqst_ != NULL ? *infiniteend_rqst_ : *default_instance().infiniteend_rqst_;
#else
  return infiniteend_rqst_ != NULL ? *infiniteend_rqst_ : *default_instance_->infiniteend_rqst_;
#endif
}
inline ::vmsg::CSInfiniteEndRqst* CSInfiniteRequest::mutable_infiniteend_rqst() {
  set_has_infiniteend_rqst();
  if (infiniteend_rqst_ == NULL) infiniteend_rqst_ = new ::vmsg::CSInfiniteEndRqst;
  return infiniteend_rqst_;
}
inline ::vmsg::CSInfiniteEndRqst* CSInfiniteRequest::release_infiniteend_rqst() {
  clear_has_infiniteend_rqst();
  ::vmsg::CSInfiniteEndRqst* temp = infiniteend_rqst_;
  infiniteend_rqst_ = NULL;
  return temp;
}
inline void CSInfiniteRequest::set_allocated_infiniteend_rqst(::vmsg::CSInfiniteEndRqst* infiniteend_rqst) {
  delete infiniteend_rqst_;
  infiniteend_rqst_ = infiniteend_rqst;
  if (infiniteend_rqst) {
    set_has_infiniteend_rqst();
  } else {
    clear_has_infiniteend_rqst();
  }
}

// optional .vmsg.CSInfiniteBuyGenRqst BuyGen_Rqst = 2;
inline bool CSInfiniteRequest::has_buygen_rqst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSInfiniteRequest::set_has_buygen_rqst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSInfiniteRequest::clear_has_buygen_rqst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSInfiniteRequest::clear_buygen_rqst() {
  if (buygen_rqst_ != NULL) buygen_rqst_->::vmsg::CSInfiniteBuyGenRqst::Clear();
  clear_has_buygen_rqst();
}
inline const ::vmsg::CSInfiniteBuyGenRqst& CSInfiniteRequest::buygen_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return buygen_rqst_ != NULL ? *buygen_rqst_ : *default_instance().buygen_rqst_;
#else
  return buygen_rqst_ != NULL ? *buygen_rqst_ : *default_instance_->buygen_rqst_;
#endif
}
inline ::vmsg::CSInfiniteBuyGenRqst* CSInfiniteRequest::mutable_buygen_rqst() {
  set_has_buygen_rqst();
  if (buygen_rqst_ == NULL) buygen_rqst_ = new ::vmsg::CSInfiniteBuyGenRqst;
  return buygen_rqst_;
}
inline ::vmsg::CSInfiniteBuyGenRqst* CSInfiniteRequest::release_buygen_rqst() {
  clear_has_buygen_rqst();
  ::vmsg::CSInfiniteBuyGenRqst* temp = buygen_rqst_;
  buygen_rqst_ = NULL;
  return temp;
}
inline void CSInfiniteRequest::set_allocated_buygen_rqst(::vmsg::CSInfiniteBuyGenRqst* buygen_rqst) {
  delete buygen_rqst_;
  buygen_rqst_ = buygen_rqst;
  if (buygen_rqst) {
    set_has_buygen_rqst();
  } else {
    clear_has_buygen_rqst();
  }
}

// optional .vmsg.CSNothingLandStartRqst NothingLandStart_Rqst = 3;
inline bool CSInfiniteRequest::has_nothinglandstart_rqst() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSInfiniteRequest::set_has_nothinglandstart_rqst() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSInfiniteRequest::clear_has_nothinglandstart_rqst() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSInfiniteRequest::clear_nothinglandstart_rqst() {
  if (nothinglandstart_rqst_ != NULL) nothinglandstart_rqst_->::vmsg::CSNothingLandStartRqst::Clear();
  clear_has_nothinglandstart_rqst();
}
inline const ::vmsg::CSNothingLandStartRqst& CSInfiniteRequest::nothinglandstart_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return nothinglandstart_rqst_ != NULL ? *nothinglandstart_rqst_ : *default_instance().nothinglandstart_rqst_;
#else
  return nothinglandstart_rqst_ != NULL ? *nothinglandstart_rqst_ : *default_instance_->nothinglandstart_rqst_;
#endif
}
inline ::vmsg::CSNothingLandStartRqst* CSInfiniteRequest::mutable_nothinglandstart_rqst() {
  set_has_nothinglandstart_rqst();
  if (nothinglandstart_rqst_ == NULL) nothinglandstart_rqst_ = new ::vmsg::CSNothingLandStartRqst;
  return nothinglandstart_rqst_;
}
inline ::vmsg::CSNothingLandStartRqst* CSInfiniteRequest::release_nothinglandstart_rqst() {
  clear_has_nothinglandstart_rqst();
  ::vmsg::CSNothingLandStartRqst* temp = nothinglandstart_rqst_;
  nothinglandstart_rqst_ = NULL;
  return temp;
}
inline void CSInfiniteRequest::set_allocated_nothinglandstart_rqst(::vmsg::CSNothingLandStartRqst* nothinglandstart_rqst) {
  delete nothinglandstart_rqst_;
  nothinglandstart_rqst_ = nothinglandstart_rqst;
  if (nothinglandstart_rqst) {
    set_has_nothinglandstart_rqst();
  } else {
    clear_has_nothinglandstart_rqst();
  }
}

// optional .vmsg.CSNothingLandEndRqst NothingLandEnd_Rqst = 4;
inline bool CSInfiniteRequest::has_nothinglandend_rqst() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSInfiniteRequest::set_has_nothinglandend_rqst() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSInfiniteRequest::clear_has_nothinglandend_rqst() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSInfiniteRequest::clear_nothinglandend_rqst() {
  if (nothinglandend_rqst_ != NULL) nothinglandend_rqst_->::vmsg::CSNothingLandEndRqst::Clear();
  clear_has_nothinglandend_rqst();
}
inline const ::vmsg::CSNothingLandEndRqst& CSInfiniteRequest::nothinglandend_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return nothinglandend_rqst_ != NULL ? *nothinglandend_rqst_ : *default_instance().nothinglandend_rqst_;
#else
  return nothinglandend_rqst_ != NULL ? *nothinglandend_rqst_ : *default_instance_->nothinglandend_rqst_;
#endif
}
inline ::vmsg::CSNothingLandEndRqst* CSInfiniteRequest::mutable_nothinglandend_rqst() {
  set_has_nothinglandend_rqst();
  if (nothinglandend_rqst_ == NULL) nothinglandend_rqst_ = new ::vmsg::CSNothingLandEndRqst;
  return nothinglandend_rqst_;
}
inline ::vmsg::CSNothingLandEndRqst* CSInfiniteRequest::release_nothinglandend_rqst() {
  clear_has_nothinglandend_rqst();
  ::vmsg::CSNothingLandEndRqst* temp = nothinglandend_rqst_;
  nothinglandend_rqst_ = NULL;
  return temp;
}
inline void CSInfiniteRequest::set_allocated_nothinglandend_rqst(::vmsg::CSNothingLandEndRqst* nothinglandend_rqst) {
  delete nothinglandend_rqst_;
  nothinglandend_rqst_ = nothinglandend_rqst;
  if (nothinglandend_rqst) {
    set_has_nothinglandend_rqst();
  } else {
    clear_has_nothinglandend_rqst();
  }
}

// optional .vmsg.CSNothingLandEndRqst NothingLandMission_Report = 5;
inline bool CSInfiniteRequest::has_nothinglandmission_report() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSInfiniteRequest::set_has_nothinglandmission_report() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSInfiniteRequest::clear_has_nothinglandmission_report() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSInfiniteRequest::clear_nothinglandmission_report() {
  if (nothinglandmission_report_ != NULL) nothinglandmission_report_->::vmsg::CSNothingLandEndRqst::Clear();
  clear_has_nothinglandmission_report();
}
inline const ::vmsg::CSNothingLandEndRqst& CSInfiniteRequest::nothinglandmission_report() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return nothinglandmission_report_ != NULL ? *nothinglandmission_report_ : *default_instance().nothinglandmission_report_;
#else
  return nothinglandmission_report_ != NULL ? *nothinglandmission_report_ : *default_instance_->nothinglandmission_report_;
#endif
}
inline ::vmsg::CSNothingLandEndRqst* CSInfiniteRequest::mutable_nothinglandmission_report() {
  set_has_nothinglandmission_report();
  if (nothinglandmission_report_ == NULL) nothinglandmission_report_ = new ::vmsg::CSNothingLandEndRqst;
  return nothinglandmission_report_;
}
inline ::vmsg::CSNothingLandEndRqst* CSInfiniteRequest::release_nothinglandmission_report() {
  clear_has_nothinglandmission_report();
  ::vmsg::CSNothingLandEndRqst* temp = nothinglandmission_report_;
  nothinglandmission_report_ = NULL;
  return temp;
}
inline void CSInfiniteRequest::set_allocated_nothinglandmission_report(::vmsg::CSNothingLandEndRqst* nothinglandmission_report) {
  delete nothinglandmission_report_;
  nothinglandmission_report_ = nothinglandmission_report;
  if (nothinglandmission_report) {
    set_has_nothinglandmission_report();
  } else {
    clear_has_nothinglandmission_report();
  }
}

// -------------------------------------------------------------------

// CSInfiniteRespond

// optional .vmsg.CSInfiniteEndRsp InfiniteEnd_Rsp = 1;
inline bool CSInfiniteRespond::has_infiniteend_rsp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSInfiniteRespond::set_has_infiniteend_rsp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSInfiniteRespond::clear_has_infiniteend_rsp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSInfiniteRespond::clear_infiniteend_rsp() {
  if (infiniteend_rsp_ != NULL) infiniteend_rsp_->::vmsg::CSInfiniteEndRsp::Clear();
  clear_has_infiniteend_rsp();
}
inline const ::vmsg::CSInfiniteEndRsp& CSInfiniteRespond::infiniteend_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return infiniteend_rsp_ != NULL ? *infiniteend_rsp_ : *default_instance().infiniteend_rsp_;
#else
  return infiniteend_rsp_ != NULL ? *infiniteend_rsp_ : *default_instance_->infiniteend_rsp_;
#endif
}
inline ::vmsg::CSInfiniteEndRsp* CSInfiniteRespond::mutable_infiniteend_rsp() {
  set_has_infiniteend_rsp();
  if (infiniteend_rsp_ == NULL) infiniteend_rsp_ = new ::vmsg::CSInfiniteEndRsp;
  return infiniteend_rsp_;
}
inline ::vmsg::CSInfiniteEndRsp* CSInfiniteRespond::release_infiniteend_rsp() {
  clear_has_infiniteend_rsp();
  ::vmsg::CSInfiniteEndRsp* temp = infiniteend_rsp_;
  infiniteend_rsp_ = NULL;
  return temp;
}
inline void CSInfiniteRespond::set_allocated_infiniteend_rsp(::vmsg::CSInfiniteEndRsp* infiniteend_rsp) {
  delete infiniteend_rsp_;
  infiniteend_rsp_ = infiniteend_rsp;
  if (infiniteend_rsp) {
    set_has_infiniteend_rsp();
  } else {
    clear_has_infiniteend_rsp();
  }
}

// optional .vmsg.CSInfiniteGenInfo BuyGen_Rsp = 2;
inline bool CSInfiniteRespond::has_buygen_rsp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSInfiniteRespond::set_has_buygen_rsp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSInfiniteRespond::clear_has_buygen_rsp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSInfiniteRespond::clear_buygen_rsp() {
  if (buygen_rsp_ != NULL) buygen_rsp_->::vmsg::CSInfiniteGenInfo::Clear();
  clear_has_buygen_rsp();
}
inline const ::vmsg::CSInfiniteGenInfo& CSInfiniteRespond::buygen_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return buygen_rsp_ != NULL ? *buygen_rsp_ : *default_instance().buygen_rsp_;
#else
  return buygen_rsp_ != NULL ? *buygen_rsp_ : *default_instance_->buygen_rsp_;
#endif
}
inline ::vmsg::CSInfiniteGenInfo* CSInfiniteRespond::mutable_buygen_rsp() {
  set_has_buygen_rsp();
  if (buygen_rsp_ == NULL) buygen_rsp_ = new ::vmsg::CSInfiniteGenInfo;
  return buygen_rsp_;
}
inline ::vmsg::CSInfiniteGenInfo* CSInfiniteRespond::release_buygen_rsp() {
  clear_has_buygen_rsp();
  ::vmsg::CSInfiniteGenInfo* temp = buygen_rsp_;
  buygen_rsp_ = NULL;
  return temp;
}
inline void CSInfiniteRespond::set_allocated_buygen_rsp(::vmsg::CSInfiniteGenInfo* buygen_rsp) {
  delete buygen_rsp_;
  buygen_rsp_ = buygen_rsp;
  if (buygen_rsp) {
    set_has_buygen_rsp();
  } else {
    clear_has_buygen_rsp();
  }
}

// optional .vmsg.CSInfiniteGenInfo InfiniteGenInfo_Rsp = 3;
inline bool CSInfiniteRespond::has_infinitegeninfo_rsp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSInfiniteRespond::set_has_infinitegeninfo_rsp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSInfiniteRespond::clear_has_infinitegeninfo_rsp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSInfiniteRespond::clear_infinitegeninfo_rsp() {
  if (infinitegeninfo_rsp_ != NULL) infinitegeninfo_rsp_->::vmsg::CSInfiniteGenInfo::Clear();
  clear_has_infinitegeninfo_rsp();
}
inline const ::vmsg::CSInfiniteGenInfo& CSInfiniteRespond::infinitegeninfo_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return infinitegeninfo_rsp_ != NULL ? *infinitegeninfo_rsp_ : *default_instance().infinitegeninfo_rsp_;
#else
  return infinitegeninfo_rsp_ != NULL ? *infinitegeninfo_rsp_ : *default_instance_->infinitegeninfo_rsp_;
#endif
}
inline ::vmsg::CSInfiniteGenInfo* CSInfiniteRespond::mutable_infinitegeninfo_rsp() {
  set_has_infinitegeninfo_rsp();
  if (infinitegeninfo_rsp_ == NULL) infinitegeninfo_rsp_ = new ::vmsg::CSInfiniteGenInfo;
  return infinitegeninfo_rsp_;
}
inline ::vmsg::CSInfiniteGenInfo* CSInfiniteRespond::release_infinitegeninfo_rsp() {
  clear_has_infinitegeninfo_rsp();
  ::vmsg::CSInfiniteGenInfo* temp = infinitegeninfo_rsp_;
  infinitegeninfo_rsp_ = NULL;
  return temp;
}
inline void CSInfiniteRespond::set_allocated_infinitegeninfo_rsp(::vmsg::CSInfiniteGenInfo* infinitegeninfo_rsp) {
  delete infinitegeninfo_rsp_;
  infinitegeninfo_rsp_ = infinitegeninfo_rsp;
  if (infinitegeninfo_rsp) {
    set_has_infinitegeninfo_rsp();
  } else {
    clear_has_infinitegeninfo_rsp();
  }
}

// optional .vmsg.CSNothingLandEndRsp NothingLandEnd_Rsp = 4;
inline bool CSInfiniteRespond::has_nothinglandend_rsp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSInfiniteRespond::set_has_nothinglandend_rsp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSInfiniteRespond::clear_has_nothinglandend_rsp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSInfiniteRespond::clear_nothinglandend_rsp() {
  if (nothinglandend_rsp_ != NULL) nothinglandend_rsp_->::vmsg::CSNothingLandEndRsp::Clear();
  clear_has_nothinglandend_rsp();
}
inline const ::vmsg::CSNothingLandEndRsp& CSInfiniteRespond::nothinglandend_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return nothinglandend_rsp_ != NULL ? *nothinglandend_rsp_ : *default_instance().nothinglandend_rsp_;
#else
  return nothinglandend_rsp_ != NULL ? *nothinglandend_rsp_ : *default_instance_->nothinglandend_rsp_;
#endif
}
inline ::vmsg::CSNothingLandEndRsp* CSInfiniteRespond::mutable_nothinglandend_rsp() {
  set_has_nothinglandend_rsp();
  if (nothinglandend_rsp_ == NULL) nothinglandend_rsp_ = new ::vmsg::CSNothingLandEndRsp;
  return nothinglandend_rsp_;
}
inline ::vmsg::CSNothingLandEndRsp* CSInfiniteRespond::release_nothinglandend_rsp() {
  clear_has_nothinglandend_rsp();
  ::vmsg::CSNothingLandEndRsp* temp = nothinglandend_rsp_;
  nothinglandend_rsp_ = NULL;
  return temp;
}
inline void CSInfiniteRespond::set_allocated_nothinglandend_rsp(::vmsg::CSNothingLandEndRsp* nothinglandend_rsp) {
  delete nothinglandend_rsp_;
  nothinglandend_rsp_ = nothinglandend_rsp;
  if (nothinglandend_rsp) {
    set_has_nothinglandend_rsp();
  } else {
    clear_has_nothinglandend_rsp();
  }
}

// optional .vmsg.CSNothingLandHistoryRsp NothingLandHistory_Rsp = 5;
inline bool CSInfiniteRespond::has_nothinglandhistory_rsp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSInfiniteRespond::set_has_nothinglandhistory_rsp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSInfiniteRespond::clear_has_nothinglandhistory_rsp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSInfiniteRespond::clear_nothinglandhistory_rsp() {
  if (nothinglandhistory_rsp_ != NULL) nothinglandhistory_rsp_->::vmsg::CSNothingLandHistoryRsp::Clear();
  clear_has_nothinglandhistory_rsp();
}
inline const ::vmsg::CSNothingLandHistoryRsp& CSInfiniteRespond::nothinglandhistory_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return nothinglandhistory_rsp_ != NULL ? *nothinglandhistory_rsp_ : *default_instance().nothinglandhistory_rsp_;
#else
  return nothinglandhistory_rsp_ != NULL ? *nothinglandhistory_rsp_ : *default_instance_->nothinglandhistory_rsp_;
#endif
}
inline ::vmsg::CSNothingLandHistoryRsp* CSInfiniteRespond::mutable_nothinglandhistory_rsp() {
  set_has_nothinglandhistory_rsp();
  if (nothinglandhistory_rsp_ == NULL) nothinglandhistory_rsp_ = new ::vmsg::CSNothingLandHistoryRsp;
  return nothinglandhistory_rsp_;
}
inline ::vmsg::CSNothingLandHistoryRsp* CSInfiniteRespond::release_nothinglandhistory_rsp() {
  clear_has_nothinglandhistory_rsp();
  ::vmsg::CSNothingLandHistoryRsp* temp = nothinglandhistory_rsp_;
  nothinglandhistory_rsp_ = NULL;
  return temp;
}
inline void CSInfiniteRespond::set_allocated_nothinglandhistory_rsp(::vmsg::CSNothingLandHistoryRsp* nothinglandhistory_rsp) {
  delete nothinglandhistory_rsp_;
  nothinglandhistory_rsp_ = nothinglandhistory_rsp;
  if (nothinglandhistory_rsp) {
    set_has_nothinglandhistory_rsp();
  } else {
    clear_has_nothinglandhistory_rsp();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CSInfiniteMsg_2eproto__INCLUDED
