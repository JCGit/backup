// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSBagMsg.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "CSBagMsg.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace vmsg {

void protobuf_ShutdownFile_CSBagMsg_2eproto() {
  delete CSBagCellInfo::default_instance_;
  delete CSBagInfo::default_instance_;
  delete CSQueryBagInfoRqst::default_instance_;
  delete CSQueryBagInfoRsp::default_instance_;
  delete CSBagInfoNotify::default_instance_;
  delete CSWearEquipRqst::default_instance_;
  delete CSWearEquipRsp::default_instance_;
  delete CSEnlargeRqst::default_instance_;
  delete CSEnlargeRsp::default_instance_;
  delete CSTakeOffEquipRqst::default_instance_;
  delete CSTakeOffEquipRsp::default_instance_;
  delete CSBagSellRqst::default_instance_;
  delete CSBagSellRsp::default_instance_;
  delete CSBagStatNotify::default_instance_;
  delete CSBuyItemRqst::default_instance_;
  delete CSBuyItemRsp::default_instance_;
  delete CSConsumeItemRqst::default_instance_;
  delete CSConsumeItemRsp::default_instance_;
  delete CSBagRequest::default_instance_;
  delete CSBagRespond::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_CSBagMsg_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_CSBagMsg_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::vmsg::protobuf_AddDesc_MsgBase_2eproto();
  ::vmsg::protobuf_AddDesc_ShareByClient_2eproto();
  ::vmsg::protobuf_AddDesc_CSPlayerMsg_2eproto();
  ::vmsg::protobuf_AddDesc_CSEquipItemMsg_2eproto();
  CSBagCellInfo::default_instance_ = new CSBagCellInfo();
  CSBagInfo::default_instance_ = new CSBagInfo();
  CSQueryBagInfoRqst::default_instance_ = new CSQueryBagInfoRqst();
  CSQueryBagInfoRsp::default_instance_ = new CSQueryBagInfoRsp();
  CSBagInfoNotify::default_instance_ = new CSBagInfoNotify();
  CSWearEquipRqst::default_instance_ = new CSWearEquipRqst();
  CSWearEquipRsp::default_instance_ = new CSWearEquipRsp();
  CSEnlargeRqst::default_instance_ = new CSEnlargeRqst();
  CSEnlargeRsp::default_instance_ = new CSEnlargeRsp();
  CSTakeOffEquipRqst::default_instance_ = new CSTakeOffEquipRqst();
  CSTakeOffEquipRsp::default_instance_ = new CSTakeOffEquipRsp();
  CSBagSellRqst::default_instance_ = new CSBagSellRqst();
  CSBagSellRsp::default_instance_ = new CSBagSellRsp();
  CSBagStatNotify::default_instance_ = new CSBagStatNotify();
  CSBuyItemRqst::default_instance_ = new CSBuyItemRqst();
  CSBuyItemRsp::default_instance_ = new CSBuyItemRsp();
  CSConsumeItemRqst::default_instance_ = new CSConsumeItemRqst();
  CSConsumeItemRsp::default_instance_ = new CSConsumeItemRsp();
  CSBagRequest::default_instance_ = new CSBagRequest();
  CSBagRespond::default_instance_ = new CSBagRespond();
  CSBagCellInfo::default_instance_->InitAsDefaultInstance();
  CSBagInfo::default_instance_->InitAsDefaultInstance();
  CSQueryBagInfoRqst::default_instance_->InitAsDefaultInstance();
  CSQueryBagInfoRsp::default_instance_->InitAsDefaultInstance();
  CSBagInfoNotify::default_instance_->InitAsDefaultInstance();
  CSWearEquipRqst::default_instance_->InitAsDefaultInstance();
  CSWearEquipRsp::default_instance_->InitAsDefaultInstance();
  CSEnlargeRqst::default_instance_->InitAsDefaultInstance();
  CSEnlargeRsp::default_instance_->InitAsDefaultInstance();
  CSTakeOffEquipRqst::default_instance_->InitAsDefaultInstance();
  CSTakeOffEquipRsp::default_instance_->InitAsDefaultInstance();
  CSBagSellRqst::default_instance_->InitAsDefaultInstance();
  CSBagSellRsp::default_instance_->InitAsDefaultInstance();
  CSBagStatNotify::default_instance_->InitAsDefaultInstance();
  CSBuyItemRqst::default_instance_->InitAsDefaultInstance();
  CSBuyItemRsp::default_instance_->InitAsDefaultInstance();
  CSConsumeItemRqst::default_instance_->InitAsDefaultInstance();
  CSConsumeItemRsp::default_instance_->InitAsDefaultInstance();
  CSBagRequest::default_instance_->InitAsDefaultInstance();
  CSBagRespond::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_CSBagMsg_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_CSBagMsg_2eproto_once_);
void protobuf_AddDesc_CSBagMsg_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_CSBagMsg_2eproto_once_,
                 &protobuf_AddDesc_CSBagMsg_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_CSBagMsg_2eproto {
  StaticDescriptorInitializer_CSBagMsg_2eproto() {
    protobuf_AddDesc_CSBagMsg_2eproto();
  }
} static_descriptor_initializer_CSBagMsg_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int CSBagCellInfo::kIndexFieldNumber;
const int CSBagCellInfo::kTypeFieldNumber;
const int CSBagCellInfo::kEquipInfoFieldNumber;
const int CSBagCellInfo::kItemInfoFieldNumber;
#endif  // !_MSC_VER

CSBagCellInfo::CSBagCellInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSBagCellInfo::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  equipinfo_ = const_cast< ::vmsg::CSEquipInfo*>(
      ::vmsg::CSEquipInfo::internal_default_instance());
#else
  equipinfo_ = const_cast< ::vmsg::CSEquipInfo*>(&::vmsg::CSEquipInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  iteminfo_ = const_cast< ::vmsg::CSItemInfo*>(
      ::vmsg::CSItemInfo::internal_default_instance());
#else
  iteminfo_ = const_cast< ::vmsg::CSItemInfo*>(&::vmsg::CSItemInfo::default_instance());
#endif
}

CSBagCellInfo::CSBagCellInfo(const CSBagCellInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSBagCellInfo::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0;
  type_ = 0u;
  equipinfo_ = NULL;
  iteminfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSBagCellInfo::~CSBagCellInfo() {
  SharedDtor();
}

void CSBagCellInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete equipinfo_;
    delete iteminfo_;
  }
}

void CSBagCellInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSBagCellInfo& CSBagCellInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSBagMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSBagMsg_2eproto();
#endif
  return *default_instance_;
}

CSBagCellInfo* CSBagCellInfo::default_instance_ = NULL;

CSBagCellInfo* CSBagCellInfo::New() const {
  return new CSBagCellInfo;
}

void CSBagCellInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    index_ = 0;
    type_ = 0u;
    if (has_equipinfo()) {
      if (equipinfo_ != NULL) equipinfo_->::vmsg::CSEquipInfo::Clear();
    }
    if (has_iteminfo()) {
      if (iteminfo_ != NULL) iteminfo_->::vmsg::CSItemInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSBagCellInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 Index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_Type;
        break;
      }

      // required uint32 Type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_EquipInfo;
        break;
      }

      // optional .vmsg.CSEquipInfo EquipInfo = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_EquipInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_equipinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_ItemInfo;
        break;
      }

      // optional .vmsg.CSItemInfo ItemInfo = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ItemInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_iteminfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSBagCellInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 Index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }

  // required uint32 Type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->type(), output);
  }

  // optional .vmsg.CSEquipInfo EquipInfo = 3;
  if (has_equipinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->equipinfo(), output);
  }

  // optional .vmsg.CSItemInfo ItemInfo = 4;
  if (has_iteminfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->iteminfo(), output);
  }

}

int CSBagCellInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 Index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // required uint32 Type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // optional .vmsg.CSEquipInfo EquipInfo = 3;
    if (has_equipinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->equipinfo());
    }

    // optional .vmsg.CSItemInfo ItemInfo = 4;
    if (has_iteminfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->iteminfo());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSBagCellInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSBagCellInfo*>(&from));
}

void CSBagCellInfo::MergeFrom(const CSBagCellInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_equipinfo()) {
      mutable_equipinfo()->::vmsg::CSEquipInfo::MergeFrom(from.equipinfo());
    }
    if (from.has_iteminfo()) {
      mutable_iteminfo()->::vmsg::CSItemInfo::MergeFrom(from.iteminfo());
    }
  }
}

void CSBagCellInfo::CopyFrom(const CSBagCellInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSBagCellInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_equipinfo()) {
    if (!this->equipinfo().IsInitialized()) return false;
  }
  if (has_iteminfo()) {
    if (!this->iteminfo().IsInitialized()) return false;
  }
  return true;
}

void CSBagCellInfo::Swap(CSBagCellInfo* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(type_, other->type_);
    std::swap(equipinfo_, other->equipinfo_);
    std::swap(iteminfo_, other->iteminfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSBagCellInfo::GetTypeName() const {
  return "vmsg.CSBagCellInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CSBagInfo::kCapacityFieldNumber;
const int CSBagInfo::kCellLstFieldNumber;
#endif  // !_MSC_VER

CSBagInfo::CSBagInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSBagInfo::InitAsDefaultInstance() {
}

CSBagInfo::CSBagInfo(const CSBagInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSBagInfo::SharedCtor() {
  _cached_size_ = 0;
  capacity_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSBagInfo::~CSBagInfo() {
  SharedDtor();
}

void CSBagInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSBagInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSBagInfo& CSBagInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSBagMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSBagMsg_2eproto();
#endif
  return *default_instance_;
}

CSBagInfo* CSBagInfo::default_instance_ = NULL;

CSBagInfo* CSBagInfo::New() const {
  return new CSBagInfo;
}

void CSBagInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    capacity_ = 0u;
  }
  celllst_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSBagInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Capacity = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &capacity_)));
          set_has_capacity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_CellLst;
        break;
      }

      // repeated .vmsg.CSBagCellInfo CellLst = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_CellLst:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_celllst()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_CellLst;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSBagInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 Capacity = 1;
  if (has_capacity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->capacity(), output);
  }

  // repeated .vmsg.CSBagCellInfo CellLst = 2;
  for (int i = 0; i < this->celllst_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->celllst(i), output);
  }

}

int CSBagInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Capacity = 1;
    if (has_capacity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->capacity());
    }

  }
  // repeated .vmsg.CSBagCellInfo CellLst = 2;
  total_size += 1 * this->celllst_size();
  for (int i = 0; i < this->celllst_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->celllst(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSBagInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSBagInfo*>(&from));
}

void CSBagInfo::MergeFrom(const CSBagInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  celllst_.MergeFrom(from.celllst_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_capacity()) {
      set_capacity(from.capacity());
    }
  }
}

void CSBagInfo::CopyFrom(const CSBagInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSBagInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < celllst_size(); i++) {
    if (!this->celllst(i).IsInitialized()) return false;
  }
  return true;
}

void CSBagInfo::Swap(CSBagInfo* other) {
  if (other != this) {
    std::swap(capacity_, other->capacity_);
    celllst_.Swap(&other->celllst_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSBagInfo::GetTypeName() const {
  return "vmsg.CSBagInfo";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CSQueryBagInfoRqst::CSQueryBagInfoRqst()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSQueryBagInfoRqst::InitAsDefaultInstance() {
}

CSQueryBagInfoRqst::CSQueryBagInfoRqst(const CSQueryBagInfoRqst& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSQueryBagInfoRqst::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSQueryBagInfoRqst::~CSQueryBagInfoRqst() {
  SharedDtor();
}

void CSQueryBagInfoRqst::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSQueryBagInfoRqst::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSQueryBagInfoRqst& CSQueryBagInfoRqst::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSBagMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSBagMsg_2eproto();
#endif
  return *default_instance_;
}

CSQueryBagInfoRqst* CSQueryBagInfoRqst::default_instance_ = NULL;

CSQueryBagInfoRqst* CSQueryBagInfoRqst::New() const {
  return new CSQueryBagInfoRqst;
}

void CSQueryBagInfoRqst::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSQueryBagInfoRqst::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
  return true;
#undef DO_
}

void CSQueryBagInfoRqst::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int CSQueryBagInfoRqst::ByteSize() const {
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSQueryBagInfoRqst::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSQueryBagInfoRqst*>(&from));
}

void CSQueryBagInfoRqst::MergeFrom(const CSQueryBagInfoRqst& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void CSQueryBagInfoRqst::CopyFrom(const CSQueryBagInfoRqst& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSQueryBagInfoRqst::IsInitialized() const {

  return true;
}

void CSQueryBagInfoRqst::Swap(CSQueryBagInfoRqst* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSQueryBagInfoRqst::GetTypeName() const {
  return "vmsg.CSQueryBagInfoRqst";
}


// ===================================================================

#ifndef _MSC_VER
const int CSQueryBagInfoRsp::kBagInfoFieldNumber;
#endif  // !_MSC_VER

CSQueryBagInfoRsp::CSQueryBagInfoRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSQueryBagInfoRsp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  baginfo_ = const_cast< ::vmsg::CSBagInfo*>(
      ::vmsg::CSBagInfo::internal_default_instance());
#else
  baginfo_ = const_cast< ::vmsg::CSBagInfo*>(&::vmsg::CSBagInfo::default_instance());
#endif
}

CSQueryBagInfoRsp::CSQueryBagInfoRsp(const CSQueryBagInfoRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSQueryBagInfoRsp::SharedCtor() {
  _cached_size_ = 0;
  baginfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSQueryBagInfoRsp::~CSQueryBagInfoRsp() {
  SharedDtor();
}

void CSQueryBagInfoRsp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete baginfo_;
  }
}

void CSQueryBagInfoRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSQueryBagInfoRsp& CSQueryBagInfoRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSBagMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSBagMsg_2eproto();
#endif
  return *default_instance_;
}

CSQueryBagInfoRsp* CSQueryBagInfoRsp::default_instance_ = NULL;

CSQueryBagInfoRsp* CSQueryBagInfoRsp::New() const {
  return new CSQueryBagInfoRsp;
}

void CSQueryBagInfoRsp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_baginfo()) {
      if (baginfo_ != NULL) baginfo_->::vmsg::CSBagInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSQueryBagInfoRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vmsg.CSBagInfo BagInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_baginfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSQueryBagInfoRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .vmsg.CSBagInfo BagInfo = 1;
  if (has_baginfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->baginfo(), output);
  }

}

int CSQueryBagInfoRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .vmsg.CSBagInfo BagInfo = 1;
    if (has_baginfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->baginfo());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSQueryBagInfoRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSQueryBagInfoRsp*>(&from));
}

void CSQueryBagInfoRsp::MergeFrom(const CSQueryBagInfoRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_baginfo()) {
      mutable_baginfo()->::vmsg::CSBagInfo::MergeFrom(from.baginfo());
    }
  }
}

void CSQueryBagInfoRsp::CopyFrom(const CSQueryBagInfoRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSQueryBagInfoRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_baginfo()) {
    if (!this->baginfo().IsInitialized()) return false;
  }
  return true;
}

void CSQueryBagInfoRsp::Swap(CSQueryBagInfoRsp* other) {
  if (other != this) {
    std::swap(baginfo_, other->baginfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSQueryBagInfoRsp::GetTypeName() const {
  return "vmsg.CSQueryBagInfoRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSBagInfoNotify::kPkgIDFieldNumber;
const int CSBagInfoNotify::kBagInfoFieldNumber;
#endif  // !_MSC_VER

CSBagInfoNotify::CSBagInfoNotify()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSBagInfoNotify::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  baginfo_ = const_cast< ::vmsg::CSBagInfo*>(
      ::vmsg::CSBagInfo::internal_default_instance());
#else
  baginfo_ = const_cast< ::vmsg::CSBagInfo*>(&::vmsg::CSBagInfo::default_instance());
#endif
}

CSBagInfoNotify::CSBagInfoNotify(const CSBagInfoNotify& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSBagInfoNotify::SharedCtor() {
  _cached_size_ = 0;
  pkgid_ = 0u;
  baginfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSBagInfoNotify::~CSBagInfoNotify() {
  SharedDtor();
}

void CSBagInfoNotify::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete baginfo_;
  }
}

void CSBagInfoNotify::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSBagInfoNotify& CSBagInfoNotify::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSBagMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSBagMsg_2eproto();
#endif
  return *default_instance_;
}

CSBagInfoNotify* CSBagInfoNotify::default_instance_ = NULL;

CSBagInfoNotify* CSBagInfoNotify::New() const {
  return new CSBagInfoNotify;
}

void CSBagInfoNotify::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pkgid_ = 0u;
    if (has_baginfo()) {
      if (baginfo_ != NULL) baginfo_->::vmsg::CSBagInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSBagInfoNotify::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 PkgID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &pkgid_)));
          set_has_pkgid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_BagInfo;
        break;
      }

      // required .vmsg.CSBagInfo BagInfo = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BagInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_baginfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSBagInfoNotify::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 PkgID = 1;
  if (has_pkgid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->pkgid(), output);
  }

  // required .vmsg.CSBagInfo BagInfo = 2;
  if (has_baginfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->baginfo(), output);
  }

}

int CSBagInfoNotify::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 PkgID = 1;
    if (has_pkgid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->pkgid());
    }

    // required .vmsg.CSBagInfo BagInfo = 2;
    if (has_baginfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->baginfo());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSBagInfoNotify::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSBagInfoNotify*>(&from));
}

void CSBagInfoNotify::MergeFrom(const CSBagInfoNotify& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pkgid()) {
      set_pkgid(from.pkgid());
    }
    if (from.has_baginfo()) {
      mutable_baginfo()->::vmsg::CSBagInfo::MergeFrom(from.baginfo());
    }
  }
}

void CSBagInfoNotify::CopyFrom(const CSBagInfoNotify& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSBagInfoNotify::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  if (has_baginfo()) {
    if (!this->baginfo().IsInitialized()) return false;
  }
  return true;
}

void CSBagInfoNotify::Swap(CSBagInfoNotify* other) {
  if (other != this) {
    std::swap(pkgid_, other->pkgid_);
    std::swap(baginfo_, other->baginfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSBagInfoNotify::GetTypeName() const {
  return "vmsg.CSBagInfoNotify";
}


// ===================================================================

#ifndef _MSC_VER
const int CSWearEquipRqst::kCellIdxFieldNumber;
#endif  // !_MSC_VER

CSWearEquipRqst::CSWearEquipRqst()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSWearEquipRqst::InitAsDefaultInstance() {
}

CSWearEquipRqst::CSWearEquipRqst(const CSWearEquipRqst& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSWearEquipRqst::SharedCtor() {
  _cached_size_ = 0;
  cellidx_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSWearEquipRqst::~CSWearEquipRqst() {
  SharedDtor();
}

void CSWearEquipRqst::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSWearEquipRqst::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSWearEquipRqst& CSWearEquipRqst::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSBagMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSBagMsg_2eproto();
#endif
  return *default_instance_;
}

CSWearEquipRqst* CSWearEquipRqst::default_instance_ = NULL;

CSWearEquipRqst* CSWearEquipRqst::New() const {
  return new CSWearEquipRqst;
}

void CSWearEquipRqst::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    cellidx_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSWearEquipRqst::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 CellIdx = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cellidx_)));
          set_has_cellidx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSWearEquipRqst::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 CellIdx = 1;
  if (has_cellidx()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->cellidx(), output);
  }

}

int CSWearEquipRqst::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 CellIdx = 1;
    if (has_cellidx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cellidx());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSWearEquipRqst::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSWearEquipRqst*>(&from));
}

void CSWearEquipRqst::MergeFrom(const CSWearEquipRqst& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cellidx()) {
      set_cellidx(from.cellidx());
    }
  }
}

void CSWearEquipRqst::CopyFrom(const CSWearEquipRqst& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSWearEquipRqst::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSWearEquipRqst::Swap(CSWearEquipRqst* other) {
  if (other != this) {
    std::swap(cellidx_, other->cellidx_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSWearEquipRqst::GetTypeName() const {
  return "vmsg.CSWearEquipRqst";
}


// ===================================================================

#ifndef _MSC_VER
const int CSWearEquipRsp::kBagInfoFieldNumber;
const int CSWearEquipRsp::kPlayerDetailInfoFieldNumber;
#endif  // !_MSC_VER

CSWearEquipRsp::CSWearEquipRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSWearEquipRsp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  baginfo_ = const_cast< ::vmsg::CSBagInfo*>(
      ::vmsg::CSBagInfo::internal_default_instance());
#else
  baginfo_ = const_cast< ::vmsg::CSBagInfo*>(&::vmsg::CSBagInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  playerdetailinfo_ = const_cast< ::vmsg::CSPlayerDetailInfo*>(
      ::vmsg::CSPlayerDetailInfo::internal_default_instance());
#else
  playerdetailinfo_ = const_cast< ::vmsg::CSPlayerDetailInfo*>(&::vmsg::CSPlayerDetailInfo::default_instance());
#endif
}

CSWearEquipRsp::CSWearEquipRsp(const CSWearEquipRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSWearEquipRsp::SharedCtor() {
  _cached_size_ = 0;
  baginfo_ = NULL;
  playerdetailinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSWearEquipRsp::~CSWearEquipRsp() {
  SharedDtor();
}

void CSWearEquipRsp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete baginfo_;
    delete playerdetailinfo_;
  }
}

void CSWearEquipRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSWearEquipRsp& CSWearEquipRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSBagMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSBagMsg_2eproto();
#endif
  return *default_instance_;
}

CSWearEquipRsp* CSWearEquipRsp::default_instance_ = NULL;

CSWearEquipRsp* CSWearEquipRsp::New() const {
  return new CSWearEquipRsp;
}

void CSWearEquipRsp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_baginfo()) {
      if (baginfo_ != NULL) baginfo_->::vmsg::CSBagInfo::Clear();
    }
    if (has_playerdetailinfo()) {
      if (playerdetailinfo_ != NULL) playerdetailinfo_->::vmsg::CSPlayerDetailInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSWearEquipRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vmsg.CSBagInfo BagInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_baginfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_PlayerDetailInfo;
        break;
      }

      // required .vmsg.CSPlayerDetailInfo PlayerDetailInfo = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_PlayerDetailInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_playerdetailinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSWearEquipRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .vmsg.CSBagInfo BagInfo = 1;
  if (has_baginfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->baginfo(), output);
  }

  // required .vmsg.CSPlayerDetailInfo PlayerDetailInfo = 2;
  if (has_playerdetailinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->playerdetailinfo(), output);
  }

}

int CSWearEquipRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .vmsg.CSBagInfo BagInfo = 1;
    if (has_baginfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->baginfo());
    }

    // required .vmsg.CSPlayerDetailInfo PlayerDetailInfo = 2;
    if (has_playerdetailinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->playerdetailinfo());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSWearEquipRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSWearEquipRsp*>(&from));
}

void CSWearEquipRsp::MergeFrom(const CSWearEquipRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_baginfo()) {
      mutable_baginfo()->::vmsg::CSBagInfo::MergeFrom(from.baginfo());
    }
    if (from.has_playerdetailinfo()) {
      mutable_playerdetailinfo()->::vmsg::CSPlayerDetailInfo::MergeFrom(from.playerdetailinfo());
    }
  }
}

void CSWearEquipRsp::CopyFrom(const CSWearEquipRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSWearEquipRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_baginfo()) {
    if (!this->baginfo().IsInitialized()) return false;
  }
  if (has_playerdetailinfo()) {
    if (!this->playerdetailinfo().IsInitialized()) return false;
  }
  return true;
}

void CSWearEquipRsp::Swap(CSWearEquipRsp* other) {
  if (other != this) {
    std::swap(baginfo_, other->baginfo_);
    std::swap(playerdetailinfo_, other->playerdetailinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSWearEquipRsp::GetTypeName() const {
  return "vmsg.CSWearEquipRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSEnlargeRqst::kEnlargeCntFieldNumber;
#endif  // !_MSC_VER

CSEnlargeRqst::CSEnlargeRqst()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSEnlargeRqst::InitAsDefaultInstance() {
}

CSEnlargeRqst::CSEnlargeRqst(const CSEnlargeRqst& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSEnlargeRqst::SharedCtor() {
  _cached_size_ = 0;
  enlargecnt_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSEnlargeRqst::~CSEnlargeRqst() {
  SharedDtor();
}

void CSEnlargeRqst::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSEnlargeRqst::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSEnlargeRqst& CSEnlargeRqst::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSBagMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSBagMsg_2eproto();
#endif
  return *default_instance_;
}

CSEnlargeRqst* CSEnlargeRqst::default_instance_ = NULL;

CSEnlargeRqst* CSEnlargeRqst::New() const {
  return new CSEnlargeRqst;
}

void CSEnlargeRqst::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    enlargecnt_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSEnlargeRqst::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 EnlargeCnt = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &enlargecnt_)));
          set_has_enlargecnt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSEnlargeRqst::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 EnlargeCnt = 1;
  if (has_enlargecnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->enlargecnt(), output);
  }

}

int CSEnlargeRqst::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 EnlargeCnt = 1;
    if (has_enlargecnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->enlargecnt());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSEnlargeRqst::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSEnlargeRqst*>(&from));
}

void CSEnlargeRqst::MergeFrom(const CSEnlargeRqst& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_enlargecnt()) {
      set_enlargecnt(from.enlargecnt());
    }
  }
}

void CSEnlargeRqst::CopyFrom(const CSEnlargeRqst& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSEnlargeRqst::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSEnlargeRqst::Swap(CSEnlargeRqst* other) {
  if (other != this) {
    std::swap(enlargecnt_, other->enlargecnt_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSEnlargeRqst::GetTypeName() const {
  return "vmsg.CSEnlargeRqst";
}


// ===================================================================

#ifndef _MSC_VER
const int CSEnlargeRsp::kEnlargeCntFieldNumber;
#endif  // !_MSC_VER

CSEnlargeRsp::CSEnlargeRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSEnlargeRsp::InitAsDefaultInstance() {
}

CSEnlargeRsp::CSEnlargeRsp(const CSEnlargeRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSEnlargeRsp::SharedCtor() {
  _cached_size_ = 0;
  enlargecnt_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSEnlargeRsp::~CSEnlargeRsp() {
  SharedDtor();
}

void CSEnlargeRsp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSEnlargeRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSEnlargeRsp& CSEnlargeRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSBagMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSBagMsg_2eproto();
#endif
  return *default_instance_;
}

CSEnlargeRsp* CSEnlargeRsp::default_instance_ = NULL;

CSEnlargeRsp* CSEnlargeRsp::New() const {
  return new CSEnlargeRsp;
}

void CSEnlargeRsp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    enlargecnt_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSEnlargeRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 EnlargeCnt = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &enlargecnt_)));
          set_has_enlargecnt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSEnlargeRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 EnlargeCnt = 1;
  if (has_enlargecnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->enlargecnt(), output);
  }

}

int CSEnlargeRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 EnlargeCnt = 1;
    if (has_enlargecnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->enlargecnt());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSEnlargeRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSEnlargeRsp*>(&from));
}

void CSEnlargeRsp::MergeFrom(const CSEnlargeRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_enlargecnt()) {
      set_enlargecnt(from.enlargecnt());
    }
  }
}

void CSEnlargeRsp::CopyFrom(const CSEnlargeRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSEnlargeRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSEnlargeRsp::Swap(CSEnlargeRsp* other) {
  if (other != this) {
    std::swap(enlargecnt_, other->enlargecnt_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSEnlargeRsp::GetTypeName() const {
  return "vmsg.CSEnlargeRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSTakeOffEquipRqst::kEquipGUIDFieldNumber;
#endif  // !_MSC_VER

CSTakeOffEquipRqst::CSTakeOffEquipRqst()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSTakeOffEquipRqst::InitAsDefaultInstance() {
}

CSTakeOffEquipRqst::CSTakeOffEquipRqst(const CSTakeOffEquipRqst& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSTakeOffEquipRqst::SharedCtor() {
  _cached_size_ = 0;
  equipguid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSTakeOffEquipRqst::~CSTakeOffEquipRqst() {
  SharedDtor();
}

void CSTakeOffEquipRqst::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSTakeOffEquipRqst::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSTakeOffEquipRqst& CSTakeOffEquipRqst::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSBagMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSBagMsg_2eproto();
#endif
  return *default_instance_;
}

CSTakeOffEquipRqst* CSTakeOffEquipRqst::default_instance_ = NULL;

CSTakeOffEquipRqst* CSTakeOffEquipRqst::New() const {
  return new CSTakeOffEquipRqst;
}

void CSTakeOffEquipRqst::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    equipguid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSTakeOffEquipRqst::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 EquipGUID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &equipguid_)));
          set_has_equipguid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSTakeOffEquipRqst::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 EquipGUID = 1;
  if (has_equipguid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->equipguid(), output);
  }

}

int CSTakeOffEquipRqst::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 EquipGUID = 1;
    if (has_equipguid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->equipguid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSTakeOffEquipRqst::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSTakeOffEquipRqst*>(&from));
}

void CSTakeOffEquipRqst::MergeFrom(const CSTakeOffEquipRqst& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_equipguid()) {
      set_equipguid(from.equipguid());
    }
  }
}

void CSTakeOffEquipRqst::CopyFrom(const CSTakeOffEquipRqst& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSTakeOffEquipRqst::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSTakeOffEquipRqst::Swap(CSTakeOffEquipRqst* other) {
  if (other != this) {
    std::swap(equipguid_, other->equipguid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSTakeOffEquipRqst::GetTypeName() const {
  return "vmsg.CSTakeOffEquipRqst";
}


// ===================================================================

#ifndef _MSC_VER
const int CSTakeOffEquipRsp::kBagInfoFieldNumber;
const int CSTakeOffEquipRsp::kPlayerDetailInfoFieldNumber;
#endif  // !_MSC_VER

CSTakeOffEquipRsp::CSTakeOffEquipRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSTakeOffEquipRsp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  baginfo_ = const_cast< ::vmsg::CSBagInfo*>(
      ::vmsg::CSBagInfo::internal_default_instance());
#else
  baginfo_ = const_cast< ::vmsg::CSBagInfo*>(&::vmsg::CSBagInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  playerdetailinfo_ = const_cast< ::vmsg::CSPlayerDetailInfo*>(
      ::vmsg::CSPlayerDetailInfo::internal_default_instance());
#else
  playerdetailinfo_ = const_cast< ::vmsg::CSPlayerDetailInfo*>(&::vmsg::CSPlayerDetailInfo::default_instance());
#endif
}

CSTakeOffEquipRsp::CSTakeOffEquipRsp(const CSTakeOffEquipRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSTakeOffEquipRsp::SharedCtor() {
  _cached_size_ = 0;
  baginfo_ = NULL;
  playerdetailinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSTakeOffEquipRsp::~CSTakeOffEquipRsp() {
  SharedDtor();
}

void CSTakeOffEquipRsp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete baginfo_;
    delete playerdetailinfo_;
  }
}

void CSTakeOffEquipRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSTakeOffEquipRsp& CSTakeOffEquipRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSBagMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSBagMsg_2eproto();
#endif
  return *default_instance_;
}

CSTakeOffEquipRsp* CSTakeOffEquipRsp::default_instance_ = NULL;

CSTakeOffEquipRsp* CSTakeOffEquipRsp::New() const {
  return new CSTakeOffEquipRsp;
}

void CSTakeOffEquipRsp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_baginfo()) {
      if (baginfo_ != NULL) baginfo_->::vmsg::CSBagInfo::Clear();
    }
    if (has_playerdetailinfo()) {
      if (playerdetailinfo_ != NULL) playerdetailinfo_->::vmsg::CSPlayerDetailInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSTakeOffEquipRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vmsg.CSBagInfo BagInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_baginfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_PlayerDetailInfo;
        break;
      }

      // required .vmsg.CSPlayerDetailInfo PlayerDetailInfo = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_PlayerDetailInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_playerdetailinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSTakeOffEquipRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .vmsg.CSBagInfo BagInfo = 1;
  if (has_baginfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->baginfo(), output);
  }

  // required .vmsg.CSPlayerDetailInfo PlayerDetailInfo = 2;
  if (has_playerdetailinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->playerdetailinfo(), output);
  }

}

int CSTakeOffEquipRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .vmsg.CSBagInfo BagInfo = 1;
    if (has_baginfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->baginfo());
    }

    // required .vmsg.CSPlayerDetailInfo PlayerDetailInfo = 2;
    if (has_playerdetailinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->playerdetailinfo());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSTakeOffEquipRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSTakeOffEquipRsp*>(&from));
}

void CSTakeOffEquipRsp::MergeFrom(const CSTakeOffEquipRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_baginfo()) {
      mutable_baginfo()->::vmsg::CSBagInfo::MergeFrom(from.baginfo());
    }
    if (from.has_playerdetailinfo()) {
      mutable_playerdetailinfo()->::vmsg::CSPlayerDetailInfo::MergeFrom(from.playerdetailinfo());
    }
  }
}

void CSTakeOffEquipRsp::CopyFrom(const CSTakeOffEquipRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSTakeOffEquipRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_baginfo()) {
    if (!this->baginfo().IsInitialized()) return false;
  }
  if (has_playerdetailinfo()) {
    if (!this->playerdetailinfo().IsInitialized()) return false;
  }
  return true;
}

void CSTakeOffEquipRsp::Swap(CSTakeOffEquipRsp* other) {
  if (other != this) {
    std::swap(baginfo_, other->baginfo_);
    std::swap(playerdetailinfo_, other->playerdetailinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSTakeOffEquipRsp::GetTypeName() const {
  return "vmsg.CSTakeOffEquipRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSBagSellRqst::kBagIdxFieldNumber;
#endif  // !_MSC_VER

CSBagSellRqst::CSBagSellRqst()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSBagSellRqst::InitAsDefaultInstance() {
}

CSBagSellRqst::CSBagSellRqst(const CSBagSellRqst& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSBagSellRqst::SharedCtor() {
  _cached_size_ = 0;
  bagidx_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSBagSellRqst::~CSBagSellRqst() {
  SharedDtor();
}

void CSBagSellRqst::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSBagSellRqst::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSBagSellRqst& CSBagSellRqst::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSBagMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSBagMsg_2eproto();
#endif
  return *default_instance_;
}

CSBagSellRqst* CSBagSellRqst::default_instance_ = NULL;

CSBagSellRqst* CSBagSellRqst::New() const {
  return new CSBagSellRqst;
}

void CSBagSellRqst::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    bagidx_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSBagSellRqst::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 BagIdx = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bagidx_)));
          set_has_bagidx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSBagSellRqst::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 BagIdx = 1;
  if (has_bagidx()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->bagidx(), output);
  }

}

int CSBagSellRqst::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 BagIdx = 1;
    if (has_bagidx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bagidx());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSBagSellRqst::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSBagSellRqst*>(&from));
}

void CSBagSellRqst::MergeFrom(const CSBagSellRqst& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_bagidx()) {
      set_bagidx(from.bagidx());
    }
  }
}

void CSBagSellRqst::CopyFrom(const CSBagSellRqst& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSBagSellRqst::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSBagSellRqst::Swap(CSBagSellRqst* other) {
  if (other != this) {
    std::swap(bagidx_, other->bagidx_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSBagSellRqst::GetTypeName() const {
  return "vmsg.CSBagSellRqst";
}


// ===================================================================

#ifndef _MSC_VER
const int CSBagSellRsp::kBagIdxFieldNumber;
#endif  // !_MSC_VER

CSBagSellRsp::CSBagSellRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSBagSellRsp::InitAsDefaultInstance() {
}

CSBagSellRsp::CSBagSellRsp(const CSBagSellRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSBagSellRsp::SharedCtor() {
  _cached_size_ = 0;
  bagidx_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSBagSellRsp::~CSBagSellRsp() {
  SharedDtor();
}

void CSBagSellRsp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSBagSellRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSBagSellRsp& CSBagSellRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSBagMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSBagMsg_2eproto();
#endif
  return *default_instance_;
}

CSBagSellRsp* CSBagSellRsp::default_instance_ = NULL;

CSBagSellRsp* CSBagSellRsp::New() const {
  return new CSBagSellRsp;
}

void CSBagSellRsp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    bagidx_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSBagSellRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 BagIdx = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bagidx_)));
          set_has_bagidx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSBagSellRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 BagIdx = 1;
  if (has_bagidx()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->bagidx(), output);
  }

}

int CSBagSellRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 BagIdx = 1;
    if (has_bagidx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bagidx());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSBagSellRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSBagSellRsp*>(&from));
}

void CSBagSellRsp::MergeFrom(const CSBagSellRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_bagidx()) {
      set_bagidx(from.bagidx());
    }
  }
}

void CSBagSellRsp::CopyFrom(const CSBagSellRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSBagSellRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSBagSellRsp::Swap(CSBagSellRsp* other) {
  if (other != this) {
    std::swap(bagidx_, other->bagidx_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSBagSellRsp::GetTypeName() const {
  return "vmsg.CSBagSellRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSBagStatNotify::kIsFullFieldNumber;
#endif  // !_MSC_VER

CSBagStatNotify::CSBagStatNotify()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSBagStatNotify::InitAsDefaultInstance() {
}

CSBagStatNotify::CSBagStatNotify(const CSBagStatNotify& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSBagStatNotify::SharedCtor() {
  _cached_size_ = 0;
  isfull_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSBagStatNotify::~CSBagStatNotify() {
  SharedDtor();
}

void CSBagStatNotify::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSBagStatNotify::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSBagStatNotify& CSBagStatNotify::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSBagMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSBagMsg_2eproto();
#endif
  return *default_instance_;
}

CSBagStatNotify* CSBagStatNotify::default_instance_ = NULL;

CSBagStatNotify* CSBagStatNotify::New() const {
  return new CSBagStatNotify;
}

void CSBagStatNotify::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    isfull_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSBagStatNotify::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 IsFull = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &isfull_)));
          set_has_isfull();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSBagStatNotify::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 IsFull = 1;
  if (has_isfull()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->isfull(), output);
  }

}

int CSBagStatNotify::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 IsFull = 1;
    if (has_isfull()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->isfull());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSBagStatNotify::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSBagStatNotify*>(&from));
}

void CSBagStatNotify::MergeFrom(const CSBagStatNotify& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_isfull()) {
      set_isfull(from.isfull());
    }
  }
}

void CSBagStatNotify::CopyFrom(const CSBagStatNotify& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSBagStatNotify::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSBagStatNotify::Swap(CSBagStatNotify* other) {
  if (other != this) {
    std::swap(isfull_, other->isfull_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSBagStatNotify::GetTypeName() const {
  return "vmsg.CSBagStatNotify";
}


// ===================================================================

#ifndef _MSC_VER
const int CSBuyItemRqst::kItemTypeFieldNumber;
const int CSBuyItemRqst::kItemCfgIDFieldNumber;
const int CSBuyItemRqst::kCntFieldNumber;
#endif  // !_MSC_VER

CSBuyItemRqst::CSBuyItemRqst()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSBuyItemRqst::InitAsDefaultInstance() {
}

CSBuyItemRqst::CSBuyItemRqst(const CSBuyItemRqst& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSBuyItemRqst::SharedCtor() {
  _cached_size_ = 0;
  itemtype_ = 0u;
  itemcfgid_ = 0u;
  cnt_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSBuyItemRqst::~CSBuyItemRqst() {
  SharedDtor();
}

void CSBuyItemRqst::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSBuyItemRqst::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSBuyItemRqst& CSBuyItemRqst::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSBagMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSBagMsg_2eproto();
#endif
  return *default_instance_;
}

CSBuyItemRqst* CSBuyItemRqst::default_instance_ = NULL;

CSBuyItemRqst* CSBuyItemRqst::New() const {
  return new CSBuyItemRqst;
}

void CSBuyItemRqst::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    itemtype_ = 0u;
    itemcfgid_ = 0u;
    cnt_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSBuyItemRqst::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ItemType = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &itemtype_)));
          set_has_itemtype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_ItemCfgID;
        break;
      }

      // required uint32 ItemCfgID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ItemCfgID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &itemcfgid_)));
          set_has_itemcfgid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_Cnt;
        break;
      }

      // required uint32 Cnt = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cnt_)));
          set_has_cnt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSBuyItemRqst::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 ItemType = 1;
  if (has_itemtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->itemtype(), output);
  }

  // required uint32 ItemCfgID = 2;
  if (has_itemcfgid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->itemcfgid(), output);
  }

  // required uint32 Cnt = 3;
  if (has_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->cnt(), output);
  }

}

int CSBuyItemRqst::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ItemType = 1;
    if (has_itemtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->itemtype());
    }

    // required uint32 ItemCfgID = 2;
    if (has_itemcfgid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->itemcfgid());
    }

    // required uint32 Cnt = 3;
    if (has_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cnt());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSBuyItemRqst::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSBuyItemRqst*>(&from));
}

void CSBuyItemRqst::MergeFrom(const CSBuyItemRqst& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemtype()) {
      set_itemtype(from.itemtype());
    }
    if (from.has_itemcfgid()) {
      set_itemcfgid(from.itemcfgid());
    }
    if (from.has_cnt()) {
      set_cnt(from.cnt());
    }
  }
}

void CSBuyItemRqst::CopyFrom(const CSBuyItemRqst& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSBuyItemRqst::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSBuyItemRqst::Swap(CSBuyItemRqst* other) {
  if (other != this) {
    std::swap(itemtype_, other->itemtype_);
    std::swap(itemcfgid_, other->itemcfgid_);
    std::swap(cnt_, other->cnt_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSBuyItemRqst::GetTypeName() const {
  return "vmsg.CSBuyItemRqst";
}


// ===================================================================

#ifndef _MSC_VER
const int CSBuyItemRsp::kItemTypeFieldNumber;
const int CSBuyItemRsp::kItemCfgIDFieldNumber;
const int CSBuyItemRsp::kCntFieldNumber;
const int CSBuyItemRsp::kBagInfoFieldNumber;
#endif  // !_MSC_VER

CSBuyItemRsp::CSBuyItemRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSBuyItemRsp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  baginfo_ = const_cast< ::vmsg::CSBagInfo*>(
      ::vmsg::CSBagInfo::internal_default_instance());
#else
  baginfo_ = const_cast< ::vmsg::CSBagInfo*>(&::vmsg::CSBagInfo::default_instance());
#endif
}

CSBuyItemRsp::CSBuyItemRsp(const CSBuyItemRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSBuyItemRsp::SharedCtor() {
  _cached_size_ = 0;
  itemtype_ = 0u;
  itemcfgid_ = 0u;
  cnt_ = 0u;
  baginfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSBuyItemRsp::~CSBuyItemRsp() {
  SharedDtor();
}

void CSBuyItemRsp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete baginfo_;
  }
}

void CSBuyItemRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSBuyItemRsp& CSBuyItemRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSBagMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSBagMsg_2eproto();
#endif
  return *default_instance_;
}

CSBuyItemRsp* CSBuyItemRsp::default_instance_ = NULL;

CSBuyItemRsp* CSBuyItemRsp::New() const {
  return new CSBuyItemRsp;
}

void CSBuyItemRsp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    itemtype_ = 0u;
    itemcfgid_ = 0u;
    cnt_ = 0u;
    if (has_baginfo()) {
      if (baginfo_ != NULL) baginfo_->::vmsg::CSBagInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSBuyItemRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ItemType = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &itemtype_)));
          set_has_itemtype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_ItemCfgID;
        break;
      }

      // required uint32 ItemCfgID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ItemCfgID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &itemcfgid_)));
          set_has_itemcfgid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_Cnt;
        break;
      }

      // required uint32 Cnt = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cnt_)));
          set_has_cnt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_BagInfo;
        break;
      }

      // required .vmsg.CSBagInfo BagInfo = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BagInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_baginfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSBuyItemRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 ItemType = 1;
  if (has_itemtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->itemtype(), output);
  }

  // required uint32 ItemCfgID = 2;
  if (has_itemcfgid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->itemcfgid(), output);
  }

  // required uint32 Cnt = 3;
  if (has_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->cnt(), output);
  }

  // required .vmsg.CSBagInfo BagInfo = 4;
  if (has_baginfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->baginfo(), output);
  }

}

int CSBuyItemRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ItemType = 1;
    if (has_itemtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->itemtype());
    }

    // required uint32 ItemCfgID = 2;
    if (has_itemcfgid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->itemcfgid());
    }

    // required uint32 Cnt = 3;
    if (has_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cnt());
    }

    // required .vmsg.CSBagInfo BagInfo = 4;
    if (has_baginfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->baginfo());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSBuyItemRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSBuyItemRsp*>(&from));
}

void CSBuyItemRsp::MergeFrom(const CSBuyItemRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemtype()) {
      set_itemtype(from.itemtype());
    }
    if (from.has_itemcfgid()) {
      set_itemcfgid(from.itemcfgid());
    }
    if (from.has_cnt()) {
      set_cnt(from.cnt());
    }
    if (from.has_baginfo()) {
      mutable_baginfo()->::vmsg::CSBagInfo::MergeFrom(from.baginfo());
    }
  }
}

void CSBuyItemRsp::CopyFrom(const CSBuyItemRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSBuyItemRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_baginfo()) {
    if (!this->baginfo().IsInitialized()) return false;
  }
  return true;
}

void CSBuyItemRsp::Swap(CSBuyItemRsp* other) {
  if (other != this) {
    std::swap(itemtype_, other->itemtype_);
    std::swap(itemcfgid_, other->itemcfgid_);
    std::swap(cnt_, other->cnt_);
    std::swap(baginfo_, other->baginfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSBuyItemRsp::GetTypeName() const {
  return "vmsg.CSBuyItemRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSConsumeItemRqst::kBagIdxFieldNumber;
const int CSConsumeItemRqst::kCfgIDFieldNumber;
const int CSConsumeItemRqst::kTypeFieldNumber;
const int CSConsumeItemRqst::kCntFieldNumber;
#endif  // !_MSC_VER

CSConsumeItemRqst::CSConsumeItemRqst()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSConsumeItemRqst::InitAsDefaultInstance() {
}

CSConsumeItemRqst::CSConsumeItemRqst(const CSConsumeItemRqst& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSConsumeItemRqst::SharedCtor() {
  _cached_size_ = 0;
  bagidx_ = 0;
  cfgid_ = 0u;
  type_ = 0u;
  cnt_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSConsumeItemRqst::~CSConsumeItemRqst() {
  SharedDtor();
}

void CSConsumeItemRqst::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSConsumeItemRqst::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSConsumeItemRqst& CSConsumeItemRqst::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSBagMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSBagMsg_2eproto();
#endif
  return *default_instance_;
}

CSConsumeItemRqst* CSConsumeItemRqst::default_instance_ = NULL;

CSConsumeItemRqst* CSConsumeItemRqst::New() const {
  return new CSConsumeItemRqst;
}

void CSConsumeItemRqst::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    bagidx_ = 0;
    cfgid_ = 0u;
    type_ = 0u;
    cnt_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSConsumeItemRqst::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 BagIdx = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bagidx_)));
          set_has_bagidx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_CfgID;
        break;
      }

      // required uint32 CfgID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_CfgID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cfgid_)));
          set_has_cfgid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_Type;
        break;
      }

      // required uint32 Type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_Cnt;
        break;
      }

      // required uint32 Cnt = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cnt_)));
          set_has_cnt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSConsumeItemRqst::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 BagIdx = 1;
  if (has_bagidx()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->bagidx(), output);
  }

  // required uint32 CfgID = 2;
  if (has_cfgid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->cfgid(), output);
  }

  // required uint32 Type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->type(), output);
  }

  // required uint32 Cnt = 4;
  if (has_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->cnt(), output);
  }

}

int CSConsumeItemRqst::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 BagIdx = 1;
    if (has_bagidx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bagidx());
    }

    // required uint32 CfgID = 2;
    if (has_cfgid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cfgid());
    }

    // required uint32 Type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // required uint32 Cnt = 4;
    if (has_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cnt());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSConsumeItemRqst::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSConsumeItemRqst*>(&from));
}

void CSConsumeItemRqst::MergeFrom(const CSConsumeItemRqst& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_bagidx()) {
      set_bagidx(from.bagidx());
    }
    if (from.has_cfgid()) {
      set_cfgid(from.cfgid());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_cnt()) {
      set_cnt(from.cnt());
    }
  }
}

void CSConsumeItemRqst::CopyFrom(const CSConsumeItemRqst& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSConsumeItemRqst::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void CSConsumeItemRqst::Swap(CSConsumeItemRqst* other) {
  if (other != this) {
    std::swap(bagidx_, other->bagidx_);
    std::swap(cfgid_, other->cfgid_);
    std::swap(type_, other->type_);
    std::swap(cnt_, other->cnt_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSConsumeItemRqst::GetTypeName() const {
  return "vmsg.CSConsumeItemRqst";
}


// ===================================================================

#ifndef _MSC_VER
const int CSConsumeItemRsp::kBagInfoFieldNumber;
const int CSConsumeItemRsp::kCfgIDFieldNumber;
const int CSConsumeItemRsp::kTypeFieldNumber;
const int CSConsumeItemRsp::kCntFieldNumber;
#endif  // !_MSC_VER

CSConsumeItemRsp::CSConsumeItemRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSConsumeItemRsp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  baginfo_ = const_cast< ::vmsg::CSBagInfo*>(
      ::vmsg::CSBagInfo::internal_default_instance());
#else
  baginfo_ = const_cast< ::vmsg::CSBagInfo*>(&::vmsg::CSBagInfo::default_instance());
#endif
}

CSConsumeItemRsp::CSConsumeItemRsp(const CSConsumeItemRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSConsumeItemRsp::SharedCtor() {
  _cached_size_ = 0;
  baginfo_ = NULL;
  cfgid_ = 0u;
  type_ = 0u;
  cnt_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSConsumeItemRsp::~CSConsumeItemRsp() {
  SharedDtor();
}

void CSConsumeItemRsp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete baginfo_;
  }
}

void CSConsumeItemRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSConsumeItemRsp& CSConsumeItemRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSBagMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSBagMsg_2eproto();
#endif
  return *default_instance_;
}

CSConsumeItemRsp* CSConsumeItemRsp::default_instance_ = NULL;

CSConsumeItemRsp* CSConsumeItemRsp::New() const {
  return new CSConsumeItemRsp;
}

void CSConsumeItemRsp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_baginfo()) {
      if (baginfo_ != NULL) baginfo_->::vmsg::CSBagInfo::Clear();
    }
    cfgid_ = 0u;
    type_ = 0u;
    cnt_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSConsumeItemRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vmsg.CSBagInfo BagInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_baginfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_CfgID;
        break;
      }

      // required uint32 CfgID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_CfgID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cfgid_)));
          set_has_cfgid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_Type;
        break;
      }

      // required uint32 Type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_Cnt;
        break;
      }

      // required uint32 Cnt = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cnt_)));
          set_has_cnt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSConsumeItemRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .vmsg.CSBagInfo BagInfo = 1;
  if (has_baginfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->baginfo(), output);
  }

  // required uint32 CfgID = 2;
  if (has_cfgid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->cfgid(), output);
  }

  // required uint32 Type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->type(), output);
  }

  // required uint32 Cnt = 4;
  if (has_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->cnt(), output);
  }

}

int CSConsumeItemRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .vmsg.CSBagInfo BagInfo = 1;
    if (has_baginfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->baginfo());
    }

    // required uint32 CfgID = 2;
    if (has_cfgid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cfgid());
    }

    // required uint32 Type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // required uint32 Cnt = 4;
    if (has_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cnt());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSConsumeItemRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSConsumeItemRsp*>(&from));
}

void CSConsumeItemRsp::MergeFrom(const CSConsumeItemRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_baginfo()) {
      mutable_baginfo()->::vmsg::CSBagInfo::MergeFrom(from.baginfo());
    }
    if (from.has_cfgid()) {
      set_cfgid(from.cfgid());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_cnt()) {
      set_cnt(from.cnt());
    }
  }
}

void CSConsumeItemRsp::CopyFrom(const CSConsumeItemRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSConsumeItemRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_baginfo()) {
    if (!this->baginfo().IsInitialized()) return false;
  }
  return true;
}

void CSConsumeItemRsp::Swap(CSConsumeItemRsp* other) {
  if (other != this) {
    std::swap(baginfo_, other->baginfo_);
    std::swap(cfgid_, other->cfgid_);
    std::swap(type_, other->type_);
    std::swap(cnt_, other->cnt_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSConsumeItemRsp::GetTypeName() const {
  return "vmsg.CSConsumeItemRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSBagRequest::kQueryBagInfoRqstFieldNumber;
const int CSBagRequest::kWearEquipRqstFieldNumber;
const int CSBagRequest::kEnlargeRqstFieldNumber;
const int CSBagRequest::kTakeOffEquipRqstFieldNumber;
const int CSBagRequest::kBagSellRqstFieldNumber;
const int CSBagRequest::kBuyItemRqstFieldNumber;
const int CSBagRequest::kConsumeItemRqstFieldNumber;
#endif  // !_MSC_VER

CSBagRequest::CSBagRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSBagRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  querybaginfo_rqst_ = const_cast< ::vmsg::CSQueryBagInfoRqst*>(
      ::vmsg::CSQueryBagInfoRqst::internal_default_instance());
#else
  querybaginfo_rqst_ = const_cast< ::vmsg::CSQueryBagInfoRqst*>(&::vmsg::CSQueryBagInfoRqst::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  wearequip_rqst_ = const_cast< ::vmsg::CSWearEquipRqst*>(
      ::vmsg::CSWearEquipRqst::internal_default_instance());
#else
  wearequip_rqst_ = const_cast< ::vmsg::CSWearEquipRqst*>(&::vmsg::CSWearEquipRqst::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  enlarge_rqst_ = const_cast< ::vmsg::CSEnlargeRqst*>(
      ::vmsg::CSEnlargeRqst::internal_default_instance());
#else
  enlarge_rqst_ = const_cast< ::vmsg::CSEnlargeRqst*>(&::vmsg::CSEnlargeRqst::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  takeoffequip_rqst_ = const_cast< ::vmsg::CSTakeOffEquipRqst*>(
      ::vmsg::CSTakeOffEquipRqst::internal_default_instance());
#else
  takeoffequip_rqst_ = const_cast< ::vmsg::CSTakeOffEquipRqst*>(&::vmsg::CSTakeOffEquipRqst::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  bagsell_rqst_ = const_cast< ::vmsg::CSBagSellRqst*>(
      ::vmsg::CSBagSellRqst::internal_default_instance());
#else
  bagsell_rqst_ = const_cast< ::vmsg::CSBagSellRqst*>(&::vmsg::CSBagSellRqst::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  buyitem_rqst_ = const_cast< ::vmsg::CSBuyItemRqst*>(
      ::vmsg::CSBuyItemRqst::internal_default_instance());
#else
  buyitem_rqst_ = const_cast< ::vmsg::CSBuyItemRqst*>(&::vmsg::CSBuyItemRqst::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  consumeitem_rqst_ = const_cast< ::vmsg::CSConsumeItemRqst*>(
      ::vmsg::CSConsumeItemRqst::internal_default_instance());
#else
  consumeitem_rqst_ = const_cast< ::vmsg::CSConsumeItemRqst*>(&::vmsg::CSConsumeItemRqst::default_instance());
#endif
}

CSBagRequest::CSBagRequest(const CSBagRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSBagRequest::SharedCtor() {
  _cached_size_ = 0;
  querybaginfo_rqst_ = NULL;
  wearequip_rqst_ = NULL;
  enlarge_rqst_ = NULL;
  takeoffequip_rqst_ = NULL;
  bagsell_rqst_ = NULL;
  buyitem_rqst_ = NULL;
  consumeitem_rqst_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSBagRequest::~CSBagRequest() {
  SharedDtor();
}

void CSBagRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete querybaginfo_rqst_;
    delete wearequip_rqst_;
    delete enlarge_rqst_;
    delete takeoffequip_rqst_;
    delete bagsell_rqst_;
    delete buyitem_rqst_;
    delete consumeitem_rqst_;
  }
}

void CSBagRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSBagRequest& CSBagRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSBagMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSBagMsg_2eproto();
#endif
  return *default_instance_;
}

CSBagRequest* CSBagRequest::default_instance_ = NULL;

CSBagRequest* CSBagRequest::New() const {
  return new CSBagRequest;
}

void CSBagRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_querybaginfo_rqst()) {
      if (querybaginfo_rqst_ != NULL) querybaginfo_rqst_->::vmsg::CSQueryBagInfoRqst::Clear();
    }
    if (has_wearequip_rqst()) {
      if (wearequip_rqst_ != NULL) wearequip_rqst_->::vmsg::CSWearEquipRqst::Clear();
    }
    if (has_enlarge_rqst()) {
      if (enlarge_rqst_ != NULL) enlarge_rqst_->::vmsg::CSEnlargeRqst::Clear();
    }
    if (has_takeoffequip_rqst()) {
      if (takeoffequip_rqst_ != NULL) takeoffequip_rqst_->::vmsg::CSTakeOffEquipRqst::Clear();
    }
    if (has_bagsell_rqst()) {
      if (bagsell_rqst_ != NULL) bagsell_rqst_->::vmsg::CSBagSellRqst::Clear();
    }
    if (has_buyitem_rqst()) {
      if (buyitem_rqst_ != NULL) buyitem_rqst_->::vmsg::CSBuyItemRqst::Clear();
    }
    if (has_consumeitem_rqst()) {
      if (consumeitem_rqst_ != NULL) consumeitem_rqst_->::vmsg::CSConsumeItemRqst::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSBagRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .vmsg.CSQueryBagInfoRqst QueryBagInfo_Rqst = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_querybaginfo_rqst()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_WearEquip_Rqst;
        break;
      }

      // optional .vmsg.CSWearEquipRqst WearEquip_Rqst = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_WearEquip_Rqst:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_wearequip_rqst()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_Enlarge_Rqst;
        break;
      }

      // optional .vmsg.CSEnlargeRqst Enlarge_Rqst = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Enlarge_Rqst:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_enlarge_rqst()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_TakeOffEquip_Rqst;
        break;
      }

      // optional .vmsg.CSTakeOffEquipRqst TakeOffEquip_Rqst = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_TakeOffEquip_Rqst:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_takeoffequip_rqst()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_BagSell_Rqst;
        break;
      }

      // optional .vmsg.CSBagSellRqst BagSell_Rqst = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BagSell_Rqst:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bagsell_rqst()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_BuyItem_Rqst;
        break;
      }

      // optional .vmsg.CSBuyItemRqst BuyItem_Rqst = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyItem_Rqst:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_buyitem_rqst()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_ConsumeItem_Rqst;
        break;
      }

      // optional .vmsg.CSConsumeItemRqst ConsumeItem_Rqst = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ConsumeItem_Rqst:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_consumeitem_rqst()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSBagRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .vmsg.CSQueryBagInfoRqst QueryBagInfo_Rqst = 1;
  if (has_querybaginfo_rqst()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->querybaginfo_rqst(), output);
  }

  // optional .vmsg.CSWearEquipRqst WearEquip_Rqst = 4;
  if (has_wearequip_rqst()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->wearequip_rqst(), output);
  }

  // optional .vmsg.CSEnlargeRqst Enlarge_Rqst = 5;
  if (has_enlarge_rqst()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->enlarge_rqst(), output);
  }

  // optional .vmsg.CSTakeOffEquipRqst TakeOffEquip_Rqst = 6;
  if (has_takeoffequip_rqst()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->takeoffequip_rqst(), output);
  }

  // optional .vmsg.CSBagSellRqst BagSell_Rqst = 7;
  if (has_bagsell_rqst()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->bagsell_rqst(), output);
  }

  // optional .vmsg.CSBuyItemRqst BuyItem_Rqst = 8;
  if (has_buyitem_rqst()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->buyitem_rqst(), output);
  }

  // optional .vmsg.CSConsumeItemRqst ConsumeItem_Rqst = 9;
  if (has_consumeitem_rqst()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->consumeitem_rqst(), output);
  }

}

int CSBagRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .vmsg.CSQueryBagInfoRqst QueryBagInfo_Rqst = 1;
    if (has_querybaginfo_rqst()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->querybaginfo_rqst());
    }

    // optional .vmsg.CSWearEquipRqst WearEquip_Rqst = 4;
    if (has_wearequip_rqst()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->wearequip_rqst());
    }

    // optional .vmsg.CSEnlargeRqst Enlarge_Rqst = 5;
    if (has_enlarge_rqst()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->enlarge_rqst());
    }

    // optional .vmsg.CSTakeOffEquipRqst TakeOffEquip_Rqst = 6;
    if (has_takeoffequip_rqst()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->takeoffequip_rqst());
    }

    // optional .vmsg.CSBagSellRqst BagSell_Rqst = 7;
    if (has_bagsell_rqst()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->bagsell_rqst());
    }

    // optional .vmsg.CSBuyItemRqst BuyItem_Rqst = 8;
    if (has_buyitem_rqst()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->buyitem_rqst());
    }

    // optional .vmsg.CSConsumeItemRqst ConsumeItem_Rqst = 9;
    if (has_consumeitem_rqst()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->consumeitem_rqst());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSBagRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSBagRequest*>(&from));
}

void CSBagRequest::MergeFrom(const CSBagRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_querybaginfo_rqst()) {
      mutable_querybaginfo_rqst()->::vmsg::CSQueryBagInfoRqst::MergeFrom(from.querybaginfo_rqst());
    }
    if (from.has_wearequip_rqst()) {
      mutable_wearequip_rqst()->::vmsg::CSWearEquipRqst::MergeFrom(from.wearequip_rqst());
    }
    if (from.has_enlarge_rqst()) {
      mutable_enlarge_rqst()->::vmsg::CSEnlargeRqst::MergeFrom(from.enlarge_rqst());
    }
    if (from.has_takeoffequip_rqst()) {
      mutable_takeoffequip_rqst()->::vmsg::CSTakeOffEquipRqst::MergeFrom(from.takeoffequip_rqst());
    }
    if (from.has_bagsell_rqst()) {
      mutable_bagsell_rqst()->::vmsg::CSBagSellRqst::MergeFrom(from.bagsell_rqst());
    }
    if (from.has_buyitem_rqst()) {
      mutable_buyitem_rqst()->::vmsg::CSBuyItemRqst::MergeFrom(from.buyitem_rqst());
    }
    if (from.has_consumeitem_rqst()) {
      mutable_consumeitem_rqst()->::vmsg::CSConsumeItemRqst::MergeFrom(from.consumeitem_rqst());
    }
  }
}

void CSBagRequest::CopyFrom(const CSBagRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSBagRequest::IsInitialized() const {

  if (has_wearequip_rqst()) {
    if (!this->wearequip_rqst().IsInitialized()) return false;
  }
  if (has_enlarge_rqst()) {
    if (!this->enlarge_rqst().IsInitialized()) return false;
  }
  if (has_takeoffequip_rqst()) {
    if (!this->takeoffequip_rqst().IsInitialized()) return false;
  }
  if (has_bagsell_rqst()) {
    if (!this->bagsell_rqst().IsInitialized()) return false;
  }
  if (has_buyitem_rqst()) {
    if (!this->buyitem_rqst().IsInitialized()) return false;
  }
  if (has_consumeitem_rqst()) {
    if (!this->consumeitem_rqst().IsInitialized()) return false;
  }
  return true;
}

void CSBagRequest::Swap(CSBagRequest* other) {
  if (other != this) {
    std::swap(querybaginfo_rqst_, other->querybaginfo_rqst_);
    std::swap(wearequip_rqst_, other->wearequip_rqst_);
    std::swap(enlarge_rqst_, other->enlarge_rqst_);
    std::swap(takeoffequip_rqst_, other->takeoffequip_rqst_);
    std::swap(bagsell_rqst_, other->bagsell_rqst_);
    std::swap(buyitem_rqst_, other->buyitem_rqst_);
    std::swap(consumeitem_rqst_, other->consumeitem_rqst_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSBagRequest::GetTypeName() const {
  return "vmsg.CSBagRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int CSBagRespond::kQueryBagInfoRspFieldNumber;
const int CSBagRespond::kWearEquipRspFieldNumber;
const int CSBagRespond::kEnlargeRspFieldNumber;
const int CSBagRespond::kTakeOffEquipRspFieldNumber;
const int CSBagRespond::kBagSellRspFieldNumber;
const int CSBagRespond::kBagStatNotifyFieldNumber;
const int CSBagRespond::kBagInfoNotifyFieldNumber;
const int CSBagRespond::kConsumeItemRspFieldNumber;
const int CSBagRespond::kBuyItemRspFieldNumber;
#endif  // !_MSC_VER

CSBagRespond::CSBagRespond()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSBagRespond::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  querybaginfo_rsp_ = const_cast< ::vmsg::CSQueryBagInfoRsp*>(
      ::vmsg::CSQueryBagInfoRsp::internal_default_instance());
#else
  querybaginfo_rsp_ = const_cast< ::vmsg::CSQueryBagInfoRsp*>(&::vmsg::CSQueryBagInfoRsp::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  wearequip_rsp_ = const_cast< ::vmsg::CSWearEquipRsp*>(
      ::vmsg::CSWearEquipRsp::internal_default_instance());
#else
  wearequip_rsp_ = const_cast< ::vmsg::CSWearEquipRsp*>(&::vmsg::CSWearEquipRsp::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  enlarge_rsp_ = const_cast< ::vmsg::CSEnlargeRsp*>(
      ::vmsg::CSEnlargeRsp::internal_default_instance());
#else
  enlarge_rsp_ = const_cast< ::vmsg::CSEnlargeRsp*>(&::vmsg::CSEnlargeRsp::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  takeoffequip_rsp_ = const_cast< ::vmsg::CSTakeOffEquipRsp*>(
      ::vmsg::CSTakeOffEquipRsp::internal_default_instance());
#else
  takeoffequip_rsp_ = const_cast< ::vmsg::CSTakeOffEquipRsp*>(&::vmsg::CSTakeOffEquipRsp::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  bagsell_rsp_ = const_cast< ::vmsg::CSBagSellRsp*>(
      ::vmsg::CSBagSellRsp::internal_default_instance());
#else
  bagsell_rsp_ = const_cast< ::vmsg::CSBagSellRsp*>(&::vmsg::CSBagSellRsp::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  bagstat_notify_ = const_cast< ::vmsg::CSBagStatNotify*>(
      ::vmsg::CSBagStatNotify::internal_default_instance());
#else
  bagstat_notify_ = const_cast< ::vmsg::CSBagStatNotify*>(&::vmsg::CSBagStatNotify::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  baginfo_notify_ = const_cast< ::vmsg::CSBagInfoNotify*>(
      ::vmsg::CSBagInfoNotify::internal_default_instance());
#else
  baginfo_notify_ = const_cast< ::vmsg::CSBagInfoNotify*>(&::vmsg::CSBagInfoNotify::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  consumeitem_rsp_ = const_cast< ::vmsg::CSConsumeItemRsp*>(
      ::vmsg::CSConsumeItemRsp::internal_default_instance());
#else
  consumeitem_rsp_ = const_cast< ::vmsg::CSConsumeItemRsp*>(&::vmsg::CSConsumeItemRsp::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  buyitem_rsp_ = const_cast< ::vmsg::CSBuyItemRsp*>(
      ::vmsg::CSBuyItemRsp::internal_default_instance());
#else
  buyitem_rsp_ = const_cast< ::vmsg::CSBuyItemRsp*>(&::vmsg::CSBuyItemRsp::default_instance());
#endif
}

CSBagRespond::CSBagRespond(const CSBagRespond& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSBagRespond::SharedCtor() {
  _cached_size_ = 0;
  querybaginfo_rsp_ = NULL;
  wearequip_rsp_ = NULL;
  enlarge_rsp_ = NULL;
  takeoffequip_rsp_ = NULL;
  bagsell_rsp_ = NULL;
  bagstat_notify_ = NULL;
  baginfo_notify_ = NULL;
  consumeitem_rsp_ = NULL;
  buyitem_rsp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSBagRespond::~CSBagRespond() {
  SharedDtor();
}

void CSBagRespond::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete querybaginfo_rsp_;
    delete wearequip_rsp_;
    delete enlarge_rsp_;
    delete takeoffequip_rsp_;
    delete bagsell_rsp_;
    delete bagstat_notify_;
    delete baginfo_notify_;
    delete consumeitem_rsp_;
    delete buyitem_rsp_;
  }
}

void CSBagRespond::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSBagRespond& CSBagRespond::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSBagMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSBagMsg_2eproto();
#endif
  return *default_instance_;
}

CSBagRespond* CSBagRespond::default_instance_ = NULL;

CSBagRespond* CSBagRespond::New() const {
  return new CSBagRespond;
}

void CSBagRespond::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_querybaginfo_rsp()) {
      if (querybaginfo_rsp_ != NULL) querybaginfo_rsp_->::vmsg::CSQueryBagInfoRsp::Clear();
    }
    if (has_wearequip_rsp()) {
      if (wearequip_rsp_ != NULL) wearequip_rsp_->::vmsg::CSWearEquipRsp::Clear();
    }
    if (has_enlarge_rsp()) {
      if (enlarge_rsp_ != NULL) enlarge_rsp_->::vmsg::CSEnlargeRsp::Clear();
    }
    if (has_takeoffequip_rsp()) {
      if (takeoffequip_rsp_ != NULL) takeoffequip_rsp_->::vmsg::CSTakeOffEquipRsp::Clear();
    }
    if (has_bagsell_rsp()) {
      if (bagsell_rsp_ != NULL) bagsell_rsp_->::vmsg::CSBagSellRsp::Clear();
    }
    if (has_bagstat_notify()) {
      if (bagstat_notify_ != NULL) bagstat_notify_->::vmsg::CSBagStatNotify::Clear();
    }
    if (has_baginfo_notify()) {
      if (baginfo_notify_ != NULL) baginfo_notify_->::vmsg::CSBagInfoNotify::Clear();
    }
    if (has_consumeitem_rsp()) {
      if (consumeitem_rsp_ != NULL) consumeitem_rsp_->::vmsg::CSConsumeItemRsp::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_buyitem_rsp()) {
      if (buyitem_rsp_ != NULL) buyitem_rsp_->::vmsg::CSBuyItemRsp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSBagRespond::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .vmsg.CSQueryBagInfoRsp QueryBagInfo_Rsp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_querybaginfo_rsp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_WearEquip_Rsp;
        break;
      }

      // optional .vmsg.CSWearEquipRsp WearEquip_Rsp = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_WearEquip_Rsp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_wearequip_rsp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_Enlarge_Rsp;
        break;
      }

      // optional .vmsg.CSEnlargeRsp Enlarge_Rsp = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Enlarge_Rsp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_enlarge_rsp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_TakeOffEquip_Rsp;
        break;
      }

      // optional .vmsg.CSTakeOffEquipRsp TakeOffEquip_Rsp = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_TakeOffEquip_Rsp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_takeoffequip_rsp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_BagSell_Rsp;
        break;
      }

      // optional .vmsg.CSBagSellRsp BagSell_Rsp = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BagSell_Rsp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bagsell_rsp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_BagStat_Notify;
        break;
      }

      // optional .vmsg.CSBagStatNotify BagStat_Notify = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BagStat_Notify:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bagstat_notify()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_BagInfo_Notify;
        break;
      }

      // optional .vmsg.CSBagInfoNotify BagInfo_Notify = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BagInfo_Notify:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_baginfo_notify()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_ConsumeItem_Rsp;
        break;
      }

      // optional .vmsg.CSConsumeItemRsp ConsumeItem_Rsp = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ConsumeItem_Rsp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_consumeitem_rsp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_BuyItem_Rsp;
        break;
      }

      // optional .vmsg.CSBuyItemRsp BuyItem_Rsp = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BuyItem_Rsp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_buyitem_rsp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSBagRespond::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .vmsg.CSQueryBagInfoRsp QueryBagInfo_Rsp = 1;
  if (has_querybaginfo_rsp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->querybaginfo_rsp(), output);
  }

  // optional .vmsg.CSWearEquipRsp WearEquip_Rsp = 4;
  if (has_wearequip_rsp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->wearequip_rsp(), output);
  }

  // optional .vmsg.CSEnlargeRsp Enlarge_Rsp = 5;
  if (has_enlarge_rsp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->enlarge_rsp(), output);
  }

  // optional .vmsg.CSTakeOffEquipRsp TakeOffEquip_Rsp = 6;
  if (has_takeoffequip_rsp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->takeoffequip_rsp(), output);
  }

  // optional .vmsg.CSBagSellRsp BagSell_Rsp = 7;
  if (has_bagsell_rsp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->bagsell_rsp(), output);
  }

  // optional .vmsg.CSBagStatNotify BagStat_Notify = 8;
  if (has_bagstat_notify()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->bagstat_notify(), output);
  }

  // optional .vmsg.CSBagInfoNotify BagInfo_Notify = 9;
  if (has_baginfo_notify()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->baginfo_notify(), output);
  }

  // optional .vmsg.CSConsumeItemRsp ConsumeItem_Rsp = 10;
  if (has_consumeitem_rsp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, this->consumeitem_rsp(), output);
  }

  // optional .vmsg.CSBuyItemRsp BuyItem_Rsp = 11;
  if (has_buyitem_rsp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, this->buyitem_rsp(), output);
  }

}

int CSBagRespond::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .vmsg.CSQueryBagInfoRsp QueryBagInfo_Rsp = 1;
    if (has_querybaginfo_rsp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->querybaginfo_rsp());
    }

    // optional .vmsg.CSWearEquipRsp WearEquip_Rsp = 4;
    if (has_wearequip_rsp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->wearequip_rsp());
    }

    // optional .vmsg.CSEnlargeRsp Enlarge_Rsp = 5;
    if (has_enlarge_rsp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->enlarge_rsp());
    }

    // optional .vmsg.CSTakeOffEquipRsp TakeOffEquip_Rsp = 6;
    if (has_takeoffequip_rsp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->takeoffequip_rsp());
    }

    // optional .vmsg.CSBagSellRsp BagSell_Rsp = 7;
    if (has_bagsell_rsp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->bagsell_rsp());
    }

    // optional .vmsg.CSBagStatNotify BagStat_Notify = 8;
    if (has_bagstat_notify()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->bagstat_notify());
    }

    // optional .vmsg.CSBagInfoNotify BagInfo_Notify = 9;
    if (has_baginfo_notify()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->baginfo_notify());
    }

    // optional .vmsg.CSConsumeItemRsp ConsumeItem_Rsp = 10;
    if (has_consumeitem_rsp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->consumeitem_rsp());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .vmsg.CSBuyItemRsp BuyItem_Rsp = 11;
    if (has_buyitem_rsp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->buyitem_rsp());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSBagRespond::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSBagRespond*>(&from));
}

void CSBagRespond::MergeFrom(const CSBagRespond& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_querybaginfo_rsp()) {
      mutable_querybaginfo_rsp()->::vmsg::CSQueryBagInfoRsp::MergeFrom(from.querybaginfo_rsp());
    }
    if (from.has_wearequip_rsp()) {
      mutable_wearequip_rsp()->::vmsg::CSWearEquipRsp::MergeFrom(from.wearequip_rsp());
    }
    if (from.has_enlarge_rsp()) {
      mutable_enlarge_rsp()->::vmsg::CSEnlargeRsp::MergeFrom(from.enlarge_rsp());
    }
    if (from.has_takeoffequip_rsp()) {
      mutable_takeoffequip_rsp()->::vmsg::CSTakeOffEquipRsp::MergeFrom(from.takeoffequip_rsp());
    }
    if (from.has_bagsell_rsp()) {
      mutable_bagsell_rsp()->::vmsg::CSBagSellRsp::MergeFrom(from.bagsell_rsp());
    }
    if (from.has_bagstat_notify()) {
      mutable_bagstat_notify()->::vmsg::CSBagStatNotify::MergeFrom(from.bagstat_notify());
    }
    if (from.has_baginfo_notify()) {
      mutable_baginfo_notify()->::vmsg::CSBagInfoNotify::MergeFrom(from.baginfo_notify());
    }
    if (from.has_consumeitem_rsp()) {
      mutable_consumeitem_rsp()->::vmsg::CSConsumeItemRsp::MergeFrom(from.consumeitem_rsp());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_buyitem_rsp()) {
      mutable_buyitem_rsp()->::vmsg::CSBuyItemRsp::MergeFrom(from.buyitem_rsp());
    }
  }
}

void CSBagRespond::CopyFrom(const CSBagRespond& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSBagRespond::IsInitialized() const {

  if (has_querybaginfo_rsp()) {
    if (!this->querybaginfo_rsp().IsInitialized()) return false;
  }
  if (has_wearequip_rsp()) {
    if (!this->wearequip_rsp().IsInitialized()) return false;
  }
  if (has_enlarge_rsp()) {
    if (!this->enlarge_rsp().IsInitialized()) return false;
  }
  if (has_takeoffequip_rsp()) {
    if (!this->takeoffequip_rsp().IsInitialized()) return false;
  }
  if (has_bagsell_rsp()) {
    if (!this->bagsell_rsp().IsInitialized()) return false;
  }
  if (has_bagstat_notify()) {
    if (!this->bagstat_notify().IsInitialized()) return false;
  }
  if (has_baginfo_notify()) {
    if (!this->baginfo_notify().IsInitialized()) return false;
  }
  if (has_consumeitem_rsp()) {
    if (!this->consumeitem_rsp().IsInitialized()) return false;
  }
  if (has_buyitem_rsp()) {
    if (!this->buyitem_rsp().IsInitialized()) return false;
  }
  return true;
}

void CSBagRespond::Swap(CSBagRespond* other) {
  if (other != this) {
    std::swap(querybaginfo_rsp_, other->querybaginfo_rsp_);
    std::swap(wearequip_rsp_, other->wearequip_rsp_);
    std::swap(enlarge_rsp_, other->enlarge_rsp_);
    std::swap(takeoffequip_rsp_, other->takeoffequip_rsp_);
    std::swap(bagsell_rsp_, other->bagsell_rsp_);
    std::swap(bagstat_notify_, other->bagstat_notify_);
    std::swap(baginfo_notify_, other->baginfo_notify_);
    std::swap(consumeitem_rsp_, other->consumeitem_rsp_);
    std::swap(buyitem_rsp_, other->buyitem_rsp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSBagRespond::GetTypeName() const {
  return "vmsg.CSBagRespond";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)
