// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSEquipOpMsg.proto

#ifndef PROTOBUF_CSEquipOpMsg_2eproto__INCLUDED
#define PROTOBUF_CSEquipOpMsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MsgBase.pb.h"
#include "ShareByClient.pb.h"
#include "CSEquipItemMsg.pb.h"
#include "CSBagMsg.pb.h"
// @@protoc_insertion_point(includes)

namespace vmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CSEquipOpMsg_2eproto();
void protobuf_AssignDesc_CSEquipOpMsg_2eproto();
void protobuf_ShutdownFile_CSEquipOpMsg_2eproto();

class CSEquipRefineHero;
class CSEquipRefineBag;
class CSEquipRefineRqst;
class CSEquipRefineRsp;
class CSEquipTransRefineInfo;
class CSEquipTransRqst;
class CSEquipTransRsp;
class CSEquipLvUpConsume;
class CSEquipLvUpRqst;
class CSPlayerEquipInfo;
class CSEquipLvUpRsp;
class CSEquipStarStepRqst;
class CSEquipStarStepRsp;
class CSEquipRefitRqst;
class CSEquipRefitRsp;
class CSEquipRequest;
class CSEquipRespond;

enum REFINE_WHERE_TYPE {
  REFINE_WHERE_HERO = 1,
  REFINE_WHERE_BAG = 2
};
bool REFINE_WHERE_TYPE_IsValid(int value);
const REFINE_WHERE_TYPE REFINE_WHERE_TYPE_MIN = REFINE_WHERE_HERO;
const REFINE_WHERE_TYPE REFINE_WHERE_TYPE_MAX = REFINE_WHERE_BAG;
const int REFINE_WHERE_TYPE_ARRAYSIZE = REFINE_WHERE_TYPE_MAX + 1;

// ===================================================================

class CSEquipRefineHero : public ::google::protobuf::MessageLite {
 public:
  CSEquipRefineHero();
  virtual ~CSEquipRefineHero();

  CSEquipRefineHero(const CSEquipRefineHero& from);

  inline CSEquipRefineHero& operator=(const CSEquipRefineHero& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEquipRefineHero& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEquipRefineHero* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEquipRefineHero* other);

  // implements Message ----------------------------------------------

  CSEquipRefineHero* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEquipRefineHero& from);
  void MergeFrom(const CSEquipRefineHero& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 EquipGUID = 1;
  inline bool has_equipguid() const;
  inline void clear_equipguid();
  static const int kEquipGUIDFieldNumber = 1;
  inline ::google::protobuf::uint64 equipguid() const;
  inline void set_equipguid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSEquipRefineHero)
 private:
  inline void set_has_equipguid();
  inline void clear_has_equipguid();

  ::google::protobuf::uint64 equipguid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSEquipOpMsg_2eproto();
  friend void protobuf_ShutdownFile_CSEquipOpMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEquipRefineHero* default_instance_;
};
// -------------------------------------------------------------------

class CSEquipRefineBag : public ::google::protobuf::MessageLite {
 public:
  CSEquipRefineBag();
  virtual ~CSEquipRefineBag();

  CSEquipRefineBag(const CSEquipRefineBag& from);

  inline CSEquipRefineBag& operator=(const CSEquipRefineBag& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEquipRefineBag& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEquipRefineBag* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEquipRefineBag* other);

  // implements Message ----------------------------------------------

  CSEquipRefineBag* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEquipRefineBag& from);
  void MergeFrom(const CSEquipRefineBag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 BagIdx = 1;
  inline bool has_bagidx() const;
  inline void clear_bagidx();
  static const int kBagIdxFieldNumber = 1;
  inline ::google::protobuf::int32 bagidx() const;
  inline void set_bagidx(::google::protobuf::int32 value);

  // required uint64 EquipGUID = 2;
  inline bool has_equipguid() const;
  inline void clear_equipguid();
  static const int kEquipGUIDFieldNumber = 2;
  inline ::google::protobuf::uint64 equipguid() const;
  inline void set_equipguid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSEquipRefineBag)
 private:
  inline void set_has_bagidx();
  inline void clear_has_bagidx();
  inline void set_has_equipguid();
  inline void clear_has_equipguid();

  ::google::protobuf::uint64 equipguid_;
  ::google::protobuf::int32 bagidx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSEquipOpMsg_2eproto();
  friend void protobuf_ShutdownFile_CSEquipOpMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEquipRefineBag* default_instance_;
};
// -------------------------------------------------------------------

class CSEquipRefineRqst : public ::google::protobuf::MessageLite {
 public:
  CSEquipRefineRqst();
  virtual ~CSEquipRefineRqst();

  CSEquipRefineRqst(const CSEquipRefineRqst& from);

  inline CSEquipRefineRqst& operator=(const CSEquipRefineRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEquipRefineRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEquipRefineRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEquipRefineRqst* other);

  // implements Message ----------------------------------------------

  CSEquipRefineRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEquipRefineRqst& from);
  void MergeFrom(const CSEquipRefineRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional .vmsg.CSEquipRefineHero EquipRefineHero = 2;
  inline bool has_equiprefinehero() const;
  inline void clear_equiprefinehero();
  static const int kEquipRefineHeroFieldNumber = 2;
  inline const ::vmsg::CSEquipRefineHero& equiprefinehero() const;
  inline ::vmsg::CSEquipRefineHero* mutable_equiprefinehero();
  inline ::vmsg::CSEquipRefineHero* release_equiprefinehero();
  inline void set_allocated_equiprefinehero(::vmsg::CSEquipRefineHero* equiprefinehero);

  // optional .vmsg.CSEquipRefineBag EquipRefineBag = 3;
  inline bool has_equiprefinebag() const;
  inline void clear_equiprefinebag();
  static const int kEquipRefineBagFieldNumber = 3;
  inline const ::vmsg::CSEquipRefineBag& equiprefinebag() const;
  inline ::vmsg::CSEquipRefineBag* mutable_equiprefinebag();
  inline ::vmsg::CSEquipRefineBag* release_equiprefinebag();
  inline void set_allocated_equiprefinebag(::vmsg::CSEquipRefineBag* equiprefinebag);

  // required uint32 SelProtect = 4;
  inline bool has_selprotect() const;
  inline void clear_selprotect();
  static const int kSelProtectFieldNumber = 4;
  inline ::google::protobuf::uint32 selprotect() const;
  inline void set_selprotect(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSEquipRefineRqst)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_equiprefinehero();
  inline void clear_has_equiprefinehero();
  inline void set_has_equiprefinebag();
  inline void clear_has_equiprefinebag();
  inline void set_has_selprotect();
  inline void clear_has_selprotect();

  ::vmsg::CSEquipRefineHero* equiprefinehero_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 selprotect_;
  ::vmsg::CSEquipRefineBag* equiprefinebag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSEquipOpMsg_2eproto();
  friend void protobuf_ShutdownFile_CSEquipOpMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEquipRefineRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSEquipRefineRsp : public ::google::protobuf::MessageLite {
 public:
  CSEquipRefineRsp();
  virtual ~CSEquipRefineRsp();

  CSEquipRefineRsp(const CSEquipRefineRsp& from);

  inline CSEquipRefineRsp& operator=(const CSEquipRefineRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEquipRefineRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEquipRefineRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEquipRefineRsp* other);

  // implements Message ----------------------------------------------

  CSEquipRefineRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEquipRefineRsp& from);
  void MergeFrom(const CSEquipRefineRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 EquipGUID = 1;
  inline bool has_equipguid() const;
  inline void clear_equipguid();
  static const int kEquipGUIDFieldNumber = 1;
  inline ::google::protobuf::uint64 equipguid() const;
  inline void set_equipguid(::google::protobuf::uint64 value);

  // required uint32 RefineLv = 2;
  inline bool has_refinelv() const;
  inline void clear_refinelv();
  static const int kRefineLvFieldNumber = 2;
  inline ::google::protobuf::uint32 refinelv() const;
  inline void set_refinelv(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSEquipRefineRsp)
 private:
  inline void set_has_equipguid();
  inline void clear_has_equipguid();
  inline void set_has_refinelv();
  inline void clear_has_refinelv();

  ::google::protobuf::uint64 equipguid_;
  ::google::protobuf::uint32 refinelv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSEquipOpMsg_2eproto();
  friend void protobuf_ShutdownFile_CSEquipOpMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEquipRefineRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSEquipTransRefineInfo : public ::google::protobuf::MessageLite {
 public:
  CSEquipTransRefineInfo();
  virtual ~CSEquipTransRefineInfo();

  CSEquipTransRefineInfo(const CSEquipTransRefineInfo& from);

  inline CSEquipTransRefineInfo& operator=(const CSEquipTransRefineInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEquipTransRefineInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEquipTransRefineInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEquipTransRefineInfo* other);

  // implements Message ----------------------------------------------

  CSEquipTransRefineInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEquipTransRefineInfo& from);
  void MergeFrom(const CSEquipTransRefineInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint64 EquipGUID = 2;
  inline bool has_equipguid() const;
  inline void clear_equipguid();
  static const int kEquipGUIDFieldNumber = 2;
  inline ::google::protobuf::uint64 equipguid() const;
  inline void set_equipguid(::google::protobuf::uint64 value);

  // optional int32 BagIdx = 3;
  inline bool has_bagidx() const;
  inline void clear_bagidx();
  static const int kBagIdxFieldNumber = 3;
  inline ::google::protobuf::int32 bagidx() const;
  inline void set_bagidx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSEquipTransRefineInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_equipguid();
  inline void clear_has_equipguid();
  inline void set_has_bagidx();
  inline void clear_has_bagidx();

  ::google::protobuf::uint64 equipguid_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::int32 bagidx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSEquipOpMsg_2eproto();
  friend void protobuf_ShutdownFile_CSEquipOpMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEquipTransRefineInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSEquipTransRqst : public ::google::protobuf::MessageLite {
 public:
  CSEquipTransRqst();
  virtual ~CSEquipTransRqst();

  CSEquipTransRqst(const CSEquipTransRqst& from);

  inline CSEquipTransRqst& operator=(const CSEquipTransRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEquipTransRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEquipTransRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEquipTransRqst* other);

  // implements Message ----------------------------------------------

  CSEquipTransRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEquipTransRqst& from);
  void MergeFrom(const CSEquipTransRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSEquipTransRefineInfo FromEquip = 1;
  inline bool has_fromequip() const;
  inline void clear_fromequip();
  static const int kFromEquipFieldNumber = 1;
  inline const ::vmsg::CSEquipTransRefineInfo& fromequip() const;
  inline ::vmsg::CSEquipTransRefineInfo* mutable_fromequip();
  inline ::vmsg::CSEquipTransRefineInfo* release_fromequip();
  inline void set_allocated_fromequip(::vmsg::CSEquipTransRefineInfo* fromequip);

  // required .vmsg.CSEquipTransRefineInfo ToEquip = 2;
  inline bool has_toequip() const;
  inline void clear_toequip();
  static const int kToEquipFieldNumber = 2;
  inline const ::vmsg::CSEquipTransRefineInfo& toequip() const;
  inline ::vmsg::CSEquipTransRefineInfo* mutable_toequip();
  inline ::vmsg::CSEquipTransRefineInfo* release_toequip();
  inline void set_allocated_toequip(::vmsg::CSEquipTransRefineInfo* toequip);

  // @@protoc_insertion_point(class_scope:vmsg.CSEquipTransRqst)
 private:
  inline void set_has_fromequip();
  inline void clear_has_fromequip();
  inline void set_has_toequip();
  inline void clear_has_toequip();

  ::vmsg::CSEquipTransRefineInfo* fromequip_;
  ::vmsg::CSEquipTransRefineInfo* toequip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSEquipOpMsg_2eproto();
  friend void protobuf_ShutdownFile_CSEquipOpMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEquipTransRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSEquipTransRsp : public ::google::protobuf::MessageLite {
 public:
  CSEquipTransRsp();
  virtual ~CSEquipTransRsp();

  CSEquipTransRsp(const CSEquipTransRsp& from);

  inline CSEquipTransRsp& operator=(const CSEquipTransRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEquipTransRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEquipTransRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEquipTransRsp* other);

  // implements Message ----------------------------------------------

  CSEquipTransRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEquipTransRsp& from);
  void MergeFrom(const CSEquipTransRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 FromEquipGUID = 1;
  inline bool has_fromequipguid() const;
  inline void clear_fromequipguid();
  static const int kFromEquipGUIDFieldNumber = 1;
  inline ::google::protobuf::uint64 fromequipguid() const;
  inline void set_fromequipguid(::google::protobuf::uint64 value);

  // required uint32 FromRefineLv = 2;
  inline bool has_fromrefinelv() const;
  inline void clear_fromrefinelv();
  static const int kFromRefineLvFieldNumber = 2;
  inline ::google::protobuf::uint32 fromrefinelv() const;
  inline void set_fromrefinelv(::google::protobuf::uint32 value);

  // required uint64 ToEquipGUID = 3;
  inline bool has_toequipguid() const;
  inline void clear_toequipguid();
  static const int kToEquipGUIDFieldNumber = 3;
  inline ::google::protobuf::uint64 toequipguid() const;
  inline void set_toequipguid(::google::protobuf::uint64 value);

  // required uint32 ToRefineLv = 4;
  inline bool has_torefinelv() const;
  inline void clear_torefinelv();
  static const int kToRefineLvFieldNumber = 4;
  inline ::google::protobuf::uint32 torefinelv() const;
  inline void set_torefinelv(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSEquipTransRsp)
 private:
  inline void set_has_fromequipguid();
  inline void clear_has_fromequipguid();
  inline void set_has_fromrefinelv();
  inline void clear_has_fromrefinelv();
  inline void set_has_toequipguid();
  inline void clear_has_toequipguid();
  inline void set_has_torefinelv();
  inline void clear_has_torefinelv();

  ::google::protobuf::uint64 fromequipguid_;
  ::google::protobuf::uint64 toequipguid_;
  ::google::protobuf::uint32 fromrefinelv_;
  ::google::protobuf::uint32 torefinelv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSEquipOpMsg_2eproto();
  friend void protobuf_ShutdownFile_CSEquipOpMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEquipTransRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSEquipLvUpConsume : public ::google::protobuf::MessageLite {
 public:
  CSEquipLvUpConsume();
  virtual ~CSEquipLvUpConsume();

  CSEquipLvUpConsume(const CSEquipLvUpConsume& from);

  inline CSEquipLvUpConsume& operator=(const CSEquipLvUpConsume& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEquipLvUpConsume& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEquipLvUpConsume* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEquipLvUpConsume* other);

  // implements Message ----------------------------------------------

  CSEquipLvUpConsume* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEquipLvUpConsume& from);
  void MergeFrom(const CSEquipLvUpConsume& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint64 ID = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 2;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // required uint64 Cnt = 3;
  inline bool has_cnt() const;
  inline void clear_cnt();
  static const int kCntFieldNumber = 3;
  inline ::google::protobuf::uint64 cnt() const;
  inline void set_cnt(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSEquipLvUpConsume)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_cnt();
  inline void clear_has_cnt();

  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint64 cnt_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSEquipOpMsg_2eproto();
  friend void protobuf_ShutdownFile_CSEquipOpMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEquipLvUpConsume* default_instance_;
};
// -------------------------------------------------------------------

class CSEquipLvUpRqst : public ::google::protobuf::MessageLite {
 public:
  CSEquipLvUpRqst();
  virtual ~CSEquipLvUpRqst();

  CSEquipLvUpRqst(const CSEquipLvUpRqst& from);

  inline CSEquipLvUpRqst& operator=(const CSEquipLvUpRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEquipLvUpRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEquipLvUpRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEquipLvUpRqst* other);

  // implements Message ----------------------------------------------

  CSEquipLvUpRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEquipLvUpRqst& from);
  void MergeFrom(const CSEquipLvUpRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 BagIdx = 1;
  inline bool has_bagidx() const;
  inline void clear_bagidx();
  static const int kBagIdxFieldNumber = 1;
  inline ::google::protobuf::int32 bagidx() const;
  inline void set_bagidx(::google::protobuf::int32 value);

  // required uint64 EquipGUID = 2;
  inline bool has_equipguid() const;
  inline void clear_equipguid();
  static const int kEquipGUIDFieldNumber = 2;
  inline ::google::protobuf::uint64 equipguid() const;
  inline void set_equipguid(::google::protobuf::uint64 value);

  // repeated .vmsg.CSEquipLvUpConsume Consumes = 3;
  inline int consumes_size() const;
  inline void clear_consumes();
  static const int kConsumesFieldNumber = 3;
  inline const ::vmsg::CSEquipLvUpConsume& consumes(int index) const;
  inline ::vmsg::CSEquipLvUpConsume* mutable_consumes(int index);
  inline ::vmsg::CSEquipLvUpConsume* add_consumes();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSEquipLvUpConsume >&
      consumes() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSEquipLvUpConsume >*
      mutable_consumes();

  // @@protoc_insertion_point(class_scope:vmsg.CSEquipLvUpRqst)
 private:
  inline void set_has_bagidx();
  inline void clear_has_bagidx();
  inline void set_has_equipguid();
  inline void clear_has_equipguid();

  ::google::protobuf::uint64 equipguid_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSEquipLvUpConsume > consumes_;
  ::google::protobuf::int32 bagidx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSEquipOpMsg_2eproto();
  friend void protobuf_ShutdownFile_CSEquipOpMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEquipLvUpRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerEquipInfo : public ::google::protobuf::MessageLite {
 public:
  CSPlayerEquipInfo();
  virtual ~CSPlayerEquipInfo();

  CSPlayerEquipInfo(const CSPlayerEquipInfo& from);

  inline CSPlayerEquipInfo& operator=(const CSPlayerEquipInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerEquipInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerEquipInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerEquipInfo* other);

  // implements Message ----------------------------------------------

  CSPlayerEquipInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerEquipInfo& from);
  void MergeFrom(const CSPlayerEquipInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSEquipInfo EquipLst = 1;
  inline int equiplst_size() const;
  inline void clear_equiplst();
  static const int kEquipLstFieldNumber = 1;
  inline const ::vmsg::CSEquipInfo& equiplst(int index) const;
  inline ::vmsg::CSEquipInfo* mutable_equiplst(int index);
  inline ::vmsg::CSEquipInfo* add_equiplst();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSEquipInfo >&
      equiplst() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSEquipInfo >*
      mutable_equiplst();

  // required .vmsg.CSEquipInfo SpareEquip = 2;
  inline bool has_spareequip() const;
  inline void clear_spareequip();
  static const int kSpareEquipFieldNumber = 2;
  inline const ::vmsg::CSEquipInfo& spareequip() const;
  inline ::vmsg::CSEquipInfo* mutable_spareequip();
  inline ::vmsg::CSEquipInfo* release_spareequip();
  inline void set_allocated_spareequip(::vmsg::CSEquipInfo* spareequip);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerEquipInfo)
 private:
  inline void set_has_spareequip();
  inline void clear_has_spareequip();

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSEquipInfo > equiplst_;
  ::vmsg::CSEquipInfo* spareequip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSEquipOpMsg_2eproto();
  friend void protobuf_ShutdownFile_CSEquipOpMsg_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerEquipInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSEquipLvUpRsp : public ::google::protobuf::MessageLite {
 public:
  CSEquipLvUpRsp();
  virtual ~CSEquipLvUpRsp();

  CSEquipLvUpRsp(const CSEquipLvUpRsp& from);

  inline CSEquipLvUpRsp& operator=(const CSEquipLvUpRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEquipLvUpRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEquipLvUpRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEquipLvUpRsp* other);

  // implements Message ----------------------------------------------

  CSEquipLvUpRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEquipLvUpRsp& from);
  void MergeFrom(const CSEquipLvUpRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSBagInfo BagInfo = 1;
  inline bool has_baginfo() const;
  inline void clear_baginfo();
  static const int kBagInfoFieldNumber = 1;
  inline const ::vmsg::CSBagInfo& baginfo() const;
  inline ::vmsg::CSBagInfo* mutable_baginfo();
  inline ::vmsg::CSBagInfo* release_baginfo();
  inline void set_allocated_baginfo(::vmsg::CSBagInfo* baginfo);

  // required .vmsg.CSPlayerEquipInfo PlayerEquipInfo = 2;
  inline bool has_playerequipinfo() const;
  inline void clear_playerequipinfo();
  static const int kPlayerEquipInfoFieldNumber = 2;
  inline const ::vmsg::CSPlayerEquipInfo& playerequipinfo() const;
  inline ::vmsg::CSPlayerEquipInfo* mutable_playerequipinfo();
  inline ::vmsg::CSPlayerEquipInfo* release_playerequipinfo();
  inline void set_allocated_playerequipinfo(::vmsg::CSPlayerEquipInfo* playerequipinfo);

  // @@protoc_insertion_point(class_scope:vmsg.CSEquipLvUpRsp)
 private:
  inline void set_has_baginfo();
  inline void clear_has_baginfo();
  inline void set_has_playerequipinfo();
  inline void clear_has_playerequipinfo();

  ::vmsg::CSBagInfo* baginfo_;
  ::vmsg::CSPlayerEquipInfo* playerequipinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSEquipOpMsg_2eproto();
  friend void protobuf_ShutdownFile_CSEquipOpMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEquipLvUpRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSEquipStarStepRqst : public ::google::protobuf::MessageLite {
 public:
  CSEquipStarStepRqst();
  virtual ~CSEquipStarStepRqst();

  CSEquipStarStepRqst(const CSEquipStarStepRqst& from);

  inline CSEquipStarStepRqst& operator=(const CSEquipStarStepRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEquipStarStepRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEquipStarStepRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEquipStarStepRqst* other);

  // implements Message ----------------------------------------------

  CSEquipStarStepRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEquipStarStepRqst& from);
  void MergeFrom(const CSEquipStarStepRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 BagIdx = 1;
  inline bool has_bagidx() const;
  inline void clear_bagidx();
  static const int kBagIdxFieldNumber = 1;
  inline ::google::protobuf::int32 bagidx() const;
  inline void set_bagidx(::google::protobuf::int32 value);

  // required uint64 EquipGUID = 2;
  inline bool has_equipguid() const;
  inline void clear_equipguid();
  static const int kEquipGUIDFieldNumber = 2;
  inline ::google::protobuf::uint64 equipguid() const;
  inline void set_equipguid(::google::protobuf::uint64 value);

  // repeated uint64 NeedEquipGUIDs = 3;
  inline int needequipguids_size() const;
  inline void clear_needequipguids();
  static const int kNeedEquipGUIDsFieldNumber = 3;
  inline ::google::protobuf::uint64 needequipguids(int index) const;
  inline void set_needequipguids(int index, ::google::protobuf::uint64 value);
  inline void add_needequipguids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      needequipguids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_needequipguids();

  // @@protoc_insertion_point(class_scope:vmsg.CSEquipStarStepRqst)
 private:
  inline void set_has_bagidx();
  inline void clear_has_bagidx();
  inline void set_has_equipguid();
  inline void clear_has_equipguid();

  ::google::protobuf::uint64 equipguid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > needequipguids_;
  ::google::protobuf::int32 bagidx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSEquipOpMsg_2eproto();
  friend void protobuf_ShutdownFile_CSEquipOpMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEquipStarStepRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSEquipStarStepRsp : public ::google::protobuf::MessageLite {
 public:
  CSEquipStarStepRsp();
  virtual ~CSEquipStarStepRsp();

  CSEquipStarStepRsp(const CSEquipStarStepRsp& from);

  inline CSEquipStarStepRsp& operator=(const CSEquipStarStepRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEquipStarStepRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEquipStarStepRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEquipStarStepRsp* other);

  // implements Message ----------------------------------------------

  CSEquipStarStepRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEquipStarStepRsp& from);
  void MergeFrom(const CSEquipStarStepRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSBagInfo BagInfo = 1;
  inline bool has_baginfo() const;
  inline void clear_baginfo();
  static const int kBagInfoFieldNumber = 1;
  inline const ::vmsg::CSBagInfo& baginfo() const;
  inline ::vmsg::CSBagInfo* mutable_baginfo();
  inline ::vmsg::CSBagInfo* release_baginfo();
  inline void set_allocated_baginfo(::vmsg::CSBagInfo* baginfo);

  // required .vmsg.CSPlayerEquipInfo PlayerEquipInfo = 2;
  inline bool has_playerequipinfo() const;
  inline void clear_playerequipinfo();
  static const int kPlayerEquipInfoFieldNumber = 2;
  inline const ::vmsg::CSPlayerEquipInfo& playerequipinfo() const;
  inline ::vmsg::CSPlayerEquipInfo* mutable_playerequipinfo();
  inline ::vmsg::CSPlayerEquipInfo* release_playerequipinfo();
  inline void set_allocated_playerequipinfo(::vmsg::CSPlayerEquipInfo* playerequipinfo);

  // @@protoc_insertion_point(class_scope:vmsg.CSEquipStarStepRsp)
 private:
  inline void set_has_baginfo();
  inline void clear_has_baginfo();
  inline void set_has_playerequipinfo();
  inline void clear_has_playerequipinfo();

  ::vmsg::CSBagInfo* baginfo_;
  ::vmsg::CSPlayerEquipInfo* playerequipinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSEquipOpMsg_2eproto();
  friend void protobuf_ShutdownFile_CSEquipOpMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEquipStarStepRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSEquipRefitRqst : public ::google::protobuf::MessageLite {
 public:
  CSEquipRefitRqst();
  virtual ~CSEquipRefitRqst();

  CSEquipRefitRqst(const CSEquipRefitRqst& from);

  inline CSEquipRefitRqst& operator=(const CSEquipRefitRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEquipRefitRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEquipRefitRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEquipRefitRqst* other);

  // implements Message ----------------------------------------------

  CSEquipRefitRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEquipRefitRqst& from);
  void MergeFrom(const CSEquipRefitRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 BagIdx = 1;
  inline bool has_bagidx() const;
  inline void clear_bagidx();
  static const int kBagIdxFieldNumber = 1;
  inline ::google::protobuf::int32 bagidx() const;
  inline void set_bagidx(::google::protobuf::int32 value);

  // required uint64 EquipGUID = 2;
  inline bool has_equipguid() const;
  inline void clear_equipguid();
  static const int kEquipGUIDFieldNumber = 2;
  inline ::google::protobuf::uint64 equipguid() const;
  inline void set_equipguid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSEquipRefitRqst)
 private:
  inline void set_has_bagidx();
  inline void clear_has_bagidx();
  inline void set_has_equipguid();
  inline void clear_has_equipguid();

  ::google::protobuf::uint64 equipguid_;
  ::google::protobuf::int32 bagidx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSEquipOpMsg_2eproto();
  friend void protobuf_ShutdownFile_CSEquipOpMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEquipRefitRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSEquipRefitRsp : public ::google::protobuf::MessageLite {
 public:
  CSEquipRefitRsp();
  virtual ~CSEquipRefitRsp();

  CSEquipRefitRsp(const CSEquipRefitRsp& from);

  inline CSEquipRefitRsp& operator=(const CSEquipRefitRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEquipRefitRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEquipRefitRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEquipRefitRsp* other);

  // implements Message ----------------------------------------------

  CSEquipRefitRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEquipRefitRsp& from);
  void MergeFrom(const CSEquipRefitRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSBagInfo BagInfo = 1;
  inline bool has_baginfo() const;
  inline void clear_baginfo();
  static const int kBagInfoFieldNumber = 1;
  inline const ::vmsg::CSBagInfo& baginfo() const;
  inline ::vmsg::CSBagInfo* mutable_baginfo();
  inline ::vmsg::CSBagInfo* release_baginfo();
  inline void set_allocated_baginfo(::vmsg::CSBagInfo* baginfo);

  // required .vmsg.CSPlayerEquipInfo PlayerEquipInfo = 2;
  inline bool has_playerequipinfo() const;
  inline void clear_playerequipinfo();
  static const int kPlayerEquipInfoFieldNumber = 2;
  inline const ::vmsg::CSPlayerEquipInfo& playerequipinfo() const;
  inline ::vmsg::CSPlayerEquipInfo* mutable_playerequipinfo();
  inline ::vmsg::CSPlayerEquipInfo* release_playerequipinfo();
  inline void set_allocated_playerequipinfo(::vmsg::CSPlayerEquipInfo* playerequipinfo);

  // @@protoc_insertion_point(class_scope:vmsg.CSEquipRefitRsp)
 private:
  inline void set_has_baginfo();
  inline void clear_has_baginfo();
  inline void set_has_playerequipinfo();
  inline void clear_has_playerequipinfo();

  ::vmsg::CSBagInfo* baginfo_;
  ::vmsg::CSPlayerEquipInfo* playerequipinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSEquipOpMsg_2eproto();
  friend void protobuf_ShutdownFile_CSEquipOpMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEquipRefitRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSEquipRequest : public ::google::protobuf::MessageLite {
 public:
  CSEquipRequest();
  virtual ~CSEquipRequest();

  CSEquipRequest(const CSEquipRequest& from);

  inline CSEquipRequest& operator=(const CSEquipRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEquipRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEquipRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEquipRequest* other);

  // implements Message ----------------------------------------------

  CSEquipRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEquipRequest& from);
  void MergeFrom(const CSEquipRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSEquipRefineRqst EquipRefine_Rqst = 1;
  inline bool has_equiprefine_rqst() const;
  inline void clear_equiprefine_rqst();
  static const int kEquipRefineRqstFieldNumber = 1;
  inline const ::vmsg::CSEquipRefineRqst& equiprefine_rqst() const;
  inline ::vmsg::CSEquipRefineRqst* mutable_equiprefine_rqst();
  inline ::vmsg::CSEquipRefineRqst* release_equiprefine_rqst();
  inline void set_allocated_equiprefine_rqst(::vmsg::CSEquipRefineRqst* equiprefine_rqst);

  // optional .vmsg.CSEquipTransRqst EquipTrans_Rqst = 2;
  inline bool has_equiptrans_rqst() const;
  inline void clear_equiptrans_rqst();
  static const int kEquipTransRqstFieldNumber = 2;
  inline const ::vmsg::CSEquipTransRqst& equiptrans_rqst() const;
  inline ::vmsg::CSEquipTransRqst* mutable_equiptrans_rqst();
  inline ::vmsg::CSEquipTransRqst* release_equiptrans_rqst();
  inline void set_allocated_equiptrans_rqst(::vmsg::CSEquipTransRqst* equiptrans_rqst);

  // optional .vmsg.CSEquipLvUpRqst EquipLvUp_Rqst = 3;
  inline bool has_equiplvup_rqst() const;
  inline void clear_equiplvup_rqst();
  static const int kEquipLvUpRqstFieldNumber = 3;
  inline const ::vmsg::CSEquipLvUpRqst& equiplvup_rqst() const;
  inline ::vmsg::CSEquipLvUpRqst* mutable_equiplvup_rqst();
  inline ::vmsg::CSEquipLvUpRqst* release_equiplvup_rqst();
  inline void set_allocated_equiplvup_rqst(::vmsg::CSEquipLvUpRqst* equiplvup_rqst);

  // optional .vmsg.CSEquipStarStepRqst EquipStarStep_Rqst = 4;
  inline bool has_equipstarstep_rqst() const;
  inline void clear_equipstarstep_rqst();
  static const int kEquipStarStepRqstFieldNumber = 4;
  inline const ::vmsg::CSEquipStarStepRqst& equipstarstep_rqst() const;
  inline ::vmsg::CSEquipStarStepRqst* mutable_equipstarstep_rqst();
  inline ::vmsg::CSEquipStarStepRqst* release_equipstarstep_rqst();
  inline void set_allocated_equipstarstep_rqst(::vmsg::CSEquipStarStepRqst* equipstarstep_rqst);

  // optional .vmsg.CSEquipRefitRqst EquipRefit_Rqst = 5;
  inline bool has_equiprefit_rqst() const;
  inline void clear_equiprefit_rqst();
  static const int kEquipRefitRqstFieldNumber = 5;
  inline const ::vmsg::CSEquipRefitRqst& equiprefit_rqst() const;
  inline ::vmsg::CSEquipRefitRqst* mutable_equiprefit_rqst();
  inline ::vmsg::CSEquipRefitRqst* release_equiprefit_rqst();
  inline void set_allocated_equiprefit_rqst(::vmsg::CSEquipRefitRqst* equiprefit_rqst);

  // @@protoc_insertion_point(class_scope:vmsg.CSEquipRequest)
 private:
  inline void set_has_equiprefine_rqst();
  inline void clear_has_equiprefine_rqst();
  inline void set_has_equiptrans_rqst();
  inline void clear_has_equiptrans_rqst();
  inline void set_has_equiplvup_rqst();
  inline void clear_has_equiplvup_rqst();
  inline void set_has_equipstarstep_rqst();
  inline void clear_has_equipstarstep_rqst();
  inline void set_has_equiprefit_rqst();
  inline void clear_has_equiprefit_rqst();

  ::vmsg::CSEquipRefineRqst* equiprefine_rqst_;
  ::vmsg::CSEquipTransRqst* equiptrans_rqst_;
  ::vmsg::CSEquipLvUpRqst* equiplvup_rqst_;
  ::vmsg::CSEquipStarStepRqst* equipstarstep_rqst_;
  ::vmsg::CSEquipRefitRqst* equiprefit_rqst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSEquipOpMsg_2eproto();
  friend void protobuf_ShutdownFile_CSEquipOpMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEquipRequest* default_instance_;
};
// -------------------------------------------------------------------

class CSEquipRespond : public ::google::protobuf::MessageLite {
 public:
  CSEquipRespond();
  virtual ~CSEquipRespond();

  CSEquipRespond(const CSEquipRespond& from);

  inline CSEquipRespond& operator=(const CSEquipRespond& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEquipRespond& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEquipRespond* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEquipRespond* other);

  // implements Message ----------------------------------------------

  CSEquipRespond* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEquipRespond& from);
  void MergeFrom(const CSEquipRespond& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSEquipRefineRsp EquipRefine_Rsp = 1;
  inline bool has_equiprefine_rsp() const;
  inline void clear_equiprefine_rsp();
  static const int kEquipRefineRspFieldNumber = 1;
  inline const ::vmsg::CSEquipRefineRsp& equiprefine_rsp() const;
  inline ::vmsg::CSEquipRefineRsp* mutable_equiprefine_rsp();
  inline ::vmsg::CSEquipRefineRsp* release_equiprefine_rsp();
  inline void set_allocated_equiprefine_rsp(::vmsg::CSEquipRefineRsp* equiprefine_rsp);

  // optional .vmsg.CSEquipTransRsp EquipTrans_Rsp = 2;
  inline bool has_equiptrans_rsp() const;
  inline void clear_equiptrans_rsp();
  static const int kEquipTransRspFieldNumber = 2;
  inline const ::vmsg::CSEquipTransRsp& equiptrans_rsp() const;
  inline ::vmsg::CSEquipTransRsp* mutable_equiptrans_rsp();
  inline ::vmsg::CSEquipTransRsp* release_equiptrans_rsp();
  inline void set_allocated_equiptrans_rsp(::vmsg::CSEquipTransRsp* equiptrans_rsp);

  // optional .vmsg.CSEquipLvUpRsp EquipLvUp_Rsp = 3;
  inline bool has_equiplvup_rsp() const;
  inline void clear_equiplvup_rsp();
  static const int kEquipLvUpRspFieldNumber = 3;
  inline const ::vmsg::CSEquipLvUpRsp& equiplvup_rsp() const;
  inline ::vmsg::CSEquipLvUpRsp* mutable_equiplvup_rsp();
  inline ::vmsg::CSEquipLvUpRsp* release_equiplvup_rsp();
  inline void set_allocated_equiplvup_rsp(::vmsg::CSEquipLvUpRsp* equiplvup_rsp);

  // optional .vmsg.CSEquipStarStepRsp EquipStarStep_Rsp = 4;
  inline bool has_equipstarstep_rsp() const;
  inline void clear_equipstarstep_rsp();
  static const int kEquipStarStepRspFieldNumber = 4;
  inline const ::vmsg::CSEquipStarStepRsp& equipstarstep_rsp() const;
  inline ::vmsg::CSEquipStarStepRsp* mutable_equipstarstep_rsp();
  inline ::vmsg::CSEquipStarStepRsp* release_equipstarstep_rsp();
  inline void set_allocated_equipstarstep_rsp(::vmsg::CSEquipStarStepRsp* equipstarstep_rsp);

  // optional .vmsg.CSEquipRefitRsp EquipRefit_Rsp = 5;
  inline bool has_equiprefit_rsp() const;
  inline void clear_equiprefit_rsp();
  static const int kEquipRefitRspFieldNumber = 5;
  inline const ::vmsg::CSEquipRefitRsp& equiprefit_rsp() const;
  inline ::vmsg::CSEquipRefitRsp* mutable_equiprefit_rsp();
  inline ::vmsg::CSEquipRefitRsp* release_equiprefit_rsp();
  inline void set_allocated_equiprefit_rsp(::vmsg::CSEquipRefitRsp* equiprefit_rsp);

  // @@protoc_insertion_point(class_scope:vmsg.CSEquipRespond)
 private:
  inline void set_has_equiprefine_rsp();
  inline void clear_has_equiprefine_rsp();
  inline void set_has_equiptrans_rsp();
  inline void clear_has_equiptrans_rsp();
  inline void set_has_equiplvup_rsp();
  inline void clear_has_equiplvup_rsp();
  inline void set_has_equipstarstep_rsp();
  inline void clear_has_equipstarstep_rsp();
  inline void set_has_equiprefit_rsp();
  inline void clear_has_equiprefit_rsp();

  ::vmsg::CSEquipRefineRsp* equiprefine_rsp_;
  ::vmsg::CSEquipTransRsp* equiptrans_rsp_;
  ::vmsg::CSEquipLvUpRsp* equiplvup_rsp_;
  ::vmsg::CSEquipStarStepRsp* equipstarstep_rsp_;
  ::vmsg::CSEquipRefitRsp* equiprefit_rsp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSEquipOpMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSEquipOpMsg_2eproto();
  friend void protobuf_ShutdownFile_CSEquipOpMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEquipRespond* default_instance_;
};
// ===================================================================


// ===================================================================

// CSEquipRefineHero

// required uint64 EquipGUID = 1;
inline bool CSEquipRefineHero::has_equipguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEquipRefineHero::set_has_equipguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEquipRefineHero::clear_has_equipguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEquipRefineHero::clear_equipguid() {
  equipguid_ = GOOGLE_ULONGLONG(0);
  clear_has_equipguid();
}
inline ::google::protobuf::uint64 CSEquipRefineHero::equipguid() const {
  return equipguid_;
}
inline void CSEquipRefineHero::set_equipguid(::google::protobuf::uint64 value) {
  set_has_equipguid();
  equipguid_ = value;
}

// -------------------------------------------------------------------

// CSEquipRefineBag

// required int32 BagIdx = 1;
inline bool CSEquipRefineBag::has_bagidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEquipRefineBag::set_has_bagidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEquipRefineBag::clear_has_bagidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEquipRefineBag::clear_bagidx() {
  bagidx_ = 0;
  clear_has_bagidx();
}
inline ::google::protobuf::int32 CSEquipRefineBag::bagidx() const {
  return bagidx_;
}
inline void CSEquipRefineBag::set_bagidx(::google::protobuf::int32 value) {
  set_has_bagidx();
  bagidx_ = value;
}

// required uint64 EquipGUID = 2;
inline bool CSEquipRefineBag::has_equipguid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSEquipRefineBag::set_has_equipguid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSEquipRefineBag::clear_has_equipguid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSEquipRefineBag::clear_equipguid() {
  equipguid_ = GOOGLE_ULONGLONG(0);
  clear_has_equipguid();
}
inline ::google::protobuf::uint64 CSEquipRefineBag::equipguid() const {
  return equipguid_;
}
inline void CSEquipRefineBag::set_equipguid(::google::protobuf::uint64 value) {
  set_has_equipguid();
  equipguid_ = value;
}

// -------------------------------------------------------------------

// CSEquipRefineRqst

// required uint32 Type = 1;
inline bool CSEquipRefineRqst::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEquipRefineRqst::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEquipRefineRqst::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEquipRefineRqst::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSEquipRefineRqst::type() const {
  return type_;
}
inline void CSEquipRefineRqst::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional .vmsg.CSEquipRefineHero EquipRefineHero = 2;
inline bool CSEquipRefineRqst::has_equiprefinehero() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSEquipRefineRqst::set_has_equiprefinehero() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSEquipRefineRqst::clear_has_equiprefinehero() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSEquipRefineRqst::clear_equiprefinehero() {
  if (equiprefinehero_ != NULL) equiprefinehero_->::vmsg::CSEquipRefineHero::Clear();
  clear_has_equiprefinehero();
}
inline const ::vmsg::CSEquipRefineHero& CSEquipRefineRqst::equiprefinehero() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equiprefinehero_ != NULL ? *equiprefinehero_ : *default_instance().equiprefinehero_;
#else
  return equiprefinehero_ != NULL ? *equiprefinehero_ : *default_instance_->equiprefinehero_;
#endif
}
inline ::vmsg::CSEquipRefineHero* CSEquipRefineRqst::mutable_equiprefinehero() {
  set_has_equiprefinehero();
  if (equiprefinehero_ == NULL) equiprefinehero_ = new ::vmsg::CSEquipRefineHero;
  return equiprefinehero_;
}
inline ::vmsg::CSEquipRefineHero* CSEquipRefineRqst::release_equiprefinehero() {
  clear_has_equiprefinehero();
  ::vmsg::CSEquipRefineHero* temp = equiprefinehero_;
  equiprefinehero_ = NULL;
  return temp;
}
inline void CSEquipRefineRqst::set_allocated_equiprefinehero(::vmsg::CSEquipRefineHero* equiprefinehero) {
  delete equiprefinehero_;
  equiprefinehero_ = equiprefinehero;
  if (equiprefinehero) {
    set_has_equiprefinehero();
  } else {
    clear_has_equiprefinehero();
  }
}

// optional .vmsg.CSEquipRefineBag EquipRefineBag = 3;
inline bool CSEquipRefineRqst::has_equiprefinebag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSEquipRefineRqst::set_has_equiprefinebag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSEquipRefineRqst::clear_has_equiprefinebag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSEquipRefineRqst::clear_equiprefinebag() {
  if (equiprefinebag_ != NULL) equiprefinebag_->::vmsg::CSEquipRefineBag::Clear();
  clear_has_equiprefinebag();
}
inline const ::vmsg::CSEquipRefineBag& CSEquipRefineRqst::equiprefinebag() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equiprefinebag_ != NULL ? *equiprefinebag_ : *default_instance().equiprefinebag_;
#else
  return equiprefinebag_ != NULL ? *equiprefinebag_ : *default_instance_->equiprefinebag_;
#endif
}
inline ::vmsg::CSEquipRefineBag* CSEquipRefineRqst::mutable_equiprefinebag() {
  set_has_equiprefinebag();
  if (equiprefinebag_ == NULL) equiprefinebag_ = new ::vmsg::CSEquipRefineBag;
  return equiprefinebag_;
}
inline ::vmsg::CSEquipRefineBag* CSEquipRefineRqst::release_equiprefinebag() {
  clear_has_equiprefinebag();
  ::vmsg::CSEquipRefineBag* temp = equiprefinebag_;
  equiprefinebag_ = NULL;
  return temp;
}
inline void CSEquipRefineRqst::set_allocated_equiprefinebag(::vmsg::CSEquipRefineBag* equiprefinebag) {
  delete equiprefinebag_;
  equiprefinebag_ = equiprefinebag;
  if (equiprefinebag) {
    set_has_equiprefinebag();
  } else {
    clear_has_equiprefinebag();
  }
}

// required uint32 SelProtect = 4;
inline bool CSEquipRefineRqst::has_selprotect() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSEquipRefineRqst::set_has_selprotect() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSEquipRefineRqst::clear_has_selprotect() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSEquipRefineRqst::clear_selprotect() {
  selprotect_ = 0u;
  clear_has_selprotect();
}
inline ::google::protobuf::uint32 CSEquipRefineRqst::selprotect() const {
  return selprotect_;
}
inline void CSEquipRefineRqst::set_selprotect(::google::protobuf::uint32 value) {
  set_has_selprotect();
  selprotect_ = value;
}

// -------------------------------------------------------------------

// CSEquipRefineRsp

// required uint64 EquipGUID = 1;
inline bool CSEquipRefineRsp::has_equipguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEquipRefineRsp::set_has_equipguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEquipRefineRsp::clear_has_equipguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEquipRefineRsp::clear_equipguid() {
  equipguid_ = GOOGLE_ULONGLONG(0);
  clear_has_equipguid();
}
inline ::google::protobuf::uint64 CSEquipRefineRsp::equipguid() const {
  return equipguid_;
}
inline void CSEquipRefineRsp::set_equipguid(::google::protobuf::uint64 value) {
  set_has_equipguid();
  equipguid_ = value;
}

// required uint32 RefineLv = 2;
inline bool CSEquipRefineRsp::has_refinelv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSEquipRefineRsp::set_has_refinelv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSEquipRefineRsp::clear_has_refinelv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSEquipRefineRsp::clear_refinelv() {
  refinelv_ = 0u;
  clear_has_refinelv();
}
inline ::google::protobuf::uint32 CSEquipRefineRsp::refinelv() const {
  return refinelv_;
}
inline void CSEquipRefineRsp::set_refinelv(::google::protobuf::uint32 value) {
  set_has_refinelv();
  refinelv_ = value;
}

// -------------------------------------------------------------------

// CSEquipTransRefineInfo

// required uint32 Type = 1;
inline bool CSEquipTransRefineInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEquipTransRefineInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEquipTransRefineInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEquipTransRefineInfo::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSEquipTransRefineInfo::type() const {
  return type_;
}
inline void CSEquipTransRefineInfo::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required uint64 EquipGUID = 2;
inline bool CSEquipTransRefineInfo::has_equipguid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSEquipTransRefineInfo::set_has_equipguid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSEquipTransRefineInfo::clear_has_equipguid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSEquipTransRefineInfo::clear_equipguid() {
  equipguid_ = GOOGLE_ULONGLONG(0);
  clear_has_equipguid();
}
inline ::google::protobuf::uint64 CSEquipTransRefineInfo::equipguid() const {
  return equipguid_;
}
inline void CSEquipTransRefineInfo::set_equipguid(::google::protobuf::uint64 value) {
  set_has_equipguid();
  equipguid_ = value;
}

// optional int32 BagIdx = 3;
inline bool CSEquipTransRefineInfo::has_bagidx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSEquipTransRefineInfo::set_has_bagidx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSEquipTransRefineInfo::clear_has_bagidx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSEquipTransRefineInfo::clear_bagidx() {
  bagidx_ = 0;
  clear_has_bagidx();
}
inline ::google::protobuf::int32 CSEquipTransRefineInfo::bagidx() const {
  return bagidx_;
}
inline void CSEquipTransRefineInfo::set_bagidx(::google::protobuf::int32 value) {
  set_has_bagidx();
  bagidx_ = value;
}

// -------------------------------------------------------------------

// CSEquipTransRqst

// required .vmsg.CSEquipTransRefineInfo FromEquip = 1;
inline bool CSEquipTransRqst::has_fromequip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEquipTransRqst::set_has_fromequip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEquipTransRqst::clear_has_fromequip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEquipTransRqst::clear_fromequip() {
  if (fromequip_ != NULL) fromequip_->::vmsg::CSEquipTransRefineInfo::Clear();
  clear_has_fromequip();
}
inline const ::vmsg::CSEquipTransRefineInfo& CSEquipTransRqst::fromequip() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fromequip_ != NULL ? *fromequip_ : *default_instance().fromequip_;
#else
  return fromequip_ != NULL ? *fromequip_ : *default_instance_->fromequip_;
#endif
}
inline ::vmsg::CSEquipTransRefineInfo* CSEquipTransRqst::mutable_fromequip() {
  set_has_fromequip();
  if (fromequip_ == NULL) fromequip_ = new ::vmsg::CSEquipTransRefineInfo;
  return fromequip_;
}
inline ::vmsg::CSEquipTransRefineInfo* CSEquipTransRqst::release_fromequip() {
  clear_has_fromequip();
  ::vmsg::CSEquipTransRefineInfo* temp = fromequip_;
  fromequip_ = NULL;
  return temp;
}
inline void CSEquipTransRqst::set_allocated_fromequip(::vmsg::CSEquipTransRefineInfo* fromequip) {
  delete fromequip_;
  fromequip_ = fromequip;
  if (fromequip) {
    set_has_fromequip();
  } else {
    clear_has_fromequip();
  }
}

// required .vmsg.CSEquipTransRefineInfo ToEquip = 2;
inline bool CSEquipTransRqst::has_toequip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSEquipTransRqst::set_has_toequip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSEquipTransRqst::clear_has_toequip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSEquipTransRqst::clear_toequip() {
  if (toequip_ != NULL) toequip_->::vmsg::CSEquipTransRefineInfo::Clear();
  clear_has_toequip();
}
inline const ::vmsg::CSEquipTransRefineInfo& CSEquipTransRqst::toequip() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return toequip_ != NULL ? *toequip_ : *default_instance().toequip_;
#else
  return toequip_ != NULL ? *toequip_ : *default_instance_->toequip_;
#endif
}
inline ::vmsg::CSEquipTransRefineInfo* CSEquipTransRqst::mutable_toequip() {
  set_has_toequip();
  if (toequip_ == NULL) toequip_ = new ::vmsg::CSEquipTransRefineInfo;
  return toequip_;
}
inline ::vmsg::CSEquipTransRefineInfo* CSEquipTransRqst::release_toequip() {
  clear_has_toequip();
  ::vmsg::CSEquipTransRefineInfo* temp = toequip_;
  toequip_ = NULL;
  return temp;
}
inline void CSEquipTransRqst::set_allocated_toequip(::vmsg::CSEquipTransRefineInfo* toequip) {
  delete toequip_;
  toequip_ = toequip;
  if (toequip) {
    set_has_toequip();
  } else {
    clear_has_toequip();
  }
}

// -------------------------------------------------------------------

// CSEquipTransRsp

// required uint64 FromEquipGUID = 1;
inline bool CSEquipTransRsp::has_fromequipguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEquipTransRsp::set_has_fromequipguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEquipTransRsp::clear_has_fromequipguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEquipTransRsp::clear_fromequipguid() {
  fromequipguid_ = GOOGLE_ULONGLONG(0);
  clear_has_fromequipguid();
}
inline ::google::protobuf::uint64 CSEquipTransRsp::fromequipguid() const {
  return fromequipguid_;
}
inline void CSEquipTransRsp::set_fromequipguid(::google::protobuf::uint64 value) {
  set_has_fromequipguid();
  fromequipguid_ = value;
}

// required uint32 FromRefineLv = 2;
inline bool CSEquipTransRsp::has_fromrefinelv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSEquipTransRsp::set_has_fromrefinelv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSEquipTransRsp::clear_has_fromrefinelv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSEquipTransRsp::clear_fromrefinelv() {
  fromrefinelv_ = 0u;
  clear_has_fromrefinelv();
}
inline ::google::protobuf::uint32 CSEquipTransRsp::fromrefinelv() const {
  return fromrefinelv_;
}
inline void CSEquipTransRsp::set_fromrefinelv(::google::protobuf::uint32 value) {
  set_has_fromrefinelv();
  fromrefinelv_ = value;
}

// required uint64 ToEquipGUID = 3;
inline bool CSEquipTransRsp::has_toequipguid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSEquipTransRsp::set_has_toequipguid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSEquipTransRsp::clear_has_toequipguid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSEquipTransRsp::clear_toequipguid() {
  toequipguid_ = GOOGLE_ULONGLONG(0);
  clear_has_toequipguid();
}
inline ::google::protobuf::uint64 CSEquipTransRsp::toequipguid() const {
  return toequipguid_;
}
inline void CSEquipTransRsp::set_toequipguid(::google::protobuf::uint64 value) {
  set_has_toequipguid();
  toequipguid_ = value;
}

// required uint32 ToRefineLv = 4;
inline bool CSEquipTransRsp::has_torefinelv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSEquipTransRsp::set_has_torefinelv() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSEquipTransRsp::clear_has_torefinelv() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSEquipTransRsp::clear_torefinelv() {
  torefinelv_ = 0u;
  clear_has_torefinelv();
}
inline ::google::protobuf::uint32 CSEquipTransRsp::torefinelv() const {
  return torefinelv_;
}
inline void CSEquipTransRsp::set_torefinelv(::google::protobuf::uint32 value) {
  set_has_torefinelv();
  torefinelv_ = value;
}

// -------------------------------------------------------------------

// CSEquipLvUpConsume

// required uint32 Type = 1;
inline bool CSEquipLvUpConsume::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEquipLvUpConsume::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEquipLvUpConsume::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEquipLvUpConsume::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSEquipLvUpConsume::type() const {
  return type_;
}
inline void CSEquipLvUpConsume::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required uint64 ID = 2;
inline bool CSEquipLvUpConsume::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSEquipLvUpConsume::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSEquipLvUpConsume::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSEquipLvUpConsume::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 CSEquipLvUpConsume::id() const {
  return id_;
}
inline void CSEquipLvUpConsume::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// required uint64 Cnt = 3;
inline bool CSEquipLvUpConsume::has_cnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSEquipLvUpConsume::set_has_cnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSEquipLvUpConsume::clear_has_cnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSEquipLvUpConsume::clear_cnt() {
  cnt_ = GOOGLE_ULONGLONG(0);
  clear_has_cnt();
}
inline ::google::protobuf::uint64 CSEquipLvUpConsume::cnt() const {
  return cnt_;
}
inline void CSEquipLvUpConsume::set_cnt(::google::protobuf::uint64 value) {
  set_has_cnt();
  cnt_ = value;
}

// -------------------------------------------------------------------

// CSEquipLvUpRqst

// required int32 BagIdx = 1;
inline bool CSEquipLvUpRqst::has_bagidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEquipLvUpRqst::set_has_bagidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEquipLvUpRqst::clear_has_bagidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEquipLvUpRqst::clear_bagidx() {
  bagidx_ = 0;
  clear_has_bagidx();
}
inline ::google::protobuf::int32 CSEquipLvUpRqst::bagidx() const {
  return bagidx_;
}
inline void CSEquipLvUpRqst::set_bagidx(::google::protobuf::int32 value) {
  set_has_bagidx();
  bagidx_ = value;
}

// required uint64 EquipGUID = 2;
inline bool CSEquipLvUpRqst::has_equipguid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSEquipLvUpRqst::set_has_equipguid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSEquipLvUpRqst::clear_has_equipguid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSEquipLvUpRqst::clear_equipguid() {
  equipguid_ = GOOGLE_ULONGLONG(0);
  clear_has_equipguid();
}
inline ::google::protobuf::uint64 CSEquipLvUpRqst::equipguid() const {
  return equipguid_;
}
inline void CSEquipLvUpRqst::set_equipguid(::google::protobuf::uint64 value) {
  set_has_equipguid();
  equipguid_ = value;
}

// repeated .vmsg.CSEquipLvUpConsume Consumes = 3;
inline int CSEquipLvUpRqst::consumes_size() const {
  return consumes_.size();
}
inline void CSEquipLvUpRqst::clear_consumes() {
  consumes_.Clear();
}
inline const ::vmsg::CSEquipLvUpConsume& CSEquipLvUpRqst::consumes(int index) const {
  return consumes_.Get(index);
}
inline ::vmsg::CSEquipLvUpConsume* CSEquipLvUpRqst::mutable_consumes(int index) {
  return consumes_.Mutable(index);
}
inline ::vmsg::CSEquipLvUpConsume* CSEquipLvUpRqst::add_consumes() {
  return consumes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSEquipLvUpConsume >&
CSEquipLvUpRqst::consumes() const {
  return consumes_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSEquipLvUpConsume >*
CSEquipLvUpRqst::mutable_consumes() {
  return &consumes_;
}

// -------------------------------------------------------------------

// CSPlayerEquipInfo

// repeated .vmsg.CSEquipInfo EquipLst = 1;
inline int CSPlayerEquipInfo::equiplst_size() const {
  return equiplst_.size();
}
inline void CSPlayerEquipInfo::clear_equiplst() {
  equiplst_.Clear();
}
inline const ::vmsg::CSEquipInfo& CSPlayerEquipInfo::equiplst(int index) const {
  return equiplst_.Get(index);
}
inline ::vmsg::CSEquipInfo* CSPlayerEquipInfo::mutable_equiplst(int index) {
  return equiplst_.Mutable(index);
}
inline ::vmsg::CSEquipInfo* CSPlayerEquipInfo::add_equiplst() {
  return equiplst_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSEquipInfo >&
CSPlayerEquipInfo::equiplst() const {
  return equiplst_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSEquipInfo >*
CSPlayerEquipInfo::mutable_equiplst() {
  return &equiplst_;
}

// required .vmsg.CSEquipInfo SpareEquip = 2;
inline bool CSPlayerEquipInfo::has_spareequip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerEquipInfo::set_has_spareequip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerEquipInfo::clear_has_spareequip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerEquipInfo::clear_spareequip() {
  if (spareequip_ != NULL) spareequip_->::vmsg::CSEquipInfo::Clear();
  clear_has_spareequip();
}
inline const ::vmsg::CSEquipInfo& CSPlayerEquipInfo::spareequip() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return spareequip_ != NULL ? *spareequip_ : *default_instance().spareequip_;
#else
  return spareequip_ != NULL ? *spareequip_ : *default_instance_->spareequip_;
#endif
}
inline ::vmsg::CSEquipInfo* CSPlayerEquipInfo::mutable_spareequip() {
  set_has_spareequip();
  if (spareequip_ == NULL) spareequip_ = new ::vmsg::CSEquipInfo;
  return spareequip_;
}
inline ::vmsg::CSEquipInfo* CSPlayerEquipInfo::release_spareequip() {
  clear_has_spareequip();
  ::vmsg::CSEquipInfo* temp = spareequip_;
  spareequip_ = NULL;
  return temp;
}
inline void CSPlayerEquipInfo::set_allocated_spareequip(::vmsg::CSEquipInfo* spareequip) {
  delete spareequip_;
  spareequip_ = spareequip;
  if (spareequip) {
    set_has_spareequip();
  } else {
    clear_has_spareequip();
  }
}

// -------------------------------------------------------------------

// CSEquipLvUpRsp

// required .vmsg.CSBagInfo BagInfo = 1;
inline bool CSEquipLvUpRsp::has_baginfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEquipLvUpRsp::set_has_baginfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEquipLvUpRsp::clear_has_baginfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEquipLvUpRsp::clear_baginfo() {
  if (baginfo_ != NULL) baginfo_->::vmsg::CSBagInfo::Clear();
  clear_has_baginfo();
}
inline const ::vmsg::CSBagInfo& CSEquipLvUpRsp::baginfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return baginfo_ != NULL ? *baginfo_ : *default_instance().baginfo_;
#else
  return baginfo_ != NULL ? *baginfo_ : *default_instance_->baginfo_;
#endif
}
inline ::vmsg::CSBagInfo* CSEquipLvUpRsp::mutable_baginfo() {
  set_has_baginfo();
  if (baginfo_ == NULL) baginfo_ = new ::vmsg::CSBagInfo;
  return baginfo_;
}
inline ::vmsg::CSBagInfo* CSEquipLvUpRsp::release_baginfo() {
  clear_has_baginfo();
  ::vmsg::CSBagInfo* temp = baginfo_;
  baginfo_ = NULL;
  return temp;
}
inline void CSEquipLvUpRsp::set_allocated_baginfo(::vmsg::CSBagInfo* baginfo) {
  delete baginfo_;
  baginfo_ = baginfo;
  if (baginfo) {
    set_has_baginfo();
  } else {
    clear_has_baginfo();
  }
}

// required .vmsg.CSPlayerEquipInfo PlayerEquipInfo = 2;
inline bool CSEquipLvUpRsp::has_playerequipinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSEquipLvUpRsp::set_has_playerequipinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSEquipLvUpRsp::clear_has_playerequipinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSEquipLvUpRsp::clear_playerequipinfo() {
  if (playerequipinfo_ != NULL) playerequipinfo_->::vmsg::CSPlayerEquipInfo::Clear();
  clear_has_playerequipinfo();
}
inline const ::vmsg::CSPlayerEquipInfo& CSEquipLvUpRsp::playerequipinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerequipinfo_ != NULL ? *playerequipinfo_ : *default_instance().playerequipinfo_;
#else
  return playerequipinfo_ != NULL ? *playerequipinfo_ : *default_instance_->playerequipinfo_;
#endif
}
inline ::vmsg::CSPlayerEquipInfo* CSEquipLvUpRsp::mutable_playerequipinfo() {
  set_has_playerequipinfo();
  if (playerequipinfo_ == NULL) playerequipinfo_ = new ::vmsg::CSPlayerEquipInfo;
  return playerequipinfo_;
}
inline ::vmsg::CSPlayerEquipInfo* CSEquipLvUpRsp::release_playerequipinfo() {
  clear_has_playerequipinfo();
  ::vmsg::CSPlayerEquipInfo* temp = playerequipinfo_;
  playerequipinfo_ = NULL;
  return temp;
}
inline void CSEquipLvUpRsp::set_allocated_playerequipinfo(::vmsg::CSPlayerEquipInfo* playerequipinfo) {
  delete playerequipinfo_;
  playerequipinfo_ = playerequipinfo;
  if (playerequipinfo) {
    set_has_playerequipinfo();
  } else {
    clear_has_playerequipinfo();
  }
}

// -------------------------------------------------------------------

// CSEquipStarStepRqst

// required int32 BagIdx = 1;
inline bool CSEquipStarStepRqst::has_bagidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEquipStarStepRqst::set_has_bagidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEquipStarStepRqst::clear_has_bagidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEquipStarStepRqst::clear_bagidx() {
  bagidx_ = 0;
  clear_has_bagidx();
}
inline ::google::protobuf::int32 CSEquipStarStepRqst::bagidx() const {
  return bagidx_;
}
inline void CSEquipStarStepRqst::set_bagidx(::google::protobuf::int32 value) {
  set_has_bagidx();
  bagidx_ = value;
}

// required uint64 EquipGUID = 2;
inline bool CSEquipStarStepRqst::has_equipguid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSEquipStarStepRqst::set_has_equipguid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSEquipStarStepRqst::clear_has_equipguid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSEquipStarStepRqst::clear_equipguid() {
  equipguid_ = GOOGLE_ULONGLONG(0);
  clear_has_equipguid();
}
inline ::google::protobuf::uint64 CSEquipStarStepRqst::equipguid() const {
  return equipguid_;
}
inline void CSEquipStarStepRqst::set_equipguid(::google::protobuf::uint64 value) {
  set_has_equipguid();
  equipguid_ = value;
}

// repeated uint64 NeedEquipGUIDs = 3;
inline int CSEquipStarStepRqst::needequipguids_size() const {
  return needequipguids_.size();
}
inline void CSEquipStarStepRqst::clear_needequipguids() {
  needequipguids_.Clear();
}
inline ::google::protobuf::uint64 CSEquipStarStepRqst::needequipguids(int index) const {
  return needequipguids_.Get(index);
}
inline void CSEquipStarStepRqst::set_needequipguids(int index, ::google::protobuf::uint64 value) {
  needequipguids_.Set(index, value);
}
inline void CSEquipStarStepRqst::add_needequipguids(::google::protobuf::uint64 value) {
  needequipguids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CSEquipStarStepRqst::needequipguids() const {
  return needequipguids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CSEquipStarStepRqst::mutable_needequipguids() {
  return &needequipguids_;
}

// -------------------------------------------------------------------

// CSEquipStarStepRsp

// required .vmsg.CSBagInfo BagInfo = 1;
inline bool CSEquipStarStepRsp::has_baginfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEquipStarStepRsp::set_has_baginfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEquipStarStepRsp::clear_has_baginfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEquipStarStepRsp::clear_baginfo() {
  if (baginfo_ != NULL) baginfo_->::vmsg::CSBagInfo::Clear();
  clear_has_baginfo();
}
inline const ::vmsg::CSBagInfo& CSEquipStarStepRsp::baginfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return baginfo_ != NULL ? *baginfo_ : *default_instance().baginfo_;
#else
  return baginfo_ != NULL ? *baginfo_ : *default_instance_->baginfo_;
#endif
}
inline ::vmsg::CSBagInfo* CSEquipStarStepRsp::mutable_baginfo() {
  set_has_baginfo();
  if (baginfo_ == NULL) baginfo_ = new ::vmsg::CSBagInfo;
  return baginfo_;
}
inline ::vmsg::CSBagInfo* CSEquipStarStepRsp::release_baginfo() {
  clear_has_baginfo();
  ::vmsg::CSBagInfo* temp = baginfo_;
  baginfo_ = NULL;
  return temp;
}
inline void CSEquipStarStepRsp::set_allocated_baginfo(::vmsg::CSBagInfo* baginfo) {
  delete baginfo_;
  baginfo_ = baginfo;
  if (baginfo) {
    set_has_baginfo();
  } else {
    clear_has_baginfo();
  }
}

// required .vmsg.CSPlayerEquipInfo PlayerEquipInfo = 2;
inline bool CSEquipStarStepRsp::has_playerequipinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSEquipStarStepRsp::set_has_playerequipinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSEquipStarStepRsp::clear_has_playerequipinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSEquipStarStepRsp::clear_playerequipinfo() {
  if (playerequipinfo_ != NULL) playerequipinfo_->::vmsg::CSPlayerEquipInfo::Clear();
  clear_has_playerequipinfo();
}
inline const ::vmsg::CSPlayerEquipInfo& CSEquipStarStepRsp::playerequipinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerequipinfo_ != NULL ? *playerequipinfo_ : *default_instance().playerequipinfo_;
#else
  return playerequipinfo_ != NULL ? *playerequipinfo_ : *default_instance_->playerequipinfo_;
#endif
}
inline ::vmsg::CSPlayerEquipInfo* CSEquipStarStepRsp::mutable_playerequipinfo() {
  set_has_playerequipinfo();
  if (playerequipinfo_ == NULL) playerequipinfo_ = new ::vmsg::CSPlayerEquipInfo;
  return playerequipinfo_;
}
inline ::vmsg::CSPlayerEquipInfo* CSEquipStarStepRsp::release_playerequipinfo() {
  clear_has_playerequipinfo();
  ::vmsg::CSPlayerEquipInfo* temp = playerequipinfo_;
  playerequipinfo_ = NULL;
  return temp;
}
inline void CSEquipStarStepRsp::set_allocated_playerequipinfo(::vmsg::CSPlayerEquipInfo* playerequipinfo) {
  delete playerequipinfo_;
  playerequipinfo_ = playerequipinfo;
  if (playerequipinfo) {
    set_has_playerequipinfo();
  } else {
    clear_has_playerequipinfo();
  }
}

// -------------------------------------------------------------------

// CSEquipRefitRqst

// required int32 BagIdx = 1;
inline bool CSEquipRefitRqst::has_bagidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEquipRefitRqst::set_has_bagidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEquipRefitRqst::clear_has_bagidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEquipRefitRqst::clear_bagidx() {
  bagidx_ = 0;
  clear_has_bagidx();
}
inline ::google::protobuf::int32 CSEquipRefitRqst::bagidx() const {
  return bagidx_;
}
inline void CSEquipRefitRqst::set_bagidx(::google::protobuf::int32 value) {
  set_has_bagidx();
  bagidx_ = value;
}

// required uint64 EquipGUID = 2;
inline bool CSEquipRefitRqst::has_equipguid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSEquipRefitRqst::set_has_equipguid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSEquipRefitRqst::clear_has_equipguid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSEquipRefitRqst::clear_equipguid() {
  equipguid_ = GOOGLE_ULONGLONG(0);
  clear_has_equipguid();
}
inline ::google::protobuf::uint64 CSEquipRefitRqst::equipguid() const {
  return equipguid_;
}
inline void CSEquipRefitRqst::set_equipguid(::google::protobuf::uint64 value) {
  set_has_equipguid();
  equipguid_ = value;
}

// -------------------------------------------------------------------

// CSEquipRefitRsp

// required .vmsg.CSBagInfo BagInfo = 1;
inline bool CSEquipRefitRsp::has_baginfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEquipRefitRsp::set_has_baginfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEquipRefitRsp::clear_has_baginfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEquipRefitRsp::clear_baginfo() {
  if (baginfo_ != NULL) baginfo_->::vmsg::CSBagInfo::Clear();
  clear_has_baginfo();
}
inline const ::vmsg::CSBagInfo& CSEquipRefitRsp::baginfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return baginfo_ != NULL ? *baginfo_ : *default_instance().baginfo_;
#else
  return baginfo_ != NULL ? *baginfo_ : *default_instance_->baginfo_;
#endif
}
inline ::vmsg::CSBagInfo* CSEquipRefitRsp::mutable_baginfo() {
  set_has_baginfo();
  if (baginfo_ == NULL) baginfo_ = new ::vmsg::CSBagInfo;
  return baginfo_;
}
inline ::vmsg::CSBagInfo* CSEquipRefitRsp::release_baginfo() {
  clear_has_baginfo();
  ::vmsg::CSBagInfo* temp = baginfo_;
  baginfo_ = NULL;
  return temp;
}
inline void CSEquipRefitRsp::set_allocated_baginfo(::vmsg::CSBagInfo* baginfo) {
  delete baginfo_;
  baginfo_ = baginfo;
  if (baginfo) {
    set_has_baginfo();
  } else {
    clear_has_baginfo();
  }
}

// required .vmsg.CSPlayerEquipInfo PlayerEquipInfo = 2;
inline bool CSEquipRefitRsp::has_playerequipinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSEquipRefitRsp::set_has_playerequipinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSEquipRefitRsp::clear_has_playerequipinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSEquipRefitRsp::clear_playerequipinfo() {
  if (playerequipinfo_ != NULL) playerequipinfo_->::vmsg::CSPlayerEquipInfo::Clear();
  clear_has_playerequipinfo();
}
inline const ::vmsg::CSPlayerEquipInfo& CSEquipRefitRsp::playerequipinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerequipinfo_ != NULL ? *playerequipinfo_ : *default_instance().playerequipinfo_;
#else
  return playerequipinfo_ != NULL ? *playerequipinfo_ : *default_instance_->playerequipinfo_;
#endif
}
inline ::vmsg::CSPlayerEquipInfo* CSEquipRefitRsp::mutable_playerequipinfo() {
  set_has_playerequipinfo();
  if (playerequipinfo_ == NULL) playerequipinfo_ = new ::vmsg::CSPlayerEquipInfo;
  return playerequipinfo_;
}
inline ::vmsg::CSPlayerEquipInfo* CSEquipRefitRsp::release_playerequipinfo() {
  clear_has_playerequipinfo();
  ::vmsg::CSPlayerEquipInfo* temp = playerequipinfo_;
  playerequipinfo_ = NULL;
  return temp;
}
inline void CSEquipRefitRsp::set_allocated_playerequipinfo(::vmsg::CSPlayerEquipInfo* playerequipinfo) {
  delete playerequipinfo_;
  playerequipinfo_ = playerequipinfo;
  if (playerequipinfo) {
    set_has_playerequipinfo();
  } else {
    clear_has_playerequipinfo();
  }
}

// -------------------------------------------------------------------

// CSEquipRequest

// optional .vmsg.CSEquipRefineRqst EquipRefine_Rqst = 1;
inline bool CSEquipRequest::has_equiprefine_rqst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEquipRequest::set_has_equiprefine_rqst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEquipRequest::clear_has_equiprefine_rqst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEquipRequest::clear_equiprefine_rqst() {
  if (equiprefine_rqst_ != NULL) equiprefine_rqst_->::vmsg::CSEquipRefineRqst::Clear();
  clear_has_equiprefine_rqst();
}
inline const ::vmsg::CSEquipRefineRqst& CSEquipRequest::equiprefine_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equiprefine_rqst_ != NULL ? *equiprefine_rqst_ : *default_instance().equiprefine_rqst_;
#else
  return equiprefine_rqst_ != NULL ? *equiprefine_rqst_ : *default_instance_->equiprefine_rqst_;
#endif
}
inline ::vmsg::CSEquipRefineRqst* CSEquipRequest::mutable_equiprefine_rqst() {
  set_has_equiprefine_rqst();
  if (equiprefine_rqst_ == NULL) equiprefine_rqst_ = new ::vmsg::CSEquipRefineRqst;
  return equiprefine_rqst_;
}
inline ::vmsg::CSEquipRefineRqst* CSEquipRequest::release_equiprefine_rqst() {
  clear_has_equiprefine_rqst();
  ::vmsg::CSEquipRefineRqst* temp = equiprefine_rqst_;
  equiprefine_rqst_ = NULL;
  return temp;
}
inline void CSEquipRequest::set_allocated_equiprefine_rqst(::vmsg::CSEquipRefineRqst* equiprefine_rqst) {
  delete equiprefine_rqst_;
  equiprefine_rqst_ = equiprefine_rqst;
  if (equiprefine_rqst) {
    set_has_equiprefine_rqst();
  } else {
    clear_has_equiprefine_rqst();
  }
}

// optional .vmsg.CSEquipTransRqst EquipTrans_Rqst = 2;
inline bool CSEquipRequest::has_equiptrans_rqst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSEquipRequest::set_has_equiptrans_rqst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSEquipRequest::clear_has_equiptrans_rqst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSEquipRequest::clear_equiptrans_rqst() {
  if (equiptrans_rqst_ != NULL) equiptrans_rqst_->::vmsg::CSEquipTransRqst::Clear();
  clear_has_equiptrans_rqst();
}
inline const ::vmsg::CSEquipTransRqst& CSEquipRequest::equiptrans_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equiptrans_rqst_ != NULL ? *equiptrans_rqst_ : *default_instance().equiptrans_rqst_;
#else
  return equiptrans_rqst_ != NULL ? *equiptrans_rqst_ : *default_instance_->equiptrans_rqst_;
#endif
}
inline ::vmsg::CSEquipTransRqst* CSEquipRequest::mutable_equiptrans_rqst() {
  set_has_equiptrans_rqst();
  if (equiptrans_rqst_ == NULL) equiptrans_rqst_ = new ::vmsg::CSEquipTransRqst;
  return equiptrans_rqst_;
}
inline ::vmsg::CSEquipTransRqst* CSEquipRequest::release_equiptrans_rqst() {
  clear_has_equiptrans_rqst();
  ::vmsg::CSEquipTransRqst* temp = equiptrans_rqst_;
  equiptrans_rqst_ = NULL;
  return temp;
}
inline void CSEquipRequest::set_allocated_equiptrans_rqst(::vmsg::CSEquipTransRqst* equiptrans_rqst) {
  delete equiptrans_rqst_;
  equiptrans_rqst_ = equiptrans_rqst;
  if (equiptrans_rqst) {
    set_has_equiptrans_rqst();
  } else {
    clear_has_equiptrans_rqst();
  }
}

// optional .vmsg.CSEquipLvUpRqst EquipLvUp_Rqst = 3;
inline bool CSEquipRequest::has_equiplvup_rqst() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSEquipRequest::set_has_equiplvup_rqst() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSEquipRequest::clear_has_equiplvup_rqst() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSEquipRequest::clear_equiplvup_rqst() {
  if (equiplvup_rqst_ != NULL) equiplvup_rqst_->::vmsg::CSEquipLvUpRqst::Clear();
  clear_has_equiplvup_rqst();
}
inline const ::vmsg::CSEquipLvUpRqst& CSEquipRequest::equiplvup_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equiplvup_rqst_ != NULL ? *equiplvup_rqst_ : *default_instance().equiplvup_rqst_;
#else
  return equiplvup_rqst_ != NULL ? *equiplvup_rqst_ : *default_instance_->equiplvup_rqst_;
#endif
}
inline ::vmsg::CSEquipLvUpRqst* CSEquipRequest::mutable_equiplvup_rqst() {
  set_has_equiplvup_rqst();
  if (equiplvup_rqst_ == NULL) equiplvup_rqst_ = new ::vmsg::CSEquipLvUpRqst;
  return equiplvup_rqst_;
}
inline ::vmsg::CSEquipLvUpRqst* CSEquipRequest::release_equiplvup_rqst() {
  clear_has_equiplvup_rqst();
  ::vmsg::CSEquipLvUpRqst* temp = equiplvup_rqst_;
  equiplvup_rqst_ = NULL;
  return temp;
}
inline void CSEquipRequest::set_allocated_equiplvup_rqst(::vmsg::CSEquipLvUpRqst* equiplvup_rqst) {
  delete equiplvup_rqst_;
  equiplvup_rqst_ = equiplvup_rqst;
  if (equiplvup_rqst) {
    set_has_equiplvup_rqst();
  } else {
    clear_has_equiplvup_rqst();
  }
}

// optional .vmsg.CSEquipStarStepRqst EquipStarStep_Rqst = 4;
inline bool CSEquipRequest::has_equipstarstep_rqst() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSEquipRequest::set_has_equipstarstep_rqst() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSEquipRequest::clear_has_equipstarstep_rqst() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSEquipRequest::clear_equipstarstep_rqst() {
  if (equipstarstep_rqst_ != NULL) equipstarstep_rqst_->::vmsg::CSEquipStarStepRqst::Clear();
  clear_has_equipstarstep_rqst();
}
inline const ::vmsg::CSEquipStarStepRqst& CSEquipRequest::equipstarstep_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equipstarstep_rqst_ != NULL ? *equipstarstep_rqst_ : *default_instance().equipstarstep_rqst_;
#else
  return equipstarstep_rqst_ != NULL ? *equipstarstep_rqst_ : *default_instance_->equipstarstep_rqst_;
#endif
}
inline ::vmsg::CSEquipStarStepRqst* CSEquipRequest::mutable_equipstarstep_rqst() {
  set_has_equipstarstep_rqst();
  if (equipstarstep_rqst_ == NULL) equipstarstep_rqst_ = new ::vmsg::CSEquipStarStepRqst;
  return equipstarstep_rqst_;
}
inline ::vmsg::CSEquipStarStepRqst* CSEquipRequest::release_equipstarstep_rqst() {
  clear_has_equipstarstep_rqst();
  ::vmsg::CSEquipStarStepRqst* temp = equipstarstep_rqst_;
  equipstarstep_rqst_ = NULL;
  return temp;
}
inline void CSEquipRequest::set_allocated_equipstarstep_rqst(::vmsg::CSEquipStarStepRqst* equipstarstep_rqst) {
  delete equipstarstep_rqst_;
  equipstarstep_rqst_ = equipstarstep_rqst;
  if (equipstarstep_rqst) {
    set_has_equipstarstep_rqst();
  } else {
    clear_has_equipstarstep_rqst();
  }
}

// optional .vmsg.CSEquipRefitRqst EquipRefit_Rqst = 5;
inline bool CSEquipRequest::has_equiprefit_rqst() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSEquipRequest::set_has_equiprefit_rqst() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSEquipRequest::clear_has_equiprefit_rqst() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSEquipRequest::clear_equiprefit_rqst() {
  if (equiprefit_rqst_ != NULL) equiprefit_rqst_->::vmsg::CSEquipRefitRqst::Clear();
  clear_has_equiprefit_rqst();
}
inline const ::vmsg::CSEquipRefitRqst& CSEquipRequest::equiprefit_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equiprefit_rqst_ != NULL ? *equiprefit_rqst_ : *default_instance().equiprefit_rqst_;
#else
  return equiprefit_rqst_ != NULL ? *equiprefit_rqst_ : *default_instance_->equiprefit_rqst_;
#endif
}
inline ::vmsg::CSEquipRefitRqst* CSEquipRequest::mutable_equiprefit_rqst() {
  set_has_equiprefit_rqst();
  if (equiprefit_rqst_ == NULL) equiprefit_rqst_ = new ::vmsg::CSEquipRefitRqst;
  return equiprefit_rqst_;
}
inline ::vmsg::CSEquipRefitRqst* CSEquipRequest::release_equiprefit_rqst() {
  clear_has_equiprefit_rqst();
  ::vmsg::CSEquipRefitRqst* temp = equiprefit_rqst_;
  equiprefit_rqst_ = NULL;
  return temp;
}
inline void CSEquipRequest::set_allocated_equiprefit_rqst(::vmsg::CSEquipRefitRqst* equiprefit_rqst) {
  delete equiprefit_rqst_;
  equiprefit_rqst_ = equiprefit_rqst;
  if (equiprefit_rqst) {
    set_has_equiprefit_rqst();
  } else {
    clear_has_equiprefit_rqst();
  }
}

// -------------------------------------------------------------------

// CSEquipRespond

// optional .vmsg.CSEquipRefineRsp EquipRefine_Rsp = 1;
inline bool CSEquipRespond::has_equiprefine_rsp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEquipRespond::set_has_equiprefine_rsp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEquipRespond::clear_has_equiprefine_rsp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEquipRespond::clear_equiprefine_rsp() {
  if (equiprefine_rsp_ != NULL) equiprefine_rsp_->::vmsg::CSEquipRefineRsp::Clear();
  clear_has_equiprefine_rsp();
}
inline const ::vmsg::CSEquipRefineRsp& CSEquipRespond::equiprefine_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equiprefine_rsp_ != NULL ? *equiprefine_rsp_ : *default_instance().equiprefine_rsp_;
#else
  return equiprefine_rsp_ != NULL ? *equiprefine_rsp_ : *default_instance_->equiprefine_rsp_;
#endif
}
inline ::vmsg::CSEquipRefineRsp* CSEquipRespond::mutable_equiprefine_rsp() {
  set_has_equiprefine_rsp();
  if (equiprefine_rsp_ == NULL) equiprefine_rsp_ = new ::vmsg::CSEquipRefineRsp;
  return equiprefine_rsp_;
}
inline ::vmsg::CSEquipRefineRsp* CSEquipRespond::release_equiprefine_rsp() {
  clear_has_equiprefine_rsp();
  ::vmsg::CSEquipRefineRsp* temp = equiprefine_rsp_;
  equiprefine_rsp_ = NULL;
  return temp;
}
inline void CSEquipRespond::set_allocated_equiprefine_rsp(::vmsg::CSEquipRefineRsp* equiprefine_rsp) {
  delete equiprefine_rsp_;
  equiprefine_rsp_ = equiprefine_rsp;
  if (equiprefine_rsp) {
    set_has_equiprefine_rsp();
  } else {
    clear_has_equiprefine_rsp();
  }
}

// optional .vmsg.CSEquipTransRsp EquipTrans_Rsp = 2;
inline bool CSEquipRespond::has_equiptrans_rsp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSEquipRespond::set_has_equiptrans_rsp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSEquipRespond::clear_has_equiptrans_rsp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSEquipRespond::clear_equiptrans_rsp() {
  if (equiptrans_rsp_ != NULL) equiptrans_rsp_->::vmsg::CSEquipTransRsp::Clear();
  clear_has_equiptrans_rsp();
}
inline const ::vmsg::CSEquipTransRsp& CSEquipRespond::equiptrans_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equiptrans_rsp_ != NULL ? *equiptrans_rsp_ : *default_instance().equiptrans_rsp_;
#else
  return equiptrans_rsp_ != NULL ? *equiptrans_rsp_ : *default_instance_->equiptrans_rsp_;
#endif
}
inline ::vmsg::CSEquipTransRsp* CSEquipRespond::mutable_equiptrans_rsp() {
  set_has_equiptrans_rsp();
  if (equiptrans_rsp_ == NULL) equiptrans_rsp_ = new ::vmsg::CSEquipTransRsp;
  return equiptrans_rsp_;
}
inline ::vmsg::CSEquipTransRsp* CSEquipRespond::release_equiptrans_rsp() {
  clear_has_equiptrans_rsp();
  ::vmsg::CSEquipTransRsp* temp = equiptrans_rsp_;
  equiptrans_rsp_ = NULL;
  return temp;
}
inline void CSEquipRespond::set_allocated_equiptrans_rsp(::vmsg::CSEquipTransRsp* equiptrans_rsp) {
  delete equiptrans_rsp_;
  equiptrans_rsp_ = equiptrans_rsp;
  if (equiptrans_rsp) {
    set_has_equiptrans_rsp();
  } else {
    clear_has_equiptrans_rsp();
  }
}

// optional .vmsg.CSEquipLvUpRsp EquipLvUp_Rsp = 3;
inline bool CSEquipRespond::has_equiplvup_rsp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSEquipRespond::set_has_equiplvup_rsp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSEquipRespond::clear_has_equiplvup_rsp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSEquipRespond::clear_equiplvup_rsp() {
  if (equiplvup_rsp_ != NULL) equiplvup_rsp_->::vmsg::CSEquipLvUpRsp::Clear();
  clear_has_equiplvup_rsp();
}
inline const ::vmsg::CSEquipLvUpRsp& CSEquipRespond::equiplvup_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equiplvup_rsp_ != NULL ? *equiplvup_rsp_ : *default_instance().equiplvup_rsp_;
#else
  return equiplvup_rsp_ != NULL ? *equiplvup_rsp_ : *default_instance_->equiplvup_rsp_;
#endif
}
inline ::vmsg::CSEquipLvUpRsp* CSEquipRespond::mutable_equiplvup_rsp() {
  set_has_equiplvup_rsp();
  if (equiplvup_rsp_ == NULL) equiplvup_rsp_ = new ::vmsg::CSEquipLvUpRsp;
  return equiplvup_rsp_;
}
inline ::vmsg::CSEquipLvUpRsp* CSEquipRespond::release_equiplvup_rsp() {
  clear_has_equiplvup_rsp();
  ::vmsg::CSEquipLvUpRsp* temp = equiplvup_rsp_;
  equiplvup_rsp_ = NULL;
  return temp;
}
inline void CSEquipRespond::set_allocated_equiplvup_rsp(::vmsg::CSEquipLvUpRsp* equiplvup_rsp) {
  delete equiplvup_rsp_;
  equiplvup_rsp_ = equiplvup_rsp;
  if (equiplvup_rsp) {
    set_has_equiplvup_rsp();
  } else {
    clear_has_equiplvup_rsp();
  }
}

// optional .vmsg.CSEquipStarStepRsp EquipStarStep_Rsp = 4;
inline bool CSEquipRespond::has_equipstarstep_rsp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSEquipRespond::set_has_equipstarstep_rsp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSEquipRespond::clear_has_equipstarstep_rsp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSEquipRespond::clear_equipstarstep_rsp() {
  if (equipstarstep_rsp_ != NULL) equipstarstep_rsp_->::vmsg::CSEquipStarStepRsp::Clear();
  clear_has_equipstarstep_rsp();
}
inline const ::vmsg::CSEquipStarStepRsp& CSEquipRespond::equipstarstep_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equipstarstep_rsp_ != NULL ? *equipstarstep_rsp_ : *default_instance().equipstarstep_rsp_;
#else
  return equipstarstep_rsp_ != NULL ? *equipstarstep_rsp_ : *default_instance_->equipstarstep_rsp_;
#endif
}
inline ::vmsg::CSEquipStarStepRsp* CSEquipRespond::mutable_equipstarstep_rsp() {
  set_has_equipstarstep_rsp();
  if (equipstarstep_rsp_ == NULL) equipstarstep_rsp_ = new ::vmsg::CSEquipStarStepRsp;
  return equipstarstep_rsp_;
}
inline ::vmsg::CSEquipStarStepRsp* CSEquipRespond::release_equipstarstep_rsp() {
  clear_has_equipstarstep_rsp();
  ::vmsg::CSEquipStarStepRsp* temp = equipstarstep_rsp_;
  equipstarstep_rsp_ = NULL;
  return temp;
}
inline void CSEquipRespond::set_allocated_equipstarstep_rsp(::vmsg::CSEquipStarStepRsp* equipstarstep_rsp) {
  delete equipstarstep_rsp_;
  equipstarstep_rsp_ = equipstarstep_rsp;
  if (equipstarstep_rsp) {
    set_has_equipstarstep_rsp();
  } else {
    clear_has_equipstarstep_rsp();
  }
}

// optional .vmsg.CSEquipRefitRsp EquipRefit_Rsp = 5;
inline bool CSEquipRespond::has_equiprefit_rsp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSEquipRespond::set_has_equiprefit_rsp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSEquipRespond::clear_has_equiprefit_rsp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSEquipRespond::clear_equiprefit_rsp() {
  if (equiprefit_rsp_ != NULL) equiprefit_rsp_->::vmsg::CSEquipRefitRsp::Clear();
  clear_has_equiprefit_rsp();
}
inline const ::vmsg::CSEquipRefitRsp& CSEquipRespond::equiprefit_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equiprefit_rsp_ != NULL ? *equiprefit_rsp_ : *default_instance().equiprefit_rsp_;
#else
  return equiprefit_rsp_ != NULL ? *equiprefit_rsp_ : *default_instance_->equiprefit_rsp_;
#endif
}
inline ::vmsg::CSEquipRefitRsp* CSEquipRespond::mutable_equiprefit_rsp() {
  set_has_equiprefit_rsp();
  if (equiprefit_rsp_ == NULL) equiprefit_rsp_ = new ::vmsg::CSEquipRefitRsp;
  return equiprefit_rsp_;
}
inline ::vmsg::CSEquipRefitRsp* CSEquipRespond::release_equiprefit_rsp() {
  clear_has_equiprefit_rsp();
  ::vmsg::CSEquipRefitRsp* temp = equiprefit_rsp_;
  equiprefit_rsp_ = NULL;
  return temp;
}
inline void CSEquipRespond::set_allocated_equiprefit_rsp(::vmsg::CSEquipRefitRsp* equiprefit_rsp) {
  delete equiprefit_rsp_;
  equiprefit_rsp_ = equiprefit_rsp;
  if (equiprefit_rsp) {
    set_has_equiprefit_rsp();
  } else {
    clear_has_equiprefit_rsp();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CSEquipOpMsg_2eproto__INCLUDED
