// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSCVZMsg.proto

#ifndef PROTOBUF_CSCVZMsg_2eproto__INCLUDED
#define PROTOBUF_CSCVZMsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MsgBase.pb.h"
#include "CSSenceOSD.pb.h"
// @@protoc_insertion_point(includes)

namespace vmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CSCVZMsg_2eproto();
void protobuf_AssignDesc_CSCVZMsg_2eproto();
void protobuf_ShutdownFile_CSCVZMsg_2eproto();

class CSCVZMonsterHurt;
class CSCVZMonsterHP;
class CSCVZHitMonsterRqst;
class CSCVZHitedRqst;
class CSVZControlMonsterInfo;
class CSCVZControlNotify;
class CSCVZDestroyBaseNotify;
class CSCVZHitMonsterNotify;
class CSCVZHitedNotify;
class CSCVZMonsterInfo;
class CSCVZMonsters;
class CSCVZRankData;
class CSCVZRankInfo;
class CSCVZRequest;
class CSCVZRespond;

// ===================================================================

class CSCVZMonsterHurt : public ::google::protobuf::MessageLite {
 public:
  CSCVZMonsterHurt();
  virtual ~CSCVZMonsterHurt();

  CSCVZMonsterHurt(const CSCVZMonsterHurt& from);

  inline CSCVZMonsterHurt& operator=(const CSCVZMonsterHurt& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSCVZMonsterHurt& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSCVZMonsterHurt* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSCVZMonsterHurt* other);

  // implements Message ----------------------------------------------

  CSCVZMonsterHurt* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSCVZMonsterHurt& from);
  void MergeFrom(const CSCVZMonsterHurt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 MonsterID = 1;
  inline bool has_monsterid() const;
  inline void clear_monsterid();
  static const int kMonsterIDFieldNumber = 1;
  inline ::google::protobuf::uint32 monsterid() const;
  inline void set_monsterid(::google::protobuf::uint32 value);

  // required uint32 Hurt = 2;
  inline bool has_hurt() const;
  inline void clear_hurt();
  static const int kHurtFieldNumber = 2;
  inline ::google::protobuf::uint32 hurt() const;
  inline void set_hurt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSCVZMonsterHurt)
 private:
  inline void set_has_monsterid();
  inline void clear_has_monsterid();
  inline void set_has_hurt();
  inline void clear_has_hurt();

  ::google::protobuf::uint32 monsterid_;
  ::google::protobuf::uint32 hurt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSCVZMsg_2eproto();
  friend void protobuf_ShutdownFile_CSCVZMsg_2eproto();

  void InitAsDefaultInstance();
  static CSCVZMonsterHurt* default_instance_;
};
// -------------------------------------------------------------------

class CSCVZMonsterHP : public ::google::protobuf::MessageLite {
 public:
  CSCVZMonsterHP();
  virtual ~CSCVZMonsterHP();

  CSCVZMonsterHP(const CSCVZMonsterHP& from);

  inline CSCVZMonsterHP& operator=(const CSCVZMonsterHP& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSCVZMonsterHP& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSCVZMonsterHP* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSCVZMonsterHP* other);

  // implements Message ----------------------------------------------

  CSCVZMonsterHP* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSCVZMonsterHP& from);
  void MergeFrom(const CSCVZMonsterHP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 MonsterID = 1;
  inline bool has_monsterid() const;
  inline void clear_monsterid();
  static const int kMonsterIDFieldNumber = 1;
  inline ::google::protobuf::uint32 monsterid() const;
  inline void set_monsterid(::google::protobuf::uint32 value);

  // required uint32 HP = 2;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHPFieldNumber = 2;
  inline ::google::protobuf::uint32 hp() const;
  inline void set_hp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSCVZMonsterHP)
 private:
  inline void set_has_monsterid();
  inline void clear_has_monsterid();
  inline void set_has_hp();
  inline void clear_has_hp();

  ::google::protobuf::uint32 monsterid_;
  ::google::protobuf::uint32 hp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSCVZMsg_2eproto();
  friend void protobuf_ShutdownFile_CSCVZMsg_2eproto();

  void InitAsDefaultInstance();
  static CSCVZMonsterHP* default_instance_;
};
// -------------------------------------------------------------------

class CSCVZHitMonsterRqst : public ::google::protobuf::MessageLite {
 public:
  CSCVZHitMonsterRqst();
  virtual ~CSCVZHitMonsterRqst();

  CSCVZHitMonsterRqst(const CSCVZHitMonsterRqst& from);

  inline CSCVZHitMonsterRqst& operator=(const CSCVZHitMonsterRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSCVZHitMonsterRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSCVZHitMonsterRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSCVZHitMonsterRqst* other);

  // implements Message ----------------------------------------------

  CSCVZHitMonsterRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSCVZHitMonsterRqst& from);
  void MergeFrom(const CSCVZHitMonsterRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 MP = 1;
  inline bool has_mp() const;
  inline void clear_mp();
  static const int kMPFieldNumber = 1;
  inline ::google::protobuf::uint32 mp() const;
  inline void set_mp(::google::protobuf::uint32 value);

  // repeated .vmsg.CSCVZMonsterHurt MonsterHurt = 2;
  inline int monsterhurt_size() const;
  inline void clear_monsterhurt();
  static const int kMonsterHurtFieldNumber = 2;
  inline const ::vmsg::CSCVZMonsterHurt& monsterhurt(int index) const;
  inline ::vmsg::CSCVZMonsterHurt* mutable_monsterhurt(int index);
  inline ::vmsg::CSCVZMonsterHurt* add_monsterhurt();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSCVZMonsterHurt >&
      monsterhurt() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSCVZMonsterHurt >*
      mutable_monsterhurt();

  // @@protoc_insertion_point(class_scope:vmsg.CSCVZHitMonsterRqst)
 private:
  inline void set_has_mp();
  inline void clear_has_mp();

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSCVZMonsterHurt > monsterhurt_;
  ::google::protobuf::uint32 mp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSCVZMsg_2eproto();
  friend void protobuf_ShutdownFile_CSCVZMsg_2eproto();

  void InitAsDefaultInstance();
  static CSCVZHitMonsterRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSCVZHitedRqst : public ::google::protobuf::MessageLite {
 public:
  CSCVZHitedRqst();
  virtual ~CSCVZHitedRqst();

  CSCVZHitedRqst(const CSCVZHitedRqst& from);

  inline CSCVZHitedRqst& operator=(const CSCVZHitedRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSCVZHitedRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSCVZHitedRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSCVZHitedRqst* other);

  // implements Message ----------------------------------------------

  CSCVZHitedRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSCVZHitedRqst& from);
  void MergeFrom(const CSCVZHitedRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 HP = 1;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHPFieldNumber = 1;
  inline ::google::protobuf::uint32 hp() const;
  inline void set_hp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSCVZHitedRqst)
 private:
  inline void set_has_hp();
  inline void clear_has_hp();

  ::google::protobuf::uint32 hp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSCVZMsg_2eproto();
  friend void protobuf_ShutdownFile_CSCVZMsg_2eproto();

  void InitAsDefaultInstance();
  static CSCVZHitedRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSVZControlMonsterInfo : public ::google::protobuf::MessageLite {
 public:
  CSVZControlMonsterInfo();
  virtual ~CSVZControlMonsterInfo();

  CSVZControlMonsterInfo(const CSVZControlMonsterInfo& from);

  inline CSVZControlMonsterInfo& operator=(const CSVZControlMonsterInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSVZControlMonsterInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSVZControlMonsterInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSVZControlMonsterInfo* other);

  // implements Message ----------------------------------------------

  CSVZControlMonsterInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSVZControlMonsterInfo& from);
  void MergeFrom(const CSVZControlMonsterInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 MonsterID = 1;
  inline bool has_monsterid() const;
  inline void clear_monsterid();
  static const int kMonsterIDFieldNumber = 1;
  inline ::google::protobuf::uint32 monsterid() const;
  inline void set_monsterid(::google::protobuf::uint32 value);

  // required uint32 Channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::uint32 channel() const;
  inline void set_channel(::google::protobuf::uint32 value);

  // required uint32 Wave = 3;
  inline bool has_wave() const;
  inline void clear_wave();
  static const int kWaveFieldNumber = 3;
  inline ::google::protobuf::uint32 wave() const;
  inline void set_wave(::google::protobuf::uint32 value);

  // required uint32 Lv = 4;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 4;
  inline ::google::protobuf::uint32 lv() const;
  inline void set_lv(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSVZControlMonsterInfo)
 private:
  inline void set_has_monsterid();
  inline void clear_has_monsterid();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_wave();
  inline void clear_has_wave();
  inline void set_has_lv();
  inline void clear_has_lv();

  ::google::protobuf::uint32 monsterid_;
  ::google::protobuf::uint32 channel_;
  ::google::protobuf::uint32 wave_;
  ::google::protobuf::uint32 lv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSCVZMsg_2eproto();
  friend void protobuf_ShutdownFile_CSCVZMsg_2eproto();

  void InitAsDefaultInstance();
  static CSVZControlMonsterInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSCVZControlNotify : public ::google::protobuf::MessageLite {
 public:
  CSCVZControlNotify();
  virtual ~CSCVZControlNotify();

  CSCVZControlNotify(const CSCVZControlNotify& from);

  inline CSCVZControlNotify& operator=(const CSCVZControlNotify& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSCVZControlNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSCVZControlNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSCVZControlNotify* other);

  // implements Message ----------------------------------------------

  CSCVZControlNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSCVZControlNotify& from);
  void MergeFrom(const CSCVZControlNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSVZControlMonsterInfo Monsters = 1;
  inline int monsters_size() const;
  inline void clear_monsters();
  static const int kMonstersFieldNumber = 1;
  inline const ::vmsg::CSVZControlMonsterInfo& monsters(int index) const;
  inline ::vmsg::CSVZControlMonsterInfo* mutable_monsters(int index);
  inline ::vmsg::CSVZControlMonsterInfo* add_monsters();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSVZControlMonsterInfo >&
      monsters() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSVZControlMonsterInfo >*
      mutable_monsters();

  // @@protoc_insertion_point(class_scope:vmsg.CSCVZControlNotify)
 private:

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSVZControlMonsterInfo > monsters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSCVZMsg_2eproto();
  friend void protobuf_ShutdownFile_CSCVZMsg_2eproto();

  void InitAsDefaultInstance();
  static CSCVZControlNotify* default_instance_;
};
// -------------------------------------------------------------------

class CSCVZDestroyBaseNotify : public ::google::protobuf::MessageLite {
 public:
  CSCVZDestroyBaseNotify();
  virtual ~CSCVZDestroyBaseNotify();

  CSCVZDestroyBaseNotify(const CSCVZDestroyBaseNotify& from);

  inline CSCVZDestroyBaseNotify& operator=(const CSCVZDestroyBaseNotify& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSCVZDestroyBaseNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSCVZDestroyBaseNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSCVZDestroyBaseNotify* other);

  // implements Message ----------------------------------------------

  CSCVZDestroyBaseNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSCVZDestroyBaseNotify& from);
  void MergeFrom(const CSCVZDestroyBaseNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 BaseHP = 1;
  inline int basehp_size() const;
  inline void clear_basehp();
  static const int kBaseHPFieldNumber = 1;
  inline ::google::protobuf::uint32 basehp(int index) const;
  inline void set_basehp(int index, ::google::protobuf::uint32 value);
  inline void add_basehp(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      basehp() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_basehp();

  // repeated uint32 MonsrerIDs = 2;
  inline int monsrerids_size() const;
  inline void clear_monsrerids();
  static const int kMonsrerIDsFieldNumber = 2;
  inline ::google::protobuf::uint32 monsrerids(int index) const;
  inline void set_monsrerids(int index, ::google::protobuf::uint32 value);
  inline void add_monsrerids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      monsrerids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_monsrerids();

  // @@protoc_insertion_point(class_scope:vmsg.CSCVZDestroyBaseNotify)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > basehp_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > monsrerids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSCVZMsg_2eproto();
  friend void protobuf_ShutdownFile_CSCVZMsg_2eproto();

  void InitAsDefaultInstance();
  static CSCVZDestroyBaseNotify* default_instance_;
};
// -------------------------------------------------------------------

class CSCVZHitMonsterNotify : public ::google::protobuf::MessageLite {
 public:
  CSCVZHitMonsterNotify();
  virtual ~CSCVZHitMonsterNotify();

  CSCVZHitMonsterNotify(const CSCVZHitMonsterNotify& from);

  inline CSCVZHitMonsterNotify& operator=(const CSCVZHitMonsterNotify& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSCVZHitMonsterNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSCVZHitMonsterNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSCVZHitMonsterNotify* other);

  // implements Message ----------------------------------------------

  CSCVZHitMonsterNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSCVZHitMonsterNotify& from);
  void MergeFrom(const CSCVZHitMonsterNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSCVZMonsterHP MonsterHP = 1;
  inline int monsterhp_size() const;
  inline void clear_monsterhp();
  static const int kMonsterHPFieldNumber = 1;
  inline const ::vmsg::CSCVZMonsterHP& monsterhp(int index) const;
  inline ::vmsg::CSCVZMonsterHP* mutable_monsterhp(int index);
  inline ::vmsg::CSCVZMonsterHP* add_monsterhp();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSCVZMonsterHP >&
      monsterhp() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSCVZMonsterHP >*
      mutable_monsterhp();

  // @@protoc_insertion_point(class_scope:vmsg.CSCVZHitMonsterNotify)
 private:

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSCVZMonsterHP > monsterhp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSCVZMsg_2eproto();
  friend void protobuf_ShutdownFile_CSCVZMsg_2eproto();

  void InitAsDefaultInstance();
  static CSCVZHitMonsterNotify* default_instance_;
};
// -------------------------------------------------------------------

class CSCVZHitedNotify : public ::google::protobuf::MessageLite {
 public:
  CSCVZHitedNotify();
  virtual ~CSCVZHitedNotify();

  CSCVZHitedNotify(const CSCVZHitedNotify& from);

  inline CSCVZHitedNotify& operator=(const CSCVZHitedNotify& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSCVZHitedNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSCVZHitedNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSCVZHitedNotify* other);

  // implements Message ----------------------------------------------

  CSCVZHitedNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSCVZHitedNotify& from);
  void MergeFrom(const CSCVZHitedNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // required uint32 HP = 2;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHPFieldNumber = 2;
  inline ::google::protobuf::uint32 hp() const;
  inline void set_hp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSCVZHitedNotify)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_hp();
  inline void clear_has_hp();

  ::google::protobuf::uint64 uin_;
  ::google::protobuf::uint32 hp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSCVZMsg_2eproto();
  friend void protobuf_ShutdownFile_CSCVZMsg_2eproto();

  void InitAsDefaultInstance();
  static CSCVZHitedNotify* default_instance_;
};
// -------------------------------------------------------------------

class CSCVZMonsterInfo : public ::google::protobuf::MessageLite {
 public:
  CSCVZMonsterInfo();
  virtual ~CSCVZMonsterInfo();

  CSCVZMonsterInfo(const CSCVZMonsterInfo& from);

  inline CSCVZMonsterInfo& operator=(const CSCVZMonsterInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSCVZMonsterInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSCVZMonsterInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSCVZMonsterInfo* other);

  // implements Message ----------------------------------------------

  CSCVZMonsterInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSCVZMonsterInfo& from);
  void MergeFrom(const CSCVZMonsterInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 MonsterID = 1;
  inline bool has_monsterid() const;
  inline void clear_monsterid();
  static const int kMonsterIDFieldNumber = 1;
  inline ::google::protobuf::uint32 monsterid() const;
  inline void set_monsterid(::google::protobuf::uint32 value);

  // required .vmsg.CSScenePoint Pos = 2;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 2;
  inline const ::vmsg::CSScenePoint& pos() const;
  inline ::vmsg::CSScenePoint* mutable_pos();
  inline ::vmsg::CSScenePoint* release_pos();
  inline void set_allocated_pos(::vmsg::CSScenePoint* pos);

  // required uint32 Action = 3;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 3;
  inline ::google::protobuf::uint32 action() const;
  inline void set_action(::google::protobuf::uint32 value);

  // required uint32 Wave = 4;
  inline bool has_wave() const;
  inline void clear_wave();
  static const int kWaveFieldNumber = 4;
  inline ::google::protobuf::uint32 wave() const;
  inline void set_wave(::google::protobuf::uint32 value);

  // required uint32 Lv = 5;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 5;
  inline ::google::protobuf::uint32 lv() const;
  inline void set_lv(::google::protobuf::uint32 value);

  // required uint32 SkillID = 6;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillIDFieldNumber = 6;
  inline ::google::protobuf::uint32 skillid() const;
  inline void set_skillid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSCVZMonsterInfo)
 private:
  inline void set_has_monsterid();
  inline void clear_has_monsterid();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_wave();
  inline void clear_has_wave();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_skillid();
  inline void clear_has_skillid();

  ::vmsg::CSScenePoint* pos_;
  ::google::protobuf::uint32 monsterid_;
  ::google::protobuf::uint32 action_;
  ::google::protobuf::uint32 wave_;
  ::google::protobuf::uint32 lv_;
  ::google::protobuf::uint32 skillid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSCVZMsg_2eproto();
  friend void protobuf_ShutdownFile_CSCVZMsg_2eproto();

  void InitAsDefaultInstance();
  static CSCVZMonsterInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSCVZMonsters : public ::google::protobuf::MessageLite {
 public:
  CSCVZMonsters();
  virtual ~CSCVZMonsters();

  CSCVZMonsters(const CSCVZMonsters& from);

  inline CSCVZMonsters& operator=(const CSCVZMonsters& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSCVZMonsters& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSCVZMonsters* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSCVZMonsters* other);

  // implements Message ----------------------------------------------

  CSCVZMonsters* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSCVZMonsters& from);
  void MergeFrom(const CSCVZMonsters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSCVZMonsterInfo Monsters = 1;
  inline int monsters_size() const;
  inline void clear_monsters();
  static const int kMonstersFieldNumber = 1;
  inline const ::vmsg::CSCVZMonsterInfo& monsters(int index) const;
  inline ::vmsg::CSCVZMonsterInfo* mutable_monsters(int index);
  inline ::vmsg::CSCVZMonsterInfo* add_monsters();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSCVZMonsterInfo >&
      monsters() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSCVZMonsterInfo >*
      mutable_monsters();

  // @@protoc_insertion_point(class_scope:vmsg.CSCVZMonsters)
 private:

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSCVZMonsterInfo > monsters_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSCVZMsg_2eproto();
  friend void protobuf_ShutdownFile_CSCVZMsg_2eproto();

  void InitAsDefaultInstance();
  static CSCVZMonsters* default_instance_;
};
// -------------------------------------------------------------------

class CSCVZRankData : public ::google::protobuf::MessageLite {
 public:
  CSCVZRankData();
  virtual ~CSCVZRankData();

  CSCVZRankData(const CSCVZRankData& from);

  inline CSCVZRankData& operator=(const CSCVZRankData& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSCVZRankData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSCVZRankData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSCVZRankData* other);

  // implements Message ----------------------------------------------

  CSCVZRankData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSCVZRankData& from);
  void MergeFrom(const CSCVZRankData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // required string Name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint64 Hit = 3;
  inline bool has_hit() const;
  inline void clear_hit();
  static const int kHitFieldNumber = 3;
  inline ::google::protobuf::uint64 hit() const;
  inline void set_hit(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSCVZRankData)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_hit();
  inline void clear_has_hit();

  ::google::protobuf::uint64 uin_;
  ::std::string* name_;
  ::google::protobuf::uint64 hit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSCVZMsg_2eproto();
  friend void protobuf_ShutdownFile_CSCVZMsg_2eproto();

  void InitAsDefaultInstance();
  static CSCVZRankData* default_instance_;
};
// -------------------------------------------------------------------

class CSCVZRankInfo : public ::google::protobuf::MessageLite {
 public:
  CSCVZRankInfo();
  virtual ~CSCVZRankInfo();

  CSCVZRankInfo(const CSCVZRankInfo& from);

  inline CSCVZRankInfo& operator=(const CSCVZRankInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSCVZRankInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSCVZRankInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSCVZRankInfo* other);

  // implements Message ----------------------------------------------

  CSCVZRankInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSCVZRankInfo& from);
  void MergeFrom(const CSCVZRankInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSCVZRankData RankDatas = 1;
  inline int rankdatas_size() const;
  inline void clear_rankdatas();
  static const int kRankDatasFieldNumber = 1;
  inline const ::vmsg::CSCVZRankData& rankdatas(int index) const;
  inline ::vmsg::CSCVZRankData* mutable_rankdatas(int index);
  inline ::vmsg::CSCVZRankData* add_rankdatas();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSCVZRankData >&
      rankdatas() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSCVZRankData >*
      mutable_rankdatas();

  // @@protoc_insertion_point(class_scope:vmsg.CSCVZRankInfo)
 private:

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSCVZRankData > rankdatas_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSCVZMsg_2eproto();
  friend void protobuf_ShutdownFile_CSCVZMsg_2eproto();

  void InitAsDefaultInstance();
  static CSCVZRankInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSCVZRequest : public ::google::protobuf::MessageLite {
 public:
  CSCVZRequest();
  virtual ~CSCVZRequest();

  CSCVZRequest(const CSCVZRequest& from);

  inline CSCVZRequest& operator=(const CSCVZRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSCVZRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSCVZRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSCVZRequest* other);

  // implements Message ----------------------------------------------

  CSCVZRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSCVZRequest& from);
  void MergeFrom(const CSCVZRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSCVZHitMonsterRqst HitMonster_Rqst = 1;
  inline bool has_hitmonster_rqst() const;
  inline void clear_hitmonster_rqst();
  static const int kHitMonsterRqstFieldNumber = 1;
  inline const ::vmsg::CSCVZHitMonsterRqst& hitmonster_rqst() const;
  inline ::vmsg::CSCVZHitMonsterRqst* mutable_hitmonster_rqst();
  inline ::vmsg::CSCVZHitMonsterRqst* release_hitmonster_rqst();
  inline void set_allocated_hitmonster_rqst(::vmsg::CSCVZHitMonsterRqst* hitmonster_rqst);

  // optional .vmsg.CSCVZHitedRqst Hited_Rqst = 2;
  inline bool has_hited_rqst() const;
  inline void clear_hited_rqst();
  static const int kHitedRqstFieldNumber = 2;
  inline const ::vmsg::CSCVZHitedRqst& hited_rqst() const;
  inline ::vmsg::CSCVZHitedRqst* mutable_hited_rqst();
  inline ::vmsg::CSCVZHitedRqst* release_hited_rqst();
  inline void set_allocated_hited_rqst(::vmsg::CSCVZHitedRqst* hited_rqst);

  // optional int32 DestroyBase_Rqst = 3;
  inline bool has_destroybase_rqst() const;
  inline void clear_destroybase_rqst();
  static const int kDestroyBaseRqstFieldNumber = 3;
  inline ::google::protobuf::int32 destroybase_rqst() const;
  inline void set_destroybase_rqst(::google::protobuf::int32 value);

  // optional .vmsg.CSCVZMonsters SubmitMonster_Rqst = 4;
  inline bool has_submitmonster_rqst() const;
  inline void clear_submitmonster_rqst();
  static const int kSubmitMonsterRqstFieldNumber = 4;
  inline const ::vmsg::CSCVZMonsters& submitmonster_rqst() const;
  inline ::vmsg::CSCVZMonsters* mutable_submitmonster_rqst();
  inline ::vmsg::CSCVZMonsters* release_submitmonster_rqst();
  inline void set_allocated_submitmonster_rqst(::vmsg::CSCVZMonsters* submitmonster_rqst);

  // @@protoc_insertion_point(class_scope:vmsg.CSCVZRequest)
 private:
  inline void set_has_hitmonster_rqst();
  inline void clear_has_hitmonster_rqst();
  inline void set_has_hited_rqst();
  inline void clear_has_hited_rqst();
  inline void set_has_destroybase_rqst();
  inline void clear_has_destroybase_rqst();
  inline void set_has_submitmonster_rqst();
  inline void clear_has_submitmonster_rqst();

  ::vmsg::CSCVZHitMonsterRqst* hitmonster_rqst_;
  ::vmsg::CSCVZHitedRqst* hited_rqst_;
  ::vmsg::CSCVZMonsters* submitmonster_rqst_;
  ::google::protobuf::int32 destroybase_rqst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSCVZMsg_2eproto();
  friend void protobuf_ShutdownFile_CSCVZMsg_2eproto();

  void InitAsDefaultInstance();
  static CSCVZRequest* default_instance_;
};
// -------------------------------------------------------------------

class CSCVZRespond : public ::google::protobuf::MessageLite {
 public:
  CSCVZRespond();
  virtual ~CSCVZRespond();

  CSCVZRespond(const CSCVZRespond& from);

  inline CSCVZRespond& operator=(const CSCVZRespond& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSCVZRespond& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSCVZRespond* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSCVZRespond* other);

  // implements Message ----------------------------------------------

  CSCVZRespond* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSCVZRespond& from);
  void MergeFrom(const CSCVZRespond& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSCVZControlNotify Control_Notify = 1;
  inline bool has_control_notify() const;
  inline void clear_control_notify();
  static const int kControlNotifyFieldNumber = 1;
  inline const ::vmsg::CSCVZControlNotify& control_notify() const;
  inline ::vmsg::CSCVZControlNotify* mutable_control_notify();
  inline ::vmsg::CSCVZControlNotify* release_control_notify();
  inline void set_allocated_control_notify(::vmsg::CSCVZControlNotify* control_notify);

  // optional .vmsg.CSCVZDestroyBaseNotify DestroyBase_Notify = 2;
  inline bool has_destroybase_notify() const;
  inline void clear_destroybase_notify();
  static const int kDestroyBaseNotifyFieldNumber = 2;
  inline const ::vmsg::CSCVZDestroyBaseNotify& destroybase_notify() const;
  inline ::vmsg::CSCVZDestroyBaseNotify* mutable_destroybase_notify();
  inline ::vmsg::CSCVZDestroyBaseNotify* release_destroybase_notify();
  inline void set_allocated_destroybase_notify(::vmsg::CSCVZDestroyBaseNotify* destroybase_notify);

  // optional .vmsg.CSCVZHitMonsterNotify HitMonster_Notify = 3;
  inline bool has_hitmonster_notify() const;
  inline void clear_hitmonster_notify();
  static const int kHitMonsterNotifyFieldNumber = 3;
  inline const ::vmsg::CSCVZHitMonsterNotify& hitmonster_notify() const;
  inline ::vmsg::CSCVZHitMonsterNotify* mutable_hitmonster_notify();
  inline ::vmsg::CSCVZHitMonsterNotify* release_hitmonster_notify();
  inline void set_allocated_hitmonster_notify(::vmsg::CSCVZHitMonsterNotify* hitmonster_notify);

  // optional .vmsg.CSCVZHitedNotify Hited_Notify = 4;
  inline bool has_hited_notify() const;
  inline void clear_hited_notify();
  static const int kHitedNotifyFieldNumber = 4;
  inline const ::vmsg::CSCVZHitedNotify& hited_notify() const;
  inline ::vmsg::CSCVZHitedNotify* mutable_hited_notify();
  inline ::vmsg::CSCVZHitedNotify* release_hited_notify();
  inline void set_allocated_hited_notify(::vmsg::CSCVZHitedNotify* hited_notify);

  // optional .vmsg.CSCVZMonsters Monsters_Notify = 5;
  inline bool has_monsters_notify() const;
  inline void clear_monsters_notify();
  static const int kMonstersNotifyFieldNumber = 5;
  inline const ::vmsg::CSCVZMonsters& monsters_notify() const;
  inline ::vmsg::CSCVZMonsters* mutable_monsters_notify();
  inline ::vmsg::CSCVZMonsters* release_monsters_notify();
  inline void set_allocated_monsters_notify(::vmsg::CSCVZMonsters* monsters_notify);

  // optional .vmsg.CSCVZRankInfo RankInfo_Notify = 6;
  inline bool has_rankinfo_notify() const;
  inline void clear_rankinfo_notify();
  static const int kRankInfoNotifyFieldNumber = 6;
  inline const ::vmsg::CSCVZRankInfo& rankinfo_notify() const;
  inline ::vmsg::CSCVZRankInfo* mutable_rankinfo_notify();
  inline ::vmsg::CSCVZRankInfo* release_rankinfo_notify();
  inline void set_allocated_rankinfo_notify(::vmsg::CSCVZRankInfo* rankinfo_notify);

  // optional uint32 NextWaveRemainTime = 7;
  inline bool has_nextwaveremaintime() const;
  inline void clear_nextwaveremaintime();
  static const int kNextWaveRemainTimeFieldNumber = 7;
  inline ::google::protobuf::uint32 nextwaveremaintime() const;
  inline void set_nextwaveremaintime(::google::protobuf::uint32 value);

  // optional uint32 MyContAwardCoin_Notify = 8;
  inline bool has_mycontawardcoin_notify() const;
  inline void clear_mycontawardcoin_notify();
  static const int kMyContAwardCoinNotifyFieldNumber = 8;
  inline ::google::protobuf::uint32 mycontawardcoin_notify() const;
  inline void set_mycontawardcoin_notify(::google::protobuf::uint32 value);

  // optional uint32 TotalCont_Notify = 9;
  inline bool has_totalcont_notify() const;
  inline void clear_totalcont_notify();
  static const int kTotalContNotifyFieldNumber = 9;
  inline ::google::protobuf::uint32 totalcont_notify() const;
  inline void set_totalcont_notify(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSCVZRespond)
 private:
  inline void set_has_control_notify();
  inline void clear_has_control_notify();
  inline void set_has_destroybase_notify();
  inline void clear_has_destroybase_notify();
  inline void set_has_hitmonster_notify();
  inline void clear_has_hitmonster_notify();
  inline void set_has_hited_notify();
  inline void clear_has_hited_notify();
  inline void set_has_monsters_notify();
  inline void clear_has_monsters_notify();
  inline void set_has_rankinfo_notify();
  inline void clear_has_rankinfo_notify();
  inline void set_has_nextwaveremaintime();
  inline void clear_has_nextwaveremaintime();
  inline void set_has_mycontawardcoin_notify();
  inline void clear_has_mycontawardcoin_notify();
  inline void set_has_totalcont_notify();
  inline void clear_has_totalcont_notify();

  ::vmsg::CSCVZControlNotify* control_notify_;
  ::vmsg::CSCVZDestroyBaseNotify* destroybase_notify_;
  ::vmsg::CSCVZHitMonsterNotify* hitmonster_notify_;
  ::vmsg::CSCVZHitedNotify* hited_notify_;
  ::vmsg::CSCVZMonsters* monsters_notify_;
  ::vmsg::CSCVZRankInfo* rankinfo_notify_;
  ::google::protobuf::uint32 nextwaveremaintime_;
  ::google::protobuf::uint32 mycontawardcoin_notify_;
  ::google::protobuf::uint32 totalcont_notify_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSCVZMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSCVZMsg_2eproto();
  friend void protobuf_ShutdownFile_CSCVZMsg_2eproto();

  void InitAsDefaultInstance();
  static CSCVZRespond* default_instance_;
};
// ===================================================================


// ===================================================================

// CSCVZMonsterHurt

// required uint32 MonsterID = 1;
inline bool CSCVZMonsterHurt::has_monsterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSCVZMonsterHurt::set_has_monsterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSCVZMonsterHurt::clear_has_monsterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSCVZMonsterHurt::clear_monsterid() {
  monsterid_ = 0u;
  clear_has_monsterid();
}
inline ::google::protobuf::uint32 CSCVZMonsterHurt::monsterid() const {
  return monsterid_;
}
inline void CSCVZMonsterHurt::set_monsterid(::google::protobuf::uint32 value) {
  set_has_monsterid();
  monsterid_ = value;
}

// required uint32 Hurt = 2;
inline bool CSCVZMonsterHurt::has_hurt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSCVZMonsterHurt::set_has_hurt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSCVZMonsterHurt::clear_has_hurt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSCVZMonsterHurt::clear_hurt() {
  hurt_ = 0u;
  clear_has_hurt();
}
inline ::google::protobuf::uint32 CSCVZMonsterHurt::hurt() const {
  return hurt_;
}
inline void CSCVZMonsterHurt::set_hurt(::google::protobuf::uint32 value) {
  set_has_hurt();
  hurt_ = value;
}

// -------------------------------------------------------------------

// CSCVZMonsterHP

// required uint32 MonsterID = 1;
inline bool CSCVZMonsterHP::has_monsterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSCVZMonsterHP::set_has_monsterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSCVZMonsterHP::clear_has_monsterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSCVZMonsterHP::clear_monsterid() {
  monsterid_ = 0u;
  clear_has_monsterid();
}
inline ::google::protobuf::uint32 CSCVZMonsterHP::monsterid() const {
  return monsterid_;
}
inline void CSCVZMonsterHP::set_monsterid(::google::protobuf::uint32 value) {
  set_has_monsterid();
  monsterid_ = value;
}

// required uint32 HP = 2;
inline bool CSCVZMonsterHP::has_hp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSCVZMonsterHP::set_has_hp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSCVZMonsterHP::clear_has_hp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSCVZMonsterHP::clear_hp() {
  hp_ = 0u;
  clear_has_hp();
}
inline ::google::protobuf::uint32 CSCVZMonsterHP::hp() const {
  return hp_;
}
inline void CSCVZMonsterHP::set_hp(::google::protobuf::uint32 value) {
  set_has_hp();
  hp_ = value;
}

// -------------------------------------------------------------------

// CSCVZHitMonsterRqst

// required uint32 MP = 1;
inline bool CSCVZHitMonsterRqst::has_mp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSCVZHitMonsterRqst::set_has_mp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSCVZHitMonsterRqst::clear_has_mp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSCVZHitMonsterRqst::clear_mp() {
  mp_ = 0u;
  clear_has_mp();
}
inline ::google::protobuf::uint32 CSCVZHitMonsterRqst::mp() const {
  return mp_;
}
inline void CSCVZHitMonsterRqst::set_mp(::google::protobuf::uint32 value) {
  set_has_mp();
  mp_ = value;
}

// repeated .vmsg.CSCVZMonsterHurt MonsterHurt = 2;
inline int CSCVZHitMonsterRqst::monsterhurt_size() const {
  return monsterhurt_.size();
}
inline void CSCVZHitMonsterRqst::clear_monsterhurt() {
  monsterhurt_.Clear();
}
inline const ::vmsg::CSCVZMonsterHurt& CSCVZHitMonsterRqst::monsterhurt(int index) const {
  return monsterhurt_.Get(index);
}
inline ::vmsg::CSCVZMonsterHurt* CSCVZHitMonsterRqst::mutable_monsterhurt(int index) {
  return monsterhurt_.Mutable(index);
}
inline ::vmsg::CSCVZMonsterHurt* CSCVZHitMonsterRqst::add_monsterhurt() {
  return monsterhurt_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSCVZMonsterHurt >&
CSCVZHitMonsterRqst::monsterhurt() const {
  return monsterhurt_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSCVZMonsterHurt >*
CSCVZHitMonsterRqst::mutable_monsterhurt() {
  return &monsterhurt_;
}

// -------------------------------------------------------------------

// CSCVZHitedRqst

// required uint32 HP = 1;
inline bool CSCVZHitedRqst::has_hp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSCVZHitedRqst::set_has_hp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSCVZHitedRqst::clear_has_hp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSCVZHitedRqst::clear_hp() {
  hp_ = 0u;
  clear_has_hp();
}
inline ::google::protobuf::uint32 CSCVZHitedRqst::hp() const {
  return hp_;
}
inline void CSCVZHitedRqst::set_hp(::google::protobuf::uint32 value) {
  set_has_hp();
  hp_ = value;
}

// -------------------------------------------------------------------

// CSVZControlMonsterInfo

// required uint32 MonsterID = 1;
inline bool CSVZControlMonsterInfo::has_monsterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSVZControlMonsterInfo::set_has_monsterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSVZControlMonsterInfo::clear_has_monsterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSVZControlMonsterInfo::clear_monsterid() {
  monsterid_ = 0u;
  clear_has_monsterid();
}
inline ::google::protobuf::uint32 CSVZControlMonsterInfo::monsterid() const {
  return monsterid_;
}
inline void CSVZControlMonsterInfo::set_monsterid(::google::protobuf::uint32 value) {
  set_has_monsterid();
  monsterid_ = value;
}

// required uint32 Channel = 2;
inline bool CSVZControlMonsterInfo::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSVZControlMonsterInfo::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSVZControlMonsterInfo::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSVZControlMonsterInfo::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 CSVZControlMonsterInfo::channel() const {
  return channel_;
}
inline void CSVZControlMonsterInfo::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
}

// required uint32 Wave = 3;
inline bool CSVZControlMonsterInfo::has_wave() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSVZControlMonsterInfo::set_has_wave() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSVZControlMonsterInfo::clear_has_wave() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSVZControlMonsterInfo::clear_wave() {
  wave_ = 0u;
  clear_has_wave();
}
inline ::google::protobuf::uint32 CSVZControlMonsterInfo::wave() const {
  return wave_;
}
inline void CSVZControlMonsterInfo::set_wave(::google::protobuf::uint32 value) {
  set_has_wave();
  wave_ = value;
}

// required uint32 Lv = 4;
inline bool CSVZControlMonsterInfo::has_lv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSVZControlMonsterInfo::set_has_lv() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSVZControlMonsterInfo::clear_has_lv() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSVZControlMonsterInfo::clear_lv() {
  lv_ = 0u;
  clear_has_lv();
}
inline ::google::protobuf::uint32 CSVZControlMonsterInfo::lv() const {
  return lv_;
}
inline void CSVZControlMonsterInfo::set_lv(::google::protobuf::uint32 value) {
  set_has_lv();
  lv_ = value;
}

// -------------------------------------------------------------------

// CSCVZControlNotify

// repeated .vmsg.CSVZControlMonsterInfo Monsters = 1;
inline int CSCVZControlNotify::monsters_size() const {
  return monsters_.size();
}
inline void CSCVZControlNotify::clear_monsters() {
  monsters_.Clear();
}
inline const ::vmsg::CSVZControlMonsterInfo& CSCVZControlNotify::monsters(int index) const {
  return monsters_.Get(index);
}
inline ::vmsg::CSVZControlMonsterInfo* CSCVZControlNotify::mutable_monsters(int index) {
  return monsters_.Mutable(index);
}
inline ::vmsg::CSVZControlMonsterInfo* CSCVZControlNotify::add_monsters() {
  return monsters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSVZControlMonsterInfo >&
CSCVZControlNotify::monsters() const {
  return monsters_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSVZControlMonsterInfo >*
CSCVZControlNotify::mutable_monsters() {
  return &monsters_;
}

// -------------------------------------------------------------------

// CSCVZDestroyBaseNotify

// repeated uint32 BaseHP = 1;
inline int CSCVZDestroyBaseNotify::basehp_size() const {
  return basehp_.size();
}
inline void CSCVZDestroyBaseNotify::clear_basehp() {
  basehp_.Clear();
}
inline ::google::protobuf::uint32 CSCVZDestroyBaseNotify::basehp(int index) const {
  return basehp_.Get(index);
}
inline void CSCVZDestroyBaseNotify::set_basehp(int index, ::google::protobuf::uint32 value) {
  basehp_.Set(index, value);
}
inline void CSCVZDestroyBaseNotify::add_basehp(::google::protobuf::uint32 value) {
  basehp_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSCVZDestroyBaseNotify::basehp() const {
  return basehp_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSCVZDestroyBaseNotify::mutable_basehp() {
  return &basehp_;
}

// repeated uint32 MonsrerIDs = 2;
inline int CSCVZDestroyBaseNotify::monsrerids_size() const {
  return monsrerids_.size();
}
inline void CSCVZDestroyBaseNotify::clear_monsrerids() {
  monsrerids_.Clear();
}
inline ::google::protobuf::uint32 CSCVZDestroyBaseNotify::monsrerids(int index) const {
  return monsrerids_.Get(index);
}
inline void CSCVZDestroyBaseNotify::set_monsrerids(int index, ::google::protobuf::uint32 value) {
  monsrerids_.Set(index, value);
}
inline void CSCVZDestroyBaseNotify::add_monsrerids(::google::protobuf::uint32 value) {
  monsrerids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSCVZDestroyBaseNotify::monsrerids() const {
  return monsrerids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSCVZDestroyBaseNotify::mutable_monsrerids() {
  return &monsrerids_;
}

// -------------------------------------------------------------------

// CSCVZHitMonsterNotify

// repeated .vmsg.CSCVZMonsterHP MonsterHP = 1;
inline int CSCVZHitMonsterNotify::monsterhp_size() const {
  return monsterhp_.size();
}
inline void CSCVZHitMonsterNotify::clear_monsterhp() {
  monsterhp_.Clear();
}
inline const ::vmsg::CSCVZMonsterHP& CSCVZHitMonsterNotify::monsterhp(int index) const {
  return monsterhp_.Get(index);
}
inline ::vmsg::CSCVZMonsterHP* CSCVZHitMonsterNotify::mutable_monsterhp(int index) {
  return monsterhp_.Mutable(index);
}
inline ::vmsg::CSCVZMonsterHP* CSCVZHitMonsterNotify::add_monsterhp() {
  return monsterhp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSCVZMonsterHP >&
CSCVZHitMonsterNotify::monsterhp() const {
  return monsterhp_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSCVZMonsterHP >*
CSCVZHitMonsterNotify::mutable_monsterhp() {
  return &monsterhp_;
}

// -------------------------------------------------------------------

// CSCVZHitedNotify

// required uint64 Uin = 1;
inline bool CSCVZHitedNotify::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSCVZHitedNotify::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSCVZHitedNotify::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSCVZHitedNotify::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSCVZHitedNotify::uin() const {
  return uin_;
}
inline void CSCVZHitedNotify::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
}

// required uint32 HP = 2;
inline bool CSCVZHitedNotify::has_hp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSCVZHitedNotify::set_has_hp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSCVZHitedNotify::clear_has_hp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSCVZHitedNotify::clear_hp() {
  hp_ = 0u;
  clear_has_hp();
}
inline ::google::protobuf::uint32 CSCVZHitedNotify::hp() const {
  return hp_;
}
inline void CSCVZHitedNotify::set_hp(::google::protobuf::uint32 value) {
  set_has_hp();
  hp_ = value;
}

// -------------------------------------------------------------------

// CSCVZMonsterInfo

// required uint32 MonsterID = 1;
inline bool CSCVZMonsterInfo::has_monsterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSCVZMonsterInfo::set_has_monsterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSCVZMonsterInfo::clear_has_monsterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSCVZMonsterInfo::clear_monsterid() {
  monsterid_ = 0u;
  clear_has_monsterid();
}
inline ::google::protobuf::uint32 CSCVZMonsterInfo::monsterid() const {
  return monsterid_;
}
inline void CSCVZMonsterInfo::set_monsterid(::google::protobuf::uint32 value) {
  set_has_monsterid();
  monsterid_ = value;
}

// required .vmsg.CSScenePoint Pos = 2;
inline bool CSCVZMonsterInfo::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSCVZMonsterInfo::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSCVZMonsterInfo::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSCVZMonsterInfo::clear_pos() {
  if (pos_ != NULL) pos_->::vmsg::CSScenePoint::Clear();
  clear_has_pos();
}
inline const ::vmsg::CSScenePoint& CSCVZMonsterInfo::pos() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return pos_ != NULL ? *pos_ : *default_instance().pos_;
#else
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
#endif
}
inline ::vmsg::CSScenePoint* CSCVZMonsterInfo::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::vmsg::CSScenePoint;
  return pos_;
}
inline ::vmsg::CSScenePoint* CSCVZMonsterInfo::release_pos() {
  clear_has_pos();
  ::vmsg::CSScenePoint* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void CSCVZMonsterInfo::set_allocated_pos(::vmsg::CSScenePoint* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
}

// required uint32 Action = 3;
inline bool CSCVZMonsterInfo::has_action() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSCVZMonsterInfo::set_has_action() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSCVZMonsterInfo::clear_has_action() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSCVZMonsterInfo::clear_action() {
  action_ = 0u;
  clear_has_action();
}
inline ::google::protobuf::uint32 CSCVZMonsterInfo::action() const {
  return action_;
}
inline void CSCVZMonsterInfo::set_action(::google::protobuf::uint32 value) {
  set_has_action();
  action_ = value;
}

// required uint32 Wave = 4;
inline bool CSCVZMonsterInfo::has_wave() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSCVZMonsterInfo::set_has_wave() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSCVZMonsterInfo::clear_has_wave() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSCVZMonsterInfo::clear_wave() {
  wave_ = 0u;
  clear_has_wave();
}
inline ::google::protobuf::uint32 CSCVZMonsterInfo::wave() const {
  return wave_;
}
inline void CSCVZMonsterInfo::set_wave(::google::protobuf::uint32 value) {
  set_has_wave();
  wave_ = value;
}

// required uint32 Lv = 5;
inline bool CSCVZMonsterInfo::has_lv() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSCVZMonsterInfo::set_has_lv() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSCVZMonsterInfo::clear_has_lv() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSCVZMonsterInfo::clear_lv() {
  lv_ = 0u;
  clear_has_lv();
}
inline ::google::protobuf::uint32 CSCVZMonsterInfo::lv() const {
  return lv_;
}
inline void CSCVZMonsterInfo::set_lv(::google::protobuf::uint32 value) {
  set_has_lv();
  lv_ = value;
}

// required uint32 SkillID = 6;
inline bool CSCVZMonsterInfo::has_skillid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSCVZMonsterInfo::set_has_skillid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSCVZMonsterInfo::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSCVZMonsterInfo::clear_skillid() {
  skillid_ = 0u;
  clear_has_skillid();
}
inline ::google::protobuf::uint32 CSCVZMonsterInfo::skillid() const {
  return skillid_;
}
inline void CSCVZMonsterInfo::set_skillid(::google::protobuf::uint32 value) {
  set_has_skillid();
  skillid_ = value;
}

// -------------------------------------------------------------------

// CSCVZMonsters

// repeated .vmsg.CSCVZMonsterInfo Monsters = 1;
inline int CSCVZMonsters::monsters_size() const {
  return monsters_.size();
}
inline void CSCVZMonsters::clear_monsters() {
  monsters_.Clear();
}
inline const ::vmsg::CSCVZMonsterInfo& CSCVZMonsters::monsters(int index) const {
  return monsters_.Get(index);
}
inline ::vmsg::CSCVZMonsterInfo* CSCVZMonsters::mutable_monsters(int index) {
  return monsters_.Mutable(index);
}
inline ::vmsg::CSCVZMonsterInfo* CSCVZMonsters::add_monsters() {
  return monsters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSCVZMonsterInfo >&
CSCVZMonsters::monsters() const {
  return monsters_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSCVZMonsterInfo >*
CSCVZMonsters::mutable_monsters() {
  return &monsters_;
}

// -------------------------------------------------------------------

// CSCVZRankData

// required uint64 Uin = 1;
inline bool CSCVZRankData::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSCVZRankData::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSCVZRankData::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSCVZRankData::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSCVZRankData::uin() const {
  return uin_;
}
inline void CSCVZRankData::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
}

// required string Name = 2;
inline bool CSCVZRankData::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSCVZRankData::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSCVZRankData::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSCVZRankData::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CSCVZRankData::name() const {
  return *name_;
}
inline void CSCVZRankData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CSCVZRankData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CSCVZRankData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSCVZRankData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CSCVZRankData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSCVZRankData::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 Hit = 3;
inline bool CSCVZRankData::has_hit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSCVZRankData::set_has_hit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSCVZRankData::clear_has_hit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSCVZRankData::clear_hit() {
  hit_ = GOOGLE_ULONGLONG(0);
  clear_has_hit();
}
inline ::google::protobuf::uint64 CSCVZRankData::hit() const {
  return hit_;
}
inline void CSCVZRankData::set_hit(::google::protobuf::uint64 value) {
  set_has_hit();
  hit_ = value;
}

// -------------------------------------------------------------------

// CSCVZRankInfo

// repeated .vmsg.CSCVZRankData RankDatas = 1;
inline int CSCVZRankInfo::rankdatas_size() const {
  return rankdatas_.size();
}
inline void CSCVZRankInfo::clear_rankdatas() {
  rankdatas_.Clear();
}
inline const ::vmsg::CSCVZRankData& CSCVZRankInfo::rankdatas(int index) const {
  return rankdatas_.Get(index);
}
inline ::vmsg::CSCVZRankData* CSCVZRankInfo::mutable_rankdatas(int index) {
  return rankdatas_.Mutable(index);
}
inline ::vmsg::CSCVZRankData* CSCVZRankInfo::add_rankdatas() {
  return rankdatas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSCVZRankData >&
CSCVZRankInfo::rankdatas() const {
  return rankdatas_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSCVZRankData >*
CSCVZRankInfo::mutable_rankdatas() {
  return &rankdatas_;
}

// -------------------------------------------------------------------

// CSCVZRequest

// optional .vmsg.CSCVZHitMonsterRqst HitMonster_Rqst = 1;
inline bool CSCVZRequest::has_hitmonster_rqst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSCVZRequest::set_has_hitmonster_rqst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSCVZRequest::clear_has_hitmonster_rqst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSCVZRequest::clear_hitmonster_rqst() {
  if (hitmonster_rqst_ != NULL) hitmonster_rqst_->::vmsg::CSCVZHitMonsterRqst::Clear();
  clear_has_hitmonster_rqst();
}
inline const ::vmsg::CSCVZHitMonsterRqst& CSCVZRequest::hitmonster_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return hitmonster_rqst_ != NULL ? *hitmonster_rqst_ : *default_instance().hitmonster_rqst_;
#else
  return hitmonster_rqst_ != NULL ? *hitmonster_rqst_ : *default_instance_->hitmonster_rqst_;
#endif
}
inline ::vmsg::CSCVZHitMonsterRqst* CSCVZRequest::mutable_hitmonster_rqst() {
  set_has_hitmonster_rqst();
  if (hitmonster_rqst_ == NULL) hitmonster_rqst_ = new ::vmsg::CSCVZHitMonsterRqst;
  return hitmonster_rqst_;
}
inline ::vmsg::CSCVZHitMonsterRqst* CSCVZRequest::release_hitmonster_rqst() {
  clear_has_hitmonster_rqst();
  ::vmsg::CSCVZHitMonsterRqst* temp = hitmonster_rqst_;
  hitmonster_rqst_ = NULL;
  return temp;
}
inline void CSCVZRequest::set_allocated_hitmonster_rqst(::vmsg::CSCVZHitMonsterRqst* hitmonster_rqst) {
  delete hitmonster_rqst_;
  hitmonster_rqst_ = hitmonster_rqst;
  if (hitmonster_rqst) {
    set_has_hitmonster_rqst();
  } else {
    clear_has_hitmonster_rqst();
  }
}

// optional .vmsg.CSCVZHitedRqst Hited_Rqst = 2;
inline bool CSCVZRequest::has_hited_rqst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSCVZRequest::set_has_hited_rqst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSCVZRequest::clear_has_hited_rqst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSCVZRequest::clear_hited_rqst() {
  if (hited_rqst_ != NULL) hited_rqst_->::vmsg::CSCVZHitedRqst::Clear();
  clear_has_hited_rqst();
}
inline const ::vmsg::CSCVZHitedRqst& CSCVZRequest::hited_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return hited_rqst_ != NULL ? *hited_rqst_ : *default_instance().hited_rqst_;
#else
  return hited_rqst_ != NULL ? *hited_rqst_ : *default_instance_->hited_rqst_;
#endif
}
inline ::vmsg::CSCVZHitedRqst* CSCVZRequest::mutable_hited_rqst() {
  set_has_hited_rqst();
  if (hited_rqst_ == NULL) hited_rqst_ = new ::vmsg::CSCVZHitedRqst;
  return hited_rqst_;
}
inline ::vmsg::CSCVZHitedRqst* CSCVZRequest::release_hited_rqst() {
  clear_has_hited_rqst();
  ::vmsg::CSCVZHitedRqst* temp = hited_rqst_;
  hited_rqst_ = NULL;
  return temp;
}
inline void CSCVZRequest::set_allocated_hited_rqst(::vmsg::CSCVZHitedRqst* hited_rqst) {
  delete hited_rqst_;
  hited_rqst_ = hited_rqst;
  if (hited_rqst) {
    set_has_hited_rqst();
  } else {
    clear_has_hited_rqst();
  }
}

// optional int32 DestroyBase_Rqst = 3;
inline bool CSCVZRequest::has_destroybase_rqst() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSCVZRequest::set_has_destroybase_rqst() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSCVZRequest::clear_has_destroybase_rqst() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSCVZRequest::clear_destroybase_rqst() {
  destroybase_rqst_ = 0;
  clear_has_destroybase_rqst();
}
inline ::google::protobuf::int32 CSCVZRequest::destroybase_rqst() const {
  return destroybase_rqst_;
}
inline void CSCVZRequest::set_destroybase_rqst(::google::protobuf::int32 value) {
  set_has_destroybase_rqst();
  destroybase_rqst_ = value;
}

// optional .vmsg.CSCVZMonsters SubmitMonster_Rqst = 4;
inline bool CSCVZRequest::has_submitmonster_rqst() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSCVZRequest::set_has_submitmonster_rqst() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSCVZRequest::clear_has_submitmonster_rqst() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSCVZRequest::clear_submitmonster_rqst() {
  if (submitmonster_rqst_ != NULL) submitmonster_rqst_->::vmsg::CSCVZMonsters::Clear();
  clear_has_submitmonster_rqst();
}
inline const ::vmsg::CSCVZMonsters& CSCVZRequest::submitmonster_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return submitmonster_rqst_ != NULL ? *submitmonster_rqst_ : *default_instance().submitmonster_rqst_;
#else
  return submitmonster_rqst_ != NULL ? *submitmonster_rqst_ : *default_instance_->submitmonster_rqst_;
#endif
}
inline ::vmsg::CSCVZMonsters* CSCVZRequest::mutable_submitmonster_rqst() {
  set_has_submitmonster_rqst();
  if (submitmonster_rqst_ == NULL) submitmonster_rqst_ = new ::vmsg::CSCVZMonsters;
  return submitmonster_rqst_;
}
inline ::vmsg::CSCVZMonsters* CSCVZRequest::release_submitmonster_rqst() {
  clear_has_submitmonster_rqst();
  ::vmsg::CSCVZMonsters* temp = submitmonster_rqst_;
  submitmonster_rqst_ = NULL;
  return temp;
}
inline void CSCVZRequest::set_allocated_submitmonster_rqst(::vmsg::CSCVZMonsters* submitmonster_rqst) {
  delete submitmonster_rqst_;
  submitmonster_rqst_ = submitmonster_rqst;
  if (submitmonster_rqst) {
    set_has_submitmonster_rqst();
  } else {
    clear_has_submitmonster_rqst();
  }
}

// -------------------------------------------------------------------

// CSCVZRespond

// optional .vmsg.CSCVZControlNotify Control_Notify = 1;
inline bool CSCVZRespond::has_control_notify() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSCVZRespond::set_has_control_notify() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSCVZRespond::clear_has_control_notify() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSCVZRespond::clear_control_notify() {
  if (control_notify_ != NULL) control_notify_->::vmsg::CSCVZControlNotify::Clear();
  clear_has_control_notify();
}
inline const ::vmsg::CSCVZControlNotify& CSCVZRespond::control_notify() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return control_notify_ != NULL ? *control_notify_ : *default_instance().control_notify_;
#else
  return control_notify_ != NULL ? *control_notify_ : *default_instance_->control_notify_;
#endif
}
inline ::vmsg::CSCVZControlNotify* CSCVZRespond::mutable_control_notify() {
  set_has_control_notify();
  if (control_notify_ == NULL) control_notify_ = new ::vmsg::CSCVZControlNotify;
  return control_notify_;
}
inline ::vmsg::CSCVZControlNotify* CSCVZRespond::release_control_notify() {
  clear_has_control_notify();
  ::vmsg::CSCVZControlNotify* temp = control_notify_;
  control_notify_ = NULL;
  return temp;
}
inline void CSCVZRespond::set_allocated_control_notify(::vmsg::CSCVZControlNotify* control_notify) {
  delete control_notify_;
  control_notify_ = control_notify;
  if (control_notify) {
    set_has_control_notify();
  } else {
    clear_has_control_notify();
  }
}

// optional .vmsg.CSCVZDestroyBaseNotify DestroyBase_Notify = 2;
inline bool CSCVZRespond::has_destroybase_notify() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSCVZRespond::set_has_destroybase_notify() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSCVZRespond::clear_has_destroybase_notify() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSCVZRespond::clear_destroybase_notify() {
  if (destroybase_notify_ != NULL) destroybase_notify_->::vmsg::CSCVZDestroyBaseNotify::Clear();
  clear_has_destroybase_notify();
}
inline const ::vmsg::CSCVZDestroyBaseNotify& CSCVZRespond::destroybase_notify() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return destroybase_notify_ != NULL ? *destroybase_notify_ : *default_instance().destroybase_notify_;
#else
  return destroybase_notify_ != NULL ? *destroybase_notify_ : *default_instance_->destroybase_notify_;
#endif
}
inline ::vmsg::CSCVZDestroyBaseNotify* CSCVZRespond::mutable_destroybase_notify() {
  set_has_destroybase_notify();
  if (destroybase_notify_ == NULL) destroybase_notify_ = new ::vmsg::CSCVZDestroyBaseNotify;
  return destroybase_notify_;
}
inline ::vmsg::CSCVZDestroyBaseNotify* CSCVZRespond::release_destroybase_notify() {
  clear_has_destroybase_notify();
  ::vmsg::CSCVZDestroyBaseNotify* temp = destroybase_notify_;
  destroybase_notify_ = NULL;
  return temp;
}
inline void CSCVZRespond::set_allocated_destroybase_notify(::vmsg::CSCVZDestroyBaseNotify* destroybase_notify) {
  delete destroybase_notify_;
  destroybase_notify_ = destroybase_notify;
  if (destroybase_notify) {
    set_has_destroybase_notify();
  } else {
    clear_has_destroybase_notify();
  }
}

// optional .vmsg.CSCVZHitMonsterNotify HitMonster_Notify = 3;
inline bool CSCVZRespond::has_hitmonster_notify() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSCVZRespond::set_has_hitmonster_notify() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSCVZRespond::clear_has_hitmonster_notify() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSCVZRespond::clear_hitmonster_notify() {
  if (hitmonster_notify_ != NULL) hitmonster_notify_->::vmsg::CSCVZHitMonsterNotify::Clear();
  clear_has_hitmonster_notify();
}
inline const ::vmsg::CSCVZHitMonsterNotify& CSCVZRespond::hitmonster_notify() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return hitmonster_notify_ != NULL ? *hitmonster_notify_ : *default_instance().hitmonster_notify_;
#else
  return hitmonster_notify_ != NULL ? *hitmonster_notify_ : *default_instance_->hitmonster_notify_;
#endif
}
inline ::vmsg::CSCVZHitMonsterNotify* CSCVZRespond::mutable_hitmonster_notify() {
  set_has_hitmonster_notify();
  if (hitmonster_notify_ == NULL) hitmonster_notify_ = new ::vmsg::CSCVZHitMonsterNotify;
  return hitmonster_notify_;
}
inline ::vmsg::CSCVZHitMonsterNotify* CSCVZRespond::release_hitmonster_notify() {
  clear_has_hitmonster_notify();
  ::vmsg::CSCVZHitMonsterNotify* temp = hitmonster_notify_;
  hitmonster_notify_ = NULL;
  return temp;
}
inline void CSCVZRespond::set_allocated_hitmonster_notify(::vmsg::CSCVZHitMonsterNotify* hitmonster_notify) {
  delete hitmonster_notify_;
  hitmonster_notify_ = hitmonster_notify;
  if (hitmonster_notify) {
    set_has_hitmonster_notify();
  } else {
    clear_has_hitmonster_notify();
  }
}

// optional .vmsg.CSCVZHitedNotify Hited_Notify = 4;
inline bool CSCVZRespond::has_hited_notify() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSCVZRespond::set_has_hited_notify() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSCVZRespond::clear_has_hited_notify() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSCVZRespond::clear_hited_notify() {
  if (hited_notify_ != NULL) hited_notify_->::vmsg::CSCVZHitedNotify::Clear();
  clear_has_hited_notify();
}
inline const ::vmsg::CSCVZHitedNotify& CSCVZRespond::hited_notify() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return hited_notify_ != NULL ? *hited_notify_ : *default_instance().hited_notify_;
#else
  return hited_notify_ != NULL ? *hited_notify_ : *default_instance_->hited_notify_;
#endif
}
inline ::vmsg::CSCVZHitedNotify* CSCVZRespond::mutable_hited_notify() {
  set_has_hited_notify();
  if (hited_notify_ == NULL) hited_notify_ = new ::vmsg::CSCVZHitedNotify;
  return hited_notify_;
}
inline ::vmsg::CSCVZHitedNotify* CSCVZRespond::release_hited_notify() {
  clear_has_hited_notify();
  ::vmsg::CSCVZHitedNotify* temp = hited_notify_;
  hited_notify_ = NULL;
  return temp;
}
inline void CSCVZRespond::set_allocated_hited_notify(::vmsg::CSCVZHitedNotify* hited_notify) {
  delete hited_notify_;
  hited_notify_ = hited_notify;
  if (hited_notify) {
    set_has_hited_notify();
  } else {
    clear_has_hited_notify();
  }
}

// optional .vmsg.CSCVZMonsters Monsters_Notify = 5;
inline bool CSCVZRespond::has_monsters_notify() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSCVZRespond::set_has_monsters_notify() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSCVZRespond::clear_has_monsters_notify() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSCVZRespond::clear_monsters_notify() {
  if (monsters_notify_ != NULL) monsters_notify_->::vmsg::CSCVZMonsters::Clear();
  clear_has_monsters_notify();
}
inline const ::vmsg::CSCVZMonsters& CSCVZRespond::monsters_notify() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return monsters_notify_ != NULL ? *monsters_notify_ : *default_instance().monsters_notify_;
#else
  return monsters_notify_ != NULL ? *monsters_notify_ : *default_instance_->monsters_notify_;
#endif
}
inline ::vmsg::CSCVZMonsters* CSCVZRespond::mutable_monsters_notify() {
  set_has_monsters_notify();
  if (monsters_notify_ == NULL) monsters_notify_ = new ::vmsg::CSCVZMonsters;
  return monsters_notify_;
}
inline ::vmsg::CSCVZMonsters* CSCVZRespond::release_monsters_notify() {
  clear_has_monsters_notify();
  ::vmsg::CSCVZMonsters* temp = monsters_notify_;
  monsters_notify_ = NULL;
  return temp;
}
inline void CSCVZRespond::set_allocated_monsters_notify(::vmsg::CSCVZMonsters* monsters_notify) {
  delete monsters_notify_;
  monsters_notify_ = monsters_notify;
  if (monsters_notify) {
    set_has_monsters_notify();
  } else {
    clear_has_monsters_notify();
  }
}

// optional .vmsg.CSCVZRankInfo RankInfo_Notify = 6;
inline bool CSCVZRespond::has_rankinfo_notify() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSCVZRespond::set_has_rankinfo_notify() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSCVZRespond::clear_has_rankinfo_notify() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSCVZRespond::clear_rankinfo_notify() {
  if (rankinfo_notify_ != NULL) rankinfo_notify_->::vmsg::CSCVZRankInfo::Clear();
  clear_has_rankinfo_notify();
}
inline const ::vmsg::CSCVZRankInfo& CSCVZRespond::rankinfo_notify() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return rankinfo_notify_ != NULL ? *rankinfo_notify_ : *default_instance().rankinfo_notify_;
#else
  return rankinfo_notify_ != NULL ? *rankinfo_notify_ : *default_instance_->rankinfo_notify_;
#endif
}
inline ::vmsg::CSCVZRankInfo* CSCVZRespond::mutable_rankinfo_notify() {
  set_has_rankinfo_notify();
  if (rankinfo_notify_ == NULL) rankinfo_notify_ = new ::vmsg::CSCVZRankInfo;
  return rankinfo_notify_;
}
inline ::vmsg::CSCVZRankInfo* CSCVZRespond::release_rankinfo_notify() {
  clear_has_rankinfo_notify();
  ::vmsg::CSCVZRankInfo* temp = rankinfo_notify_;
  rankinfo_notify_ = NULL;
  return temp;
}
inline void CSCVZRespond::set_allocated_rankinfo_notify(::vmsg::CSCVZRankInfo* rankinfo_notify) {
  delete rankinfo_notify_;
  rankinfo_notify_ = rankinfo_notify;
  if (rankinfo_notify) {
    set_has_rankinfo_notify();
  } else {
    clear_has_rankinfo_notify();
  }
}

// optional uint32 NextWaveRemainTime = 7;
inline bool CSCVZRespond::has_nextwaveremaintime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSCVZRespond::set_has_nextwaveremaintime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSCVZRespond::clear_has_nextwaveremaintime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSCVZRespond::clear_nextwaveremaintime() {
  nextwaveremaintime_ = 0u;
  clear_has_nextwaveremaintime();
}
inline ::google::protobuf::uint32 CSCVZRespond::nextwaveremaintime() const {
  return nextwaveremaintime_;
}
inline void CSCVZRespond::set_nextwaveremaintime(::google::protobuf::uint32 value) {
  set_has_nextwaveremaintime();
  nextwaveremaintime_ = value;
}

// optional uint32 MyContAwardCoin_Notify = 8;
inline bool CSCVZRespond::has_mycontawardcoin_notify() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSCVZRespond::set_has_mycontawardcoin_notify() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSCVZRespond::clear_has_mycontawardcoin_notify() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSCVZRespond::clear_mycontawardcoin_notify() {
  mycontawardcoin_notify_ = 0u;
  clear_has_mycontawardcoin_notify();
}
inline ::google::protobuf::uint32 CSCVZRespond::mycontawardcoin_notify() const {
  return mycontawardcoin_notify_;
}
inline void CSCVZRespond::set_mycontawardcoin_notify(::google::protobuf::uint32 value) {
  set_has_mycontawardcoin_notify();
  mycontawardcoin_notify_ = value;
}

// optional uint32 TotalCont_Notify = 9;
inline bool CSCVZRespond::has_totalcont_notify() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSCVZRespond::set_has_totalcont_notify() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSCVZRespond::clear_has_totalcont_notify() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSCVZRespond::clear_totalcont_notify() {
  totalcont_notify_ = 0u;
  clear_has_totalcont_notify();
}
inline ::google::protobuf::uint32 CSCVZRespond::totalcont_notify() const {
  return totalcont_notify_;
}
inline void CSCVZRespond::set_totalcont_notify(::google::protobuf::uint32 value) {
  set_has_totalcont_notify();
  totalcont_notify_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CSCVZMsg_2eproto__INCLUDED
