// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSGoldMsg.proto

#ifndef PROTOBUF_CSGoldMsg_2eproto__INCLUDED
#define PROTOBUF_CSGoldMsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MsgBase.pb.h"
#include "ShareByClient.pb.h"
#include "CSBagMsg.pb.h"
// @@protoc_insertion_point(includes)

namespace vmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CSGoldMsg_2eproto();
void protobuf_AssignDesc_CSGoldMsg_2eproto();
void protobuf_ShutdownFile_CSGoldMsg_2eproto();

class CSGoldInfo;
class CSBuyGoldRqst;
class CSBuyGoldRsp;
class CSBuyRMBStoreRqst;
class CSBuyRMBStoreRsp;
class CSRMBStoreProductInfo;
class CSQueryRMBStoreRsp;
class CSQueryRMBStoreItemRqst;
class CSQueryRMBStoreItemRsp;
class CSAppAuthedBuyRqst;
class CSAppAuthedBuyRsp;
class CSAppAuthedBuySucceedRqst;
class CSGoldRequest;
class CSGoldRespond;

// ===================================================================

class CSGoldInfo : public ::google::protobuf::MessageLite {
 public:
  CSGoldInfo();
  virtual ~CSGoldInfo();

  CSGoldInfo(const CSGoldInfo& from);

  inline CSGoldInfo& operator=(const CSGoldInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSGoldInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGoldInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGoldInfo* other);

  // implements Message ----------------------------------------------

  CSGoldInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGoldInfo& from);
  void MergeFrom(const CSGoldInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Gold = 1;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 1;
  inline ::google::protobuf::uint32 gold() const;
  inline void set_gold(::google::protobuf::uint32 value);

  // required uint32 TotalGoldByMoney = 2;
  inline bool has_totalgoldbymoney() const;
  inline void clear_totalgoldbymoney();
  static const int kTotalGoldByMoneyFieldNumber = 2;
  inline ::google::protobuf::uint32 totalgoldbymoney() const;
  inline void set_totalgoldbymoney(::google::protobuf::uint32 value);

  // optional uint32 PayFlag = 3;
  inline bool has_payflag() const;
  inline void clear_payflag();
  static const int kPayFlagFieldNumber = 3;
  inline ::google::protobuf::uint32 payflag() const;
  inline void set_payflag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSGoldInfo)
 private:
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_totalgoldbymoney();
  inline void clear_has_totalgoldbymoney();
  inline void set_has_payflag();
  inline void clear_has_payflag();

  ::google::protobuf::uint32 gold_;
  ::google::protobuf::uint32 totalgoldbymoney_;
  ::google::protobuf::uint32 payflag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSGoldMsg_2eproto();
  friend void protobuf_ShutdownFile_CSGoldMsg_2eproto();

  void InitAsDefaultInstance();
  static CSGoldInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSBuyGoldRqst : public ::google::protobuf::MessageLite {
 public:
  CSBuyGoldRqst();
  virtual ~CSBuyGoldRqst();

  CSBuyGoldRqst(const CSBuyGoldRqst& from);

  inline CSBuyGoldRqst& operator=(const CSBuyGoldRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBuyGoldRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBuyGoldRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBuyGoldRqst* other);

  // implements Message ----------------------------------------------

  CSBuyGoldRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBuyGoldRqst& from);
  void MergeFrom(const CSBuyGoldRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string str = 1;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 1;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  inline void set_allocated_str(::std::string* str);

  // @@protoc_insertion_point(class_scope:vmsg.CSBuyGoldRqst)
 private:
  inline void set_has_str();
  inline void clear_has_str();

  ::std::string* str_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSGoldMsg_2eproto();
  friend void protobuf_ShutdownFile_CSGoldMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBuyGoldRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSBuyGoldRsp : public ::google::protobuf::MessageLite {
 public:
  CSBuyGoldRsp();
  virtual ~CSBuyGoldRsp();

  CSBuyGoldRsp(const CSBuyGoldRsp& from);

  inline CSBuyGoldRsp& operator=(const CSBuyGoldRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBuyGoldRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBuyGoldRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBuyGoldRsp* other);

  // implements Message ----------------------------------------------

  CSBuyGoldRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBuyGoldRsp& from);
  void MergeFrom(const CSBuyGoldRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string str = 1;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 1;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  inline void set_allocated_str(::std::string* str);

  // @@protoc_insertion_point(class_scope:vmsg.CSBuyGoldRsp)
 private:
  inline void set_has_str();
  inline void clear_has_str();

  ::std::string* str_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSGoldMsg_2eproto();
  friend void protobuf_ShutdownFile_CSGoldMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBuyGoldRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSBuyRMBStoreRqst : public ::google::protobuf::MessageLite {
 public:
  CSBuyRMBStoreRqst();
  virtual ~CSBuyRMBStoreRqst();

  CSBuyRMBStoreRqst(const CSBuyRMBStoreRqst& from);

  inline CSBuyRMBStoreRqst& operator=(const CSBuyRMBStoreRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBuyRMBStoreRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBuyRMBStoreRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBuyRMBStoreRqst* other);

  // implements Message ----------------------------------------------

  CSBuyRMBStoreRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBuyRMBStoreRqst& from);
  void MergeFrom(const CSBuyRMBStoreRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string str = 1;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 1;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  inline void set_allocated_str(::std::string* str);

  // @@protoc_insertion_point(class_scope:vmsg.CSBuyRMBStoreRqst)
 private:
  inline void set_has_str();
  inline void clear_has_str();

  ::std::string* str_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSGoldMsg_2eproto();
  friend void protobuf_ShutdownFile_CSGoldMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBuyRMBStoreRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSBuyRMBStoreRsp : public ::google::protobuf::MessageLite {
 public:
  CSBuyRMBStoreRsp();
  virtual ~CSBuyRMBStoreRsp();

  CSBuyRMBStoreRsp(const CSBuyRMBStoreRsp& from);

  inline CSBuyRMBStoreRsp& operator=(const CSBuyRMBStoreRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBuyRMBStoreRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBuyRMBStoreRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBuyRMBStoreRsp* other);

  // implements Message ----------------------------------------------

  CSBuyRMBStoreRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBuyRMBStoreRsp& from);
  void MergeFrom(const CSBuyRMBStoreRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string str = 1;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 1;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  inline void set_allocated_str(::std::string* str);

  // optional .vmsg.CSBagInfo BagInfo = 2;
  inline bool has_baginfo() const;
  inline void clear_baginfo();
  static const int kBagInfoFieldNumber = 2;
  inline const ::vmsg::CSBagInfo& baginfo() const;
  inline ::vmsg::CSBagInfo* mutable_baginfo();
  inline ::vmsg::CSBagInfo* release_baginfo();
  inline void set_allocated_baginfo(::vmsg::CSBagInfo* baginfo);

  // @@protoc_insertion_point(class_scope:vmsg.CSBuyRMBStoreRsp)
 private:
  inline void set_has_str();
  inline void clear_has_str();
  inline void set_has_baginfo();
  inline void clear_has_baginfo();

  ::std::string* str_;
  ::vmsg::CSBagInfo* baginfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSGoldMsg_2eproto();
  friend void protobuf_ShutdownFile_CSGoldMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBuyRMBStoreRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSRMBStoreProductInfo : public ::google::protobuf::MessageLite {
 public:
  CSRMBStoreProductInfo();
  virtual ~CSRMBStoreProductInfo();

  CSRMBStoreProductInfo(const CSRMBStoreProductInfo& from);

  inline CSRMBStoreProductInfo& operator=(const CSRMBStoreProductInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSRMBStoreProductInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRMBStoreProductInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRMBStoreProductInfo* other);

  // implements Message ----------------------------------------------

  CSRMBStoreProductInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRMBStoreProductInfo& from);
  void MergeFrom(const CSRMBStoreProductInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ChannelProductID = 1;
  inline bool has_channelproductid() const;
  inline void clear_channelproductid();
  static const int kChannelProductIDFieldNumber = 1;
  inline const ::std::string& channelproductid() const;
  inline void set_channelproductid(const ::std::string& value);
  inline void set_channelproductid(const char* value);
  inline void set_channelproductid(const char* value, size_t size);
  inline ::std::string* mutable_channelproductid();
  inline ::std::string* release_channelproductid();
  inline void set_allocated_channelproductid(::std::string* channelproductid);

  // required uint32 ElmtType = 2;
  inline bool has_elmttype() const;
  inline void clear_elmttype();
  static const int kElmtTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 elmttype() const;
  inline void set_elmttype(::google::protobuf::uint32 value);

  // required uint32 ElmtCfgID = 3;
  inline bool has_elmtcfgid() const;
  inline void clear_elmtcfgid();
  static const int kElmtCfgIDFieldNumber = 3;
  inline ::google::protobuf::uint32 elmtcfgid() const;
  inline void set_elmtcfgid(::google::protobuf::uint32 value);

  // required uint32 ElmtCnt = 4;
  inline bool has_elmtcnt() const;
  inline void clear_elmtcnt();
  static const int kElmtCntFieldNumber = 4;
  inline ::google::protobuf::uint32 elmtcnt() const;
  inline void set_elmtcnt(::google::protobuf::uint32 value);

  // required uint32 ExtraCnt = 5;
  inline bool has_extracnt() const;
  inline void clear_extracnt();
  static const int kExtraCntFieldNumber = 5;
  inline ::google::protobuf::uint32 extracnt() const;
  inline void set_extracnt(::google::protobuf::uint32 value);

  // required uint32 Price = 6;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 6;
  inline ::google::protobuf::uint32 price() const;
  inline void set_price(::google::protobuf::uint32 value);

  // required uint32 FirstExtraCnt = 7;
  inline bool has_firstextracnt() const;
  inline void clear_firstextracnt();
  static const int kFirstExtraCntFieldNumber = 7;
  inline ::google::protobuf::uint32 firstextracnt() const;
  inline void set_firstextracnt(::google::protobuf::uint32 value);

  // required string ICON = 8;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kICONFieldNumber = 8;
  inline const ::std::string& icon() const;
  inline void set_icon(const ::std::string& value);
  inline void set_icon(const char* value);
  inline void set_icon(const char* value, size_t size);
  inline ::std::string* mutable_icon();
  inline ::std::string* release_icon();
  inline void set_allocated_icon(::std::string* icon);

  // required uint32 ID = 9;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 9;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 ExtraItemType = 10;
  inline bool has_extraitemtype() const;
  inline void clear_extraitemtype();
  static const int kExtraItemTypeFieldNumber = 10;
  inline ::google::protobuf::uint32 extraitemtype() const;
  inline void set_extraitemtype(::google::protobuf::uint32 value);

  // required uint32 ExtraItemID = 11;
  inline bool has_extraitemid() const;
  inline void clear_extraitemid();
  static const int kExtraItemIDFieldNumber = 11;
  inline ::google::protobuf::uint32 extraitemid() const;
  inline void set_extraitemid(::google::protobuf::uint32 value);

  // required uint32 ExtraItemCnt = 12;
  inline bool has_extraitemcnt() const;
  inline void clear_extraitemcnt();
  static const int kExtraItemCntFieldNumber = 12;
  inline ::google::protobuf::uint32 extraitemcnt() const;
  inline void set_extraitemcnt(::google::protobuf::uint32 value);

  // required uint32 TabID = 13;
  inline bool has_tabid() const;
  inline void clear_tabid();
  static const int kTabIDFieldNumber = 13;
  inline ::google::protobuf::uint32 tabid() const;
  inline void set_tabid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSRMBStoreProductInfo)
 private:
  inline void set_has_channelproductid();
  inline void clear_has_channelproductid();
  inline void set_has_elmttype();
  inline void clear_has_elmttype();
  inline void set_has_elmtcfgid();
  inline void clear_has_elmtcfgid();
  inline void set_has_elmtcnt();
  inline void clear_has_elmtcnt();
  inline void set_has_extracnt();
  inline void clear_has_extracnt();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_firstextracnt();
  inline void clear_has_firstextracnt();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_extraitemtype();
  inline void clear_has_extraitemtype();
  inline void set_has_extraitemid();
  inline void clear_has_extraitemid();
  inline void set_has_extraitemcnt();
  inline void clear_has_extraitemcnt();
  inline void set_has_tabid();
  inline void clear_has_tabid();

  ::std::string* channelproductid_;
  ::google::protobuf::uint32 elmttype_;
  ::google::protobuf::uint32 elmtcfgid_;
  ::google::protobuf::uint32 elmtcnt_;
  ::google::protobuf::uint32 extracnt_;
  ::google::protobuf::uint32 price_;
  ::google::protobuf::uint32 firstextracnt_;
  ::std::string* icon_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 extraitemtype_;
  ::google::protobuf::uint32 extraitemid_;
  ::google::protobuf::uint32 extraitemcnt_;
  ::google::protobuf::uint32 tabid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSGoldMsg_2eproto();
  friend void protobuf_ShutdownFile_CSGoldMsg_2eproto();

  void InitAsDefaultInstance();
  static CSRMBStoreProductInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSQueryRMBStoreRsp : public ::google::protobuf::MessageLite {
 public:
  CSQueryRMBStoreRsp();
  virtual ~CSQueryRMBStoreRsp();

  CSQueryRMBStoreRsp(const CSQueryRMBStoreRsp& from);

  inline CSQueryRMBStoreRsp& operator=(const CSQueryRMBStoreRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSQueryRMBStoreRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQueryRMBStoreRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQueryRMBStoreRsp* other);

  // implements Message ----------------------------------------------

  CSQueryRMBStoreRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQueryRMBStoreRsp& from);
  void MergeFrom(const CSQueryRMBStoreRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSRMBStoreProductInfo Products = 1;
  inline int products_size() const;
  inline void clear_products();
  static const int kProductsFieldNumber = 1;
  inline const ::vmsg::CSRMBStoreProductInfo& products(int index) const;
  inline ::vmsg::CSRMBStoreProductInfo* mutable_products(int index);
  inline ::vmsg::CSRMBStoreProductInfo* add_products();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSRMBStoreProductInfo >&
      products() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSRMBStoreProductInfo >*
      mutable_products();

  // repeated uint32 BoughtIDs = 2;
  inline int boughtids_size() const;
  inline void clear_boughtids();
  static const int kBoughtIDsFieldNumber = 2;
  inline ::google::protobuf::uint32 boughtids(int index) const;
  inline void set_boughtids(int index, ::google::protobuf::uint32 value);
  inline void add_boughtids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      boughtids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_boughtids();

  // @@protoc_insertion_point(class_scope:vmsg.CSQueryRMBStoreRsp)
 private:

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSRMBStoreProductInfo > products_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > boughtids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSGoldMsg_2eproto();
  friend void protobuf_ShutdownFile_CSGoldMsg_2eproto();

  void InitAsDefaultInstance();
  static CSQueryRMBStoreRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSQueryRMBStoreItemRqst : public ::google::protobuf::MessageLite {
 public:
  CSQueryRMBStoreItemRqst();
  virtual ~CSQueryRMBStoreItemRqst();

  CSQueryRMBStoreItemRqst(const CSQueryRMBStoreItemRqst& from);

  inline CSQueryRMBStoreItemRqst& operator=(const CSQueryRMBStoreItemRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSQueryRMBStoreItemRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQueryRMBStoreItemRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQueryRMBStoreItemRqst* other);

  // implements Message ----------------------------------------------

  CSQueryRMBStoreItemRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQueryRMBStoreItemRqst& from);
  void MergeFrom(const CSQueryRMBStoreItemRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ProductID = 1;
  inline bool has_productid() const;
  inline void clear_productid();
  static const int kProductIDFieldNumber = 1;
  inline ::google::protobuf::uint32 productid() const;
  inline void set_productid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSQueryRMBStoreItemRqst)
 private:
  inline void set_has_productid();
  inline void clear_has_productid();

  ::google::protobuf::uint32 productid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSGoldMsg_2eproto();
  friend void protobuf_ShutdownFile_CSGoldMsg_2eproto();

  void InitAsDefaultInstance();
  static CSQueryRMBStoreItemRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSQueryRMBStoreItemRsp : public ::google::protobuf::MessageLite {
 public:
  CSQueryRMBStoreItemRsp();
  virtual ~CSQueryRMBStoreItemRsp();

  CSQueryRMBStoreItemRsp(const CSQueryRMBStoreItemRsp& from);

  inline CSQueryRMBStoreItemRsp& operator=(const CSQueryRMBStoreItemRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSQueryRMBStoreItemRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQueryRMBStoreItemRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQueryRMBStoreItemRsp* other);

  // implements Message ----------------------------------------------

  CSQueryRMBStoreItemRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQueryRMBStoreItemRsp& from);
  void MergeFrom(const CSQueryRMBStoreItemRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSRMBStoreProductInfo ProductInfo = 1;
  inline bool has_productinfo() const;
  inline void clear_productinfo();
  static const int kProductInfoFieldNumber = 1;
  inline const ::vmsg::CSRMBStoreProductInfo& productinfo() const;
  inline ::vmsg::CSRMBStoreProductInfo* mutable_productinfo();
  inline ::vmsg::CSRMBStoreProductInfo* release_productinfo();
  inline void set_allocated_productinfo(::vmsg::CSRMBStoreProductInfo* productinfo);

  // @@protoc_insertion_point(class_scope:vmsg.CSQueryRMBStoreItemRsp)
 private:
  inline void set_has_productinfo();
  inline void clear_has_productinfo();

  ::vmsg::CSRMBStoreProductInfo* productinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSGoldMsg_2eproto();
  friend void protobuf_ShutdownFile_CSGoldMsg_2eproto();

  void InitAsDefaultInstance();
  static CSQueryRMBStoreItemRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSAppAuthedBuyRqst : public ::google::protobuf::MessageLite {
 public:
  CSAppAuthedBuyRqst();
  virtual ~CSAppAuthedBuyRqst();

  CSAppAuthedBuyRqst(const CSAppAuthedBuyRqst& from);

  inline CSAppAuthedBuyRqst& operator=(const CSAppAuthedBuyRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSAppAuthedBuyRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAppAuthedBuyRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAppAuthedBuyRqst* other);

  // implements Message ----------------------------------------------

  CSAppAuthedBuyRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAppAuthedBuyRqst& from);
  void MergeFrom(const CSAppAuthedBuyRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ProductID = 1;
  inline bool has_productid() const;
  inline void clear_productid();
  static const int kProductIDFieldNumber = 1;
  inline const ::std::string& productid() const;
  inline void set_productid(const ::std::string& value);
  inline void set_productid(const char* value);
  inline void set_productid(const char* value, size_t size);
  inline ::std::string* mutable_productid();
  inline ::std::string* release_productid();
  inline void set_allocated_productid(::std::string* productid);

  // required uint32 Count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSAppAuthedBuyRqst)
 private:
  inline void set_has_productid();
  inline void clear_has_productid();
  inline void set_has_count();
  inline void clear_has_count();

  ::std::string* productid_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSGoldMsg_2eproto();
  friend void protobuf_ShutdownFile_CSGoldMsg_2eproto();

  void InitAsDefaultInstance();
  static CSAppAuthedBuyRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSAppAuthedBuyRsp : public ::google::protobuf::MessageLite {
 public:
  CSAppAuthedBuyRsp();
  virtual ~CSAppAuthedBuyRsp();

  CSAppAuthedBuyRsp(const CSAppAuthedBuyRsp& from);

  inline CSAppAuthedBuyRsp& operator=(const CSAppAuthedBuyRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSAppAuthedBuyRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAppAuthedBuyRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAppAuthedBuyRsp* other);

  // implements Message ----------------------------------------------

  CSAppAuthedBuyRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAppAuthedBuyRsp& from);
  void MergeFrom(const CSAppAuthedBuyRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string OrderID = 1;
  inline bool has_orderid() const;
  inline void clear_orderid();
  static const int kOrderIDFieldNumber = 1;
  inline const ::std::string& orderid() const;
  inline void set_orderid(const ::std::string& value);
  inline void set_orderid(const char* value);
  inline void set_orderid(const char* value, size_t size);
  inline ::std::string* mutable_orderid();
  inline ::std::string* release_orderid();
  inline void set_allocated_orderid(::std::string* orderid);

  // required string ProductID = 2;
  inline bool has_productid() const;
  inline void clear_productid();
  static const int kProductIDFieldNumber = 2;
  inline const ::std::string& productid() const;
  inline void set_productid(const ::std::string& value);
  inline void set_productid(const char* value);
  inline void set_productid(const char* value, size_t size);
  inline ::std::string* mutable_productid();
  inline ::std::string* release_productid();
  inline void set_allocated_productid(::std::string* productid);

  // required uint32 Count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // required uint32 TotalMoneyAmount = 4;
  inline bool has_totalmoneyamount() const;
  inline void clear_totalmoneyamount();
  static const int kTotalMoneyAmountFieldNumber = 4;
  inline ::google::protobuf::uint32 totalmoneyamount() const;
  inline void set_totalmoneyamount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSAppAuthedBuyRsp)
 private:
  inline void set_has_orderid();
  inline void clear_has_orderid();
  inline void set_has_productid();
  inline void clear_has_productid();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_totalmoneyamount();
  inline void clear_has_totalmoneyamount();

  ::std::string* orderid_;
  ::std::string* productid_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 totalmoneyamount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSGoldMsg_2eproto();
  friend void protobuf_ShutdownFile_CSGoldMsg_2eproto();

  void InitAsDefaultInstance();
  static CSAppAuthedBuyRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSAppAuthedBuySucceedRqst : public ::google::protobuf::MessageLite {
 public:
  CSAppAuthedBuySucceedRqst();
  virtual ~CSAppAuthedBuySucceedRqst();

  CSAppAuthedBuySucceedRqst(const CSAppAuthedBuySucceedRqst& from);

  inline CSAppAuthedBuySucceedRqst& operator=(const CSAppAuthedBuySucceedRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSAppAuthedBuySucceedRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAppAuthedBuySucceedRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAppAuthedBuySucceedRqst* other);

  // implements Message ----------------------------------------------

  CSAppAuthedBuySucceedRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAppAuthedBuySucceedRqst& from);
  void MergeFrom(const CSAppAuthedBuySucceedRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ProductID = 1;
  inline bool has_productid() const;
  inline void clear_productid();
  static const int kProductIDFieldNumber = 1;
  inline const ::std::string& productid() const;
  inline void set_productid(const ::std::string& value);
  inline void set_productid(const char* value);
  inline void set_productid(const char* value, size_t size);
  inline ::std::string* mutable_productid();
  inline ::std::string* release_productid();
  inline void set_allocated_productid(::std::string* productid);

  // required uint32 TotalMoneyAmount = 2;
  inline bool has_totalmoneyamount() const;
  inline void clear_totalmoneyamount();
  static const int kTotalMoneyAmountFieldNumber = 2;
  inline ::google::protobuf::uint32 totalmoneyamount() const;
  inline void set_totalmoneyamount(::google::protobuf::uint32 value);

  // required string OrderID = 3;
  inline bool has_orderid() const;
  inline void clear_orderid();
  static const int kOrderIDFieldNumber = 3;
  inline const ::std::string& orderid() const;
  inline void set_orderid(const ::std::string& value);
  inline void set_orderid(const char* value);
  inline void set_orderid(const char* value, size_t size);
  inline ::std::string* mutable_orderid();
  inline ::std::string* release_orderid();
  inline void set_allocated_orderid(::std::string* orderid);

  // required uint32 Count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSAppAuthedBuySucceedRqst)
 private:
  inline void set_has_productid();
  inline void clear_has_productid();
  inline void set_has_totalmoneyamount();
  inline void clear_has_totalmoneyamount();
  inline void set_has_orderid();
  inline void clear_has_orderid();
  inline void set_has_count();
  inline void clear_has_count();

  ::std::string* productid_;
  ::std::string* orderid_;
  ::google::protobuf::uint32 totalmoneyamount_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSGoldMsg_2eproto();
  friend void protobuf_ShutdownFile_CSGoldMsg_2eproto();

  void InitAsDefaultInstance();
  static CSAppAuthedBuySucceedRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSGoldRequest : public ::google::protobuf::MessageLite {
 public:
  CSGoldRequest();
  virtual ~CSGoldRequest();

  CSGoldRequest(const CSGoldRequest& from);

  inline CSGoldRequest& operator=(const CSGoldRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSGoldRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGoldRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGoldRequest* other);

  // implements Message ----------------------------------------------

  CSGoldRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGoldRequest& from);
  void MergeFrom(const CSGoldRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSBuyGoldRqst BuyGold_Rqst = 1;
  inline bool has_buygold_rqst() const;
  inline void clear_buygold_rqst();
  static const int kBuyGoldRqstFieldNumber = 1;
  inline const ::vmsg::CSBuyGoldRqst& buygold_rqst() const;
  inline ::vmsg::CSBuyGoldRqst* mutable_buygold_rqst();
  inline ::vmsg::CSBuyGoldRqst* release_buygold_rqst();
  inline void set_allocated_buygold_rqst(::vmsg::CSBuyGoldRqst* buygold_rqst);

  // optional .vmsg.CSBuyRMBStoreRqst BuyRMBStore_Rqst = 2;
  inline bool has_buyrmbstore_rqst() const;
  inline void clear_buyrmbstore_rqst();
  static const int kBuyRMBStoreRqstFieldNumber = 2;
  inline const ::vmsg::CSBuyRMBStoreRqst& buyrmbstore_rqst() const;
  inline ::vmsg::CSBuyRMBStoreRqst* mutable_buyrmbstore_rqst();
  inline ::vmsg::CSBuyRMBStoreRqst* release_buyrmbstore_rqst();
  inline void set_allocated_buyrmbstore_rqst(::vmsg::CSBuyRMBStoreRqst* buyrmbstore_rqst);

  // optional .vmsg.CSAppAuthedBuySucceedRqst AppAuthedBuySucceed_Rqst = 3;
  inline bool has_appauthedbuysucceed_rqst() const;
  inline void clear_appauthedbuysucceed_rqst();
  static const int kAppAuthedBuySucceedRqstFieldNumber = 3;
  inline const ::vmsg::CSAppAuthedBuySucceedRqst& appauthedbuysucceed_rqst() const;
  inline ::vmsg::CSAppAuthedBuySucceedRqst* mutable_appauthedbuysucceed_rqst();
  inline ::vmsg::CSAppAuthedBuySucceedRqst* release_appauthedbuysucceed_rqst();
  inline void set_allocated_appauthedbuysucceed_rqst(::vmsg::CSAppAuthedBuySucceedRqst* appauthedbuysucceed_rqst);

  // optional .vmsg.CSAppAuthedBuyRqst AppAuthedBuy_Rqst = 4;
  inline bool has_appauthedbuy_rqst() const;
  inline void clear_appauthedbuy_rqst();
  static const int kAppAuthedBuyRqstFieldNumber = 4;
  inline const ::vmsg::CSAppAuthedBuyRqst& appauthedbuy_rqst() const;
  inline ::vmsg::CSAppAuthedBuyRqst* mutable_appauthedbuy_rqst();
  inline ::vmsg::CSAppAuthedBuyRqst* release_appauthedbuy_rqst();
  inline void set_allocated_appauthedbuy_rqst(::vmsg::CSAppAuthedBuyRqst* appauthedbuy_rqst);

  // optional .vmsg.CSQueryRMBStoreItemRqst QuerySingleItem_Rqst = 5;
  inline bool has_querysingleitem_rqst() const;
  inline void clear_querysingleitem_rqst();
  static const int kQuerySingleItemRqstFieldNumber = 5;
  inline const ::vmsg::CSQueryRMBStoreItemRqst& querysingleitem_rqst() const;
  inline ::vmsg::CSQueryRMBStoreItemRqst* mutable_querysingleitem_rqst();
  inline ::vmsg::CSQueryRMBStoreItemRqst* release_querysingleitem_rqst();
  inline void set_allocated_querysingleitem_rqst(::vmsg::CSQueryRMBStoreItemRqst* querysingleitem_rqst);

  // @@protoc_insertion_point(class_scope:vmsg.CSGoldRequest)
 private:
  inline void set_has_buygold_rqst();
  inline void clear_has_buygold_rqst();
  inline void set_has_buyrmbstore_rqst();
  inline void clear_has_buyrmbstore_rqst();
  inline void set_has_appauthedbuysucceed_rqst();
  inline void clear_has_appauthedbuysucceed_rqst();
  inline void set_has_appauthedbuy_rqst();
  inline void clear_has_appauthedbuy_rqst();
  inline void set_has_querysingleitem_rqst();
  inline void clear_has_querysingleitem_rqst();

  ::vmsg::CSBuyGoldRqst* buygold_rqst_;
  ::vmsg::CSBuyRMBStoreRqst* buyrmbstore_rqst_;
  ::vmsg::CSAppAuthedBuySucceedRqst* appauthedbuysucceed_rqst_;
  ::vmsg::CSAppAuthedBuyRqst* appauthedbuy_rqst_;
  ::vmsg::CSQueryRMBStoreItemRqst* querysingleitem_rqst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSGoldMsg_2eproto();
  friend void protobuf_ShutdownFile_CSGoldMsg_2eproto();

  void InitAsDefaultInstance();
  static CSGoldRequest* default_instance_;
};
// -------------------------------------------------------------------

class CSGoldRespond : public ::google::protobuf::MessageLite {
 public:
  CSGoldRespond();
  virtual ~CSGoldRespond();

  CSGoldRespond(const CSGoldRespond& from);

  inline CSGoldRespond& operator=(const CSGoldRespond& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSGoldRespond& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGoldRespond* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGoldRespond* other);

  // implements Message ----------------------------------------------

  CSGoldRespond* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGoldRespond& from);
  void MergeFrom(const CSGoldRespond& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSGoldInfo QueryGold_Rsp = 1;
  inline bool has_querygold_rsp() const;
  inline void clear_querygold_rsp();
  static const int kQueryGoldRspFieldNumber = 1;
  inline const ::vmsg::CSGoldInfo& querygold_rsp() const;
  inline ::vmsg::CSGoldInfo* mutable_querygold_rsp();
  inline ::vmsg::CSGoldInfo* release_querygold_rsp();
  inline void set_allocated_querygold_rsp(::vmsg::CSGoldInfo* querygold_rsp);

  // optional .vmsg.CSGoldInfo Gold_Notify = 2;
  inline bool has_gold_notify() const;
  inline void clear_gold_notify();
  static const int kGoldNotifyFieldNumber = 2;
  inline const ::vmsg::CSGoldInfo& gold_notify() const;
  inline ::vmsg::CSGoldInfo* mutable_gold_notify();
  inline ::vmsg::CSGoldInfo* release_gold_notify();
  inline void set_allocated_gold_notify(::vmsg::CSGoldInfo* gold_notify);

  // optional .vmsg.CSBuyGoldRsp BuyGold_Rsp = 3;
  inline bool has_buygold_rsp() const;
  inline void clear_buygold_rsp();
  static const int kBuyGoldRspFieldNumber = 3;
  inline const ::vmsg::CSBuyGoldRsp& buygold_rsp() const;
  inline ::vmsg::CSBuyGoldRsp* mutable_buygold_rsp();
  inline ::vmsg::CSBuyGoldRsp* release_buygold_rsp();
  inline void set_allocated_buygold_rsp(::vmsg::CSBuyGoldRsp* buygold_rsp);

  // optional .vmsg.CSBuyRMBStoreRsp BuyRMBStore_Rsp = 4;
  inline bool has_buyrmbstore_rsp() const;
  inline void clear_buyrmbstore_rsp();
  static const int kBuyRMBStoreRspFieldNumber = 4;
  inline const ::vmsg::CSBuyRMBStoreRsp& buyrmbstore_rsp() const;
  inline ::vmsg::CSBuyRMBStoreRsp* mutable_buyrmbstore_rsp();
  inline ::vmsg::CSBuyRMBStoreRsp* release_buyrmbstore_rsp();
  inline void set_allocated_buyrmbstore_rsp(::vmsg::CSBuyRMBStoreRsp* buyrmbstore_rsp);

  // optional .vmsg.CSQueryRMBStoreRsp QueryRMBStore_Rsp = 5;
  inline bool has_queryrmbstore_rsp() const;
  inline void clear_queryrmbstore_rsp();
  static const int kQueryRMBStoreRspFieldNumber = 5;
  inline const ::vmsg::CSQueryRMBStoreRsp& queryrmbstore_rsp() const;
  inline ::vmsg::CSQueryRMBStoreRsp* mutable_queryrmbstore_rsp();
  inline ::vmsg::CSQueryRMBStoreRsp* release_queryrmbstore_rsp();
  inline void set_allocated_queryrmbstore_rsp(::vmsg::CSQueryRMBStoreRsp* queryrmbstore_rsp);

  // optional .vmsg.CSAppAuthedBuyRsp AppAuthedBuy_Rsp = 6;
  inline bool has_appauthedbuy_rsp() const;
  inline void clear_appauthedbuy_rsp();
  static const int kAppAuthedBuyRspFieldNumber = 6;
  inline const ::vmsg::CSAppAuthedBuyRsp& appauthedbuy_rsp() const;
  inline ::vmsg::CSAppAuthedBuyRsp* mutable_appauthedbuy_rsp();
  inline ::vmsg::CSAppAuthedBuyRsp* release_appauthedbuy_rsp();
  inline void set_allocated_appauthedbuy_rsp(::vmsg::CSAppAuthedBuyRsp* appauthedbuy_rsp);

  // optional .vmsg.CSQueryRMBStoreItemRsp QuerySingleItem_Rsp = 7;
  inline bool has_querysingleitem_rsp() const;
  inline void clear_querysingleitem_rsp();
  static const int kQuerySingleItemRspFieldNumber = 7;
  inline const ::vmsg::CSQueryRMBStoreItemRsp& querysingleitem_rsp() const;
  inline ::vmsg::CSQueryRMBStoreItemRsp* mutable_querysingleitem_rsp();
  inline ::vmsg::CSQueryRMBStoreItemRsp* release_querysingleitem_rsp();
  inline void set_allocated_querysingleitem_rsp(::vmsg::CSQueryRMBStoreItemRsp* querysingleitem_rsp);

  // @@protoc_insertion_point(class_scope:vmsg.CSGoldRespond)
 private:
  inline void set_has_querygold_rsp();
  inline void clear_has_querygold_rsp();
  inline void set_has_gold_notify();
  inline void clear_has_gold_notify();
  inline void set_has_buygold_rsp();
  inline void clear_has_buygold_rsp();
  inline void set_has_buyrmbstore_rsp();
  inline void clear_has_buyrmbstore_rsp();
  inline void set_has_queryrmbstore_rsp();
  inline void clear_has_queryrmbstore_rsp();
  inline void set_has_appauthedbuy_rsp();
  inline void clear_has_appauthedbuy_rsp();
  inline void set_has_querysingleitem_rsp();
  inline void clear_has_querysingleitem_rsp();

  ::vmsg::CSGoldInfo* querygold_rsp_;
  ::vmsg::CSGoldInfo* gold_notify_;
  ::vmsg::CSBuyGoldRsp* buygold_rsp_;
  ::vmsg::CSBuyRMBStoreRsp* buyrmbstore_rsp_;
  ::vmsg::CSQueryRMBStoreRsp* queryrmbstore_rsp_;
  ::vmsg::CSAppAuthedBuyRsp* appauthedbuy_rsp_;
  ::vmsg::CSQueryRMBStoreItemRsp* querysingleitem_rsp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSGoldMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSGoldMsg_2eproto();
  friend void protobuf_ShutdownFile_CSGoldMsg_2eproto();

  void InitAsDefaultInstance();
  static CSGoldRespond* default_instance_;
};
// ===================================================================


// ===================================================================

// CSGoldInfo

// required uint32 Gold = 1;
inline bool CSGoldInfo::has_gold() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGoldInfo::set_has_gold() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGoldInfo::clear_has_gold() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGoldInfo::clear_gold() {
  gold_ = 0u;
  clear_has_gold();
}
inline ::google::protobuf::uint32 CSGoldInfo::gold() const {
  return gold_;
}
inline void CSGoldInfo::set_gold(::google::protobuf::uint32 value) {
  set_has_gold();
  gold_ = value;
}

// required uint32 TotalGoldByMoney = 2;
inline bool CSGoldInfo::has_totalgoldbymoney() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGoldInfo::set_has_totalgoldbymoney() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGoldInfo::clear_has_totalgoldbymoney() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGoldInfo::clear_totalgoldbymoney() {
  totalgoldbymoney_ = 0u;
  clear_has_totalgoldbymoney();
}
inline ::google::protobuf::uint32 CSGoldInfo::totalgoldbymoney() const {
  return totalgoldbymoney_;
}
inline void CSGoldInfo::set_totalgoldbymoney(::google::protobuf::uint32 value) {
  set_has_totalgoldbymoney();
  totalgoldbymoney_ = value;
}

// optional uint32 PayFlag = 3;
inline bool CSGoldInfo::has_payflag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSGoldInfo::set_has_payflag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSGoldInfo::clear_has_payflag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSGoldInfo::clear_payflag() {
  payflag_ = 0u;
  clear_has_payflag();
}
inline ::google::protobuf::uint32 CSGoldInfo::payflag() const {
  return payflag_;
}
inline void CSGoldInfo::set_payflag(::google::protobuf::uint32 value) {
  set_has_payflag();
  payflag_ = value;
}

// -------------------------------------------------------------------

// CSBuyGoldRqst

// required string str = 1;
inline bool CSBuyGoldRqst::has_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBuyGoldRqst::set_has_str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBuyGoldRqst::clear_has_str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBuyGoldRqst::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& CSBuyGoldRqst::str() const {
  return *str_;
}
inline void CSBuyGoldRqst::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void CSBuyGoldRqst::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void CSBuyGoldRqst::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSBuyGoldRqst::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* CSBuyGoldRqst::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSBuyGoldRqst::set_allocated_str(::std::string* str) {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    delete str_;
  }
  if (str) {
    set_has_str();
    str_ = str;
  } else {
    clear_has_str();
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSBuyGoldRsp

// required string str = 1;
inline bool CSBuyGoldRsp::has_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBuyGoldRsp::set_has_str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBuyGoldRsp::clear_has_str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBuyGoldRsp::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& CSBuyGoldRsp::str() const {
  return *str_;
}
inline void CSBuyGoldRsp::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void CSBuyGoldRsp::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void CSBuyGoldRsp::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSBuyGoldRsp::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* CSBuyGoldRsp::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSBuyGoldRsp::set_allocated_str(::std::string* str) {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    delete str_;
  }
  if (str) {
    set_has_str();
    str_ = str;
  } else {
    clear_has_str();
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSBuyRMBStoreRqst

// required string str = 1;
inline bool CSBuyRMBStoreRqst::has_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBuyRMBStoreRqst::set_has_str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBuyRMBStoreRqst::clear_has_str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBuyRMBStoreRqst::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& CSBuyRMBStoreRqst::str() const {
  return *str_;
}
inline void CSBuyRMBStoreRqst::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void CSBuyRMBStoreRqst::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void CSBuyRMBStoreRqst::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSBuyRMBStoreRqst::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* CSBuyRMBStoreRqst::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSBuyRMBStoreRqst::set_allocated_str(::std::string* str) {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    delete str_;
  }
  if (str) {
    set_has_str();
    str_ = str;
  } else {
    clear_has_str();
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSBuyRMBStoreRsp

// required string str = 1;
inline bool CSBuyRMBStoreRsp::has_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBuyRMBStoreRsp::set_has_str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBuyRMBStoreRsp::clear_has_str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBuyRMBStoreRsp::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& CSBuyRMBStoreRsp::str() const {
  return *str_;
}
inline void CSBuyRMBStoreRsp::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void CSBuyRMBStoreRsp::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void CSBuyRMBStoreRsp::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSBuyRMBStoreRsp::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* CSBuyRMBStoreRsp::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSBuyRMBStoreRsp::set_allocated_str(::std::string* str) {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    delete str_;
  }
  if (str) {
    set_has_str();
    str_ = str;
  } else {
    clear_has_str();
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .vmsg.CSBagInfo BagInfo = 2;
inline bool CSBuyRMBStoreRsp::has_baginfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBuyRMBStoreRsp::set_has_baginfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBuyRMBStoreRsp::clear_has_baginfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBuyRMBStoreRsp::clear_baginfo() {
  if (baginfo_ != NULL) baginfo_->::vmsg::CSBagInfo::Clear();
  clear_has_baginfo();
}
inline const ::vmsg::CSBagInfo& CSBuyRMBStoreRsp::baginfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return baginfo_ != NULL ? *baginfo_ : *default_instance().baginfo_;
#else
  return baginfo_ != NULL ? *baginfo_ : *default_instance_->baginfo_;
#endif
}
inline ::vmsg::CSBagInfo* CSBuyRMBStoreRsp::mutable_baginfo() {
  set_has_baginfo();
  if (baginfo_ == NULL) baginfo_ = new ::vmsg::CSBagInfo;
  return baginfo_;
}
inline ::vmsg::CSBagInfo* CSBuyRMBStoreRsp::release_baginfo() {
  clear_has_baginfo();
  ::vmsg::CSBagInfo* temp = baginfo_;
  baginfo_ = NULL;
  return temp;
}
inline void CSBuyRMBStoreRsp::set_allocated_baginfo(::vmsg::CSBagInfo* baginfo) {
  delete baginfo_;
  baginfo_ = baginfo;
  if (baginfo) {
    set_has_baginfo();
  } else {
    clear_has_baginfo();
  }
}

// -------------------------------------------------------------------

// CSRMBStoreProductInfo

// required string ChannelProductID = 1;
inline bool CSRMBStoreProductInfo::has_channelproductid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRMBStoreProductInfo::set_has_channelproductid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRMBStoreProductInfo::clear_has_channelproductid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRMBStoreProductInfo::clear_channelproductid() {
  if (channelproductid_ != &::google::protobuf::internal::kEmptyString) {
    channelproductid_->clear();
  }
  clear_has_channelproductid();
}
inline const ::std::string& CSRMBStoreProductInfo::channelproductid() const {
  return *channelproductid_;
}
inline void CSRMBStoreProductInfo::set_channelproductid(const ::std::string& value) {
  set_has_channelproductid();
  if (channelproductid_ == &::google::protobuf::internal::kEmptyString) {
    channelproductid_ = new ::std::string;
  }
  channelproductid_->assign(value);
}
inline void CSRMBStoreProductInfo::set_channelproductid(const char* value) {
  set_has_channelproductid();
  if (channelproductid_ == &::google::protobuf::internal::kEmptyString) {
    channelproductid_ = new ::std::string;
  }
  channelproductid_->assign(value);
}
inline void CSRMBStoreProductInfo::set_channelproductid(const char* value, size_t size) {
  set_has_channelproductid();
  if (channelproductid_ == &::google::protobuf::internal::kEmptyString) {
    channelproductid_ = new ::std::string;
  }
  channelproductid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSRMBStoreProductInfo::mutable_channelproductid() {
  set_has_channelproductid();
  if (channelproductid_ == &::google::protobuf::internal::kEmptyString) {
    channelproductid_ = new ::std::string;
  }
  return channelproductid_;
}
inline ::std::string* CSRMBStoreProductInfo::release_channelproductid() {
  clear_has_channelproductid();
  if (channelproductid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channelproductid_;
    channelproductid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSRMBStoreProductInfo::set_allocated_channelproductid(::std::string* channelproductid) {
  if (channelproductid_ != &::google::protobuf::internal::kEmptyString) {
    delete channelproductid_;
  }
  if (channelproductid) {
    set_has_channelproductid();
    channelproductid_ = channelproductid;
  } else {
    clear_has_channelproductid();
    channelproductid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 ElmtType = 2;
inline bool CSRMBStoreProductInfo::has_elmttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRMBStoreProductInfo::set_has_elmttype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRMBStoreProductInfo::clear_has_elmttype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRMBStoreProductInfo::clear_elmttype() {
  elmttype_ = 0u;
  clear_has_elmttype();
}
inline ::google::protobuf::uint32 CSRMBStoreProductInfo::elmttype() const {
  return elmttype_;
}
inline void CSRMBStoreProductInfo::set_elmttype(::google::protobuf::uint32 value) {
  set_has_elmttype();
  elmttype_ = value;
}

// required uint32 ElmtCfgID = 3;
inline bool CSRMBStoreProductInfo::has_elmtcfgid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSRMBStoreProductInfo::set_has_elmtcfgid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSRMBStoreProductInfo::clear_has_elmtcfgid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSRMBStoreProductInfo::clear_elmtcfgid() {
  elmtcfgid_ = 0u;
  clear_has_elmtcfgid();
}
inline ::google::protobuf::uint32 CSRMBStoreProductInfo::elmtcfgid() const {
  return elmtcfgid_;
}
inline void CSRMBStoreProductInfo::set_elmtcfgid(::google::protobuf::uint32 value) {
  set_has_elmtcfgid();
  elmtcfgid_ = value;
}

// required uint32 ElmtCnt = 4;
inline bool CSRMBStoreProductInfo::has_elmtcnt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSRMBStoreProductInfo::set_has_elmtcnt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSRMBStoreProductInfo::clear_has_elmtcnt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSRMBStoreProductInfo::clear_elmtcnt() {
  elmtcnt_ = 0u;
  clear_has_elmtcnt();
}
inline ::google::protobuf::uint32 CSRMBStoreProductInfo::elmtcnt() const {
  return elmtcnt_;
}
inline void CSRMBStoreProductInfo::set_elmtcnt(::google::protobuf::uint32 value) {
  set_has_elmtcnt();
  elmtcnt_ = value;
}

// required uint32 ExtraCnt = 5;
inline bool CSRMBStoreProductInfo::has_extracnt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSRMBStoreProductInfo::set_has_extracnt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSRMBStoreProductInfo::clear_has_extracnt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSRMBStoreProductInfo::clear_extracnt() {
  extracnt_ = 0u;
  clear_has_extracnt();
}
inline ::google::protobuf::uint32 CSRMBStoreProductInfo::extracnt() const {
  return extracnt_;
}
inline void CSRMBStoreProductInfo::set_extracnt(::google::protobuf::uint32 value) {
  set_has_extracnt();
  extracnt_ = value;
}

// required uint32 Price = 6;
inline bool CSRMBStoreProductInfo::has_price() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSRMBStoreProductInfo::set_has_price() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSRMBStoreProductInfo::clear_has_price() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSRMBStoreProductInfo::clear_price() {
  price_ = 0u;
  clear_has_price();
}
inline ::google::protobuf::uint32 CSRMBStoreProductInfo::price() const {
  return price_;
}
inline void CSRMBStoreProductInfo::set_price(::google::protobuf::uint32 value) {
  set_has_price();
  price_ = value;
}

// required uint32 FirstExtraCnt = 7;
inline bool CSRMBStoreProductInfo::has_firstextracnt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSRMBStoreProductInfo::set_has_firstextracnt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSRMBStoreProductInfo::clear_has_firstextracnt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSRMBStoreProductInfo::clear_firstextracnt() {
  firstextracnt_ = 0u;
  clear_has_firstextracnt();
}
inline ::google::protobuf::uint32 CSRMBStoreProductInfo::firstextracnt() const {
  return firstextracnt_;
}
inline void CSRMBStoreProductInfo::set_firstextracnt(::google::protobuf::uint32 value) {
  set_has_firstextracnt();
  firstextracnt_ = value;
}

// required string ICON = 8;
inline bool CSRMBStoreProductInfo::has_icon() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSRMBStoreProductInfo::set_has_icon() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSRMBStoreProductInfo::clear_has_icon() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSRMBStoreProductInfo::clear_icon() {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    icon_->clear();
  }
  clear_has_icon();
}
inline const ::std::string& CSRMBStoreProductInfo::icon() const {
  return *icon_;
}
inline void CSRMBStoreProductInfo::set_icon(const ::std::string& value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void CSRMBStoreProductInfo::set_icon(const char* value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void CSRMBStoreProductInfo::set_icon(const char* value, size_t size) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSRMBStoreProductInfo::mutable_icon() {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  return icon_;
}
inline ::std::string* CSRMBStoreProductInfo::release_icon() {
  clear_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = icon_;
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSRMBStoreProductInfo::set_allocated_icon(::std::string* icon) {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    delete icon_;
  }
  if (icon) {
    set_has_icon();
    icon_ = icon;
  } else {
    clear_has_icon();
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 ID = 9;
inline bool CSRMBStoreProductInfo::has_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSRMBStoreProductInfo::set_has_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSRMBStoreProductInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSRMBStoreProductInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CSRMBStoreProductInfo::id() const {
  return id_;
}
inline void CSRMBStoreProductInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 ExtraItemType = 10;
inline bool CSRMBStoreProductInfo::has_extraitemtype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CSRMBStoreProductInfo::set_has_extraitemtype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CSRMBStoreProductInfo::clear_has_extraitemtype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CSRMBStoreProductInfo::clear_extraitemtype() {
  extraitemtype_ = 0u;
  clear_has_extraitemtype();
}
inline ::google::protobuf::uint32 CSRMBStoreProductInfo::extraitemtype() const {
  return extraitemtype_;
}
inline void CSRMBStoreProductInfo::set_extraitemtype(::google::protobuf::uint32 value) {
  set_has_extraitemtype();
  extraitemtype_ = value;
}

// required uint32 ExtraItemID = 11;
inline bool CSRMBStoreProductInfo::has_extraitemid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CSRMBStoreProductInfo::set_has_extraitemid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CSRMBStoreProductInfo::clear_has_extraitemid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CSRMBStoreProductInfo::clear_extraitemid() {
  extraitemid_ = 0u;
  clear_has_extraitemid();
}
inline ::google::protobuf::uint32 CSRMBStoreProductInfo::extraitemid() const {
  return extraitemid_;
}
inline void CSRMBStoreProductInfo::set_extraitemid(::google::protobuf::uint32 value) {
  set_has_extraitemid();
  extraitemid_ = value;
}

// required uint32 ExtraItemCnt = 12;
inline bool CSRMBStoreProductInfo::has_extraitemcnt() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CSRMBStoreProductInfo::set_has_extraitemcnt() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CSRMBStoreProductInfo::clear_has_extraitemcnt() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CSRMBStoreProductInfo::clear_extraitemcnt() {
  extraitemcnt_ = 0u;
  clear_has_extraitemcnt();
}
inline ::google::protobuf::uint32 CSRMBStoreProductInfo::extraitemcnt() const {
  return extraitemcnt_;
}
inline void CSRMBStoreProductInfo::set_extraitemcnt(::google::protobuf::uint32 value) {
  set_has_extraitemcnt();
  extraitemcnt_ = value;
}

// required uint32 TabID = 13;
inline bool CSRMBStoreProductInfo::has_tabid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CSRMBStoreProductInfo::set_has_tabid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CSRMBStoreProductInfo::clear_has_tabid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CSRMBStoreProductInfo::clear_tabid() {
  tabid_ = 0u;
  clear_has_tabid();
}
inline ::google::protobuf::uint32 CSRMBStoreProductInfo::tabid() const {
  return tabid_;
}
inline void CSRMBStoreProductInfo::set_tabid(::google::protobuf::uint32 value) {
  set_has_tabid();
  tabid_ = value;
}

// -------------------------------------------------------------------

// CSQueryRMBStoreRsp

// repeated .vmsg.CSRMBStoreProductInfo Products = 1;
inline int CSQueryRMBStoreRsp::products_size() const {
  return products_.size();
}
inline void CSQueryRMBStoreRsp::clear_products() {
  products_.Clear();
}
inline const ::vmsg::CSRMBStoreProductInfo& CSQueryRMBStoreRsp::products(int index) const {
  return products_.Get(index);
}
inline ::vmsg::CSRMBStoreProductInfo* CSQueryRMBStoreRsp::mutable_products(int index) {
  return products_.Mutable(index);
}
inline ::vmsg::CSRMBStoreProductInfo* CSQueryRMBStoreRsp::add_products() {
  return products_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSRMBStoreProductInfo >&
CSQueryRMBStoreRsp::products() const {
  return products_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSRMBStoreProductInfo >*
CSQueryRMBStoreRsp::mutable_products() {
  return &products_;
}

// repeated uint32 BoughtIDs = 2;
inline int CSQueryRMBStoreRsp::boughtids_size() const {
  return boughtids_.size();
}
inline void CSQueryRMBStoreRsp::clear_boughtids() {
  boughtids_.Clear();
}
inline ::google::protobuf::uint32 CSQueryRMBStoreRsp::boughtids(int index) const {
  return boughtids_.Get(index);
}
inline void CSQueryRMBStoreRsp::set_boughtids(int index, ::google::protobuf::uint32 value) {
  boughtids_.Set(index, value);
}
inline void CSQueryRMBStoreRsp::add_boughtids(::google::protobuf::uint32 value) {
  boughtids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSQueryRMBStoreRsp::boughtids() const {
  return boughtids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSQueryRMBStoreRsp::mutable_boughtids() {
  return &boughtids_;
}

// -------------------------------------------------------------------

// CSQueryRMBStoreItemRqst

// required uint32 ProductID = 1;
inline bool CSQueryRMBStoreItemRqst::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSQueryRMBStoreItemRqst::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSQueryRMBStoreItemRqst::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSQueryRMBStoreItemRqst::clear_productid() {
  productid_ = 0u;
  clear_has_productid();
}
inline ::google::protobuf::uint32 CSQueryRMBStoreItemRqst::productid() const {
  return productid_;
}
inline void CSQueryRMBStoreItemRqst::set_productid(::google::protobuf::uint32 value) {
  set_has_productid();
  productid_ = value;
}

// -------------------------------------------------------------------

// CSQueryRMBStoreItemRsp

// required .vmsg.CSRMBStoreProductInfo ProductInfo = 1;
inline bool CSQueryRMBStoreItemRsp::has_productinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSQueryRMBStoreItemRsp::set_has_productinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSQueryRMBStoreItemRsp::clear_has_productinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSQueryRMBStoreItemRsp::clear_productinfo() {
  if (productinfo_ != NULL) productinfo_->::vmsg::CSRMBStoreProductInfo::Clear();
  clear_has_productinfo();
}
inline const ::vmsg::CSRMBStoreProductInfo& CSQueryRMBStoreItemRsp::productinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return productinfo_ != NULL ? *productinfo_ : *default_instance().productinfo_;
#else
  return productinfo_ != NULL ? *productinfo_ : *default_instance_->productinfo_;
#endif
}
inline ::vmsg::CSRMBStoreProductInfo* CSQueryRMBStoreItemRsp::mutable_productinfo() {
  set_has_productinfo();
  if (productinfo_ == NULL) productinfo_ = new ::vmsg::CSRMBStoreProductInfo;
  return productinfo_;
}
inline ::vmsg::CSRMBStoreProductInfo* CSQueryRMBStoreItemRsp::release_productinfo() {
  clear_has_productinfo();
  ::vmsg::CSRMBStoreProductInfo* temp = productinfo_;
  productinfo_ = NULL;
  return temp;
}
inline void CSQueryRMBStoreItemRsp::set_allocated_productinfo(::vmsg::CSRMBStoreProductInfo* productinfo) {
  delete productinfo_;
  productinfo_ = productinfo;
  if (productinfo) {
    set_has_productinfo();
  } else {
    clear_has_productinfo();
  }
}

// -------------------------------------------------------------------

// CSAppAuthedBuyRqst

// required string ProductID = 1;
inline bool CSAppAuthedBuyRqst::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAppAuthedBuyRqst::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAppAuthedBuyRqst::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAppAuthedBuyRqst::clear_productid() {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    productid_->clear();
  }
  clear_has_productid();
}
inline const ::std::string& CSAppAuthedBuyRqst::productid() const {
  return *productid_;
}
inline void CSAppAuthedBuyRqst::set_productid(const ::std::string& value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void CSAppAuthedBuyRqst::set_productid(const char* value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void CSAppAuthedBuyRqst::set_productid(const char* value, size_t size) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSAppAuthedBuyRqst::mutable_productid() {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  return productid_;
}
inline ::std::string* CSAppAuthedBuyRqst::release_productid() {
  clear_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productid_;
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSAppAuthedBuyRqst::set_allocated_productid(::std::string* productid) {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    delete productid_;
  }
  if (productid) {
    set_has_productid();
    productid_ = productid;
  } else {
    clear_has_productid();
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 Count = 2;
inline bool CSAppAuthedBuyRqst::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSAppAuthedBuyRqst::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSAppAuthedBuyRqst::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSAppAuthedBuyRqst::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CSAppAuthedBuyRqst::count() const {
  return count_;
}
inline void CSAppAuthedBuyRqst::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// CSAppAuthedBuyRsp

// required string OrderID = 1;
inline bool CSAppAuthedBuyRsp::has_orderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAppAuthedBuyRsp::set_has_orderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAppAuthedBuyRsp::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAppAuthedBuyRsp::clear_orderid() {
  if (orderid_ != &::google::protobuf::internal::kEmptyString) {
    orderid_->clear();
  }
  clear_has_orderid();
}
inline const ::std::string& CSAppAuthedBuyRsp::orderid() const {
  return *orderid_;
}
inline void CSAppAuthedBuyRsp::set_orderid(const ::std::string& value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
}
inline void CSAppAuthedBuyRsp::set_orderid(const char* value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
}
inline void CSAppAuthedBuyRsp::set_orderid(const char* value, size_t size) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSAppAuthedBuyRsp::mutable_orderid() {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  return orderid_;
}
inline ::std::string* CSAppAuthedBuyRsp::release_orderid() {
  clear_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderid_;
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSAppAuthedBuyRsp::set_allocated_orderid(::std::string* orderid) {
  if (orderid_ != &::google::protobuf::internal::kEmptyString) {
    delete orderid_;
  }
  if (orderid) {
    set_has_orderid();
    orderid_ = orderid;
  } else {
    clear_has_orderid();
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ProductID = 2;
inline bool CSAppAuthedBuyRsp::has_productid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSAppAuthedBuyRsp::set_has_productid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSAppAuthedBuyRsp::clear_has_productid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSAppAuthedBuyRsp::clear_productid() {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    productid_->clear();
  }
  clear_has_productid();
}
inline const ::std::string& CSAppAuthedBuyRsp::productid() const {
  return *productid_;
}
inline void CSAppAuthedBuyRsp::set_productid(const ::std::string& value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void CSAppAuthedBuyRsp::set_productid(const char* value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void CSAppAuthedBuyRsp::set_productid(const char* value, size_t size) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSAppAuthedBuyRsp::mutable_productid() {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  return productid_;
}
inline ::std::string* CSAppAuthedBuyRsp::release_productid() {
  clear_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productid_;
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSAppAuthedBuyRsp::set_allocated_productid(::std::string* productid) {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    delete productid_;
  }
  if (productid) {
    set_has_productid();
    productid_ = productid;
  } else {
    clear_has_productid();
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 Count = 3;
inline bool CSAppAuthedBuyRsp::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSAppAuthedBuyRsp::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSAppAuthedBuyRsp::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSAppAuthedBuyRsp::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CSAppAuthedBuyRsp::count() const {
  return count_;
}
inline void CSAppAuthedBuyRsp::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// required uint32 TotalMoneyAmount = 4;
inline bool CSAppAuthedBuyRsp::has_totalmoneyamount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSAppAuthedBuyRsp::set_has_totalmoneyamount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSAppAuthedBuyRsp::clear_has_totalmoneyamount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSAppAuthedBuyRsp::clear_totalmoneyamount() {
  totalmoneyamount_ = 0u;
  clear_has_totalmoneyamount();
}
inline ::google::protobuf::uint32 CSAppAuthedBuyRsp::totalmoneyamount() const {
  return totalmoneyamount_;
}
inline void CSAppAuthedBuyRsp::set_totalmoneyamount(::google::protobuf::uint32 value) {
  set_has_totalmoneyamount();
  totalmoneyamount_ = value;
}

// -------------------------------------------------------------------

// CSAppAuthedBuySucceedRqst

// required string ProductID = 1;
inline bool CSAppAuthedBuySucceedRqst::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAppAuthedBuySucceedRqst::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAppAuthedBuySucceedRqst::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAppAuthedBuySucceedRqst::clear_productid() {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    productid_->clear();
  }
  clear_has_productid();
}
inline const ::std::string& CSAppAuthedBuySucceedRqst::productid() const {
  return *productid_;
}
inline void CSAppAuthedBuySucceedRqst::set_productid(const ::std::string& value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void CSAppAuthedBuySucceedRqst::set_productid(const char* value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void CSAppAuthedBuySucceedRqst::set_productid(const char* value, size_t size) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSAppAuthedBuySucceedRqst::mutable_productid() {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  return productid_;
}
inline ::std::string* CSAppAuthedBuySucceedRqst::release_productid() {
  clear_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productid_;
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSAppAuthedBuySucceedRqst::set_allocated_productid(::std::string* productid) {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    delete productid_;
  }
  if (productid) {
    set_has_productid();
    productid_ = productid;
  } else {
    clear_has_productid();
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 TotalMoneyAmount = 2;
inline bool CSAppAuthedBuySucceedRqst::has_totalmoneyamount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSAppAuthedBuySucceedRqst::set_has_totalmoneyamount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSAppAuthedBuySucceedRqst::clear_has_totalmoneyamount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSAppAuthedBuySucceedRqst::clear_totalmoneyamount() {
  totalmoneyamount_ = 0u;
  clear_has_totalmoneyamount();
}
inline ::google::protobuf::uint32 CSAppAuthedBuySucceedRqst::totalmoneyamount() const {
  return totalmoneyamount_;
}
inline void CSAppAuthedBuySucceedRqst::set_totalmoneyamount(::google::protobuf::uint32 value) {
  set_has_totalmoneyamount();
  totalmoneyamount_ = value;
}

// required string OrderID = 3;
inline bool CSAppAuthedBuySucceedRqst::has_orderid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSAppAuthedBuySucceedRqst::set_has_orderid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSAppAuthedBuySucceedRqst::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSAppAuthedBuySucceedRqst::clear_orderid() {
  if (orderid_ != &::google::protobuf::internal::kEmptyString) {
    orderid_->clear();
  }
  clear_has_orderid();
}
inline const ::std::string& CSAppAuthedBuySucceedRqst::orderid() const {
  return *orderid_;
}
inline void CSAppAuthedBuySucceedRqst::set_orderid(const ::std::string& value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
}
inline void CSAppAuthedBuySucceedRqst::set_orderid(const char* value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
}
inline void CSAppAuthedBuySucceedRqst::set_orderid(const char* value, size_t size) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSAppAuthedBuySucceedRqst::mutable_orderid() {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  return orderid_;
}
inline ::std::string* CSAppAuthedBuySucceedRqst::release_orderid() {
  clear_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderid_;
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSAppAuthedBuySucceedRqst::set_allocated_orderid(::std::string* orderid) {
  if (orderid_ != &::google::protobuf::internal::kEmptyString) {
    delete orderid_;
  }
  if (orderid) {
    set_has_orderid();
    orderid_ = orderid;
  } else {
    clear_has_orderid();
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 Count = 4;
inline bool CSAppAuthedBuySucceedRqst::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSAppAuthedBuySucceedRqst::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSAppAuthedBuySucceedRqst::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSAppAuthedBuySucceedRqst::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 CSAppAuthedBuySucceedRqst::count() const {
  return count_;
}
inline void CSAppAuthedBuySucceedRqst::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// CSGoldRequest

// optional .vmsg.CSBuyGoldRqst BuyGold_Rqst = 1;
inline bool CSGoldRequest::has_buygold_rqst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGoldRequest::set_has_buygold_rqst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGoldRequest::clear_has_buygold_rqst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGoldRequest::clear_buygold_rqst() {
  if (buygold_rqst_ != NULL) buygold_rqst_->::vmsg::CSBuyGoldRqst::Clear();
  clear_has_buygold_rqst();
}
inline const ::vmsg::CSBuyGoldRqst& CSGoldRequest::buygold_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return buygold_rqst_ != NULL ? *buygold_rqst_ : *default_instance().buygold_rqst_;
#else
  return buygold_rqst_ != NULL ? *buygold_rqst_ : *default_instance_->buygold_rqst_;
#endif
}
inline ::vmsg::CSBuyGoldRqst* CSGoldRequest::mutable_buygold_rqst() {
  set_has_buygold_rqst();
  if (buygold_rqst_ == NULL) buygold_rqst_ = new ::vmsg::CSBuyGoldRqst;
  return buygold_rqst_;
}
inline ::vmsg::CSBuyGoldRqst* CSGoldRequest::release_buygold_rqst() {
  clear_has_buygold_rqst();
  ::vmsg::CSBuyGoldRqst* temp = buygold_rqst_;
  buygold_rqst_ = NULL;
  return temp;
}
inline void CSGoldRequest::set_allocated_buygold_rqst(::vmsg::CSBuyGoldRqst* buygold_rqst) {
  delete buygold_rqst_;
  buygold_rqst_ = buygold_rqst;
  if (buygold_rqst) {
    set_has_buygold_rqst();
  } else {
    clear_has_buygold_rqst();
  }
}

// optional .vmsg.CSBuyRMBStoreRqst BuyRMBStore_Rqst = 2;
inline bool CSGoldRequest::has_buyrmbstore_rqst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGoldRequest::set_has_buyrmbstore_rqst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGoldRequest::clear_has_buyrmbstore_rqst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGoldRequest::clear_buyrmbstore_rqst() {
  if (buyrmbstore_rqst_ != NULL) buyrmbstore_rqst_->::vmsg::CSBuyRMBStoreRqst::Clear();
  clear_has_buyrmbstore_rqst();
}
inline const ::vmsg::CSBuyRMBStoreRqst& CSGoldRequest::buyrmbstore_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return buyrmbstore_rqst_ != NULL ? *buyrmbstore_rqst_ : *default_instance().buyrmbstore_rqst_;
#else
  return buyrmbstore_rqst_ != NULL ? *buyrmbstore_rqst_ : *default_instance_->buyrmbstore_rqst_;
#endif
}
inline ::vmsg::CSBuyRMBStoreRqst* CSGoldRequest::mutable_buyrmbstore_rqst() {
  set_has_buyrmbstore_rqst();
  if (buyrmbstore_rqst_ == NULL) buyrmbstore_rqst_ = new ::vmsg::CSBuyRMBStoreRqst;
  return buyrmbstore_rqst_;
}
inline ::vmsg::CSBuyRMBStoreRqst* CSGoldRequest::release_buyrmbstore_rqst() {
  clear_has_buyrmbstore_rqst();
  ::vmsg::CSBuyRMBStoreRqst* temp = buyrmbstore_rqst_;
  buyrmbstore_rqst_ = NULL;
  return temp;
}
inline void CSGoldRequest::set_allocated_buyrmbstore_rqst(::vmsg::CSBuyRMBStoreRqst* buyrmbstore_rqst) {
  delete buyrmbstore_rqst_;
  buyrmbstore_rqst_ = buyrmbstore_rqst;
  if (buyrmbstore_rqst) {
    set_has_buyrmbstore_rqst();
  } else {
    clear_has_buyrmbstore_rqst();
  }
}

// optional .vmsg.CSAppAuthedBuySucceedRqst AppAuthedBuySucceed_Rqst = 3;
inline bool CSGoldRequest::has_appauthedbuysucceed_rqst() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSGoldRequest::set_has_appauthedbuysucceed_rqst() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSGoldRequest::clear_has_appauthedbuysucceed_rqst() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSGoldRequest::clear_appauthedbuysucceed_rqst() {
  if (appauthedbuysucceed_rqst_ != NULL) appauthedbuysucceed_rqst_->::vmsg::CSAppAuthedBuySucceedRqst::Clear();
  clear_has_appauthedbuysucceed_rqst();
}
inline const ::vmsg::CSAppAuthedBuySucceedRqst& CSGoldRequest::appauthedbuysucceed_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return appauthedbuysucceed_rqst_ != NULL ? *appauthedbuysucceed_rqst_ : *default_instance().appauthedbuysucceed_rqst_;
#else
  return appauthedbuysucceed_rqst_ != NULL ? *appauthedbuysucceed_rqst_ : *default_instance_->appauthedbuysucceed_rqst_;
#endif
}
inline ::vmsg::CSAppAuthedBuySucceedRqst* CSGoldRequest::mutable_appauthedbuysucceed_rqst() {
  set_has_appauthedbuysucceed_rqst();
  if (appauthedbuysucceed_rqst_ == NULL) appauthedbuysucceed_rqst_ = new ::vmsg::CSAppAuthedBuySucceedRqst;
  return appauthedbuysucceed_rqst_;
}
inline ::vmsg::CSAppAuthedBuySucceedRqst* CSGoldRequest::release_appauthedbuysucceed_rqst() {
  clear_has_appauthedbuysucceed_rqst();
  ::vmsg::CSAppAuthedBuySucceedRqst* temp = appauthedbuysucceed_rqst_;
  appauthedbuysucceed_rqst_ = NULL;
  return temp;
}
inline void CSGoldRequest::set_allocated_appauthedbuysucceed_rqst(::vmsg::CSAppAuthedBuySucceedRqst* appauthedbuysucceed_rqst) {
  delete appauthedbuysucceed_rqst_;
  appauthedbuysucceed_rqst_ = appauthedbuysucceed_rqst;
  if (appauthedbuysucceed_rqst) {
    set_has_appauthedbuysucceed_rqst();
  } else {
    clear_has_appauthedbuysucceed_rqst();
  }
}

// optional .vmsg.CSAppAuthedBuyRqst AppAuthedBuy_Rqst = 4;
inline bool CSGoldRequest::has_appauthedbuy_rqst() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSGoldRequest::set_has_appauthedbuy_rqst() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSGoldRequest::clear_has_appauthedbuy_rqst() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSGoldRequest::clear_appauthedbuy_rqst() {
  if (appauthedbuy_rqst_ != NULL) appauthedbuy_rqst_->::vmsg::CSAppAuthedBuyRqst::Clear();
  clear_has_appauthedbuy_rqst();
}
inline const ::vmsg::CSAppAuthedBuyRqst& CSGoldRequest::appauthedbuy_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return appauthedbuy_rqst_ != NULL ? *appauthedbuy_rqst_ : *default_instance().appauthedbuy_rqst_;
#else
  return appauthedbuy_rqst_ != NULL ? *appauthedbuy_rqst_ : *default_instance_->appauthedbuy_rqst_;
#endif
}
inline ::vmsg::CSAppAuthedBuyRqst* CSGoldRequest::mutable_appauthedbuy_rqst() {
  set_has_appauthedbuy_rqst();
  if (appauthedbuy_rqst_ == NULL) appauthedbuy_rqst_ = new ::vmsg::CSAppAuthedBuyRqst;
  return appauthedbuy_rqst_;
}
inline ::vmsg::CSAppAuthedBuyRqst* CSGoldRequest::release_appauthedbuy_rqst() {
  clear_has_appauthedbuy_rqst();
  ::vmsg::CSAppAuthedBuyRqst* temp = appauthedbuy_rqst_;
  appauthedbuy_rqst_ = NULL;
  return temp;
}
inline void CSGoldRequest::set_allocated_appauthedbuy_rqst(::vmsg::CSAppAuthedBuyRqst* appauthedbuy_rqst) {
  delete appauthedbuy_rqst_;
  appauthedbuy_rqst_ = appauthedbuy_rqst;
  if (appauthedbuy_rqst) {
    set_has_appauthedbuy_rqst();
  } else {
    clear_has_appauthedbuy_rqst();
  }
}

// optional .vmsg.CSQueryRMBStoreItemRqst QuerySingleItem_Rqst = 5;
inline bool CSGoldRequest::has_querysingleitem_rqst() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSGoldRequest::set_has_querysingleitem_rqst() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSGoldRequest::clear_has_querysingleitem_rqst() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSGoldRequest::clear_querysingleitem_rqst() {
  if (querysingleitem_rqst_ != NULL) querysingleitem_rqst_->::vmsg::CSQueryRMBStoreItemRqst::Clear();
  clear_has_querysingleitem_rqst();
}
inline const ::vmsg::CSQueryRMBStoreItemRqst& CSGoldRequest::querysingleitem_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return querysingleitem_rqst_ != NULL ? *querysingleitem_rqst_ : *default_instance().querysingleitem_rqst_;
#else
  return querysingleitem_rqst_ != NULL ? *querysingleitem_rqst_ : *default_instance_->querysingleitem_rqst_;
#endif
}
inline ::vmsg::CSQueryRMBStoreItemRqst* CSGoldRequest::mutable_querysingleitem_rqst() {
  set_has_querysingleitem_rqst();
  if (querysingleitem_rqst_ == NULL) querysingleitem_rqst_ = new ::vmsg::CSQueryRMBStoreItemRqst;
  return querysingleitem_rqst_;
}
inline ::vmsg::CSQueryRMBStoreItemRqst* CSGoldRequest::release_querysingleitem_rqst() {
  clear_has_querysingleitem_rqst();
  ::vmsg::CSQueryRMBStoreItemRqst* temp = querysingleitem_rqst_;
  querysingleitem_rqst_ = NULL;
  return temp;
}
inline void CSGoldRequest::set_allocated_querysingleitem_rqst(::vmsg::CSQueryRMBStoreItemRqst* querysingleitem_rqst) {
  delete querysingleitem_rqst_;
  querysingleitem_rqst_ = querysingleitem_rqst;
  if (querysingleitem_rqst) {
    set_has_querysingleitem_rqst();
  } else {
    clear_has_querysingleitem_rqst();
  }
}

// -------------------------------------------------------------------

// CSGoldRespond

// optional .vmsg.CSGoldInfo QueryGold_Rsp = 1;
inline bool CSGoldRespond::has_querygold_rsp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGoldRespond::set_has_querygold_rsp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGoldRespond::clear_has_querygold_rsp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGoldRespond::clear_querygold_rsp() {
  if (querygold_rsp_ != NULL) querygold_rsp_->::vmsg::CSGoldInfo::Clear();
  clear_has_querygold_rsp();
}
inline const ::vmsg::CSGoldInfo& CSGoldRespond::querygold_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return querygold_rsp_ != NULL ? *querygold_rsp_ : *default_instance().querygold_rsp_;
#else
  return querygold_rsp_ != NULL ? *querygold_rsp_ : *default_instance_->querygold_rsp_;
#endif
}
inline ::vmsg::CSGoldInfo* CSGoldRespond::mutable_querygold_rsp() {
  set_has_querygold_rsp();
  if (querygold_rsp_ == NULL) querygold_rsp_ = new ::vmsg::CSGoldInfo;
  return querygold_rsp_;
}
inline ::vmsg::CSGoldInfo* CSGoldRespond::release_querygold_rsp() {
  clear_has_querygold_rsp();
  ::vmsg::CSGoldInfo* temp = querygold_rsp_;
  querygold_rsp_ = NULL;
  return temp;
}
inline void CSGoldRespond::set_allocated_querygold_rsp(::vmsg::CSGoldInfo* querygold_rsp) {
  delete querygold_rsp_;
  querygold_rsp_ = querygold_rsp;
  if (querygold_rsp) {
    set_has_querygold_rsp();
  } else {
    clear_has_querygold_rsp();
  }
}

// optional .vmsg.CSGoldInfo Gold_Notify = 2;
inline bool CSGoldRespond::has_gold_notify() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGoldRespond::set_has_gold_notify() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGoldRespond::clear_has_gold_notify() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGoldRespond::clear_gold_notify() {
  if (gold_notify_ != NULL) gold_notify_->::vmsg::CSGoldInfo::Clear();
  clear_has_gold_notify();
}
inline const ::vmsg::CSGoldInfo& CSGoldRespond::gold_notify() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gold_notify_ != NULL ? *gold_notify_ : *default_instance().gold_notify_;
#else
  return gold_notify_ != NULL ? *gold_notify_ : *default_instance_->gold_notify_;
#endif
}
inline ::vmsg::CSGoldInfo* CSGoldRespond::mutable_gold_notify() {
  set_has_gold_notify();
  if (gold_notify_ == NULL) gold_notify_ = new ::vmsg::CSGoldInfo;
  return gold_notify_;
}
inline ::vmsg::CSGoldInfo* CSGoldRespond::release_gold_notify() {
  clear_has_gold_notify();
  ::vmsg::CSGoldInfo* temp = gold_notify_;
  gold_notify_ = NULL;
  return temp;
}
inline void CSGoldRespond::set_allocated_gold_notify(::vmsg::CSGoldInfo* gold_notify) {
  delete gold_notify_;
  gold_notify_ = gold_notify;
  if (gold_notify) {
    set_has_gold_notify();
  } else {
    clear_has_gold_notify();
  }
}

// optional .vmsg.CSBuyGoldRsp BuyGold_Rsp = 3;
inline bool CSGoldRespond::has_buygold_rsp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSGoldRespond::set_has_buygold_rsp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSGoldRespond::clear_has_buygold_rsp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSGoldRespond::clear_buygold_rsp() {
  if (buygold_rsp_ != NULL) buygold_rsp_->::vmsg::CSBuyGoldRsp::Clear();
  clear_has_buygold_rsp();
}
inline const ::vmsg::CSBuyGoldRsp& CSGoldRespond::buygold_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return buygold_rsp_ != NULL ? *buygold_rsp_ : *default_instance().buygold_rsp_;
#else
  return buygold_rsp_ != NULL ? *buygold_rsp_ : *default_instance_->buygold_rsp_;
#endif
}
inline ::vmsg::CSBuyGoldRsp* CSGoldRespond::mutable_buygold_rsp() {
  set_has_buygold_rsp();
  if (buygold_rsp_ == NULL) buygold_rsp_ = new ::vmsg::CSBuyGoldRsp;
  return buygold_rsp_;
}
inline ::vmsg::CSBuyGoldRsp* CSGoldRespond::release_buygold_rsp() {
  clear_has_buygold_rsp();
  ::vmsg::CSBuyGoldRsp* temp = buygold_rsp_;
  buygold_rsp_ = NULL;
  return temp;
}
inline void CSGoldRespond::set_allocated_buygold_rsp(::vmsg::CSBuyGoldRsp* buygold_rsp) {
  delete buygold_rsp_;
  buygold_rsp_ = buygold_rsp;
  if (buygold_rsp) {
    set_has_buygold_rsp();
  } else {
    clear_has_buygold_rsp();
  }
}

// optional .vmsg.CSBuyRMBStoreRsp BuyRMBStore_Rsp = 4;
inline bool CSGoldRespond::has_buyrmbstore_rsp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSGoldRespond::set_has_buyrmbstore_rsp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSGoldRespond::clear_has_buyrmbstore_rsp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSGoldRespond::clear_buyrmbstore_rsp() {
  if (buyrmbstore_rsp_ != NULL) buyrmbstore_rsp_->::vmsg::CSBuyRMBStoreRsp::Clear();
  clear_has_buyrmbstore_rsp();
}
inline const ::vmsg::CSBuyRMBStoreRsp& CSGoldRespond::buyrmbstore_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return buyrmbstore_rsp_ != NULL ? *buyrmbstore_rsp_ : *default_instance().buyrmbstore_rsp_;
#else
  return buyrmbstore_rsp_ != NULL ? *buyrmbstore_rsp_ : *default_instance_->buyrmbstore_rsp_;
#endif
}
inline ::vmsg::CSBuyRMBStoreRsp* CSGoldRespond::mutable_buyrmbstore_rsp() {
  set_has_buyrmbstore_rsp();
  if (buyrmbstore_rsp_ == NULL) buyrmbstore_rsp_ = new ::vmsg::CSBuyRMBStoreRsp;
  return buyrmbstore_rsp_;
}
inline ::vmsg::CSBuyRMBStoreRsp* CSGoldRespond::release_buyrmbstore_rsp() {
  clear_has_buyrmbstore_rsp();
  ::vmsg::CSBuyRMBStoreRsp* temp = buyrmbstore_rsp_;
  buyrmbstore_rsp_ = NULL;
  return temp;
}
inline void CSGoldRespond::set_allocated_buyrmbstore_rsp(::vmsg::CSBuyRMBStoreRsp* buyrmbstore_rsp) {
  delete buyrmbstore_rsp_;
  buyrmbstore_rsp_ = buyrmbstore_rsp;
  if (buyrmbstore_rsp) {
    set_has_buyrmbstore_rsp();
  } else {
    clear_has_buyrmbstore_rsp();
  }
}

// optional .vmsg.CSQueryRMBStoreRsp QueryRMBStore_Rsp = 5;
inline bool CSGoldRespond::has_queryrmbstore_rsp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSGoldRespond::set_has_queryrmbstore_rsp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSGoldRespond::clear_has_queryrmbstore_rsp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSGoldRespond::clear_queryrmbstore_rsp() {
  if (queryrmbstore_rsp_ != NULL) queryrmbstore_rsp_->::vmsg::CSQueryRMBStoreRsp::Clear();
  clear_has_queryrmbstore_rsp();
}
inline const ::vmsg::CSQueryRMBStoreRsp& CSGoldRespond::queryrmbstore_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return queryrmbstore_rsp_ != NULL ? *queryrmbstore_rsp_ : *default_instance().queryrmbstore_rsp_;
#else
  return queryrmbstore_rsp_ != NULL ? *queryrmbstore_rsp_ : *default_instance_->queryrmbstore_rsp_;
#endif
}
inline ::vmsg::CSQueryRMBStoreRsp* CSGoldRespond::mutable_queryrmbstore_rsp() {
  set_has_queryrmbstore_rsp();
  if (queryrmbstore_rsp_ == NULL) queryrmbstore_rsp_ = new ::vmsg::CSQueryRMBStoreRsp;
  return queryrmbstore_rsp_;
}
inline ::vmsg::CSQueryRMBStoreRsp* CSGoldRespond::release_queryrmbstore_rsp() {
  clear_has_queryrmbstore_rsp();
  ::vmsg::CSQueryRMBStoreRsp* temp = queryrmbstore_rsp_;
  queryrmbstore_rsp_ = NULL;
  return temp;
}
inline void CSGoldRespond::set_allocated_queryrmbstore_rsp(::vmsg::CSQueryRMBStoreRsp* queryrmbstore_rsp) {
  delete queryrmbstore_rsp_;
  queryrmbstore_rsp_ = queryrmbstore_rsp;
  if (queryrmbstore_rsp) {
    set_has_queryrmbstore_rsp();
  } else {
    clear_has_queryrmbstore_rsp();
  }
}

// optional .vmsg.CSAppAuthedBuyRsp AppAuthedBuy_Rsp = 6;
inline bool CSGoldRespond::has_appauthedbuy_rsp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSGoldRespond::set_has_appauthedbuy_rsp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSGoldRespond::clear_has_appauthedbuy_rsp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSGoldRespond::clear_appauthedbuy_rsp() {
  if (appauthedbuy_rsp_ != NULL) appauthedbuy_rsp_->::vmsg::CSAppAuthedBuyRsp::Clear();
  clear_has_appauthedbuy_rsp();
}
inline const ::vmsg::CSAppAuthedBuyRsp& CSGoldRespond::appauthedbuy_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return appauthedbuy_rsp_ != NULL ? *appauthedbuy_rsp_ : *default_instance().appauthedbuy_rsp_;
#else
  return appauthedbuy_rsp_ != NULL ? *appauthedbuy_rsp_ : *default_instance_->appauthedbuy_rsp_;
#endif
}
inline ::vmsg::CSAppAuthedBuyRsp* CSGoldRespond::mutable_appauthedbuy_rsp() {
  set_has_appauthedbuy_rsp();
  if (appauthedbuy_rsp_ == NULL) appauthedbuy_rsp_ = new ::vmsg::CSAppAuthedBuyRsp;
  return appauthedbuy_rsp_;
}
inline ::vmsg::CSAppAuthedBuyRsp* CSGoldRespond::release_appauthedbuy_rsp() {
  clear_has_appauthedbuy_rsp();
  ::vmsg::CSAppAuthedBuyRsp* temp = appauthedbuy_rsp_;
  appauthedbuy_rsp_ = NULL;
  return temp;
}
inline void CSGoldRespond::set_allocated_appauthedbuy_rsp(::vmsg::CSAppAuthedBuyRsp* appauthedbuy_rsp) {
  delete appauthedbuy_rsp_;
  appauthedbuy_rsp_ = appauthedbuy_rsp;
  if (appauthedbuy_rsp) {
    set_has_appauthedbuy_rsp();
  } else {
    clear_has_appauthedbuy_rsp();
  }
}

// optional .vmsg.CSQueryRMBStoreItemRsp QuerySingleItem_Rsp = 7;
inline bool CSGoldRespond::has_querysingleitem_rsp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSGoldRespond::set_has_querysingleitem_rsp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSGoldRespond::clear_has_querysingleitem_rsp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSGoldRespond::clear_querysingleitem_rsp() {
  if (querysingleitem_rsp_ != NULL) querysingleitem_rsp_->::vmsg::CSQueryRMBStoreItemRsp::Clear();
  clear_has_querysingleitem_rsp();
}
inline const ::vmsg::CSQueryRMBStoreItemRsp& CSGoldRespond::querysingleitem_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return querysingleitem_rsp_ != NULL ? *querysingleitem_rsp_ : *default_instance().querysingleitem_rsp_;
#else
  return querysingleitem_rsp_ != NULL ? *querysingleitem_rsp_ : *default_instance_->querysingleitem_rsp_;
#endif
}
inline ::vmsg::CSQueryRMBStoreItemRsp* CSGoldRespond::mutable_querysingleitem_rsp() {
  set_has_querysingleitem_rsp();
  if (querysingleitem_rsp_ == NULL) querysingleitem_rsp_ = new ::vmsg::CSQueryRMBStoreItemRsp;
  return querysingleitem_rsp_;
}
inline ::vmsg::CSQueryRMBStoreItemRsp* CSGoldRespond::release_querysingleitem_rsp() {
  clear_has_querysingleitem_rsp();
  ::vmsg::CSQueryRMBStoreItemRsp* temp = querysingleitem_rsp_;
  querysingleitem_rsp_ = NULL;
  return temp;
}
inline void CSGoldRespond::set_allocated_querysingleitem_rsp(::vmsg::CSQueryRMBStoreItemRsp* querysingleitem_rsp) {
  delete querysingleitem_rsp_;
  querysingleitem_rsp_ = querysingleitem_rsp;
  if (querysingleitem_rsp) {
    set_has_querysingleitem_rsp();
  } else {
    clear_has_querysingleitem_rsp();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CSGoldMsg_2eproto__INCLUDED
