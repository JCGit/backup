// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MsgBase.proto

#ifndef PROTOBUF_MsgBase_2eproto__INCLUDED
#define PROTOBUF_MsgBase_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace vmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MsgBase_2eproto();
void protobuf_AssignDesc_MsgBase_2eproto();
void protobuf_ShutdownFile_MsgBase_2eproto();

class QQAuthInfo;
class OAuthInfo;
class SinaAutoInfo;
class QihuAutoInfo;
class AuthInfo;
class CSPlayerLoginRqst;
class CSPlayerLoginRsp;
class MsgHead;
class PBFieldDescriptor;
class PBMsgDescriptor;
class RouteHead;
class NullMsg;

enum MsgHead_MSG_TYPE {
  MsgHead_MSG_TYPE_RQST_MSG = 1,
  MsgHead_MSG_TYPE_RSP_MSG = 2,
  MsgHead_MSG_TYPE_NOTICE_MSG = 3
};
bool MsgHead_MSG_TYPE_IsValid(int value);
const MsgHead_MSG_TYPE MsgHead_MSG_TYPE_MSG_TYPE_MIN = MsgHead_MSG_TYPE_RQST_MSG;
const MsgHead_MSG_TYPE MsgHead_MSG_TYPE_MSG_TYPE_MAX = MsgHead_MSG_TYPE_NOTICE_MSG;
const int MsgHead_MSG_TYPE_MSG_TYPE_ARRAYSIZE = MsgHead_MSG_TYPE_MSG_TYPE_MAX + 1;

enum AuthErrorCode {
  VCONND_PLAYER_AUTH_OK = 0,
  VCONND_PLAYER_AUTH_FAIL = 1,
  VCONND_PLAYER_AUTH_TIMEOUT = 2
};
bool AuthErrorCode_IsValid(int value);
const AuthErrorCode AuthErrorCode_MIN = VCONND_PLAYER_AUTH_OK;
const AuthErrorCode AuthErrorCode_MAX = VCONND_PLAYER_AUTH_TIMEOUT;
const int AuthErrorCode_ARRAYSIZE = AuthErrorCode_MAX + 1;

enum AccountPlatform {
  QQ_ACCOUNT_PLATFORM = 1,
  SINA_ACCOUNT_PLATFORM = 2
};
bool AccountPlatform_IsValid(int value);
const AccountPlatform AccountPlatform_MIN = QQ_ACCOUNT_PLATFORM;
const AccountPlatform AccountPlatform_MAX = SINA_ACCOUNT_PLATFORM;
const int AccountPlatform_ARRAYSIZE = AccountPlatform_MAX + 1;

enum LoginMsgID {
  CS_CMD_PLAYER_LOGIN = 800000
};
bool LoginMsgID_IsValid(int value);
const LoginMsgID LoginMsgID_MIN = CS_CMD_PLAYER_LOGIN;
const LoginMsgID LoginMsgID_MAX = CS_CMD_PLAYER_LOGIN;
const int LoginMsgID_ARRAYSIZE = LoginMsgID_MAX + 1;

// ===================================================================

class QQAuthInfo : public ::google::protobuf::MessageLite {
 public:
  QQAuthInfo();
  virtual ~QQAuthInfo();

  QQAuthInfo(const QQAuthInfo& from);

  inline QQAuthInfo& operator=(const QQAuthInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const QQAuthInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QQAuthInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QQAuthInfo* other);

  // implements Message ----------------------------------------------

  QQAuthInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QQAuthInfo& from);
  void MergeFrom(const QQAuthInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string openid = 1;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 1;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // required string openkey = 2;
  inline bool has_openkey() const;
  inline void clear_openkey();
  static const int kOpenkeyFieldNumber = 2;
  inline const ::std::string& openkey() const;
  inline void set_openkey(const ::std::string& value);
  inline void set_openkey(const char* value);
  inline void set_openkey(const char* value, size_t size);
  inline ::std::string* mutable_openkey();
  inline ::std::string* release_openkey();
  inline void set_allocated_openkey(::std::string* openkey);

  // required uint32 appid = 3;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 3;
  inline ::google::protobuf::uint32 appid() const;
  inline void set_appid(::google::protobuf::uint32 value);

  // required string pf = 5;
  inline bool has_pf() const;
  inline void clear_pf();
  static const int kPfFieldNumber = 5;
  inline const ::std::string& pf() const;
  inline void set_pf(const ::std::string& value);
  inline void set_pf(const char* value);
  inline void set_pf(const char* value, size_t size);
  inline ::std::string* mutable_pf();
  inline ::std::string* release_pf();
  inline void set_allocated_pf(::std::string* pf);

  // @@protoc_insertion_point(class_scope:vmsg.QQAuthInfo)
 private:
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_openkey();
  inline void clear_has_openkey();
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_pf();
  inline void clear_has_pf();

  ::std::string* openid_;
  ::std::string* openkey_;
  ::std::string* pf_;
  ::google::protobuf::uint32 appid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MsgBase_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MsgBase_2eproto();
  #endif
  friend void protobuf_AssignDesc_MsgBase_2eproto();
  friend void protobuf_ShutdownFile_MsgBase_2eproto();

  void InitAsDefaultInstance();
  static QQAuthInfo* default_instance_;
};
// -------------------------------------------------------------------

class OAuthInfo : public ::google::protobuf::MessageLite {
 public:
  OAuthInfo();
  virtual ~OAuthInfo();

  OAuthInfo(const OAuthInfo& from);

  inline OAuthInfo& operator=(const OAuthInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const OAuthInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OAuthInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OAuthInfo* other);

  // implements Message ----------------------------------------------

  OAuthInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OAuthInfo& from);
  void MergeFrom(const OAuthInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // required string OpenKey = 2;
  inline bool has_openkey() const;
  inline void clear_openkey();
  static const int kOpenKeyFieldNumber = 2;
  inline const ::std::string& openkey() const;
  inline void set_openkey(const ::std::string& value);
  inline void set_openkey(const char* value);
  inline void set_openkey(const char* value, size_t size);
  inline ::std::string* mutable_openkey();
  inline ::std::string* release_openkey();
  inline void set_allocated_openkey(::std::string* openkey);

  // @@protoc_insertion_point(class_scope:vmsg.OAuthInfo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_openkey();
  inline void clear_has_openkey();

  ::std::string* uid_;
  ::std::string* openkey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MsgBase_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MsgBase_2eproto();
  #endif
  friend void protobuf_AssignDesc_MsgBase_2eproto();
  friend void protobuf_ShutdownFile_MsgBase_2eproto();

  void InitAsDefaultInstance();
  static OAuthInfo* default_instance_;
};
// -------------------------------------------------------------------

class SinaAutoInfo : public ::google::protobuf::MessageLite {
 public:
  SinaAutoInfo();
  virtual ~SinaAutoInfo();

  SinaAutoInfo(const SinaAutoInfo& from);

  inline SinaAutoInfo& operator=(const SinaAutoInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const SinaAutoInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SinaAutoInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SinaAutoInfo* other);

  // implements Message ----------------------------------------------

  SinaAutoInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SinaAutoInfo& from);
  void MergeFrom(const SinaAutoInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required string SessionKey = 2;
  inline bool has_sessionkey() const;
  inline void clear_sessionkey();
  static const int kSessionKeyFieldNumber = 2;
  inline const ::std::string& sessionkey() const;
  inline void set_sessionkey(const ::std::string& value);
  inline void set_sessionkey(const char* value);
  inline void set_sessionkey(const char* value, size_t size);
  inline ::std::string* mutable_sessionkey();
  inline ::std::string* release_sessionkey();
  inline void set_allocated_sessionkey(::std::string* sessionkey);

  // required uint64 CreateTime = 3;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreateTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 createtime() const;
  inline void set_createtime(::google::protobuf::uint64 value);

  // required uint64 ExpireTime = 4;
  inline bool has_expiretime() const;
  inline void clear_expiretime();
  static const int kExpireTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 expiretime() const;
  inline void set_expiretime(::google::protobuf::uint64 value);

  // required string Signature = 5;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 5;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const char* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:vmsg.SinaAutoInfo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_sessionkey();
  inline void clear_has_sessionkey();
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_expiretime();
  inline void clear_has_expiretime();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::google::protobuf::uint64 uid_;
  ::std::string* sessionkey_;
  ::google::protobuf::uint64 createtime_;
  ::google::protobuf::uint64 expiretime_;
  ::std::string* signature_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MsgBase_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MsgBase_2eproto();
  #endif
  friend void protobuf_AssignDesc_MsgBase_2eproto();
  friend void protobuf_ShutdownFile_MsgBase_2eproto();

  void InitAsDefaultInstance();
  static SinaAutoInfo* default_instance_;
};
// -------------------------------------------------------------------

class QihuAutoInfo : public ::google::protobuf::MessageLite {
 public:
  QihuAutoInfo();
  virtual ~QihuAutoInfo();

  QihuAutoInfo(const QihuAutoInfo& from);

  inline QihuAutoInfo& operator=(const QihuAutoInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const QihuAutoInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QihuAutoInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QihuAutoInfo* other);

  // implements Message ----------------------------------------------

  QihuAutoInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QihuAutoInfo& from);
  void MergeFrom(const QihuAutoInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required uint32 Time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // required string SeverID = 3;
  inline bool has_severid() const;
  inline void clear_severid();
  static const int kSeverIDFieldNumber = 3;
  inline const ::std::string& severid() const;
  inline void set_severid(const ::std::string& value);
  inline void set_severid(const char* value);
  inline void set_severid(const char* value, size_t size);
  inline ::std::string* mutable_severid();
  inline ::std::string* release_severid();
  inline void set_allocated_severid(::std::string* severid);

  // required string Signature = 4;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 4;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const char* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:vmsg.QihuAutoInfo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_severid();
  inline void clear_has_severid();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::google::protobuf::uint64 uid_;
  ::std::string* severid_;
  ::std::string* signature_;
  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MsgBase_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MsgBase_2eproto();
  #endif
  friend void protobuf_AssignDesc_MsgBase_2eproto();
  friend void protobuf_ShutdownFile_MsgBase_2eproto();

  void InitAsDefaultInstance();
  static QihuAutoInfo* default_instance_;
};
// -------------------------------------------------------------------

class AuthInfo : public ::google::protobuf::MessageLite {
 public:
  AuthInfo();
  virtual ~AuthInfo();

  AuthInfo(const AuthInfo& from);

  inline AuthInfo& operator=(const AuthInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const AuthInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthInfo* other);

  // implements Message ----------------------------------------------

  AuthInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthInfo& from);
  void MergeFrom(const AuthInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string openid = 1;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 1;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // required string openkey = 2;
  inline bool has_openkey() const;
  inline void clear_openkey();
  static const int kOpenkeyFieldNumber = 2;
  inline const ::std::string& openkey() const;
  inline void set_openkey(const ::std::string& value);
  inline void set_openkey(const char* value);
  inline void set_openkey(const char* value, size_t size);
  inline ::std::string* mutable_openkey();
  inline ::std::string* release_openkey();
  inline void set_allocated_openkey(::std::string* openkey);

  // required string platform = 3;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 3;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  inline ::std::string* release_platform();
  inline void set_allocated_platform(::std::string* platform);

  // @@protoc_insertion_point(class_scope:vmsg.AuthInfo)
 private:
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_openkey();
  inline void clear_has_openkey();
  inline void set_has_platform();
  inline void clear_has_platform();

  ::std::string* openid_;
  ::std::string* openkey_;
  ::std::string* platform_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MsgBase_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MsgBase_2eproto();
  #endif
  friend void protobuf_AssignDesc_MsgBase_2eproto();
  friend void protobuf_ShutdownFile_MsgBase_2eproto();

  void InitAsDefaultInstance();
  static AuthInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerLoginRqst : public ::google::protobuf::MessageLite {
 public:
  CSPlayerLoginRqst();
  virtual ~CSPlayerLoginRqst();

  CSPlayerLoginRqst(const CSPlayerLoginRqst& from);

  inline CSPlayerLoginRqst& operator=(const CSPlayerLoginRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerLoginRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerLoginRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerLoginRqst* other);

  // implements Message ----------------------------------------------

  CSPlayerLoginRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerLoginRqst& from);
  void MergeFrom(const CSPlayerLoginRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string loginInfo = 1;
  inline bool has_logininfo() const;
  inline void clear_logininfo();
  static const int kLoginInfoFieldNumber = 1;
  inline const ::std::string& logininfo() const;
  inline void set_logininfo(const ::std::string& value);
  inline void set_logininfo(const char* value);
  inline void set_logininfo(const char* value, size_t size);
  inline ::std::string* mutable_logininfo();
  inline ::std::string* release_logininfo();
  inline void set_allocated_logininfo(::std::string* logininfo);

  // optional uint32 ZoneID = 2;
  inline bool has_zoneid() const;
  inline void clear_zoneid();
  static const int kZoneIDFieldNumber = 2;
  inline ::google::protobuf::uint32 zoneid() const;
  inline void set_zoneid(::google::protobuf::uint32 value);

  // optional .vmsg.AuthInfo AuthInfo = 3;
  inline bool has_authinfo() const;
  inline void clear_authinfo();
  static const int kAuthInfoFieldNumber = 3;
  inline const ::vmsg::AuthInfo& authinfo() const;
  inline ::vmsg::AuthInfo* mutable_authinfo();
  inline ::vmsg::AuthInfo* release_authinfo();
  inline void set_allocated_authinfo(::vmsg::AuthInfo* authinfo);

  // optional uint32 GuestLogin = 4;
  inline bool has_guestlogin() const;
  inline void clear_guestlogin();
  static const int kGuestLoginFieldNumber = 4;
  inline ::google::protobuf::uint32 guestlogin() const;
  inline void set_guestlogin(::google::protobuf::uint32 value);

  // optional string AppPlatform = 5;
  inline bool has_appplatform() const;
  inline void clear_appplatform();
  static const int kAppPlatformFieldNumber = 5;
  inline const ::std::string& appplatform() const;
  inline void set_appplatform(const ::std::string& value);
  inline void set_appplatform(const char* value);
  inline void set_appplatform(const char* value, size_t size);
  inline ::std::string* mutable_appplatform();
  inline ::std::string* release_appplatform();
  inline void set_allocated_appplatform(::std::string* appplatform);

  // required uint64 Sign = 6;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 6;
  inline ::google::protobuf::uint64 sign() const;
  inline void set_sign(::google::protobuf::uint64 value);

  // required uint32 Time = 7;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 7;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerLoginRqst)
 private:
  inline void set_has_logininfo();
  inline void clear_has_logininfo();
  inline void set_has_zoneid();
  inline void clear_has_zoneid();
  inline void set_has_authinfo();
  inline void clear_has_authinfo();
  inline void set_has_guestlogin();
  inline void clear_has_guestlogin();
  inline void set_has_appplatform();
  inline void clear_has_appplatform();
  inline void set_has_sign();
  inline void clear_has_sign();
  inline void set_has_time();
  inline void clear_has_time();

  ::std::string* logininfo_;
  ::vmsg::AuthInfo* authinfo_;
  ::google::protobuf::uint32 zoneid_;
  ::google::protobuf::uint32 guestlogin_;
  ::std::string* appplatform_;
  ::google::protobuf::uint64 sign_;
  ::google::protobuf::uint32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MsgBase_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MsgBase_2eproto();
  #endif
  friend void protobuf_AssignDesc_MsgBase_2eproto();
  friend void protobuf_ShutdownFile_MsgBase_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerLoginRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerLoginRsp : public ::google::protobuf::MessageLite {
 public:
  CSPlayerLoginRsp();
  virtual ~CSPlayerLoginRsp();

  CSPlayerLoginRsp(const CSPlayerLoginRsp& from);

  inline CSPlayerLoginRsp& operator=(const CSPlayerLoginRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerLoginRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerLoginRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerLoginRsp* other);

  // implements Message ----------------------------------------------

  CSPlayerLoginRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerLoginRsp& from);
  void MergeFrom(const CSPlayerLoginRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string loginInfo = 1;
  inline bool has_logininfo() const;
  inline void clear_logininfo();
  static const int kLoginInfoFieldNumber = 1;
  inline const ::std::string& logininfo() const;
  inline void set_logininfo(const ::std::string& value);
  inline void set_logininfo(const char* value);
  inline void set_logininfo(const char* value, size_t size);
  inline ::std::string* mutable_logininfo();
  inline ::std::string* release_logininfo();
  inline void set_allocated_logininfo(::std::string* logininfo);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerLoginRsp)
 private:
  inline void set_has_logininfo();
  inline void clear_has_logininfo();

  ::std::string* logininfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MsgBase_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MsgBase_2eproto();
  #endif
  friend void protobuf_AssignDesc_MsgBase_2eproto();
  friend void protobuf_ShutdownFile_MsgBase_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerLoginRsp* default_instance_;
};
// -------------------------------------------------------------------

class MsgHead : public ::google::protobuf::MessageLite {
 public:
  MsgHead();
  virtual ~MsgHead();

  MsgHead(const MsgHead& from);

  inline MsgHead& operator=(const MsgHead& from) {
    CopyFrom(from);
    return *this;
  }

  static const MsgHead& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgHead* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgHead* other);

  // implements Message ----------------------------------------------

  MsgHead* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgHead& from);
  void MergeFrom(const MsgHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef MsgHead_MSG_TYPE MSG_TYPE;
  static const MSG_TYPE RQST_MSG = MsgHead_MSG_TYPE_RQST_MSG;
  static const MSG_TYPE RSP_MSG = MsgHead_MSG_TYPE_RSP_MSG;
  static const MSG_TYPE NOTICE_MSG = MsgHead_MSG_TYPE_NOTICE_MSG;
  static inline bool MSG_TYPE_IsValid(int value) {
    return MsgHead_MSG_TYPE_IsValid(value);
  }
  static const MSG_TYPE MSG_TYPE_MIN =
    MsgHead_MSG_TYPE_MSG_TYPE_MIN;
  static const MSG_TYPE MSG_TYPE_MAX =
    MsgHead_MSG_TYPE_MSG_TYPE_MAX;
  static const int MSG_TYPE_ARRAYSIZE =
    MsgHead_MSG_TYPE_MSG_TYPE_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required uint32 Msg_ID = 1;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIDFieldNumber = 1;
  inline ::google::protobuf::uint32 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint32 value);

  // required uint64 Uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required uint64 Act = 3;
  inline bool has_act() const;
  inline void clear_act();
  static const int kActFieldNumber = 3;
  inline ::google::protobuf::uint64 act() const;
  inline void set_act(::google::protobuf::uint64 value);

  // required uint32 Seq = 4;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 4;
  inline ::google::protobuf::uint32 seq() const;
  inline void set_seq(::google::protobuf::uint32 value);

  // required .vmsg.MsgHead.MSG_TYPE Msg_Type = 5;
  inline bool has_msg_type() const;
  inline void clear_msg_type();
  static const int kMsgTypeFieldNumber = 5;
  inline ::vmsg::MsgHead_MSG_TYPE msg_type() const;
  inline void set_msg_type(::vmsg::MsgHead_MSG_TYPE value);

  // optional uint32 App_ID = 6 [default = 0];
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIDFieldNumber = 6;
  inline ::google::protobuf::uint32 app_id() const;
  inline void set_app_id(::google::protobuf::uint32 value);

  // optional uint32 RouteID = 7;
  inline bool has_routeid() const;
  inline void clear_routeid();
  static const int kRouteIDFieldNumber = 7;
  inline ::google::protobuf::uint32 routeid() const;
  inline void set_routeid(::google::protobuf::uint32 value);

  // optional .vmsg.CSPlayerLoginRqst LoginRqst = 8;
  inline bool has_loginrqst() const;
  inline void clear_loginrqst();
  static const int kLoginRqstFieldNumber = 8;
  inline const ::vmsg::CSPlayerLoginRqst& loginrqst() const;
  inline ::vmsg::CSPlayerLoginRqst* mutable_loginrqst();
  inline ::vmsg::CSPlayerLoginRqst* release_loginrqst();
  inline void set_allocated_loginrqst(::vmsg::CSPlayerLoginRqst* loginrqst);

  // optional .vmsg.CSPlayerLoginRsp LoginRsp = 9;
  inline bool has_loginrsp() const;
  inline void clear_loginrsp();
  static const int kLoginRspFieldNumber = 9;
  inline const ::vmsg::CSPlayerLoginRsp& loginrsp() const;
  inline ::vmsg::CSPlayerLoginRsp* mutable_loginrsp();
  inline ::vmsg::CSPlayerLoginRsp* release_loginrsp();
  inline void set_allocated_loginrsp(::vmsg::CSPlayerLoginRsp* loginrsp);

  // optional uint64 QuickLoginKey = 10;
  inline bool has_quickloginkey() const;
  inline void clear_quickloginkey();
  static const int kQuickLoginKeyFieldNumber = 10;
  inline ::google::protobuf::uint64 quickloginkey() const;
  inline void set_quickloginkey(::google::protobuf::uint64 value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(MsgHead)
  // @@protoc_insertion_point(class_scope:vmsg.MsgHead)
 private:
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_act();
  inline void clear_has_act();
  inline void set_has_seq();
  inline void clear_has_seq();
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_routeid();
  inline void clear_has_routeid();
  inline void set_has_loginrqst();
  inline void clear_has_loginrqst();
  inline void set_has_loginrsp();
  inline void clear_has_loginrsp();
  inline void set_has_quickloginkey();
  inline void clear_has_quickloginkey();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint32 msg_id_;
  ::google::protobuf::uint32 seq_;
  ::google::protobuf::uint64 act_;
  int msg_type_;
  ::google::protobuf::uint32 app_id_;
  ::vmsg::CSPlayerLoginRqst* loginrqst_;
  ::vmsg::CSPlayerLoginRsp* loginrsp_;
  ::google::protobuf::uint64 quickloginkey_;
  ::google::protobuf::uint32 routeid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MsgBase_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MsgBase_2eproto();
  #endif
  friend void protobuf_AssignDesc_MsgBase_2eproto();
  friend void protobuf_ShutdownFile_MsgBase_2eproto();

  void InitAsDefaultInstance();
  static MsgHead* default_instance_;
};
// -------------------------------------------------------------------

class PBFieldDescriptor : public ::google::protobuf::MessageLite {
 public:
  PBFieldDescriptor();
  virtual ~PBFieldDescriptor();

  PBFieldDescriptor(const PBFieldDescriptor& from);

  inline PBFieldDescriptor& operator=(const PBFieldDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  static const PBFieldDescriptor& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PBFieldDescriptor* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PBFieldDescriptor* other);

  // implements Message ----------------------------------------------

  PBFieldDescriptor* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PBFieldDescriptor& from);
  void MergeFrom(const PBFieldDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Field = 1;
  inline bool has_field() const;
  inline void clear_field();
  static const int kFieldFieldNumber = 1;
  inline const ::std::string& field() const;
  inline void set_field(const ::std::string& value);
  inline void set_field(const char* value);
  inline void set_field(const char* value, size_t size);
  inline ::std::string* mutable_field();
  inline ::std::string* release_field();
  inline void set_allocated_field(::std::string* field);

  // required int32 Tag = 2;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 2;
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);

  // required int32 Type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vmsg.PBFieldDescriptor)
 private:
  inline void set_has_field();
  inline void clear_has_field();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_type();
  inline void clear_has_type();

  ::std::string* field_;
  ::google::protobuf::int32 tag_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MsgBase_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MsgBase_2eproto();
  #endif
  friend void protobuf_AssignDesc_MsgBase_2eproto();
  friend void protobuf_ShutdownFile_MsgBase_2eproto();

  void InitAsDefaultInstance();
  static PBFieldDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class PBMsgDescriptor : public ::google::protobuf::MessageLite {
 public:
  PBMsgDescriptor();
  virtual ~PBMsgDescriptor();

  PBMsgDescriptor(const PBMsgDescriptor& from);

  inline PBMsgDescriptor& operator=(const PBMsgDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  static const PBMsgDescriptor& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PBMsgDescriptor* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PBMsgDescriptor* other);

  // implements Message ----------------------------------------------

  PBMsgDescriptor* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PBMsgDescriptor& from);
  void MergeFrom(const PBMsgDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.PBFieldDescriptor Fields = 1;
  inline int fields_size() const;
  inline void clear_fields();
  static const int kFieldsFieldNumber = 1;
  inline const ::vmsg::PBFieldDescriptor& fields(int index) const;
  inline ::vmsg::PBFieldDescriptor* mutable_fields(int index);
  inline ::vmsg::PBFieldDescriptor* add_fields();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::PBFieldDescriptor >&
      fields() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::PBFieldDescriptor >*
      mutable_fields();

  // @@protoc_insertion_point(class_scope:vmsg.PBMsgDescriptor)
 private:

  ::google::protobuf::RepeatedPtrField< ::vmsg::PBFieldDescriptor > fields_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MsgBase_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MsgBase_2eproto();
  #endif
  friend void protobuf_AssignDesc_MsgBase_2eproto();
  friend void protobuf_ShutdownFile_MsgBase_2eproto();

  void InitAsDefaultInstance();
  static PBMsgDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class RouteHead : public ::google::protobuf::MessageLite {
 public:
  RouteHead();
  virtual ~RouteHead();

  RouteHead(const RouteHead& from);

  inline RouteHead& operator=(const RouteHead& from) {
    CopyFrom(from);
    return *this;
  }

  static const RouteHead& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RouteHead* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RouteHead* other);

  // implements Message ----------------------------------------------

  RouteHead* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RouteHead& from);
  void MergeFrom(const RouteHead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 src_app_id = 1;
  inline bool has_src_app_id() const;
  inline void clear_src_app_id();
  static const int kSrcAppIdFieldNumber = 1;
  inline ::google::protobuf::uint32 src_app_id() const;
  inline void set_src_app_id(::google::protobuf::uint32 value);

  // required uint64 src_route_key = 2;
  inline bool has_src_route_key() const;
  inline void clear_src_route_key();
  static const int kSrcRouteKeyFieldNumber = 2;
  inline ::google::protobuf::uint64 src_route_key() const;
  inline void set_src_route_key(::google::protobuf::uint64 value);

  // required uint32 dst_app_id = 3;
  inline bool has_dst_app_id() const;
  inline void clear_dst_app_id();
  static const int kDstAppIdFieldNumber = 3;
  inline ::google::protobuf::uint32 dst_app_id() const;
  inline void set_dst_app_id(::google::protobuf::uint32 value);

  // required uint64 dst_route_key = 4;
  inline bool has_dst_route_key() const;
  inline void clear_dst_route_key();
  static const int kDstRouteKeyFieldNumber = 4;
  inline ::google::protobuf::uint64 dst_route_key() const;
  inline void set_dst_route_key(::google::protobuf::uint64 value);

  // optional uint64 load_banance_key = 5;
  inline bool has_load_banance_key() const;
  inline void clear_load_banance_key();
  static const int kLoadBananceKeyFieldNumber = 5;
  inline ::google::protobuf::uint64 load_banance_key() const;
  inline void set_load_banance_key(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.RouteHead)
 private:
  inline void set_has_src_app_id();
  inline void clear_has_src_app_id();
  inline void set_has_src_route_key();
  inline void clear_has_src_route_key();
  inline void set_has_dst_app_id();
  inline void clear_has_dst_app_id();
  inline void set_has_dst_route_key();
  inline void clear_has_dst_route_key();
  inline void set_has_load_banance_key();
  inline void clear_has_load_banance_key();

  ::google::protobuf::uint64 src_route_key_;
  ::google::protobuf::uint32 src_app_id_;
  ::google::protobuf::uint32 dst_app_id_;
  ::google::protobuf::uint64 dst_route_key_;
  ::google::protobuf::uint64 load_banance_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MsgBase_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MsgBase_2eproto();
  #endif
  friend void protobuf_AssignDesc_MsgBase_2eproto();
  friend void protobuf_ShutdownFile_MsgBase_2eproto();

  void InitAsDefaultInstance();
  static RouteHead* default_instance_;
};
// -------------------------------------------------------------------

class NullMsg : public ::google::protobuf::MessageLite {
 public:
  NullMsg();
  virtual ~NullMsg();

  NullMsg(const NullMsg& from);

  inline NullMsg& operator=(const NullMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const NullMsg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NullMsg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NullMsg* other);

  // implements Message ----------------------------------------------

  NullMsg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NullMsg& from);
  void MergeFrom(const NullMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.MsgHead Msg_Head = 1;
  inline bool has_msg_head() const;
  inline void clear_msg_head();
  static const int kMsgHeadFieldNumber = 1;
  inline const ::vmsg::MsgHead& msg_head() const;
  inline ::vmsg::MsgHead* mutable_msg_head();
  inline ::vmsg::MsgHead* release_msg_head();
  inline void set_allocated_msg_head(::vmsg::MsgHead* msg_head);

  // @@protoc_insertion_point(class_scope:vmsg.NullMsg)
 private:
  inline void set_has_msg_head();
  inline void clear_has_msg_head();

  ::vmsg::MsgHead* msg_head_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_MsgBase_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_MsgBase_2eproto();
  #endif
  friend void protobuf_AssignDesc_MsgBase_2eproto();
  friend void protobuf_ShutdownFile_MsgBase_2eproto();

  void InitAsDefaultInstance();
  static NullMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// QQAuthInfo

// required string openid = 1;
inline bool QQAuthInfo::has_openid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QQAuthInfo::set_has_openid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QQAuthInfo::clear_has_openid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QQAuthInfo::clear_openid() {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& QQAuthInfo::openid() const {
  return *openid_;
}
inline void QQAuthInfo::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void QQAuthInfo::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void QQAuthInfo::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QQAuthInfo::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  return openid_;
}
inline ::std::string* QQAuthInfo::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QQAuthInfo::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string openkey = 2;
inline bool QQAuthInfo::has_openkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QQAuthInfo::set_has_openkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QQAuthInfo::clear_has_openkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QQAuthInfo::clear_openkey() {
  if (openkey_ != &::google::protobuf::internal::kEmptyString) {
    openkey_->clear();
  }
  clear_has_openkey();
}
inline const ::std::string& QQAuthInfo::openkey() const {
  return *openkey_;
}
inline void QQAuthInfo::set_openkey(const ::std::string& value) {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  openkey_->assign(value);
}
inline void QQAuthInfo::set_openkey(const char* value) {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  openkey_->assign(value);
}
inline void QQAuthInfo::set_openkey(const char* value, size_t size) {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  openkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QQAuthInfo::mutable_openkey() {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  return openkey_;
}
inline ::std::string* QQAuthInfo::release_openkey() {
  clear_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openkey_;
    openkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QQAuthInfo::set_allocated_openkey(::std::string* openkey) {
  if (openkey_ != &::google::protobuf::internal::kEmptyString) {
    delete openkey_;
  }
  if (openkey) {
    set_has_openkey();
    openkey_ = openkey;
  } else {
    clear_has_openkey();
    openkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 appid = 3;
inline bool QQAuthInfo::has_appid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QQAuthInfo::set_has_appid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QQAuthInfo::clear_has_appid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QQAuthInfo::clear_appid() {
  appid_ = 0u;
  clear_has_appid();
}
inline ::google::protobuf::uint32 QQAuthInfo::appid() const {
  return appid_;
}
inline void QQAuthInfo::set_appid(::google::protobuf::uint32 value) {
  set_has_appid();
  appid_ = value;
}

// required string pf = 5;
inline bool QQAuthInfo::has_pf() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QQAuthInfo::set_has_pf() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QQAuthInfo::clear_has_pf() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QQAuthInfo::clear_pf() {
  if (pf_ != &::google::protobuf::internal::kEmptyString) {
    pf_->clear();
  }
  clear_has_pf();
}
inline const ::std::string& QQAuthInfo::pf() const {
  return *pf_;
}
inline void QQAuthInfo::set_pf(const ::std::string& value) {
  set_has_pf();
  if (pf_ == &::google::protobuf::internal::kEmptyString) {
    pf_ = new ::std::string;
  }
  pf_->assign(value);
}
inline void QQAuthInfo::set_pf(const char* value) {
  set_has_pf();
  if (pf_ == &::google::protobuf::internal::kEmptyString) {
    pf_ = new ::std::string;
  }
  pf_->assign(value);
}
inline void QQAuthInfo::set_pf(const char* value, size_t size) {
  set_has_pf();
  if (pf_ == &::google::protobuf::internal::kEmptyString) {
    pf_ = new ::std::string;
  }
  pf_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QQAuthInfo::mutable_pf() {
  set_has_pf();
  if (pf_ == &::google::protobuf::internal::kEmptyString) {
    pf_ = new ::std::string;
  }
  return pf_;
}
inline ::std::string* QQAuthInfo::release_pf() {
  clear_has_pf();
  if (pf_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pf_;
    pf_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QQAuthInfo::set_allocated_pf(::std::string* pf) {
  if (pf_ != &::google::protobuf::internal::kEmptyString) {
    delete pf_;
  }
  if (pf) {
    set_has_pf();
    pf_ = pf;
  } else {
    clear_has_pf();
    pf_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OAuthInfo

// required string Uid = 1;
inline bool OAuthInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OAuthInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OAuthInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OAuthInfo::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& OAuthInfo::uid() const {
  return *uid_;
}
inline void OAuthInfo::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void OAuthInfo::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void OAuthInfo::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OAuthInfo::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* OAuthInfo::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OAuthInfo::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string OpenKey = 2;
inline bool OAuthInfo::has_openkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OAuthInfo::set_has_openkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OAuthInfo::clear_has_openkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OAuthInfo::clear_openkey() {
  if (openkey_ != &::google::protobuf::internal::kEmptyString) {
    openkey_->clear();
  }
  clear_has_openkey();
}
inline const ::std::string& OAuthInfo::openkey() const {
  return *openkey_;
}
inline void OAuthInfo::set_openkey(const ::std::string& value) {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  openkey_->assign(value);
}
inline void OAuthInfo::set_openkey(const char* value) {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  openkey_->assign(value);
}
inline void OAuthInfo::set_openkey(const char* value, size_t size) {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  openkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OAuthInfo::mutable_openkey() {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  return openkey_;
}
inline ::std::string* OAuthInfo::release_openkey() {
  clear_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openkey_;
    openkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OAuthInfo::set_allocated_openkey(::std::string* openkey) {
  if (openkey_ != &::google::protobuf::internal::kEmptyString) {
    delete openkey_;
  }
  if (openkey) {
    set_has_openkey();
    openkey_ = openkey;
  } else {
    clear_has_openkey();
    openkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SinaAutoInfo

// required uint64 Uid = 1;
inline bool SinaAutoInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SinaAutoInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SinaAutoInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SinaAutoInfo::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 SinaAutoInfo::uid() const {
  return uid_;
}
inline void SinaAutoInfo::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// required string SessionKey = 2;
inline bool SinaAutoInfo::has_sessionkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SinaAutoInfo::set_has_sessionkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SinaAutoInfo::clear_has_sessionkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SinaAutoInfo::clear_sessionkey() {
  if (sessionkey_ != &::google::protobuf::internal::kEmptyString) {
    sessionkey_->clear();
  }
  clear_has_sessionkey();
}
inline const ::std::string& SinaAutoInfo::sessionkey() const {
  return *sessionkey_;
}
inline void SinaAutoInfo::set_sessionkey(const ::std::string& value) {
  set_has_sessionkey();
  if (sessionkey_ == &::google::protobuf::internal::kEmptyString) {
    sessionkey_ = new ::std::string;
  }
  sessionkey_->assign(value);
}
inline void SinaAutoInfo::set_sessionkey(const char* value) {
  set_has_sessionkey();
  if (sessionkey_ == &::google::protobuf::internal::kEmptyString) {
    sessionkey_ = new ::std::string;
  }
  sessionkey_->assign(value);
}
inline void SinaAutoInfo::set_sessionkey(const char* value, size_t size) {
  set_has_sessionkey();
  if (sessionkey_ == &::google::protobuf::internal::kEmptyString) {
    sessionkey_ = new ::std::string;
  }
  sessionkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SinaAutoInfo::mutable_sessionkey() {
  set_has_sessionkey();
  if (sessionkey_ == &::google::protobuf::internal::kEmptyString) {
    sessionkey_ = new ::std::string;
  }
  return sessionkey_;
}
inline ::std::string* SinaAutoInfo::release_sessionkey() {
  clear_has_sessionkey();
  if (sessionkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sessionkey_;
    sessionkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SinaAutoInfo::set_allocated_sessionkey(::std::string* sessionkey) {
  if (sessionkey_ != &::google::protobuf::internal::kEmptyString) {
    delete sessionkey_;
  }
  if (sessionkey) {
    set_has_sessionkey();
    sessionkey_ = sessionkey;
  } else {
    clear_has_sessionkey();
    sessionkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 CreateTime = 3;
inline bool SinaAutoInfo::has_createtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SinaAutoInfo::set_has_createtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SinaAutoInfo::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SinaAutoInfo::clear_createtime() {
  createtime_ = GOOGLE_ULONGLONG(0);
  clear_has_createtime();
}
inline ::google::protobuf::uint64 SinaAutoInfo::createtime() const {
  return createtime_;
}
inline void SinaAutoInfo::set_createtime(::google::protobuf::uint64 value) {
  set_has_createtime();
  createtime_ = value;
}

// required uint64 ExpireTime = 4;
inline bool SinaAutoInfo::has_expiretime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SinaAutoInfo::set_has_expiretime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SinaAutoInfo::clear_has_expiretime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SinaAutoInfo::clear_expiretime() {
  expiretime_ = GOOGLE_ULONGLONG(0);
  clear_has_expiretime();
}
inline ::google::protobuf::uint64 SinaAutoInfo::expiretime() const {
  return expiretime_;
}
inline void SinaAutoInfo::set_expiretime(::google::protobuf::uint64 value) {
  set_has_expiretime();
  expiretime_ = value;
}

// required string Signature = 5;
inline bool SinaAutoInfo::has_signature() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SinaAutoInfo::set_has_signature() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SinaAutoInfo::clear_has_signature() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SinaAutoInfo::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& SinaAutoInfo::signature() const {
  return *signature_;
}
inline void SinaAutoInfo::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SinaAutoInfo::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SinaAutoInfo::set_signature(const char* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SinaAutoInfo::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* SinaAutoInfo::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SinaAutoInfo::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// QihuAutoInfo

// required uint64 Uid = 1;
inline bool QihuAutoInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QihuAutoInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QihuAutoInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QihuAutoInfo::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 QihuAutoInfo::uid() const {
  return uid_;
}
inline void QihuAutoInfo::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// required uint32 Time = 2;
inline bool QihuAutoInfo::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QihuAutoInfo::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QihuAutoInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QihuAutoInfo::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 QihuAutoInfo::time() const {
  return time_;
}
inline void QihuAutoInfo::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// required string SeverID = 3;
inline bool QihuAutoInfo::has_severid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QihuAutoInfo::set_has_severid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QihuAutoInfo::clear_has_severid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QihuAutoInfo::clear_severid() {
  if (severid_ != &::google::protobuf::internal::kEmptyString) {
    severid_->clear();
  }
  clear_has_severid();
}
inline const ::std::string& QihuAutoInfo::severid() const {
  return *severid_;
}
inline void QihuAutoInfo::set_severid(const ::std::string& value) {
  set_has_severid();
  if (severid_ == &::google::protobuf::internal::kEmptyString) {
    severid_ = new ::std::string;
  }
  severid_->assign(value);
}
inline void QihuAutoInfo::set_severid(const char* value) {
  set_has_severid();
  if (severid_ == &::google::protobuf::internal::kEmptyString) {
    severid_ = new ::std::string;
  }
  severid_->assign(value);
}
inline void QihuAutoInfo::set_severid(const char* value, size_t size) {
  set_has_severid();
  if (severid_ == &::google::protobuf::internal::kEmptyString) {
    severid_ = new ::std::string;
  }
  severid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QihuAutoInfo::mutable_severid() {
  set_has_severid();
  if (severid_ == &::google::protobuf::internal::kEmptyString) {
    severid_ = new ::std::string;
  }
  return severid_;
}
inline ::std::string* QihuAutoInfo::release_severid() {
  clear_has_severid();
  if (severid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = severid_;
    severid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QihuAutoInfo::set_allocated_severid(::std::string* severid) {
  if (severid_ != &::google::protobuf::internal::kEmptyString) {
    delete severid_;
  }
  if (severid) {
    set_has_severid();
    severid_ = severid;
  } else {
    clear_has_severid();
    severid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Signature = 4;
inline bool QihuAutoInfo::has_signature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QihuAutoInfo::set_has_signature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QihuAutoInfo::clear_has_signature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QihuAutoInfo::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& QihuAutoInfo::signature() const {
  return *signature_;
}
inline void QihuAutoInfo::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void QihuAutoInfo::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void QihuAutoInfo::set_signature(const char* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QihuAutoInfo::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* QihuAutoInfo::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QihuAutoInfo::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AuthInfo

// required string openid = 1;
inline bool AuthInfo::has_openid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthInfo::set_has_openid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthInfo::clear_has_openid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthInfo::clear_openid() {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& AuthInfo::openid() const {
  return *openid_;
}
inline void AuthInfo::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void AuthInfo::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void AuthInfo::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthInfo::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  return openid_;
}
inline ::std::string* AuthInfo::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuthInfo::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string openkey = 2;
inline bool AuthInfo::has_openkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthInfo::set_has_openkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthInfo::clear_has_openkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthInfo::clear_openkey() {
  if (openkey_ != &::google::protobuf::internal::kEmptyString) {
    openkey_->clear();
  }
  clear_has_openkey();
}
inline const ::std::string& AuthInfo::openkey() const {
  return *openkey_;
}
inline void AuthInfo::set_openkey(const ::std::string& value) {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  openkey_->assign(value);
}
inline void AuthInfo::set_openkey(const char* value) {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  openkey_->assign(value);
}
inline void AuthInfo::set_openkey(const char* value, size_t size) {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  openkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthInfo::mutable_openkey() {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  return openkey_;
}
inline ::std::string* AuthInfo::release_openkey() {
  clear_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openkey_;
    openkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuthInfo::set_allocated_openkey(::std::string* openkey) {
  if (openkey_ != &::google::protobuf::internal::kEmptyString) {
    delete openkey_;
  }
  if (openkey) {
    set_has_openkey();
    openkey_ = openkey;
  } else {
    clear_has_openkey();
    openkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string platform = 3;
inline bool AuthInfo::has_platform() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuthInfo::set_has_platform() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuthInfo::clear_has_platform() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuthInfo::clear_platform() {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    platform_->clear();
  }
  clear_has_platform();
}
inline const ::std::string& AuthInfo::platform() const {
  return *platform_;
}
inline void AuthInfo::set_platform(const ::std::string& value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void AuthInfo::set_platform(const char* value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void AuthInfo::set_platform(const char* value, size_t size) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthInfo::mutable_platform() {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  return platform_;
}
inline ::std::string* AuthInfo::release_platform() {
  clear_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platform_;
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuthInfo::set_allocated_platform(::std::string* platform) {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    delete platform_;
  }
  if (platform) {
    set_has_platform();
    platform_ = platform;
  } else {
    clear_has_platform();
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSPlayerLoginRqst

// required string loginInfo = 1;
inline bool CSPlayerLoginRqst::has_logininfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerLoginRqst::set_has_logininfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerLoginRqst::clear_has_logininfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerLoginRqst::clear_logininfo() {
  if (logininfo_ != &::google::protobuf::internal::kEmptyString) {
    logininfo_->clear();
  }
  clear_has_logininfo();
}
inline const ::std::string& CSPlayerLoginRqst::logininfo() const {
  return *logininfo_;
}
inline void CSPlayerLoginRqst::set_logininfo(const ::std::string& value) {
  set_has_logininfo();
  if (logininfo_ == &::google::protobuf::internal::kEmptyString) {
    logininfo_ = new ::std::string;
  }
  logininfo_->assign(value);
}
inline void CSPlayerLoginRqst::set_logininfo(const char* value) {
  set_has_logininfo();
  if (logininfo_ == &::google::protobuf::internal::kEmptyString) {
    logininfo_ = new ::std::string;
  }
  logininfo_->assign(value);
}
inline void CSPlayerLoginRqst::set_logininfo(const char* value, size_t size) {
  set_has_logininfo();
  if (logininfo_ == &::google::protobuf::internal::kEmptyString) {
    logininfo_ = new ::std::string;
  }
  logininfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSPlayerLoginRqst::mutable_logininfo() {
  set_has_logininfo();
  if (logininfo_ == &::google::protobuf::internal::kEmptyString) {
    logininfo_ = new ::std::string;
  }
  return logininfo_;
}
inline ::std::string* CSPlayerLoginRqst::release_logininfo() {
  clear_has_logininfo();
  if (logininfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = logininfo_;
    logininfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSPlayerLoginRqst::set_allocated_logininfo(::std::string* logininfo) {
  if (logininfo_ != &::google::protobuf::internal::kEmptyString) {
    delete logininfo_;
  }
  if (logininfo) {
    set_has_logininfo();
    logininfo_ = logininfo;
  } else {
    clear_has_logininfo();
    logininfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 ZoneID = 2;
inline bool CSPlayerLoginRqst::has_zoneid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerLoginRqst::set_has_zoneid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerLoginRqst::clear_has_zoneid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerLoginRqst::clear_zoneid() {
  zoneid_ = 0u;
  clear_has_zoneid();
}
inline ::google::protobuf::uint32 CSPlayerLoginRqst::zoneid() const {
  return zoneid_;
}
inline void CSPlayerLoginRqst::set_zoneid(::google::protobuf::uint32 value) {
  set_has_zoneid();
  zoneid_ = value;
}

// optional .vmsg.AuthInfo AuthInfo = 3;
inline bool CSPlayerLoginRqst::has_authinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPlayerLoginRqst::set_has_authinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPlayerLoginRqst::clear_has_authinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPlayerLoginRqst::clear_authinfo() {
  if (authinfo_ != NULL) authinfo_->::vmsg::AuthInfo::Clear();
  clear_has_authinfo();
}
inline const ::vmsg::AuthInfo& CSPlayerLoginRqst::authinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return authinfo_ != NULL ? *authinfo_ : *default_instance().authinfo_;
#else
  return authinfo_ != NULL ? *authinfo_ : *default_instance_->authinfo_;
#endif
}
inline ::vmsg::AuthInfo* CSPlayerLoginRqst::mutable_authinfo() {
  set_has_authinfo();
  if (authinfo_ == NULL) authinfo_ = new ::vmsg::AuthInfo;
  return authinfo_;
}
inline ::vmsg::AuthInfo* CSPlayerLoginRqst::release_authinfo() {
  clear_has_authinfo();
  ::vmsg::AuthInfo* temp = authinfo_;
  authinfo_ = NULL;
  return temp;
}
inline void CSPlayerLoginRqst::set_allocated_authinfo(::vmsg::AuthInfo* authinfo) {
  delete authinfo_;
  authinfo_ = authinfo;
  if (authinfo) {
    set_has_authinfo();
  } else {
    clear_has_authinfo();
  }
}

// optional uint32 GuestLogin = 4;
inline bool CSPlayerLoginRqst::has_guestlogin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPlayerLoginRqst::set_has_guestlogin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPlayerLoginRqst::clear_has_guestlogin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPlayerLoginRqst::clear_guestlogin() {
  guestlogin_ = 0u;
  clear_has_guestlogin();
}
inline ::google::protobuf::uint32 CSPlayerLoginRqst::guestlogin() const {
  return guestlogin_;
}
inline void CSPlayerLoginRqst::set_guestlogin(::google::protobuf::uint32 value) {
  set_has_guestlogin();
  guestlogin_ = value;
}

// optional string AppPlatform = 5;
inline bool CSPlayerLoginRqst::has_appplatform() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPlayerLoginRqst::set_has_appplatform() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPlayerLoginRqst::clear_has_appplatform() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPlayerLoginRqst::clear_appplatform() {
  if (appplatform_ != &::google::protobuf::internal::kEmptyString) {
    appplatform_->clear();
  }
  clear_has_appplatform();
}
inline const ::std::string& CSPlayerLoginRqst::appplatform() const {
  return *appplatform_;
}
inline void CSPlayerLoginRqst::set_appplatform(const ::std::string& value) {
  set_has_appplatform();
  if (appplatform_ == &::google::protobuf::internal::kEmptyString) {
    appplatform_ = new ::std::string;
  }
  appplatform_->assign(value);
}
inline void CSPlayerLoginRqst::set_appplatform(const char* value) {
  set_has_appplatform();
  if (appplatform_ == &::google::protobuf::internal::kEmptyString) {
    appplatform_ = new ::std::string;
  }
  appplatform_->assign(value);
}
inline void CSPlayerLoginRqst::set_appplatform(const char* value, size_t size) {
  set_has_appplatform();
  if (appplatform_ == &::google::protobuf::internal::kEmptyString) {
    appplatform_ = new ::std::string;
  }
  appplatform_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSPlayerLoginRqst::mutable_appplatform() {
  set_has_appplatform();
  if (appplatform_ == &::google::protobuf::internal::kEmptyString) {
    appplatform_ = new ::std::string;
  }
  return appplatform_;
}
inline ::std::string* CSPlayerLoginRqst::release_appplatform() {
  clear_has_appplatform();
  if (appplatform_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appplatform_;
    appplatform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSPlayerLoginRqst::set_allocated_appplatform(::std::string* appplatform) {
  if (appplatform_ != &::google::protobuf::internal::kEmptyString) {
    delete appplatform_;
  }
  if (appplatform) {
    set_has_appplatform();
    appplatform_ = appplatform;
  } else {
    clear_has_appplatform();
    appplatform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 Sign = 6;
inline bool CSPlayerLoginRqst::has_sign() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSPlayerLoginRqst::set_has_sign() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSPlayerLoginRqst::clear_has_sign() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSPlayerLoginRqst::clear_sign() {
  sign_ = GOOGLE_ULONGLONG(0);
  clear_has_sign();
}
inline ::google::protobuf::uint64 CSPlayerLoginRqst::sign() const {
  return sign_;
}
inline void CSPlayerLoginRqst::set_sign(::google::protobuf::uint64 value) {
  set_has_sign();
  sign_ = value;
}

// required uint32 Time = 7;
inline bool CSPlayerLoginRqst::has_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSPlayerLoginRqst::set_has_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSPlayerLoginRqst::clear_has_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSPlayerLoginRqst::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 CSPlayerLoginRqst::time() const {
  return time_;
}
inline void CSPlayerLoginRqst::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// CSPlayerLoginRsp

// required string loginInfo = 1;
inline bool CSPlayerLoginRsp::has_logininfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerLoginRsp::set_has_logininfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerLoginRsp::clear_has_logininfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerLoginRsp::clear_logininfo() {
  if (logininfo_ != &::google::protobuf::internal::kEmptyString) {
    logininfo_->clear();
  }
  clear_has_logininfo();
}
inline const ::std::string& CSPlayerLoginRsp::logininfo() const {
  return *logininfo_;
}
inline void CSPlayerLoginRsp::set_logininfo(const ::std::string& value) {
  set_has_logininfo();
  if (logininfo_ == &::google::protobuf::internal::kEmptyString) {
    logininfo_ = new ::std::string;
  }
  logininfo_->assign(value);
}
inline void CSPlayerLoginRsp::set_logininfo(const char* value) {
  set_has_logininfo();
  if (logininfo_ == &::google::protobuf::internal::kEmptyString) {
    logininfo_ = new ::std::string;
  }
  logininfo_->assign(value);
}
inline void CSPlayerLoginRsp::set_logininfo(const char* value, size_t size) {
  set_has_logininfo();
  if (logininfo_ == &::google::protobuf::internal::kEmptyString) {
    logininfo_ = new ::std::string;
  }
  logininfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSPlayerLoginRsp::mutable_logininfo() {
  set_has_logininfo();
  if (logininfo_ == &::google::protobuf::internal::kEmptyString) {
    logininfo_ = new ::std::string;
  }
  return logininfo_;
}
inline ::std::string* CSPlayerLoginRsp::release_logininfo() {
  clear_has_logininfo();
  if (logininfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = logininfo_;
    logininfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSPlayerLoginRsp::set_allocated_logininfo(::std::string* logininfo) {
  if (logininfo_ != &::google::protobuf::internal::kEmptyString) {
    delete logininfo_;
  }
  if (logininfo) {
    set_has_logininfo();
    logininfo_ = logininfo;
  } else {
    clear_has_logininfo();
    logininfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MsgHead

// required uint32 Msg_ID = 1;
inline bool MsgHead::has_msg_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgHead::set_has_msg_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgHead::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgHead::clear_msg_id() {
  msg_id_ = 0u;
  clear_has_msg_id();
}
inline ::google::protobuf::uint32 MsgHead::msg_id() const {
  return msg_id_;
}
inline void MsgHead::set_msg_id(::google::protobuf::uint32 value) {
  set_has_msg_id();
  msg_id_ = value;
}

// required uint64 Uid = 2;
inline bool MsgHead::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgHead::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgHead::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgHead::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 MsgHead::uid() const {
  return uid_;
}
inline void MsgHead::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// required uint64 Act = 3;
inline bool MsgHead::has_act() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgHead::set_has_act() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgHead::clear_has_act() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgHead::clear_act() {
  act_ = GOOGLE_ULONGLONG(0);
  clear_has_act();
}
inline ::google::protobuf::uint64 MsgHead::act() const {
  return act_;
}
inline void MsgHead::set_act(::google::protobuf::uint64 value) {
  set_has_act();
  act_ = value;
}

// required uint32 Seq = 4;
inline bool MsgHead::has_seq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgHead::set_has_seq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgHead::clear_has_seq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgHead::clear_seq() {
  seq_ = 0u;
  clear_has_seq();
}
inline ::google::protobuf::uint32 MsgHead::seq() const {
  return seq_;
}
inline void MsgHead::set_seq(::google::protobuf::uint32 value) {
  set_has_seq();
  seq_ = value;
}

// required .vmsg.MsgHead.MSG_TYPE Msg_Type = 5;
inline bool MsgHead::has_msg_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgHead::set_has_msg_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgHead::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgHead::clear_msg_type() {
  msg_type_ = 1;
  clear_has_msg_type();
}
inline ::vmsg::MsgHead_MSG_TYPE MsgHead::msg_type() const {
  return static_cast< ::vmsg::MsgHead_MSG_TYPE >(msg_type_);
}
inline void MsgHead::set_msg_type(::vmsg::MsgHead_MSG_TYPE value) {
  assert(::vmsg::MsgHead_MSG_TYPE_IsValid(value));
  set_has_msg_type();
  msg_type_ = value;
}

// optional uint32 App_ID = 6 [default = 0];
inline bool MsgHead::has_app_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgHead::set_has_app_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgHead::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgHead::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 MsgHead::app_id() const {
  return app_id_;
}
inline void MsgHead::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
}

// optional uint32 RouteID = 7;
inline bool MsgHead::has_routeid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MsgHead::set_has_routeid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MsgHead::clear_has_routeid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MsgHead::clear_routeid() {
  routeid_ = 0u;
  clear_has_routeid();
}
inline ::google::protobuf::uint32 MsgHead::routeid() const {
  return routeid_;
}
inline void MsgHead::set_routeid(::google::protobuf::uint32 value) {
  set_has_routeid();
  routeid_ = value;
}

// optional .vmsg.CSPlayerLoginRqst LoginRqst = 8;
inline bool MsgHead::has_loginrqst() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MsgHead::set_has_loginrqst() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MsgHead::clear_has_loginrqst() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MsgHead::clear_loginrqst() {
  if (loginrqst_ != NULL) loginrqst_->::vmsg::CSPlayerLoginRqst::Clear();
  clear_has_loginrqst();
}
inline const ::vmsg::CSPlayerLoginRqst& MsgHead::loginrqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return loginrqst_ != NULL ? *loginrqst_ : *default_instance().loginrqst_;
#else
  return loginrqst_ != NULL ? *loginrqst_ : *default_instance_->loginrqst_;
#endif
}
inline ::vmsg::CSPlayerLoginRqst* MsgHead::mutable_loginrqst() {
  set_has_loginrqst();
  if (loginrqst_ == NULL) loginrqst_ = new ::vmsg::CSPlayerLoginRqst;
  return loginrqst_;
}
inline ::vmsg::CSPlayerLoginRqst* MsgHead::release_loginrqst() {
  clear_has_loginrqst();
  ::vmsg::CSPlayerLoginRqst* temp = loginrqst_;
  loginrqst_ = NULL;
  return temp;
}
inline void MsgHead::set_allocated_loginrqst(::vmsg::CSPlayerLoginRqst* loginrqst) {
  delete loginrqst_;
  loginrqst_ = loginrqst;
  if (loginrqst) {
    set_has_loginrqst();
  } else {
    clear_has_loginrqst();
  }
}

// optional .vmsg.CSPlayerLoginRsp LoginRsp = 9;
inline bool MsgHead::has_loginrsp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MsgHead::set_has_loginrsp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MsgHead::clear_has_loginrsp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MsgHead::clear_loginrsp() {
  if (loginrsp_ != NULL) loginrsp_->::vmsg::CSPlayerLoginRsp::Clear();
  clear_has_loginrsp();
}
inline const ::vmsg::CSPlayerLoginRsp& MsgHead::loginrsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return loginrsp_ != NULL ? *loginrsp_ : *default_instance().loginrsp_;
#else
  return loginrsp_ != NULL ? *loginrsp_ : *default_instance_->loginrsp_;
#endif
}
inline ::vmsg::CSPlayerLoginRsp* MsgHead::mutable_loginrsp() {
  set_has_loginrsp();
  if (loginrsp_ == NULL) loginrsp_ = new ::vmsg::CSPlayerLoginRsp;
  return loginrsp_;
}
inline ::vmsg::CSPlayerLoginRsp* MsgHead::release_loginrsp() {
  clear_has_loginrsp();
  ::vmsg::CSPlayerLoginRsp* temp = loginrsp_;
  loginrsp_ = NULL;
  return temp;
}
inline void MsgHead::set_allocated_loginrsp(::vmsg::CSPlayerLoginRsp* loginrsp) {
  delete loginrsp_;
  loginrsp_ = loginrsp;
  if (loginrsp) {
    set_has_loginrsp();
  } else {
    clear_has_loginrsp();
  }
}

// optional uint64 QuickLoginKey = 10;
inline bool MsgHead::has_quickloginkey() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MsgHead::set_has_quickloginkey() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MsgHead::clear_has_quickloginkey() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MsgHead::clear_quickloginkey() {
  quickloginkey_ = GOOGLE_ULONGLONG(0);
  clear_has_quickloginkey();
}
inline ::google::protobuf::uint64 MsgHead::quickloginkey() const {
  return quickloginkey_;
}
inline void MsgHead::set_quickloginkey(::google::protobuf::uint64 value) {
  set_has_quickloginkey();
  quickloginkey_ = value;
}

// -------------------------------------------------------------------

// PBFieldDescriptor

// required string Field = 1;
inline bool PBFieldDescriptor::has_field() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PBFieldDescriptor::set_has_field() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PBFieldDescriptor::clear_has_field() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PBFieldDescriptor::clear_field() {
  if (field_ != &::google::protobuf::internal::kEmptyString) {
    field_->clear();
  }
  clear_has_field();
}
inline const ::std::string& PBFieldDescriptor::field() const {
  return *field_;
}
inline void PBFieldDescriptor::set_field(const ::std::string& value) {
  set_has_field();
  if (field_ == &::google::protobuf::internal::kEmptyString) {
    field_ = new ::std::string;
  }
  field_->assign(value);
}
inline void PBFieldDescriptor::set_field(const char* value) {
  set_has_field();
  if (field_ == &::google::protobuf::internal::kEmptyString) {
    field_ = new ::std::string;
  }
  field_->assign(value);
}
inline void PBFieldDescriptor::set_field(const char* value, size_t size) {
  set_has_field();
  if (field_ == &::google::protobuf::internal::kEmptyString) {
    field_ = new ::std::string;
  }
  field_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PBFieldDescriptor::mutable_field() {
  set_has_field();
  if (field_ == &::google::protobuf::internal::kEmptyString) {
    field_ = new ::std::string;
  }
  return field_;
}
inline ::std::string* PBFieldDescriptor::release_field() {
  clear_has_field();
  if (field_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = field_;
    field_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PBFieldDescriptor::set_allocated_field(::std::string* field) {
  if (field_ != &::google::protobuf::internal::kEmptyString) {
    delete field_;
  }
  if (field) {
    set_has_field();
    field_ = field;
  } else {
    clear_has_field();
    field_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 Tag = 2;
inline bool PBFieldDescriptor::has_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PBFieldDescriptor::set_has_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PBFieldDescriptor::clear_has_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PBFieldDescriptor::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 PBFieldDescriptor::tag() const {
  return tag_;
}
inline void PBFieldDescriptor::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
}

// required int32 Type = 3;
inline bool PBFieldDescriptor::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PBFieldDescriptor::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PBFieldDescriptor::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PBFieldDescriptor::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 PBFieldDescriptor::type() const {
  return type_;
}
inline void PBFieldDescriptor::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// PBMsgDescriptor

// repeated .vmsg.PBFieldDescriptor Fields = 1;
inline int PBMsgDescriptor::fields_size() const {
  return fields_.size();
}
inline void PBMsgDescriptor::clear_fields() {
  fields_.Clear();
}
inline const ::vmsg::PBFieldDescriptor& PBMsgDescriptor::fields(int index) const {
  return fields_.Get(index);
}
inline ::vmsg::PBFieldDescriptor* PBMsgDescriptor::mutable_fields(int index) {
  return fields_.Mutable(index);
}
inline ::vmsg::PBFieldDescriptor* PBMsgDescriptor::add_fields() {
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::PBFieldDescriptor >&
PBMsgDescriptor::fields() const {
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::PBFieldDescriptor >*
PBMsgDescriptor::mutable_fields() {
  return &fields_;
}

// -------------------------------------------------------------------

// RouteHead

// required uint32 src_app_id = 1;
inline bool RouteHead::has_src_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RouteHead::set_has_src_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RouteHead::clear_has_src_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RouteHead::clear_src_app_id() {
  src_app_id_ = 0u;
  clear_has_src_app_id();
}
inline ::google::protobuf::uint32 RouteHead::src_app_id() const {
  return src_app_id_;
}
inline void RouteHead::set_src_app_id(::google::protobuf::uint32 value) {
  set_has_src_app_id();
  src_app_id_ = value;
}

// required uint64 src_route_key = 2;
inline bool RouteHead::has_src_route_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RouteHead::set_has_src_route_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RouteHead::clear_has_src_route_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RouteHead::clear_src_route_key() {
  src_route_key_ = GOOGLE_ULONGLONG(0);
  clear_has_src_route_key();
}
inline ::google::protobuf::uint64 RouteHead::src_route_key() const {
  return src_route_key_;
}
inline void RouteHead::set_src_route_key(::google::protobuf::uint64 value) {
  set_has_src_route_key();
  src_route_key_ = value;
}

// required uint32 dst_app_id = 3;
inline bool RouteHead::has_dst_app_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RouteHead::set_has_dst_app_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RouteHead::clear_has_dst_app_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RouteHead::clear_dst_app_id() {
  dst_app_id_ = 0u;
  clear_has_dst_app_id();
}
inline ::google::protobuf::uint32 RouteHead::dst_app_id() const {
  return dst_app_id_;
}
inline void RouteHead::set_dst_app_id(::google::protobuf::uint32 value) {
  set_has_dst_app_id();
  dst_app_id_ = value;
}

// required uint64 dst_route_key = 4;
inline bool RouteHead::has_dst_route_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RouteHead::set_has_dst_route_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RouteHead::clear_has_dst_route_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RouteHead::clear_dst_route_key() {
  dst_route_key_ = GOOGLE_ULONGLONG(0);
  clear_has_dst_route_key();
}
inline ::google::protobuf::uint64 RouteHead::dst_route_key() const {
  return dst_route_key_;
}
inline void RouteHead::set_dst_route_key(::google::protobuf::uint64 value) {
  set_has_dst_route_key();
  dst_route_key_ = value;
}

// optional uint64 load_banance_key = 5;
inline bool RouteHead::has_load_banance_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RouteHead::set_has_load_banance_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RouteHead::clear_has_load_banance_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RouteHead::clear_load_banance_key() {
  load_banance_key_ = GOOGLE_ULONGLONG(0);
  clear_has_load_banance_key();
}
inline ::google::protobuf::uint64 RouteHead::load_banance_key() const {
  return load_banance_key_;
}
inline void RouteHead::set_load_banance_key(::google::protobuf::uint64 value) {
  set_has_load_banance_key();
  load_banance_key_ = value;
}

// -------------------------------------------------------------------

// NullMsg

// required .vmsg.MsgHead Msg_Head = 1;
inline bool NullMsg::has_msg_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NullMsg::set_has_msg_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NullMsg::clear_has_msg_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NullMsg::clear_msg_head() {
  if (msg_head_ != NULL) msg_head_->::vmsg::MsgHead::Clear();
  clear_has_msg_head();
}
inline const ::vmsg::MsgHead& NullMsg::msg_head() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return msg_head_ != NULL ? *msg_head_ : *default_instance().msg_head_;
#else
  return msg_head_ != NULL ? *msg_head_ : *default_instance_->msg_head_;
#endif
}
inline ::vmsg::MsgHead* NullMsg::mutable_msg_head() {
  set_has_msg_head();
  if (msg_head_ == NULL) msg_head_ = new ::vmsg::MsgHead;
  return msg_head_;
}
inline ::vmsg::MsgHead* NullMsg::release_msg_head() {
  clear_has_msg_head();
  ::vmsg::MsgHead* temp = msg_head_;
  msg_head_ = NULL;
  return temp;
}
inline void NullMsg::set_allocated_msg_head(::vmsg::MsgHead* msg_head) {
  delete msg_head_;
  msg_head_ = msg_head;
  if (msg_head) {
    set_has_msg_head();
  } else {
    clear_has_msg_head();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MsgBase_2eproto__INCLUDED
