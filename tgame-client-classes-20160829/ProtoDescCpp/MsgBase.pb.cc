// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MsgBase.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "MsgBase.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace vmsg {

void protobuf_ShutdownFile_MsgBase_2eproto() {
  delete QQAuthInfo::default_instance_;
  delete OAuthInfo::default_instance_;
  delete SinaAutoInfo::default_instance_;
  delete QihuAutoInfo::default_instance_;
  delete AuthInfo::default_instance_;
  delete CSPlayerLoginRqst::default_instance_;
  delete CSPlayerLoginRsp::default_instance_;
  delete MsgHead::default_instance_;
  delete PBFieldDescriptor::default_instance_;
  delete PBMsgDescriptor::default_instance_;
  delete RouteHead::default_instance_;
  delete NullMsg::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_MsgBase_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_MsgBase_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  QQAuthInfo::default_instance_ = new QQAuthInfo();
  OAuthInfo::default_instance_ = new OAuthInfo();
  SinaAutoInfo::default_instance_ = new SinaAutoInfo();
  QihuAutoInfo::default_instance_ = new QihuAutoInfo();
  AuthInfo::default_instance_ = new AuthInfo();
  CSPlayerLoginRqst::default_instance_ = new CSPlayerLoginRqst();
  CSPlayerLoginRsp::default_instance_ = new CSPlayerLoginRsp();
  MsgHead::default_instance_ = new MsgHead();
  PBFieldDescriptor::default_instance_ = new PBFieldDescriptor();
  PBMsgDescriptor::default_instance_ = new PBMsgDescriptor();
  RouteHead::default_instance_ = new RouteHead();
  NullMsg::default_instance_ = new NullMsg();
  QQAuthInfo::default_instance_->InitAsDefaultInstance();
  OAuthInfo::default_instance_->InitAsDefaultInstance();
  SinaAutoInfo::default_instance_->InitAsDefaultInstance();
  QihuAutoInfo::default_instance_->InitAsDefaultInstance();
  AuthInfo::default_instance_->InitAsDefaultInstance();
  CSPlayerLoginRqst::default_instance_->InitAsDefaultInstance();
  CSPlayerLoginRsp::default_instance_->InitAsDefaultInstance();
  MsgHead::default_instance_->InitAsDefaultInstance();
  PBFieldDescriptor::default_instance_->InitAsDefaultInstance();
  PBMsgDescriptor::default_instance_->InitAsDefaultInstance();
  RouteHead::default_instance_->InitAsDefaultInstance();
  NullMsg::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_MsgBase_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_MsgBase_2eproto_once_);
void protobuf_AddDesc_MsgBase_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_MsgBase_2eproto_once_,
                 &protobuf_AddDesc_MsgBase_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_MsgBase_2eproto {
  StaticDescriptorInitializer_MsgBase_2eproto() {
    protobuf_AddDesc_MsgBase_2eproto();
  }
} static_descriptor_initializer_MsgBase_2eproto_;
#endif
bool AuthErrorCode_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool AccountPlatform_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool LoginMsgID_IsValid(int value) {
  switch(value) {
    case 800000:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int QQAuthInfo::kOpenidFieldNumber;
const int QQAuthInfo::kOpenkeyFieldNumber;
const int QQAuthInfo::kAppidFieldNumber;
const int QQAuthInfo::kPfFieldNumber;
#endif  // !_MSC_VER

QQAuthInfo::QQAuthInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void QQAuthInfo::InitAsDefaultInstance() {
}

QQAuthInfo::QQAuthInfo(const QQAuthInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void QQAuthInfo::SharedCtor() {
  _cached_size_ = 0;
  openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  openkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  appid_ = 0u;
  pf_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QQAuthInfo::~QQAuthInfo() {
  SharedDtor();
}

void QQAuthInfo::SharedDtor() {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    delete openid_;
  }
  if (openkey_ != &::google::protobuf::internal::kEmptyString) {
    delete openkey_;
  }
  if (pf_ != &::google::protobuf::internal::kEmptyString) {
    delete pf_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void QQAuthInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const QQAuthInfo& QQAuthInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_MsgBase_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_MsgBase_2eproto();
#endif
  return *default_instance_;
}

QQAuthInfo* QQAuthInfo::default_instance_ = NULL;

QQAuthInfo* QQAuthInfo::New() const {
  return new QQAuthInfo;
}

void QQAuthInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_openid()) {
      if (openid_ != &::google::protobuf::internal::kEmptyString) {
        openid_->clear();
      }
    }
    if (has_openkey()) {
      if (openkey_ != &::google::protobuf::internal::kEmptyString) {
        openkey_->clear();
      }
    }
    appid_ = 0u;
    if (has_pf()) {
      if (pf_ != &::google::protobuf::internal::kEmptyString) {
        pf_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool QQAuthInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string openid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_openid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_openkey;
        break;
      }

      // required string openkey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_openkey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_openkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_appid;
        break;
      }

      // required uint32 appid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_appid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &appid_)));
          set_has_appid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_pf;
        break;
      }

      // required string pf = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void QQAuthInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string openid = 1;
  if (has_openid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->openid(), output);
  }

  // required string openkey = 2;
  if (has_openkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->openkey(), output);
  }

  // required uint32 appid = 3;
  if (has_appid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->appid(), output);
  }

  // required string pf = 5;
  if (has_pf()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->pf(), output);
  }

}

int QQAuthInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string openid = 1;
    if (has_openid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->openid());
    }

    // required string openkey = 2;
    if (has_openkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->openkey());
    }

    // required uint32 appid = 3;
    if (has_appid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->appid());
    }

    // required string pf = 5;
    if (has_pf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pf());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QQAuthInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const QQAuthInfo*>(&from));
}

void QQAuthInfo::MergeFrom(const QQAuthInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_openid()) {
      set_openid(from.openid());
    }
    if (from.has_openkey()) {
      set_openkey(from.openkey());
    }
    if (from.has_appid()) {
      set_appid(from.appid());
    }
    if (from.has_pf()) {
      set_pf(from.pf());
    }
  }
}

void QQAuthInfo::CopyFrom(const QQAuthInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QQAuthInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void QQAuthInfo::Swap(QQAuthInfo* other) {
  if (other != this) {
    std::swap(openid_, other->openid_);
    std::swap(openkey_, other->openkey_);
    std::swap(appid_, other->appid_);
    std::swap(pf_, other->pf_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string QQAuthInfo::GetTypeName() const {
  return "vmsg.QQAuthInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int OAuthInfo::kUidFieldNumber;
const int OAuthInfo::kOpenKeyFieldNumber;
#endif  // !_MSC_VER

OAuthInfo::OAuthInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void OAuthInfo::InitAsDefaultInstance() {
}

OAuthInfo::OAuthInfo(const OAuthInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void OAuthInfo::SharedCtor() {
  _cached_size_ = 0;
  uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  openkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OAuthInfo::~OAuthInfo() {
  SharedDtor();
}

void OAuthInfo::SharedDtor() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (openkey_ != &::google::protobuf::internal::kEmptyString) {
    delete openkey_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void OAuthInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OAuthInfo& OAuthInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_MsgBase_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_MsgBase_2eproto();
#endif
  return *default_instance_;
}

OAuthInfo* OAuthInfo::default_instance_ = NULL;

OAuthInfo* OAuthInfo::New() const {
  return new OAuthInfo;
}

void OAuthInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_uid()) {
      if (uid_ != &::google::protobuf::internal::kEmptyString) {
        uid_->clear();
      }
    }
    if (has_openkey()) {
      if (openkey_ != &::google::protobuf::internal::kEmptyString) {
        openkey_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool OAuthInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string Uid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_uid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_OpenKey;
        break;
      }

      // required string OpenKey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_OpenKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_openkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OAuthInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string Uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->uid(), output);
  }

  // required string OpenKey = 2;
  if (has_openkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->openkey(), output);
  }

}

int OAuthInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string Uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->uid());
    }

    // required string OpenKey = 2;
    if (has_openkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->openkey());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OAuthInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OAuthInfo*>(&from));
}

void OAuthInfo::MergeFrom(const OAuthInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_openkey()) {
      set_openkey(from.openkey());
    }
  }
}

void OAuthInfo::CopyFrom(const OAuthInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OAuthInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void OAuthInfo::Swap(OAuthInfo* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(openkey_, other->openkey_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OAuthInfo::GetTypeName() const {
  return "vmsg.OAuthInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int SinaAutoInfo::kUidFieldNumber;
const int SinaAutoInfo::kSessionKeyFieldNumber;
const int SinaAutoInfo::kCreateTimeFieldNumber;
const int SinaAutoInfo::kExpireTimeFieldNumber;
const int SinaAutoInfo::kSignatureFieldNumber;
#endif  // !_MSC_VER

SinaAutoInfo::SinaAutoInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SinaAutoInfo::InitAsDefaultInstance() {
}

SinaAutoInfo::SinaAutoInfo(const SinaAutoInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SinaAutoInfo::SharedCtor() {
  _cached_size_ = 0;
  uid_ = GOOGLE_ULONGLONG(0);
  sessionkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  createtime_ = GOOGLE_ULONGLONG(0);
  expiretime_ = GOOGLE_ULONGLONG(0);
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SinaAutoInfo::~SinaAutoInfo() {
  SharedDtor();
}

void SinaAutoInfo::SharedDtor() {
  if (sessionkey_ != &::google::protobuf::internal::kEmptyString) {
    delete sessionkey_;
  }
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SinaAutoInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SinaAutoInfo& SinaAutoInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_MsgBase_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_MsgBase_2eproto();
#endif
  return *default_instance_;
}

SinaAutoInfo* SinaAutoInfo::default_instance_ = NULL;

SinaAutoInfo* SinaAutoInfo::New() const {
  return new SinaAutoInfo;
}

void SinaAutoInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = GOOGLE_ULONGLONG(0);
    if (has_sessionkey()) {
      if (sessionkey_ != &::google::protobuf::internal::kEmptyString) {
        sessionkey_->clear();
      }
    }
    createtime_ = GOOGLE_ULONGLONG(0);
    expiretime_ = GOOGLE_ULONGLONG(0);
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::kEmptyString) {
        signature_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SinaAutoInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_SessionKey;
        break;
      }

      // required string SessionKey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_SessionKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sessionkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_CreateTime;
        break;
      }

      // required uint64 CreateTime = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_CreateTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &createtime_)));
          set_has_createtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_ExpireTime;
        break;
      }

      // required uint64 ExpireTime = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ExpireTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &expiretime_)));
          set_has_expiretime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_Signature;
        break;
      }

      // required string Signature = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_signature()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SinaAutoInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 Uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uid(), output);
  }

  // required string SessionKey = 2;
  if (has_sessionkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->sessionkey(), output);
  }

  // required uint64 CreateTime = 3;
  if (has_createtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->createtime(), output);
  }

  // required uint64 ExpireTime = 4;
  if (has_expiretime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->expiretime(), output);
  }

  // required string Signature = 5;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->signature(), output);
  }

}

int SinaAutoInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uid());
    }

    // required string SessionKey = 2;
    if (has_sessionkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sessionkey());
    }

    // required uint64 CreateTime = 3;
    if (has_createtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->createtime());
    }

    // required uint64 ExpireTime = 4;
    if (has_expiretime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->expiretime());
    }

    // required string Signature = 5;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->signature());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SinaAutoInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SinaAutoInfo*>(&from));
}

void SinaAutoInfo::MergeFrom(const SinaAutoInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_sessionkey()) {
      set_sessionkey(from.sessionkey());
    }
    if (from.has_createtime()) {
      set_createtime(from.createtime());
    }
    if (from.has_expiretime()) {
      set_expiretime(from.expiretime());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
  }
}

void SinaAutoInfo::CopyFrom(const SinaAutoInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SinaAutoInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void SinaAutoInfo::Swap(SinaAutoInfo* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(sessionkey_, other->sessionkey_);
    std::swap(createtime_, other->createtime_);
    std::swap(expiretime_, other->expiretime_);
    std::swap(signature_, other->signature_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SinaAutoInfo::GetTypeName() const {
  return "vmsg.SinaAutoInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int QihuAutoInfo::kUidFieldNumber;
const int QihuAutoInfo::kTimeFieldNumber;
const int QihuAutoInfo::kSeverIDFieldNumber;
const int QihuAutoInfo::kSignatureFieldNumber;
#endif  // !_MSC_VER

QihuAutoInfo::QihuAutoInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void QihuAutoInfo::InitAsDefaultInstance() {
}

QihuAutoInfo::QihuAutoInfo(const QihuAutoInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void QihuAutoInfo::SharedCtor() {
  _cached_size_ = 0;
  uid_ = GOOGLE_ULONGLONG(0);
  time_ = 0u;
  severid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QihuAutoInfo::~QihuAutoInfo() {
  SharedDtor();
}

void QihuAutoInfo::SharedDtor() {
  if (severid_ != &::google::protobuf::internal::kEmptyString) {
    delete severid_;
  }
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void QihuAutoInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const QihuAutoInfo& QihuAutoInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_MsgBase_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_MsgBase_2eproto();
#endif
  return *default_instance_;
}

QihuAutoInfo* QihuAutoInfo::default_instance_ = NULL;

QihuAutoInfo* QihuAutoInfo::New() const {
  return new QihuAutoInfo;
}

void QihuAutoInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    uid_ = GOOGLE_ULONGLONG(0);
    time_ = 0u;
    if (has_severid()) {
      if (severid_ != &::google::protobuf::internal::kEmptyString) {
        severid_->clear();
      }
    }
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::kEmptyString) {
        signature_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool QihuAutoInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 Uid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_Time;
        break;
      }

      // required uint32 Time = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_SeverID;
        break;
      }

      // required string SeverID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_SeverID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_severid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_Signature;
        break;
      }

      // required string Signature = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_signature()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void QihuAutoInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 Uid = 1;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->uid(), output);
  }

  // required uint32 Time = 2;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time(), output);
  }

  // required string SeverID = 3;
  if (has_severid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->severid(), output);
  }

  // required string Signature = 4;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->signature(), output);
  }

}

int QihuAutoInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 Uid = 1;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uid());
    }

    // required uint32 Time = 2;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time());
    }

    // required string SeverID = 3;
    if (has_severid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->severid());
    }

    // required string Signature = 4;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->signature());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QihuAutoInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const QihuAutoInfo*>(&from));
}

void QihuAutoInfo::MergeFrom(const QihuAutoInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_severid()) {
      set_severid(from.severid());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
  }
}

void QihuAutoInfo::CopyFrom(const QihuAutoInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QihuAutoInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void QihuAutoInfo::Swap(QihuAutoInfo* other) {
  if (other != this) {
    std::swap(uid_, other->uid_);
    std::swap(time_, other->time_);
    std::swap(severid_, other->severid_);
    std::swap(signature_, other->signature_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string QihuAutoInfo::GetTypeName() const {
  return "vmsg.QihuAutoInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int AuthInfo::kOpenidFieldNumber;
const int AuthInfo::kOpenkeyFieldNumber;
const int AuthInfo::kPlatformFieldNumber;
#endif  // !_MSC_VER

AuthInfo::AuthInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AuthInfo::InitAsDefaultInstance() {
}

AuthInfo::AuthInfo(const AuthInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AuthInfo::SharedCtor() {
  _cached_size_ = 0;
  openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  openkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AuthInfo::~AuthInfo() {
  SharedDtor();
}

void AuthInfo::SharedDtor() {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    delete openid_;
  }
  if (openkey_ != &::google::protobuf::internal::kEmptyString) {
    delete openkey_;
  }
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    delete platform_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AuthInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AuthInfo& AuthInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_MsgBase_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_MsgBase_2eproto();
#endif
  return *default_instance_;
}

AuthInfo* AuthInfo::default_instance_ = NULL;

AuthInfo* AuthInfo::New() const {
  return new AuthInfo;
}

void AuthInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_openid()) {
      if (openid_ != &::google::protobuf::internal::kEmptyString) {
        openid_->clear();
      }
    }
    if (has_openkey()) {
      if (openkey_ != &::google::protobuf::internal::kEmptyString) {
        openkey_->clear();
      }
    }
    if (has_platform()) {
      if (platform_ != &::google::protobuf::internal::kEmptyString) {
        platform_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AuthInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string openid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_openid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_openkey;
        break;
      }

      // required string openkey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_openkey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_openkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_platform;
        break;
      }

      // required string platform = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_platform:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_platform()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AuthInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string openid = 1;
  if (has_openid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->openid(), output);
  }

  // required string openkey = 2;
  if (has_openkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->openkey(), output);
  }

  // required string platform = 3;
  if (has_platform()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->platform(), output);
  }

}

int AuthInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string openid = 1;
    if (has_openid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->openid());
    }

    // required string openkey = 2;
    if (has_openkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->openkey());
    }

    // required string platform = 3;
    if (has_platform()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->platform());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AuthInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AuthInfo*>(&from));
}

void AuthInfo::MergeFrom(const AuthInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_openid()) {
      set_openid(from.openid());
    }
    if (from.has_openkey()) {
      set_openkey(from.openkey());
    }
    if (from.has_platform()) {
      set_platform(from.platform());
    }
  }
}

void AuthInfo::CopyFrom(const AuthInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void AuthInfo::Swap(AuthInfo* other) {
  if (other != this) {
    std::swap(openid_, other->openid_);
    std::swap(openkey_, other->openkey_);
    std::swap(platform_, other->platform_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AuthInfo::GetTypeName() const {
  return "vmsg.AuthInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPlayerLoginRqst::kLoginInfoFieldNumber;
const int CSPlayerLoginRqst::kZoneIDFieldNumber;
const int CSPlayerLoginRqst::kAuthInfoFieldNumber;
const int CSPlayerLoginRqst::kGuestLoginFieldNumber;
const int CSPlayerLoginRqst::kAppPlatformFieldNumber;
const int CSPlayerLoginRqst::kSignFieldNumber;
const int CSPlayerLoginRqst::kTimeFieldNumber;
#endif  // !_MSC_VER

CSPlayerLoginRqst::CSPlayerLoginRqst()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSPlayerLoginRqst::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  authinfo_ = const_cast< ::vmsg::AuthInfo*>(
      ::vmsg::AuthInfo::internal_default_instance());
#else
  authinfo_ = const_cast< ::vmsg::AuthInfo*>(&::vmsg::AuthInfo::default_instance());
#endif
}

CSPlayerLoginRqst::CSPlayerLoginRqst(const CSPlayerLoginRqst& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSPlayerLoginRqst::SharedCtor() {
  _cached_size_ = 0;
  logininfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  zoneid_ = 0u;
  authinfo_ = NULL;
  guestlogin_ = 0u;
  appplatform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  sign_ = GOOGLE_ULONGLONG(0);
  time_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPlayerLoginRqst::~CSPlayerLoginRqst() {
  SharedDtor();
}

void CSPlayerLoginRqst::SharedDtor() {
  if (logininfo_ != &::google::protobuf::internal::kEmptyString) {
    delete logininfo_;
  }
  if (appplatform_ != &::google::protobuf::internal::kEmptyString) {
    delete appplatform_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete authinfo_;
  }
}

void CSPlayerLoginRqst::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPlayerLoginRqst& CSPlayerLoginRqst::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_MsgBase_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_MsgBase_2eproto();
#endif
  return *default_instance_;
}

CSPlayerLoginRqst* CSPlayerLoginRqst::default_instance_ = NULL;

CSPlayerLoginRqst* CSPlayerLoginRqst::New() const {
  return new CSPlayerLoginRqst;
}

void CSPlayerLoginRqst::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_logininfo()) {
      if (logininfo_ != &::google::protobuf::internal::kEmptyString) {
        logininfo_->clear();
      }
    }
    zoneid_ = 0u;
    if (has_authinfo()) {
      if (authinfo_ != NULL) authinfo_->::vmsg::AuthInfo::Clear();
    }
    guestlogin_ = 0u;
    if (has_appplatform()) {
      if (appplatform_ != &::google::protobuf::internal::kEmptyString) {
        appplatform_->clear();
      }
    }
    sign_ = GOOGLE_ULONGLONG(0);
    time_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSPlayerLoginRqst::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string loginInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_logininfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_ZoneID;
        break;
      }

      // optional uint32 ZoneID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ZoneID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &zoneid_)));
          set_has_zoneid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_AuthInfo;
        break;
      }

      // optional .vmsg.AuthInfo AuthInfo = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_AuthInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_authinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_GuestLogin;
        break;
      }

      // optional uint32 GuestLogin = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_GuestLogin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &guestlogin_)));
          set_has_guestlogin();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_AppPlatform;
        break;
      }

      // optional string AppPlatform = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_AppPlatform:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_appplatform()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_Sign;
        break;
      }

      // required uint64 Sign = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Sign:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &sign_)));
          set_has_sign();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_Time;
        break;
      }

      // required uint32 Time = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSPlayerLoginRqst::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string loginInfo = 1;
  if (has_logininfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->logininfo(), output);
  }

  // optional uint32 ZoneID = 2;
  if (has_zoneid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->zoneid(), output);
  }

  // optional .vmsg.AuthInfo AuthInfo = 3;
  if (has_authinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->authinfo(), output);
  }

  // optional uint32 GuestLogin = 4;
  if (has_guestlogin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->guestlogin(), output);
  }

  // optional string AppPlatform = 5;
  if (has_appplatform()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->appplatform(), output);
  }

  // required uint64 Sign = 6;
  if (has_sign()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->sign(), output);
  }

  // required uint32 Time = 7;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->time(), output);
  }

}

int CSPlayerLoginRqst::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string loginInfo = 1;
    if (has_logininfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->logininfo());
    }

    // optional uint32 ZoneID = 2;
    if (has_zoneid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->zoneid());
    }

    // optional .vmsg.AuthInfo AuthInfo = 3;
    if (has_authinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->authinfo());
    }

    // optional uint32 GuestLogin = 4;
    if (has_guestlogin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->guestlogin());
    }

    // optional string AppPlatform = 5;
    if (has_appplatform()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->appplatform());
    }

    // required uint64 Sign = 6;
    if (has_sign()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->sign());
    }

    // required uint32 Time = 7;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPlayerLoginRqst::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPlayerLoginRqst*>(&from));
}

void CSPlayerLoginRqst::MergeFrom(const CSPlayerLoginRqst& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_logininfo()) {
      set_logininfo(from.logininfo());
    }
    if (from.has_zoneid()) {
      set_zoneid(from.zoneid());
    }
    if (from.has_authinfo()) {
      mutable_authinfo()->::vmsg::AuthInfo::MergeFrom(from.authinfo());
    }
    if (from.has_guestlogin()) {
      set_guestlogin(from.guestlogin());
    }
    if (from.has_appplatform()) {
      set_appplatform(from.appplatform());
    }
    if (from.has_sign()) {
      set_sign(from.sign());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
  }
}

void CSPlayerLoginRqst::CopyFrom(const CSPlayerLoginRqst& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPlayerLoginRqst::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000061) != 0x00000061) return false;

  if (has_authinfo()) {
    if (!this->authinfo().IsInitialized()) return false;
  }
  return true;
}

void CSPlayerLoginRqst::Swap(CSPlayerLoginRqst* other) {
  if (other != this) {
    std::swap(logininfo_, other->logininfo_);
    std::swap(zoneid_, other->zoneid_);
    std::swap(authinfo_, other->authinfo_);
    std::swap(guestlogin_, other->guestlogin_);
    std::swap(appplatform_, other->appplatform_);
    std::swap(sign_, other->sign_);
    std::swap(time_, other->time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPlayerLoginRqst::GetTypeName() const {
  return "vmsg.CSPlayerLoginRqst";
}


// ===================================================================

#ifndef _MSC_VER
const int CSPlayerLoginRsp::kLoginInfoFieldNumber;
#endif  // !_MSC_VER

CSPlayerLoginRsp::CSPlayerLoginRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSPlayerLoginRsp::InitAsDefaultInstance() {
}

CSPlayerLoginRsp::CSPlayerLoginRsp(const CSPlayerLoginRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSPlayerLoginRsp::SharedCtor() {
  _cached_size_ = 0;
  logininfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSPlayerLoginRsp::~CSPlayerLoginRsp() {
  SharedDtor();
}

void CSPlayerLoginRsp::SharedDtor() {
  if (logininfo_ != &::google::protobuf::internal::kEmptyString) {
    delete logininfo_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSPlayerLoginRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSPlayerLoginRsp& CSPlayerLoginRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_MsgBase_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_MsgBase_2eproto();
#endif
  return *default_instance_;
}

CSPlayerLoginRsp* CSPlayerLoginRsp::default_instance_ = NULL;

CSPlayerLoginRsp* CSPlayerLoginRsp::New() const {
  return new CSPlayerLoginRsp;
}

void CSPlayerLoginRsp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_logininfo()) {
      if (logininfo_ != &::google::protobuf::internal::kEmptyString) {
        logininfo_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSPlayerLoginRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string loginInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_logininfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSPlayerLoginRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string loginInfo = 1;
  if (has_logininfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->logininfo(), output);
  }

}

int CSPlayerLoginRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string loginInfo = 1;
    if (has_logininfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->logininfo());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSPlayerLoginRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSPlayerLoginRsp*>(&from));
}

void CSPlayerLoginRsp::MergeFrom(const CSPlayerLoginRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_logininfo()) {
      set_logininfo(from.logininfo());
    }
  }
}

void CSPlayerLoginRsp::CopyFrom(const CSPlayerLoginRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSPlayerLoginRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSPlayerLoginRsp::Swap(CSPlayerLoginRsp* other) {
  if (other != this) {
    std::swap(logininfo_, other->logininfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSPlayerLoginRsp::GetTypeName() const {
  return "vmsg.CSPlayerLoginRsp";
}


// ===================================================================

bool MsgHead_MSG_TYPE_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const MsgHead_MSG_TYPE MsgHead::RQST_MSG;
const MsgHead_MSG_TYPE MsgHead::RSP_MSG;
const MsgHead_MSG_TYPE MsgHead::NOTICE_MSG;
const MsgHead_MSG_TYPE MsgHead::MSG_TYPE_MIN;
const MsgHead_MSG_TYPE MsgHead::MSG_TYPE_MAX;
const int MsgHead::MSG_TYPE_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int MsgHead::kMsgIDFieldNumber;
const int MsgHead::kUidFieldNumber;
const int MsgHead::kActFieldNumber;
const int MsgHead::kSeqFieldNumber;
const int MsgHead::kMsgTypeFieldNumber;
const int MsgHead::kAppIDFieldNumber;
const int MsgHead::kRouteIDFieldNumber;
const int MsgHead::kLoginRqstFieldNumber;
const int MsgHead::kLoginRspFieldNumber;
const int MsgHead::kQuickLoginKeyFieldNumber;
#endif  // !_MSC_VER

MsgHead::MsgHead()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MsgHead::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  loginrqst_ = const_cast< ::vmsg::CSPlayerLoginRqst*>(
      ::vmsg::CSPlayerLoginRqst::internal_default_instance());
#else
  loginrqst_ = const_cast< ::vmsg::CSPlayerLoginRqst*>(&::vmsg::CSPlayerLoginRqst::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  loginrsp_ = const_cast< ::vmsg::CSPlayerLoginRsp*>(
      ::vmsg::CSPlayerLoginRsp::internal_default_instance());
#else
  loginrsp_ = const_cast< ::vmsg::CSPlayerLoginRsp*>(&::vmsg::CSPlayerLoginRsp::default_instance());
#endif
}

MsgHead::MsgHead(const MsgHead& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MsgHead::SharedCtor() {
  _cached_size_ = 0;
  msg_id_ = 0u;
  uid_ = GOOGLE_ULONGLONG(0);
  act_ = GOOGLE_ULONGLONG(0);
  seq_ = 0u;
  msg_type_ = 1;
  app_id_ = 0u;
  routeid_ = 0u;
  loginrqst_ = NULL;
  loginrsp_ = NULL;
  quickloginkey_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgHead::~MsgHead() {
  SharedDtor();
}

void MsgHead::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete loginrqst_;
    delete loginrsp_;
  }
}

void MsgHead::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgHead& MsgHead::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_MsgBase_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_MsgBase_2eproto();
#endif
  return *default_instance_;
}

MsgHead* MsgHead::default_instance_ = NULL;

MsgHead* MsgHead::New() const {
  return new MsgHead;
}

void MsgHead::Clear() {
  _extensions_.Clear();
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    msg_id_ = 0u;
    uid_ = GOOGLE_ULONGLONG(0);
    act_ = GOOGLE_ULONGLONG(0);
    seq_ = 0u;
    msg_type_ = 1;
    app_id_ = 0u;
    routeid_ = 0u;
    if (has_loginrqst()) {
      if (loginrqst_ != NULL) loginrqst_->::vmsg::CSPlayerLoginRqst::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_loginrsp()) {
      if (loginrsp_ != NULL) loginrsp_->::vmsg::CSPlayerLoginRsp::Clear();
    }
    quickloginkey_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MsgHead::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Msg_ID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &msg_id_)));
          set_has_msg_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_Uid;
        break;
      }

      // required uint64 Uid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Uid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_Act;
        break;
      }

      // required uint64 Act = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Act:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &act_)));
          set_has_act();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_Seq;
        break;
      }

      // required uint32 Seq = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Seq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &seq_)));
          set_has_seq();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_Msg_Type;
        break;
      }

      // required .vmsg.MsgHead.MSG_TYPE Msg_Type = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Msg_Type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::vmsg::MsgHead_MSG_TYPE_IsValid(value)) {
            set_msg_type(static_cast< ::vmsg::MsgHead_MSG_TYPE >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_App_ID;
        break;
      }

      // optional uint32 App_ID = 6 [default = 0];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_App_ID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &app_id_)));
          set_has_app_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_RouteID;
        break;
      }

      // optional uint32 RouteID = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_RouteID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &routeid_)));
          set_has_routeid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_LoginRqst;
        break;
      }

      // optional .vmsg.CSPlayerLoginRqst LoginRqst = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_LoginRqst:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_loginrqst()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_LoginRsp;
        break;
      }

      // optional .vmsg.CSPlayerLoginRsp LoginRsp = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_LoginRsp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_loginrsp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_QuickLoginKey;
        break;
      }

      // optional uint64 QuickLoginKey = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_QuickLoginKey:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &quickloginkey_)));
          set_has_quickloginkey();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        if ((800u <= tag)) {
        #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
          DO_(_extensions_.ParseField(tag, input, &default_instance()));
        #else
          DO_(_extensions_.ParseField(tag, input, default_instance_));
        #endif
          continue;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MsgHead::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 Msg_ID = 1;
  if (has_msg_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->msg_id(), output);
  }

  // required uint64 Uid = 2;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->uid(), output);
  }

  // required uint64 Act = 3;
  if (has_act()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->act(), output);
  }

  // required uint32 Seq = 4;
  if (has_seq()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->seq(), output);
  }

  // required .vmsg.MsgHead.MSG_TYPE Msg_Type = 5;
  if (has_msg_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->msg_type(), output);
  }

  // optional uint32 App_ID = 6 [default = 0];
  if (has_app_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->app_id(), output);
  }

  // optional uint32 RouteID = 7;
  if (has_routeid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->routeid(), output);
  }

  // optional .vmsg.CSPlayerLoginRqst LoginRqst = 8;
  if (has_loginrqst()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->loginrqst(), output);
  }

  // optional .vmsg.CSPlayerLoginRsp LoginRsp = 9;
  if (has_loginrsp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->loginrsp(), output);
  }

  // optional uint64 QuickLoginKey = 10;
  if (has_quickloginkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(10, this->quickloginkey(), output);
  }

  // Extension range [100, 536870912)
  _extensions_.SerializeWithCachedSizes(
      100, 536870912, output);

}

int MsgHead::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Msg_ID = 1;
    if (has_msg_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->msg_id());
    }

    // required uint64 Uid = 2;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uid());
    }

    // required uint64 Act = 3;
    if (has_act()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->act());
    }

    // required uint32 Seq = 4;
    if (has_seq()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->seq());
    }

    // required .vmsg.MsgHead.MSG_TYPE Msg_Type = 5;
    if (has_msg_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->msg_type());
    }

    // optional uint32 App_ID = 6 [default = 0];
    if (has_app_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->app_id());
    }

    // optional uint32 RouteID = 7;
    if (has_routeid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->routeid());
    }

    // optional .vmsg.CSPlayerLoginRqst LoginRqst = 8;
    if (has_loginrqst()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->loginrqst());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .vmsg.CSPlayerLoginRsp LoginRsp = 9;
    if (has_loginrsp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->loginrsp());
    }

    // optional uint64 QuickLoginKey = 10;
    if (has_quickloginkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->quickloginkey());
    }

  }
  total_size += _extensions_.ByteSize();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgHead::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgHead*>(&from));
}

void MsgHead::MergeFrom(const MsgHead& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_msg_id()) {
      set_msg_id(from.msg_id());
    }
    if (from.has_uid()) {
      set_uid(from.uid());
    }
    if (from.has_act()) {
      set_act(from.act());
    }
    if (from.has_seq()) {
      set_seq(from.seq());
    }
    if (from.has_msg_type()) {
      set_msg_type(from.msg_type());
    }
    if (from.has_app_id()) {
      set_app_id(from.app_id());
    }
    if (from.has_routeid()) {
      set_routeid(from.routeid());
    }
    if (from.has_loginrqst()) {
      mutable_loginrqst()->::vmsg::CSPlayerLoginRqst::MergeFrom(from.loginrqst());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_loginrsp()) {
      mutable_loginrsp()->::vmsg::CSPlayerLoginRsp::MergeFrom(from.loginrsp());
    }
    if (from.has_quickloginkey()) {
      set_quickloginkey(from.quickloginkey());
    }
  }
  _extensions_.MergeFrom(from._extensions_);
}

void MsgHead::CopyFrom(const MsgHead& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgHead::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_loginrqst()) {
    if (!this->loginrqst().IsInitialized()) return false;
  }
  if (has_loginrsp()) {
    if (!this->loginrsp().IsInitialized()) return false;
  }

  if (!_extensions_.IsInitialized()) return false;  return true;
}

void MsgHead::Swap(MsgHead* other) {
  if (other != this) {
    std::swap(msg_id_, other->msg_id_);
    std::swap(uid_, other->uid_);
    std::swap(act_, other->act_);
    std::swap(seq_, other->seq_);
    std::swap(msg_type_, other->msg_type_);
    std::swap(app_id_, other->app_id_);
    std::swap(routeid_, other->routeid_);
    std::swap(loginrqst_, other->loginrqst_);
    std::swap(loginrsp_, other->loginrsp_);
    std::swap(quickloginkey_, other->quickloginkey_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
    _extensions_.Swap(&other->_extensions_);
  }
}

::std::string MsgHead::GetTypeName() const {
  return "vmsg.MsgHead";
}


// ===================================================================

#ifndef _MSC_VER
const int PBFieldDescriptor::kFieldFieldNumber;
const int PBFieldDescriptor::kTagFieldNumber;
const int PBFieldDescriptor::kTypeFieldNumber;
#endif  // !_MSC_VER

PBFieldDescriptor::PBFieldDescriptor()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PBFieldDescriptor::InitAsDefaultInstance() {
}

PBFieldDescriptor::PBFieldDescriptor(const PBFieldDescriptor& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PBFieldDescriptor::SharedCtor() {
  _cached_size_ = 0;
  field_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  tag_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PBFieldDescriptor::~PBFieldDescriptor() {
  SharedDtor();
}

void PBFieldDescriptor::SharedDtor() {
  if (field_ != &::google::protobuf::internal::kEmptyString) {
    delete field_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PBFieldDescriptor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PBFieldDescriptor& PBFieldDescriptor::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_MsgBase_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_MsgBase_2eproto();
#endif
  return *default_instance_;
}

PBFieldDescriptor* PBFieldDescriptor::default_instance_ = NULL;

PBFieldDescriptor* PBFieldDescriptor::New() const {
  return new PBFieldDescriptor;
}

void PBFieldDescriptor::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_field()) {
      if (field_ != &::google::protobuf::internal::kEmptyString) {
        field_->clear();
      }
    }
    tag_ = 0;
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PBFieldDescriptor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string Field = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_field()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_Tag;
        break;
      }

      // required int32 Tag = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Tag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &tag_)));
          set_has_tag();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_Type;
        break;
      }

      // required int32 Type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PBFieldDescriptor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string Field = 1;
  if (has_field()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->field(), output);
  }

  // required int32 Tag = 2;
  if (has_tag()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->tag(), output);
  }

  // required int32 Type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->type(), output);
  }

}

int PBFieldDescriptor::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string Field = 1;
    if (has_field()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->field());
    }

    // required int32 Tag = 2;
    if (has_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->tag());
    }

    // required int32 Type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PBFieldDescriptor::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PBFieldDescriptor*>(&from));
}

void PBFieldDescriptor::MergeFrom(const PBFieldDescriptor& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_field()) {
      set_field(from.field());
    }
    if (from.has_tag()) {
      set_tag(from.tag());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void PBFieldDescriptor::CopyFrom(const PBFieldDescriptor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PBFieldDescriptor::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void PBFieldDescriptor::Swap(PBFieldDescriptor* other) {
  if (other != this) {
    std::swap(field_, other->field_);
    std::swap(tag_, other->tag_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PBFieldDescriptor::GetTypeName() const {
  return "vmsg.PBFieldDescriptor";
}


// ===================================================================

#ifndef _MSC_VER
const int PBMsgDescriptor::kFieldsFieldNumber;
#endif  // !_MSC_VER

PBMsgDescriptor::PBMsgDescriptor()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PBMsgDescriptor::InitAsDefaultInstance() {
}

PBMsgDescriptor::PBMsgDescriptor(const PBMsgDescriptor& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PBMsgDescriptor::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PBMsgDescriptor::~PBMsgDescriptor() {
  SharedDtor();
}

void PBMsgDescriptor::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PBMsgDescriptor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PBMsgDescriptor& PBMsgDescriptor::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_MsgBase_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_MsgBase_2eproto();
#endif
  return *default_instance_;
}

PBMsgDescriptor* PBMsgDescriptor::default_instance_ = NULL;

PBMsgDescriptor* PBMsgDescriptor::New() const {
  return new PBMsgDescriptor;
}

void PBMsgDescriptor::Clear() {
  fields_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PBMsgDescriptor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .vmsg.PBFieldDescriptor Fields = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Fields:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_fields()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_Fields;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PBMsgDescriptor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .vmsg.PBFieldDescriptor Fields = 1;
  for (int i = 0; i < this->fields_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->fields(i), output);
  }

}

int PBMsgDescriptor::ByteSize() const {
  int total_size = 0;

  // repeated .vmsg.PBFieldDescriptor Fields = 1;
  total_size += 1 * this->fields_size();
  for (int i = 0; i < this->fields_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->fields(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PBMsgDescriptor::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PBMsgDescriptor*>(&from));
}

void PBMsgDescriptor::MergeFrom(const PBMsgDescriptor& from) {
  GOOGLE_CHECK_NE(&from, this);
  fields_.MergeFrom(from.fields_);
}

void PBMsgDescriptor::CopyFrom(const PBMsgDescriptor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PBMsgDescriptor::IsInitialized() const {

  for (int i = 0; i < fields_size(); i++) {
    if (!this->fields(i).IsInitialized()) return false;
  }
  return true;
}

void PBMsgDescriptor::Swap(PBMsgDescriptor* other) {
  if (other != this) {
    fields_.Swap(&other->fields_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PBMsgDescriptor::GetTypeName() const {
  return "vmsg.PBMsgDescriptor";
}


// ===================================================================

#ifndef _MSC_VER
const int RouteHead::kSrcAppIdFieldNumber;
const int RouteHead::kSrcRouteKeyFieldNumber;
const int RouteHead::kDstAppIdFieldNumber;
const int RouteHead::kDstRouteKeyFieldNumber;
const int RouteHead::kLoadBananceKeyFieldNumber;
#endif  // !_MSC_VER

RouteHead::RouteHead()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RouteHead::InitAsDefaultInstance() {
}

RouteHead::RouteHead(const RouteHead& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RouteHead::SharedCtor() {
  _cached_size_ = 0;
  src_app_id_ = 0u;
  src_route_key_ = GOOGLE_ULONGLONG(0);
  dst_app_id_ = 0u;
  dst_route_key_ = GOOGLE_ULONGLONG(0);
  load_banance_key_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RouteHead::~RouteHead() {
  SharedDtor();
}

void RouteHead::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RouteHead::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RouteHead& RouteHead::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_MsgBase_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_MsgBase_2eproto();
#endif
  return *default_instance_;
}

RouteHead* RouteHead::default_instance_ = NULL;

RouteHead* RouteHead::New() const {
  return new RouteHead;
}

void RouteHead::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    src_app_id_ = 0u;
    src_route_key_ = GOOGLE_ULONGLONG(0);
    dst_app_id_ = 0u;
    dst_route_key_ = GOOGLE_ULONGLONG(0);
    load_banance_key_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RouteHead::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 src_app_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &src_app_id_)));
          set_has_src_app_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_src_route_key;
        break;
      }

      // required uint64 src_route_key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_src_route_key:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &src_route_key_)));
          set_has_src_route_key();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_dst_app_id;
        break;
      }

      // required uint32 dst_app_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_dst_app_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dst_app_id_)));
          set_has_dst_app_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_dst_route_key;
        break;
      }

      // required uint64 dst_route_key = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_dst_route_key:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dst_route_key_)));
          set_has_dst_route_key();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_load_banance_key;
        break;
      }

      // optional uint64 load_banance_key = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_load_banance_key:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &load_banance_key_)));
          set_has_load_banance_key();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RouteHead::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 src_app_id = 1;
  if (has_src_app_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->src_app_id(), output);
  }

  // required uint64 src_route_key = 2;
  if (has_src_route_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->src_route_key(), output);
  }

  // required uint32 dst_app_id = 3;
  if (has_dst_app_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->dst_app_id(), output);
  }

  // required uint64 dst_route_key = 4;
  if (has_dst_route_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->dst_route_key(), output);
  }

  // optional uint64 load_banance_key = 5;
  if (has_load_banance_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->load_banance_key(), output);
  }

}

int RouteHead::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 src_app_id = 1;
    if (has_src_app_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->src_app_id());
    }

    // required uint64 src_route_key = 2;
    if (has_src_route_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->src_route_key());
    }

    // required uint32 dst_app_id = 3;
    if (has_dst_app_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dst_app_id());
    }

    // required uint64 dst_route_key = 4;
    if (has_dst_route_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->dst_route_key());
    }

    // optional uint64 load_banance_key = 5;
    if (has_load_banance_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->load_banance_key());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RouteHead::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RouteHead*>(&from));
}

void RouteHead::MergeFrom(const RouteHead& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_src_app_id()) {
      set_src_app_id(from.src_app_id());
    }
    if (from.has_src_route_key()) {
      set_src_route_key(from.src_route_key());
    }
    if (from.has_dst_app_id()) {
      set_dst_app_id(from.dst_app_id());
    }
    if (from.has_dst_route_key()) {
      set_dst_route_key(from.dst_route_key());
    }
    if (from.has_load_banance_key()) {
      set_load_banance_key(from.load_banance_key());
    }
  }
}

void RouteHead::CopyFrom(const RouteHead& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RouteHead::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void RouteHead::Swap(RouteHead* other) {
  if (other != this) {
    std::swap(src_app_id_, other->src_app_id_);
    std::swap(src_route_key_, other->src_route_key_);
    std::swap(dst_app_id_, other->dst_app_id_);
    std::swap(dst_route_key_, other->dst_route_key_);
    std::swap(load_banance_key_, other->load_banance_key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RouteHead::GetTypeName() const {
  return "vmsg.RouteHead";
}


// ===================================================================

#ifndef _MSC_VER
const int NullMsg::kMsgHeadFieldNumber;
#endif  // !_MSC_VER

NullMsg::NullMsg()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NullMsg::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  msg_head_ = const_cast< ::vmsg::MsgHead*>(
      ::vmsg::MsgHead::internal_default_instance());
#else
  msg_head_ = const_cast< ::vmsg::MsgHead*>(&::vmsg::MsgHead::default_instance());
#endif
}

NullMsg::NullMsg(const NullMsg& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NullMsg::SharedCtor() {
  _cached_size_ = 0;
  msg_head_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NullMsg::~NullMsg() {
  SharedDtor();
}

void NullMsg::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete msg_head_;
  }
}

void NullMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NullMsg& NullMsg::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_MsgBase_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_MsgBase_2eproto();
#endif
  return *default_instance_;
}

NullMsg* NullMsg::default_instance_ = NULL;

NullMsg* NullMsg::New() const {
  return new NullMsg;
}

void NullMsg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_msg_head()) {
      if (msg_head_ != NULL) msg_head_->::vmsg::MsgHead::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NullMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vmsg.MsgHead Msg_Head = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_head()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NullMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .vmsg.MsgHead Msg_Head = 1;
  if (has_msg_head()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->msg_head(), output);
  }

}

int NullMsg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .vmsg.MsgHead Msg_Head = 1;
    if (has_msg_head()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->msg_head());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NullMsg::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NullMsg*>(&from));
}

void NullMsg::MergeFrom(const NullMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_msg_head()) {
      mutable_msg_head()->::vmsg::MsgHead::MergeFrom(from.msg_head());
    }
  }
}

void NullMsg::CopyFrom(const NullMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NullMsg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_msg_head()) {
    if (!this->msg_head().IsInitialized()) return false;
  }
  return true;
}

void NullMsg::Swap(NullMsg* other) {
  if (other != this) {
    std::swap(msg_head_, other->msg_head_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NullMsg::GetTypeName() const {
  return "vmsg.NullMsg";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)
