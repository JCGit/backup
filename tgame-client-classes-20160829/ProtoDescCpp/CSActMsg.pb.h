// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSActMsg.proto

#ifndef PROTOBUF_CSActMsg_2eproto__INCLUDED
#define PROTOBUF_CSActMsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MsgBase.pb.h"
// @@protoc_insertion_point(includes)

namespace vmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CSActMsg_2eproto();
void protobuf_AssignDesc_CSActMsg_2eproto();
void protobuf_ShutdownFile_CSActMsg_2eproto();

class CSManualActPart;
class CSWorldBossActPart;
class CSActInfo;
class CSActStatChange;
class CSActQueryRsp;
class CSActRequest;
class CSActRespond;

// ===================================================================

class CSManualActPart : public ::google::protobuf::MessageLite {
 public:
  CSManualActPart();
  virtual ~CSManualActPart();

  CSManualActPart(const CSManualActPart& from);

  inline CSManualActPart& operator=(const CSManualActPart& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSManualActPart& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSManualActPart* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSManualActPart* other);

  // implements Message ----------------------------------------------

  CSManualActPart* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSManualActPart& from);
  void MergeFrom(const CSManualActPart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ManualCnt = 1;
  inline bool has_manualcnt() const;
  inline void clear_manualcnt();
  static const int kManualCntFieldNumber = 1;
  inline ::google::protobuf::uint32 manualcnt() const;
  inline void set_manualcnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSManualActPart)
 private:
  inline void set_has_manualcnt();
  inline void clear_has_manualcnt();

  ::google::protobuf::uint32 manualcnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSActMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSActMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSActMsg_2eproto();
  friend void protobuf_ShutdownFile_CSActMsg_2eproto();

  void InitAsDefaultInstance();
  static CSManualActPart* default_instance_;
};
// -------------------------------------------------------------------

class CSWorldBossActPart : public ::google::protobuf::MessageLite {
 public:
  CSWorldBossActPart();
  virtual ~CSWorldBossActPart();

  CSWorldBossActPart(const CSWorldBossActPart& from);

  inline CSWorldBossActPart& operator=(const CSWorldBossActPart& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWorldBossActPart& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWorldBossActPart* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWorldBossActPart* other);

  // implements Message ----------------------------------------------

  CSWorldBossActPart* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWorldBossActPart& from);
  void MergeFrom(const CSWorldBossActPart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Delegated = 1;
  inline bool has_delegated() const;
  inline void clear_delegated();
  static const int kDelegatedFieldNumber = 1;
  inline ::google::protobuf::uint32 delegated() const;
  inline void set_delegated(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSWorldBossActPart)
 private:
  inline void set_has_delegated();
  inline void clear_has_delegated();

  ::google::protobuf::uint32 delegated_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSActMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSActMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSActMsg_2eproto();
  friend void protobuf_ShutdownFile_CSActMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWorldBossActPart* default_instance_;
};
// -------------------------------------------------------------------

class CSActInfo : public ::google::protobuf::MessageLite {
 public:
  CSActInfo();
  virtual ~CSActInfo();

  CSActInfo(const CSActInfo& from);

  inline CSActInfo& operator=(const CSActInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSActInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSActInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSActInfo* other);

  // implements Message ----------------------------------------------

  CSActInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSActInfo& from);
  void MergeFrom(const CSActInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ActID = 1;
  inline bool has_actid() const;
  inline void clear_actid();
  static const int kActIDFieldNumber = 1;
  inline ::google::protobuf::uint32 actid() const;
  inline void set_actid(::google::protobuf::uint32 value);

  // required uint32 ActStat = 2;
  inline bool has_actstat() const;
  inline void clear_actstat();
  static const int kActStatFieldNumber = 2;
  inline ::google::protobuf::uint32 actstat() const;
  inline void set_actstat(::google::protobuf::uint32 value);

  // required int32 StartTime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 3;
  inline ::google::protobuf::int32 starttime() const;
  inline void set_starttime(::google::protobuf::int32 value);

  // required int32 OverTime = 4;
  inline bool has_overtime() const;
  inline void clear_overtime();
  static const int kOverTimeFieldNumber = 4;
  inline ::google::protobuf::int32 overtime() const;
  inline void set_overtime(::google::protobuf::int32 value);

  // optional .vmsg.CSManualActPart ManualAct = 5;
  inline bool has_manualact() const;
  inline void clear_manualact();
  static const int kManualActFieldNumber = 5;
  inline const ::vmsg::CSManualActPart& manualact() const;
  inline ::vmsg::CSManualActPart* mutable_manualact();
  inline ::vmsg::CSManualActPart* release_manualact();
  inline void set_allocated_manualact(::vmsg::CSManualActPart* manualact);

  // optional .vmsg.CSWorldBossActPart WorldBossAct = 6;
  inline bool has_worldbossact() const;
  inline void clear_worldbossact();
  static const int kWorldBossActFieldNumber = 6;
  inline const ::vmsg::CSWorldBossActPart& worldbossact() const;
  inline ::vmsg::CSWorldBossActPart* mutable_worldbossact();
  inline ::vmsg::CSWorldBossActPart* release_worldbossact();
  inline void set_allocated_worldbossact(::vmsg::CSWorldBossActPart* worldbossact);

  // @@protoc_insertion_point(class_scope:vmsg.CSActInfo)
 private:
  inline void set_has_actid();
  inline void clear_has_actid();
  inline void set_has_actstat();
  inline void clear_has_actstat();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_overtime();
  inline void clear_has_overtime();
  inline void set_has_manualact();
  inline void clear_has_manualact();
  inline void set_has_worldbossact();
  inline void clear_has_worldbossact();

  ::google::protobuf::uint32 actid_;
  ::google::protobuf::uint32 actstat_;
  ::google::protobuf::int32 starttime_;
  ::google::protobuf::int32 overtime_;
  ::vmsg::CSManualActPart* manualact_;
  ::vmsg::CSWorldBossActPart* worldbossact_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSActMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSActMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSActMsg_2eproto();
  friend void protobuf_ShutdownFile_CSActMsg_2eproto();

  void InitAsDefaultInstance();
  static CSActInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSActStatChange : public ::google::protobuf::MessageLite {
 public:
  CSActStatChange();
  virtual ~CSActStatChange();

  CSActStatChange(const CSActStatChange& from);

  inline CSActStatChange& operator=(const CSActStatChange& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSActStatChange& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSActStatChange* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSActStatChange* other);

  // implements Message ----------------------------------------------

  CSActStatChange* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSActStatChange& from);
  void MergeFrom(const CSActStatChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ActID = 1;
  inline bool has_actid() const;
  inline void clear_actid();
  static const int kActIDFieldNumber = 1;
  inline ::google::protobuf::uint32 actid() const;
  inline void set_actid(::google::protobuf::uint32 value);

  // required uint32 ActStat = 2;
  inline bool has_actstat() const;
  inline void clear_actstat();
  static const int kActStatFieldNumber = 2;
  inline ::google::protobuf::uint32 actstat() const;
  inline void set_actstat(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSActStatChange)
 private:
  inline void set_has_actid();
  inline void clear_has_actid();
  inline void set_has_actstat();
  inline void clear_has_actstat();

  ::google::protobuf::uint32 actid_;
  ::google::protobuf::uint32 actstat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSActMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSActMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSActMsg_2eproto();
  friend void protobuf_ShutdownFile_CSActMsg_2eproto();

  void InitAsDefaultInstance();
  static CSActStatChange* default_instance_;
};
// -------------------------------------------------------------------

class CSActQueryRsp : public ::google::protobuf::MessageLite {
 public:
  CSActQueryRsp();
  virtual ~CSActQueryRsp();

  CSActQueryRsp(const CSActQueryRsp& from);

  inline CSActQueryRsp& operator=(const CSActQueryRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSActQueryRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSActQueryRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSActQueryRsp* other);

  // implements Message ----------------------------------------------

  CSActQueryRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSActQueryRsp& from);
  void MergeFrom(const CSActQueryRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSActInfo ActInfos = 1;
  inline int actinfos_size() const;
  inline void clear_actinfos();
  static const int kActInfosFieldNumber = 1;
  inline const ::vmsg::CSActInfo& actinfos(int index) const;
  inline ::vmsg::CSActInfo* mutable_actinfos(int index);
  inline ::vmsg::CSActInfo* add_actinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSActInfo >&
      actinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSActInfo >*
      mutable_actinfos();

  // @@protoc_insertion_point(class_scope:vmsg.CSActQueryRsp)
 private:

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSActInfo > actinfos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSActMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSActMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSActMsg_2eproto();
  friend void protobuf_ShutdownFile_CSActMsg_2eproto();

  void InitAsDefaultInstance();
  static CSActQueryRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSActRequest : public ::google::protobuf::MessageLite {
 public:
  CSActRequest();
  virtual ~CSActRequest();

  CSActRequest(const CSActRequest& from);

  inline CSActRequest& operator=(const CSActRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSActRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSActRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSActRequest* other);

  // implements Message ----------------------------------------------

  CSActRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSActRequest& from);
  void MergeFrom(const CSActRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vmsg.CSActRequest)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSActMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSActMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSActMsg_2eproto();
  friend void protobuf_ShutdownFile_CSActMsg_2eproto();

  void InitAsDefaultInstance();
  static CSActRequest* default_instance_;
};
// -------------------------------------------------------------------

class CSActRespond : public ::google::protobuf::MessageLite {
 public:
  CSActRespond();
  virtual ~CSActRespond();

  CSActRespond(const CSActRespond& from);

  inline CSActRespond& operator=(const CSActRespond& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSActRespond& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSActRespond* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSActRespond* other);

  // implements Message ----------------------------------------------

  CSActRespond* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSActRespond& from);
  void MergeFrom(const CSActRespond& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSActQueryRsp ActQuery_Rsp = 1;
  inline bool has_actquery_rsp() const;
  inline void clear_actquery_rsp();
  static const int kActQueryRspFieldNumber = 1;
  inline const ::vmsg::CSActQueryRsp& actquery_rsp() const;
  inline ::vmsg::CSActQueryRsp* mutable_actquery_rsp();
  inline ::vmsg::CSActQueryRsp* release_actquery_rsp();
  inline void set_allocated_actquery_rsp(::vmsg::CSActQueryRsp* actquery_rsp);

  // optional .vmsg.CSActStatChange ActStat_Notify = 2;
  inline bool has_actstat_notify() const;
  inline void clear_actstat_notify();
  static const int kActStatNotifyFieldNumber = 2;
  inline const ::vmsg::CSActStatChange& actstat_notify() const;
  inline ::vmsg::CSActStatChange* mutable_actstat_notify();
  inline ::vmsg::CSActStatChange* release_actstat_notify();
  inline void set_allocated_actstat_notify(::vmsg::CSActStatChange* actstat_notify);

  // @@protoc_insertion_point(class_scope:vmsg.CSActRespond)
 private:
  inline void set_has_actquery_rsp();
  inline void clear_has_actquery_rsp();
  inline void set_has_actstat_notify();
  inline void clear_has_actstat_notify();

  ::vmsg::CSActQueryRsp* actquery_rsp_;
  ::vmsg::CSActStatChange* actstat_notify_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSActMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSActMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSActMsg_2eproto();
  friend void protobuf_ShutdownFile_CSActMsg_2eproto();

  void InitAsDefaultInstance();
  static CSActRespond* default_instance_;
};
// ===================================================================


// ===================================================================

// CSManualActPart

// required uint32 ManualCnt = 1;
inline bool CSManualActPart::has_manualcnt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSManualActPart::set_has_manualcnt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSManualActPart::clear_has_manualcnt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSManualActPart::clear_manualcnt() {
  manualcnt_ = 0u;
  clear_has_manualcnt();
}
inline ::google::protobuf::uint32 CSManualActPart::manualcnt() const {
  return manualcnt_;
}
inline void CSManualActPart::set_manualcnt(::google::protobuf::uint32 value) {
  set_has_manualcnt();
  manualcnt_ = value;
}

// -------------------------------------------------------------------

// CSWorldBossActPart

// required uint32 Delegated = 1;
inline bool CSWorldBossActPart::has_delegated() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWorldBossActPart::set_has_delegated() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWorldBossActPart::clear_has_delegated() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWorldBossActPart::clear_delegated() {
  delegated_ = 0u;
  clear_has_delegated();
}
inline ::google::protobuf::uint32 CSWorldBossActPart::delegated() const {
  return delegated_;
}
inline void CSWorldBossActPart::set_delegated(::google::protobuf::uint32 value) {
  set_has_delegated();
  delegated_ = value;
}

// -------------------------------------------------------------------

// CSActInfo

// required uint32 ActID = 1;
inline bool CSActInfo::has_actid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSActInfo::set_has_actid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSActInfo::clear_has_actid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSActInfo::clear_actid() {
  actid_ = 0u;
  clear_has_actid();
}
inline ::google::protobuf::uint32 CSActInfo::actid() const {
  return actid_;
}
inline void CSActInfo::set_actid(::google::protobuf::uint32 value) {
  set_has_actid();
  actid_ = value;
}

// required uint32 ActStat = 2;
inline bool CSActInfo::has_actstat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSActInfo::set_has_actstat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSActInfo::clear_has_actstat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSActInfo::clear_actstat() {
  actstat_ = 0u;
  clear_has_actstat();
}
inline ::google::protobuf::uint32 CSActInfo::actstat() const {
  return actstat_;
}
inline void CSActInfo::set_actstat(::google::protobuf::uint32 value) {
  set_has_actstat();
  actstat_ = value;
}

// required int32 StartTime = 3;
inline bool CSActInfo::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSActInfo::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSActInfo::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSActInfo::clear_starttime() {
  starttime_ = 0;
  clear_has_starttime();
}
inline ::google::protobuf::int32 CSActInfo::starttime() const {
  return starttime_;
}
inline void CSActInfo::set_starttime(::google::protobuf::int32 value) {
  set_has_starttime();
  starttime_ = value;
}

// required int32 OverTime = 4;
inline bool CSActInfo::has_overtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSActInfo::set_has_overtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSActInfo::clear_has_overtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSActInfo::clear_overtime() {
  overtime_ = 0;
  clear_has_overtime();
}
inline ::google::protobuf::int32 CSActInfo::overtime() const {
  return overtime_;
}
inline void CSActInfo::set_overtime(::google::protobuf::int32 value) {
  set_has_overtime();
  overtime_ = value;
}

// optional .vmsg.CSManualActPart ManualAct = 5;
inline bool CSActInfo::has_manualact() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSActInfo::set_has_manualact() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSActInfo::clear_has_manualact() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSActInfo::clear_manualact() {
  if (manualact_ != NULL) manualact_->::vmsg::CSManualActPart::Clear();
  clear_has_manualact();
}
inline const ::vmsg::CSManualActPart& CSActInfo::manualact() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return manualact_ != NULL ? *manualact_ : *default_instance().manualact_;
#else
  return manualact_ != NULL ? *manualact_ : *default_instance_->manualact_;
#endif
}
inline ::vmsg::CSManualActPart* CSActInfo::mutable_manualact() {
  set_has_manualact();
  if (manualact_ == NULL) manualact_ = new ::vmsg::CSManualActPart;
  return manualact_;
}
inline ::vmsg::CSManualActPart* CSActInfo::release_manualact() {
  clear_has_manualact();
  ::vmsg::CSManualActPart* temp = manualact_;
  manualact_ = NULL;
  return temp;
}
inline void CSActInfo::set_allocated_manualact(::vmsg::CSManualActPart* manualact) {
  delete manualact_;
  manualact_ = manualact;
  if (manualact) {
    set_has_manualact();
  } else {
    clear_has_manualact();
  }
}

// optional .vmsg.CSWorldBossActPart WorldBossAct = 6;
inline bool CSActInfo::has_worldbossact() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSActInfo::set_has_worldbossact() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSActInfo::clear_has_worldbossact() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSActInfo::clear_worldbossact() {
  if (worldbossact_ != NULL) worldbossact_->::vmsg::CSWorldBossActPart::Clear();
  clear_has_worldbossact();
}
inline const ::vmsg::CSWorldBossActPart& CSActInfo::worldbossact() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return worldbossact_ != NULL ? *worldbossact_ : *default_instance().worldbossact_;
#else
  return worldbossact_ != NULL ? *worldbossact_ : *default_instance_->worldbossact_;
#endif
}
inline ::vmsg::CSWorldBossActPart* CSActInfo::mutable_worldbossact() {
  set_has_worldbossact();
  if (worldbossact_ == NULL) worldbossact_ = new ::vmsg::CSWorldBossActPart;
  return worldbossact_;
}
inline ::vmsg::CSWorldBossActPart* CSActInfo::release_worldbossact() {
  clear_has_worldbossact();
  ::vmsg::CSWorldBossActPart* temp = worldbossact_;
  worldbossact_ = NULL;
  return temp;
}
inline void CSActInfo::set_allocated_worldbossact(::vmsg::CSWorldBossActPart* worldbossact) {
  delete worldbossact_;
  worldbossact_ = worldbossact;
  if (worldbossact) {
    set_has_worldbossact();
  } else {
    clear_has_worldbossact();
  }
}

// -------------------------------------------------------------------

// CSActStatChange

// required uint32 ActID = 1;
inline bool CSActStatChange::has_actid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSActStatChange::set_has_actid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSActStatChange::clear_has_actid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSActStatChange::clear_actid() {
  actid_ = 0u;
  clear_has_actid();
}
inline ::google::protobuf::uint32 CSActStatChange::actid() const {
  return actid_;
}
inline void CSActStatChange::set_actid(::google::protobuf::uint32 value) {
  set_has_actid();
  actid_ = value;
}

// required uint32 ActStat = 2;
inline bool CSActStatChange::has_actstat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSActStatChange::set_has_actstat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSActStatChange::clear_has_actstat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSActStatChange::clear_actstat() {
  actstat_ = 0u;
  clear_has_actstat();
}
inline ::google::protobuf::uint32 CSActStatChange::actstat() const {
  return actstat_;
}
inline void CSActStatChange::set_actstat(::google::protobuf::uint32 value) {
  set_has_actstat();
  actstat_ = value;
}

// -------------------------------------------------------------------

// CSActQueryRsp

// repeated .vmsg.CSActInfo ActInfos = 1;
inline int CSActQueryRsp::actinfos_size() const {
  return actinfos_.size();
}
inline void CSActQueryRsp::clear_actinfos() {
  actinfos_.Clear();
}
inline const ::vmsg::CSActInfo& CSActQueryRsp::actinfos(int index) const {
  return actinfos_.Get(index);
}
inline ::vmsg::CSActInfo* CSActQueryRsp::mutable_actinfos(int index) {
  return actinfos_.Mutable(index);
}
inline ::vmsg::CSActInfo* CSActQueryRsp::add_actinfos() {
  return actinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSActInfo >&
CSActQueryRsp::actinfos() const {
  return actinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSActInfo >*
CSActQueryRsp::mutable_actinfos() {
  return &actinfos_;
}

// -------------------------------------------------------------------

// CSActRequest

// -------------------------------------------------------------------

// CSActRespond

// optional .vmsg.CSActQueryRsp ActQuery_Rsp = 1;
inline bool CSActRespond::has_actquery_rsp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSActRespond::set_has_actquery_rsp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSActRespond::clear_has_actquery_rsp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSActRespond::clear_actquery_rsp() {
  if (actquery_rsp_ != NULL) actquery_rsp_->::vmsg::CSActQueryRsp::Clear();
  clear_has_actquery_rsp();
}
inline const ::vmsg::CSActQueryRsp& CSActRespond::actquery_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return actquery_rsp_ != NULL ? *actquery_rsp_ : *default_instance().actquery_rsp_;
#else
  return actquery_rsp_ != NULL ? *actquery_rsp_ : *default_instance_->actquery_rsp_;
#endif
}
inline ::vmsg::CSActQueryRsp* CSActRespond::mutable_actquery_rsp() {
  set_has_actquery_rsp();
  if (actquery_rsp_ == NULL) actquery_rsp_ = new ::vmsg::CSActQueryRsp;
  return actquery_rsp_;
}
inline ::vmsg::CSActQueryRsp* CSActRespond::release_actquery_rsp() {
  clear_has_actquery_rsp();
  ::vmsg::CSActQueryRsp* temp = actquery_rsp_;
  actquery_rsp_ = NULL;
  return temp;
}
inline void CSActRespond::set_allocated_actquery_rsp(::vmsg::CSActQueryRsp* actquery_rsp) {
  delete actquery_rsp_;
  actquery_rsp_ = actquery_rsp;
  if (actquery_rsp) {
    set_has_actquery_rsp();
  } else {
    clear_has_actquery_rsp();
  }
}

// optional .vmsg.CSActStatChange ActStat_Notify = 2;
inline bool CSActRespond::has_actstat_notify() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSActRespond::set_has_actstat_notify() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSActRespond::clear_has_actstat_notify() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSActRespond::clear_actstat_notify() {
  if (actstat_notify_ != NULL) actstat_notify_->::vmsg::CSActStatChange::Clear();
  clear_has_actstat_notify();
}
inline const ::vmsg::CSActStatChange& CSActRespond::actstat_notify() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return actstat_notify_ != NULL ? *actstat_notify_ : *default_instance().actstat_notify_;
#else
  return actstat_notify_ != NULL ? *actstat_notify_ : *default_instance_->actstat_notify_;
#endif
}
inline ::vmsg::CSActStatChange* CSActRespond::mutable_actstat_notify() {
  set_has_actstat_notify();
  if (actstat_notify_ == NULL) actstat_notify_ = new ::vmsg::CSActStatChange;
  return actstat_notify_;
}
inline ::vmsg::CSActStatChange* CSActRespond::release_actstat_notify() {
  clear_has_actstat_notify();
  ::vmsg::CSActStatChange* temp = actstat_notify_;
  actstat_notify_ = NULL;
  return temp;
}
inline void CSActRespond::set_allocated_actstat_notify(::vmsg::CSActStatChange* actstat_notify) {
  delete actstat_notify_;
  actstat_notify_ = actstat_notify;
  if (actstat_notify) {
    set_has_actstat_notify();
  } else {
    clear_has_actstat_notify();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CSActMsg_2eproto__INCLUDED
