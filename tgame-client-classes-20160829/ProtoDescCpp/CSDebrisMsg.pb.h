// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSDebrisMsg.proto

#ifndef PROTOBUF_CSDebrisMsg_2eproto__INCLUDED
#define PROTOBUF_CSDebrisMsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MsgBase.pb.h"
#include "ShareByClient.pb.h"
// @@protoc_insertion_point(includes)

namespace vmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CSDebrisMsg_2eproto();
void protobuf_AssignDesc_CSDebrisMsg_2eproto();
void protobuf_ShutdownFile_CSDebrisMsg_2eproto();

class CSDebrisInfo;
class CSDebrisBagInfo;
class CSDebrisComposeRqst;
class CSDebrisComposeRsp;
class CSDebrisRequest;
class CSDebrisRespond;

// ===================================================================

class CSDebrisInfo : public ::google::protobuf::MessageLite {
 public:
  CSDebrisInfo();
  virtual ~CSDebrisInfo();

  CSDebrisInfo(const CSDebrisInfo& from);

  inline CSDebrisInfo& operator=(const CSDebrisInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSDebrisInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDebrisInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDebrisInfo* other);

  // implements Message ----------------------------------------------

  CSDebrisInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDebrisInfo& from);
  void MergeFrom(const CSDebrisInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 DebrisCfgID = 1;
  inline bool has_debriscfgid() const;
  inline void clear_debriscfgid();
  static const int kDebrisCfgIDFieldNumber = 1;
  inline ::google::protobuf::uint32 debriscfgid() const;
  inline void set_debriscfgid(::google::protobuf::uint32 value);

  // required uint32 DebrisCnt = 2;
  inline bool has_debriscnt() const;
  inline void clear_debriscnt();
  static const int kDebrisCntFieldNumber = 2;
  inline ::google::protobuf::uint32 debriscnt() const;
  inline void set_debriscnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSDebrisInfo)
 private:
  inline void set_has_debriscfgid();
  inline void clear_has_debriscfgid();
  inline void set_has_debriscnt();
  inline void clear_has_debriscnt();

  ::google::protobuf::uint32 debriscfgid_;
  ::google::protobuf::uint32 debriscnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSDebrisMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSDebrisMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSDebrisMsg_2eproto();
  friend void protobuf_ShutdownFile_CSDebrisMsg_2eproto();

  void InitAsDefaultInstance();
  static CSDebrisInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSDebrisBagInfo : public ::google::protobuf::MessageLite {
 public:
  CSDebrisBagInfo();
  virtual ~CSDebrisBagInfo();

  CSDebrisBagInfo(const CSDebrisBagInfo& from);

  inline CSDebrisBagInfo& operator=(const CSDebrisBagInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSDebrisBagInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDebrisBagInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDebrisBagInfo* other);

  // implements Message ----------------------------------------------

  CSDebrisBagInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDebrisBagInfo& from);
  void MergeFrom(const CSDebrisBagInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSDebrisInfo DebrisInfos = 1;
  inline int debrisinfos_size() const;
  inline void clear_debrisinfos();
  static const int kDebrisInfosFieldNumber = 1;
  inline const ::vmsg::CSDebrisInfo& debrisinfos(int index) const;
  inline ::vmsg::CSDebrisInfo* mutable_debrisinfos(int index);
  inline ::vmsg::CSDebrisInfo* add_debrisinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSDebrisInfo >&
      debrisinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSDebrisInfo >*
      mutable_debrisinfos();

  // @@protoc_insertion_point(class_scope:vmsg.CSDebrisBagInfo)
 private:

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSDebrisInfo > debrisinfos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSDebrisMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSDebrisMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSDebrisMsg_2eproto();
  friend void protobuf_ShutdownFile_CSDebrisMsg_2eproto();

  void InitAsDefaultInstance();
  static CSDebrisBagInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSDebrisComposeRqst : public ::google::protobuf::MessageLite {
 public:
  CSDebrisComposeRqst();
  virtual ~CSDebrisComposeRqst();

  CSDebrisComposeRqst(const CSDebrisComposeRqst& from);

  inline CSDebrisComposeRqst& operator=(const CSDebrisComposeRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSDebrisComposeRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDebrisComposeRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDebrisComposeRqst* other);

  // implements Message ----------------------------------------------

  CSDebrisComposeRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDebrisComposeRqst& from);
  void MergeFrom(const CSDebrisComposeRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 DebrisCfgID = 1;
  inline bool has_debriscfgid() const;
  inline void clear_debriscfgid();
  static const int kDebrisCfgIDFieldNumber = 1;
  inline ::google::protobuf::uint32 debriscfgid() const;
  inline void set_debriscfgid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSDebrisComposeRqst)
 private:
  inline void set_has_debriscfgid();
  inline void clear_has_debriscfgid();

  ::google::protobuf::uint32 debriscfgid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSDebrisMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSDebrisMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSDebrisMsg_2eproto();
  friend void protobuf_ShutdownFile_CSDebrisMsg_2eproto();

  void InitAsDefaultInstance();
  static CSDebrisComposeRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSDebrisComposeRsp : public ::google::protobuf::MessageLite {
 public:
  CSDebrisComposeRsp();
  virtual ~CSDebrisComposeRsp();

  CSDebrisComposeRsp(const CSDebrisComposeRsp& from);

  inline CSDebrisComposeRsp& operator=(const CSDebrisComposeRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSDebrisComposeRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDebrisComposeRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDebrisComposeRsp* other);

  // implements Message ----------------------------------------------

  CSDebrisComposeRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDebrisComposeRsp& from);
  void MergeFrom(const CSDebrisComposeRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSDebrisBagInfo DebrisBagInfo = 1;
  inline bool has_debrisbaginfo() const;
  inline void clear_debrisbaginfo();
  static const int kDebrisBagInfoFieldNumber = 1;
  inline const ::vmsg::CSDebrisBagInfo& debrisbaginfo() const;
  inline ::vmsg::CSDebrisBagInfo* mutable_debrisbaginfo();
  inline ::vmsg::CSDebrisBagInfo* release_debrisbaginfo();
  inline void set_allocated_debrisbaginfo(::vmsg::CSDebrisBagInfo* debrisbaginfo);

  // @@protoc_insertion_point(class_scope:vmsg.CSDebrisComposeRsp)
 private:
  inline void set_has_debrisbaginfo();
  inline void clear_has_debrisbaginfo();

  ::vmsg::CSDebrisBagInfo* debrisbaginfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSDebrisMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSDebrisMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSDebrisMsg_2eproto();
  friend void protobuf_ShutdownFile_CSDebrisMsg_2eproto();

  void InitAsDefaultInstance();
  static CSDebrisComposeRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSDebrisRequest : public ::google::protobuf::MessageLite {
 public:
  CSDebrisRequest();
  virtual ~CSDebrisRequest();

  CSDebrisRequest(const CSDebrisRequest& from);

  inline CSDebrisRequest& operator=(const CSDebrisRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSDebrisRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDebrisRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDebrisRequest* other);

  // implements Message ----------------------------------------------

  CSDebrisRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDebrisRequest& from);
  void MergeFrom(const CSDebrisRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSDebrisComposeRqst DebrisCompose_Rqst = 1;
  inline bool has_debriscompose_rqst() const;
  inline void clear_debriscompose_rqst();
  static const int kDebrisComposeRqstFieldNumber = 1;
  inline const ::vmsg::CSDebrisComposeRqst& debriscompose_rqst() const;
  inline ::vmsg::CSDebrisComposeRqst* mutable_debriscompose_rqst();
  inline ::vmsg::CSDebrisComposeRqst* release_debriscompose_rqst();
  inline void set_allocated_debriscompose_rqst(::vmsg::CSDebrisComposeRqst* debriscompose_rqst);

  // @@protoc_insertion_point(class_scope:vmsg.CSDebrisRequest)
 private:
  inline void set_has_debriscompose_rqst();
  inline void clear_has_debriscompose_rqst();

  ::vmsg::CSDebrisComposeRqst* debriscompose_rqst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSDebrisMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSDebrisMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSDebrisMsg_2eproto();
  friend void protobuf_ShutdownFile_CSDebrisMsg_2eproto();

  void InitAsDefaultInstance();
  static CSDebrisRequest* default_instance_;
};
// -------------------------------------------------------------------

class CSDebrisRespond : public ::google::protobuf::MessageLite {
 public:
  CSDebrisRespond();
  virtual ~CSDebrisRespond();

  CSDebrisRespond(const CSDebrisRespond& from);

  inline CSDebrisRespond& operator=(const CSDebrisRespond& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSDebrisRespond& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDebrisRespond* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDebrisRespond* other);

  // implements Message ----------------------------------------------

  CSDebrisRespond* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDebrisRespond& from);
  void MergeFrom(const CSDebrisRespond& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSDebrisComposeRsp DebrisCompose_Rsp = 1;
  inline bool has_debriscompose_rsp() const;
  inline void clear_debriscompose_rsp();
  static const int kDebrisComposeRspFieldNumber = 1;
  inline const ::vmsg::CSDebrisComposeRsp& debriscompose_rsp() const;
  inline ::vmsg::CSDebrisComposeRsp* mutable_debriscompose_rsp();
  inline ::vmsg::CSDebrisComposeRsp* release_debriscompose_rsp();
  inline void set_allocated_debriscompose_rsp(::vmsg::CSDebrisComposeRsp* debriscompose_rsp);

  // optional .vmsg.CSDebrisBagInfo DebrisBagQuery_Rsp = 2;
  inline bool has_debrisbagquery_rsp() const;
  inline void clear_debrisbagquery_rsp();
  static const int kDebrisBagQueryRspFieldNumber = 2;
  inline const ::vmsg::CSDebrisBagInfo& debrisbagquery_rsp() const;
  inline ::vmsg::CSDebrisBagInfo* mutable_debrisbagquery_rsp();
  inline ::vmsg::CSDebrisBagInfo* release_debrisbagquery_rsp();
  inline void set_allocated_debrisbagquery_rsp(::vmsg::CSDebrisBagInfo* debrisbagquery_rsp);

  // @@protoc_insertion_point(class_scope:vmsg.CSDebrisRespond)
 private:
  inline void set_has_debriscompose_rsp();
  inline void clear_has_debriscompose_rsp();
  inline void set_has_debrisbagquery_rsp();
  inline void clear_has_debrisbagquery_rsp();

  ::vmsg::CSDebrisComposeRsp* debriscompose_rsp_;
  ::vmsg::CSDebrisBagInfo* debrisbagquery_rsp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSDebrisMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSDebrisMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSDebrisMsg_2eproto();
  friend void protobuf_ShutdownFile_CSDebrisMsg_2eproto();

  void InitAsDefaultInstance();
  static CSDebrisRespond* default_instance_;
};
// ===================================================================


// ===================================================================

// CSDebrisInfo

// required uint32 DebrisCfgID = 1;
inline bool CSDebrisInfo::has_debriscfgid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDebrisInfo::set_has_debriscfgid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDebrisInfo::clear_has_debriscfgid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDebrisInfo::clear_debriscfgid() {
  debriscfgid_ = 0u;
  clear_has_debriscfgid();
}
inline ::google::protobuf::uint32 CSDebrisInfo::debriscfgid() const {
  return debriscfgid_;
}
inline void CSDebrisInfo::set_debriscfgid(::google::protobuf::uint32 value) {
  set_has_debriscfgid();
  debriscfgid_ = value;
}

// required uint32 DebrisCnt = 2;
inline bool CSDebrisInfo::has_debriscnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSDebrisInfo::set_has_debriscnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSDebrisInfo::clear_has_debriscnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSDebrisInfo::clear_debriscnt() {
  debriscnt_ = 0u;
  clear_has_debriscnt();
}
inline ::google::protobuf::uint32 CSDebrisInfo::debriscnt() const {
  return debriscnt_;
}
inline void CSDebrisInfo::set_debriscnt(::google::protobuf::uint32 value) {
  set_has_debriscnt();
  debriscnt_ = value;
}

// -------------------------------------------------------------------

// CSDebrisBagInfo

// repeated .vmsg.CSDebrisInfo DebrisInfos = 1;
inline int CSDebrisBagInfo::debrisinfos_size() const {
  return debrisinfos_.size();
}
inline void CSDebrisBagInfo::clear_debrisinfos() {
  debrisinfos_.Clear();
}
inline const ::vmsg::CSDebrisInfo& CSDebrisBagInfo::debrisinfos(int index) const {
  return debrisinfos_.Get(index);
}
inline ::vmsg::CSDebrisInfo* CSDebrisBagInfo::mutable_debrisinfos(int index) {
  return debrisinfos_.Mutable(index);
}
inline ::vmsg::CSDebrisInfo* CSDebrisBagInfo::add_debrisinfos() {
  return debrisinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSDebrisInfo >&
CSDebrisBagInfo::debrisinfos() const {
  return debrisinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSDebrisInfo >*
CSDebrisBagInfo::mutable_debrisinfos() {
  return &debrisinfos_;
}

// -------------------------------------------------------------------

// CSDebrisComposeRqst

// required uint32 DebrisCfgID = 1;
inline bool CSDebrisComposeRqst::has_debriscfgid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDebrisComposeRqst::set_has_debriscfgid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDebrisComposeRqst::clear_has_debriscfgid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDebrisComposeRqst::clear_debriscfgid() {
  debriscfgid_ = 0u;
  clear_has_debriscfgid();
}
inline ::google::protobuf::uint32 CSDebrisComposeRqst::debriscfgid() const {
  return debriscfgid_;
}
inline void CSDebrisComposeRqst::set_debriscfgid(::google::protobuf::uint32 value) {
  set_has_debriscfgid();
  debriscfgid_ = value;
}

// -------------------------------------------------------------------

// CSDebrisComposeRsp

// required .vmsg.CSDebrisBagInfo DebrisBagInfo = 1;
inline bool CSDebrisComposeRsp::has_debrisbaginfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDebrisComposeRsp::set_has_debrisbaginfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDebrisComposeRsp::clear_has_debrisbaginfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDebrisComposeRsp::clear_debrisbaginfo() {
  if (debrisbaginfo_ != NULL) debrisbaginfo_->::vmsg::CSDebrisBagInfo::Clear();
  clear_has_debrisbaginfo();
}
inline const ::vmsg::CSDebrisBagInfo& CSDebrisComposeRsp::debrisbaginfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return debrisbaginfo_ != NULL ? *debrisbaginfo_ : *default_instance().debrisbaginfo_;
#else
  return debrisbaginfo_ != NULL ? *debrisbaginfo_ : *default_instance_->debrisbaginfo_;
#endif
}
inline ::vmsg::CSDebrisBagInfo* CSDebrisComposeRsp::mutable_debrisbaginfo() {
  set_has_debrisbaginfo();
  if (debrisbaginfo_ == NULL) debrisbaginfo_ = new ::vmsg::CSDebrisBagInfo;
  return debrisbaginfo_;
}
inline ::vmsg::CSDebrisBagInfo* CSDebrisComposeRsp::release_debrisbaginfo() {
  clear_has_debrisbaginfo();
  ::vmsg::CSDebrisBagInfo* temp = debrisbaginfo_;
  debrisbaginfo_ = NULL;
  return temp;
}
inline void CSDebrisComposeRsp::set_allocated_debrisbaginfo(::vmsg::CSDebrisBagInfo* debrisbaginfo) {
  delete debrisbaginfo_;
  debrisbaginfo_ = debrisbaginfo;
  if (debrisbaginfo) {
    set_has_debrisbaginfo();
  } else {
    clear_has_debrisbaginfo();
  }
}

// -------------------------------------------------------------------

// CSDebrisRequest

// optional .vmsg.CSDebrisComposeRqst DebrisCompose_Rqst = 1;
inline bool CSDebrisRequest::has_debriscompose_rqst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDebrisRequest::set_has_debriscompose_rqst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDebrisRequest::clear_has_debriscompose_rqst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDebrisRequest::clear_debriscompose_rqst() {
  if (debriscompose_rqst_ != NULL) debriscompose_rqst_->::vmsg::CSDebrisComposeRqst::Clear();
  clear_has_debriscompose_rqst();
}
inline const ::vmsg::CSDebrisComposeRqst& CSDebrisRequest::debriscompose_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return debriscompose_rqst_ != NULL ? *debriscompose_rqst_ : *default_instance().debriscompose_rqst_;
#else
  return debriscompose_rqst_ != NULL ? *debriscompose_rqst_ : *default_instance_->debriscompose_rqst_;
#endif
}
inline ::vmsg::CSDebrisComposeRqst* CSDebrisRequest::mutable_debriscompose_rqst() {
  set_has_debriscompose_rqst();
  if (debriscompose_rqst_ == NULL) debriscompose_rqst_ = new ::vmsg::CSDebrisComposeRqst;
  return debriscompose_rqst_;
}
inline ::vmsg::CSDebrisComposeRqst* CSDebrisRequest::release_debriscompose_rqst() {
  clear_has_debriscompose_rqst();
  ::vmsg::CSDebrisComposeRqst* temp = debriscompose_rqst_;
  debriscompose_rqst_ = NULL;
  return temp;
}
inline void CSDebrisRequest::set_allocated_debriscompose_rqst(::vmsg::CSDebrisComposeRqst* debriscompose_rqst) {
  delete debriscompose_rqst_;
  debriscompose_rqst_ = debriscompose_rqst;
  if (debriscompose_rqst) {
    set_has_debriscompose_rqst();
  } else {
    clear_has_debriscompose_rqst();
  }
}

// -------------------------------------------------------------------

// CSDebrisRespond

// optional .vmsg.CSDebrisComposeRsp DebrisCompose_Rsp = 1;
inline bool CSDebrisRespond::has_debriscompose_rsp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDebrisRespond::set_has_debriscompose_rsp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDebrisRespond::clear_has_debriscompose_rsp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDebrisRespond::clear_debriscompose_rsp() {
  if (debriscompose_rsp_ != NULL) debriscompose_rsp_->::vmsg::CSDebrisComposeRsp::Clear();
  clear_has_debriscompose_rsp();
}
inline const ::vmsg::CSDebrisComposeRsp& CSDebrisRespond::debriscompose_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return debriscompose_rsp_ != NULL ? *debriscompose_rsp_ : *default_instance().debriscompose_rsp_;
#else
  return debriscompose_rsp_ != NULL ? *debriscompose_rsp_ : *default_instance_->debriscompose_rsp_;
#endif
}
inline ::vmsg::CSDebrisComposeRsp* CSDebrisRespond::mutable_debriscompose_rsp() {
  set_has_debriscompose_rsp();
  if (debriscompose_rsp_ == NULL) debriscompose_rsp_ = new ::vmsg::CSDebrisComposeRsp;
  return debriscompose_rsp_;
}
inline ::vmsg::CSDebrisComposeRsp* CSDebrisRespond::release_debriscompose_rsp() {
  clear_has_debriscompose_rsp();
  ::vmsg::CSDebrisComposeRsp* temp = debriscompose_rsp_;
  debriscompose_rsp_ = NULL;
  return temp;
}
inline void CSDebrisRespond::set_allocated_debriscompose_rsp(::vmsg::CSDebrisComposeRsp* debriscompose_rsp) {
  delete debriscompose_rsp_;
  debriscompose_rsp_ = debriscompose_rsp;
  if (debriscompose_rsp) {
    set_has_debriscompose_rsp();
  } else {
    clear_has_debriscompose_rsp();
  }
}

// optional .vmsg.CSDebrisBagInfo DebrisBagQuery_Rsp = 2;
inline bool CSDebrisRespond::has_debrisbagquery_rsp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSDebrisRespond::set_has_debrisbagquery_rsp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSDebrisRespond::clear_has_debrisbagquery_rsp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSDebrisRespond::clear_debrisbagquery_rsp() {
  if (debrisbagquery_rsp_ != NULL) debrisbagquery_rsp_->::vmsg::CSDebrisBagInfo::Clear();
  clear_has_debrisbagquery_rsp();
}
inline const ::vmsg::CSDebrisBagInfo& CSDebrisRespond::debrisbagquery_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return debrisbagquery_rsp_ != NULL ? *debrisbagquery_rsp_ : *default_instance().debrisbagquery_rsp_;
#else
  return debrisbagquery_rsp_ != NULL ? *debrisbagquery_rsp_ : *default_instance_->debrisbagquery_rsp_;
#endif
}
inline ::vmsg::CSDebrisBagInfo* CSDebrisRespond::mutable_debrisbagquery_rsp() {
  set_has_debrisbagquery_rsp();
  if (debrisbagquery_rsp_ == NULL) debrisbagquery_rsp_ = new ::vmsg::CSDebrisBagInfo;
  return debrisbagquery_rsp_;
}
inline ::vmsg::CSDebrisBagInfo* CSDebrisRespond::release_debrisbagquery_rsp() {
  clear_has_debrisbagquery_rsp();
  ::vmsg::CSDebrisBagInfo* temp = debrisbagquery_rsp_;
  debrisbagquery_rsp_ = NULL;
  return temp;
}
inline void CSDebrisRespond::set_allocated_debrisbagquery_rsp(::vmsg::CSDebrisBagInfo* debrisbagquery_rsp) {
  delete debrisbagquery_rsp_;
  debrisbagquery_rsp_ = debrisbagquery_rsp;
  if (debrisbagquery_rsp) {
    set_has_debrisbagquery_rsp();
  } else {
    clear_has_debrisbagquery_rsp();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CSDebrisMsg_2eproto__INCLUDED
