// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSMailMsg.proto

#ifndef PROTOBUF_CSMailMsg_2eproto__INCLUDED
#define PROTOBUF_CSMailMsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MsgBase.pb.h"
#include "ShareByClient.pb.h"
// @@protoc_insertion_point(includes)

namespace vmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CSMailMsg_2eproto();
void protobuf_AssignDesc_CSMailMsg_2eproto();
void protobuf_ShutdownFile_CSMailMsg_2eproto();

class CSMailAttach;
class CSMail;
class CSMailSep;
class CSGrpMailBreif;
class CSMailBox;
class CSQueryMailRsp;
class CSReadMailRqst;
class CSOneMail;
class CSGetAttachRqst;
class CSGetAttachRsp;
class CSDeleteMailRqst;
class CSDeleteMailRsp;
class CSReadMailRsp;
class CSMailRequest;
class CSMailRespond;

// ===================================================================

class CSMailAttach : public ::google::protobuf::MessageLite {
 public:
  CSMailAttach();
  virtual ~CSMailAttach();

  CSMailAttach(const CSMailAttach& from);

  inline CSMailAttach& operator=(const CSMailAttach& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMailAttach& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMailAttach* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMailAttach* other);

  // implements Message ----------------------------------------------

  CSMailAttach* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMailAttach& from);
  void MergeFrom(const CSMailAttach& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 AttachType = 1;
  inline bool has_attachtype() const;
  inline void clear_attachtype();
  static const int kAttachTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 attachtype() const;
  inline void set_attachtype(::google::protobuf::uint32 value);

  // required uint32 AttachCfgID = 2;
  inline bool has_attachcfgid() const;
  inline void clear_attachcfgid();
  static const int kAttachCfgIDFieldNumber = 2;
  inline ::google::protobuf::uint32 attachcfgid() const;
  inline void set_attachcfgid(::google::protobuf::uint32 value);

  // required uint32 AttachCnt = 3;
  inline bool has_attachcnt() const;
  inline void clear_attachcnt();
  static const int kAttachCntFieldNumber = 3;
  inline ::google::protobuf::uint32 attachcnt() const;
  inline void set_attachcnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSMailAttach)
 private:
  inline void set_has_attachtype();
  inline void clear_has_attachtype();
  inline void set_has_attachcfgid();
  inline void clear_has_attachcfgid();
  inline void set_has_attachcnt();
  inline void clear_has_attachcnt();

  ::google::protobuf::uint32 attachtype_;
  ::google::protobuf::uint32 attachcfgid_;
  ::google::protobuf::uint32 attachcnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMailMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMailMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMailMsg_2eproto();
  friend void protobuf_ShutdownFile_CSMailMsg_2eproto();

  void InitAsDefaultInstance();
  static CSMailAttach* default_instance_;
};
// -------------------------------------------------------------------

class CSMail : public ::google::protobuf::MessageLite {
 public:
  CSMail();
  virtual ~CSMail();

  CSMail(const CSMail& from);

  inline CSMail& operator=(const CSMail& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMail* other);

  // implements Message ----------------------------------------------

  CSMail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMail& from);
  void MergeFrom(const CSMail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 MailID = 1;
  inline bool has_mailid() const;
  inline void clear_mailid();
  static const int kMailIDFieldNumber = 1;
  inline ::google::protobuf::uint64 mailid() const;
  inline void set_mailid(::google::protobuf::uint64 value);

  // required string MailHead = 2;
  inline bool has_mailhead() const;
  inline void clear_mailhead();
  static const int kMailHeadFieldNumber = 2;
  inline const ::std::string& mailhead() const;
  inline void set_mailhead(const ::std::string& value);
  inline void set_mailhead(const char* value);
  inline void set_mailhead(const char* value, size_t size);
  inline ::std::string* mutable_mailhead();
  inline ::std::string* release_mailhead();
  inline void set_allocated_mailhead(::std::string* mailhead);

  // required uint64 Sender = 3;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 3;
  inline ::google::protobuf::uint64 sender() const;
  inline void set_sender(::google::protobuf::uint64 value);

  // required int32 RemainTime = 4;
  inline bool has_remaintime() const;
  inline void clear_remaintime();
  static const int kRemainTimeFieldNumber = 4;
  inline ::google::protobuf::int32 remaintime() const;
  inline void set_remaintime(::google::protobuf::int32 value);

  // required int32 HadRead = 5;
  inline bool has_hadread() const;
  inline void clear_hadread();
  static const int kHadReadFieldNumber = 5;
  inline ::google::protobuf::int32 hadread() const;
  inline void set_hadread(::google::protobuf::int32 value);

  // required int32 HadGetAttach = 6;
  inline bool has_hadgetattach() const;
  inline void clear_hadgetattach();
  static const int kHadGetAttachFieldNumber = 6;
  inline ::google::protobuf::int32 hadgetattach() const;
  inline void set_hadgetattach(::google::protobuf::int32 value);

  // required int32 HasAttach = 7;
  inline bool has_hasattach() const;
  inline void clear_hasattach();
  static const int kHasAttachFieldNumber = 7;
  inline ::google::protobuf::int32 hasattach() const;
  inline void set_hasattach(::google::protobuf::int32 value);

  // required int32 TimeStamp = 8;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimeStampFieldNumber = 8;
  inline ::google::protobuf::int32 timestamp() const;
  inline void set_timestamp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSMail)
 private:
  inline void set_has_mailid();
  inline void clear_has_mailid();
  inline void set_has_mailhead();
  inline void clear_has_mailhead();
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_remaintime();
  inline void clear_has_remaintime();
  inline void set_has_hadread();
  inline void clear_has_hadread();
  inline void set_has_hadgetattach();
  inline void clear_has_hadgetattach();
  inline void set_has_hasattach();
  inline void clear_has_hasattach();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::uint64 mailid_;
  ::std::string* mailhead_;
  ::google::protobuf::uint64 sender_;
  ::google::protobuf::int32 remaintime_;
  ::google::protobuf::int32 hadread_;
  ::google::protobuf::int32 hadgetattach_;
  ::google::protobuf::int32 hasattach_;
  ::google::protobuf::int32 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMailMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMailMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMailMsg_2eproto();
  friend void protobuf_ShutdownFile_CSMailMsg_2eproto();

  void InitAsDefaultInstance();
  static CSMail* default_instance_;
};
// -------------------------------------------------------------------

class CSMailSep : public ::google::protobuf::MessageLite {
 public:
  CSMailSep();
  virtual ~CSMailSep();

  CSMailSep(const CSMailSep& from);

  inline CSMailSep& operator=(const CSMailSep& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMailSep& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMailSep* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMailSep* other);

  // implements Message ----------------------------------------------

  CSMailSep* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMailSep& from);
  void MergeFrom(const CSMailSep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 MailID = 1;
  inline bool has_mailid() const;
  inline void clear_mailid();
  static const int kMailIDFieldNumber = 1;
  inline ::google::protobuf::uint64 mailid() const;
  inline void set_mailid(::google::protobuf::uint64 value);

  // required int32 HadRead = 2;
  inline bool has_hadread() const;
  inline void clear_hadread();
  static const int kHadReadFieldNumber = 2;
  inline ::google::protobuf::int32 hadread() const;
  inline void set_hadread(::google::protobuf::int32 value);

  // required int32 HadGetAttach = 3;
  inline bool has_hadgetattach() const;
  inline void clear_hadgetattach();
  static const int kHadGetAttachFieldNumber = 3;
  inline ::google::protobuf::int32 hadgetattach() const;
  inline void set_hadgetattach(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSMailSep)
 private:
  inline void set_has_mailid();
  inline void clear_has_mailid();
  inline void set_has_hadread();
  inline void clear_has_hadread();
  inline void set_has_hadgetattach();
  inline void clear_has_hadgetattach();

  ::google::protobuf::uint64 mailid_;
  ::google::protobuf::int32 hadread_;
  ::google::protobuf::int32 hadgetattach_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMailMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMailMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMailMsg_2eproto();
  friend void protobuf_ShutdownFile_CSMailMsg_2eproto();

  void InitAsDefaultInstance();
  static CSMailSep* default_instance_;
};
// -------------------------------------------------------------------

class CSGrpMailBreif : public ::google::protobuf::MessageLite {
 public:
  CSGrpMailBreif();
  virtual ~CSGrpMailBreif();

  CSGrpMailBreif(const CSGrpMailBreif& from);

  inline CSGrpMailBreif& operator=(const CSGrpMailBreif& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSGrpMailBreif& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGrpMailBreif* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGrpMailBreif* other);

  // implements Message ----------------------------------------------

  CSGrpMailBreif* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGrpMailBreif& from);
  void MergeFrom(const CSGrpMailBreif& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 MailID = 1;
  inline bool has_mailid() const;
  inline void clear_mailid();
  static const int kMailIDFieldNumber = 1;
  inline ::google::protobuf::uint64 mailid() const;
  inline void set_mailid(::google::protobuf::uint64 value);

  // required uint64 Sender = 2;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 2;
  inline ::google::protobuf::uint64 sender() const;
  inline void set_sender(::google::protobuf::uint64 value);

  // required string MailHead = 3;
  inline bool has_mailhead() const;
  inline void clear_mailhead();
  static const int kMailHeadFieldNumber = 3;
  inline const ::std::string& mailhead() const;
  inline void set_mailhead(const ::std::string& value);
  inline void set_mailhead(const char* value);
  inline void set_mailhead(const char* value, size_t size);
  inline ::std::string* mutable_mailhead();
  inline ::std::string* release_mailhead();
  inline void set_allocated_mailhead(::std::string* mailhead);

  // required int32 RemainTime = 4;
  inline bool has_remaintime() const;
  inline void clear_remaintime();
  static const int kRemainTimeFieldNumber = 4;
  inline ::google::protobuf::int32 remaintime() const;
  inline void set_remaintime(::google::protobuf::int32 value);

  // required int32 HasAttach = 5;
  inline bool has_hasattach() const;
  inline void clear_hasattach();
  static const int kHasAttachFieldNumber = 5;
  inline ::google::protobuf::int32 hasattach() const;
  inline void set_hasattach(::google::protobuf::int32 value);

  // required int32 TimeStamp = 6;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimeStampFieldNumber = 6;
  inline ::google::protobuf::int32 timestamp() const;
  inline void set_timestamp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSGrpMailBreif)
 private:
  inline void set_has_mailid();
  inline void clear_has_mailid();
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_mailhead();
  inline void clear_has_mailhead();
  inline void set_has_remaintime();
  inline void clear_has_remaintime();
  inline void set_has_hasattach();
  inline void clear_has_hasattach();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::uint64 mailid_;
  ::google::protobuf::uint64 sender_;
  ::std::string* mailhead_;
  ::google::protobuf::int32 remaintime_;
  ::google::protobuf::int32 hasattach_;
  ::google::protobuf::int32 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMailMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMailMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMailMsg_2eproto();
  friend void protobuf_ShutdownFile_CSMailMsg_2eproto();

  void InitAsDefaultInstance();
  static CSGrpMailBreif* default_instance_;
};
// -------------------------------------------------------------------

class CSMailBox : public ::google::protobuf::MessageLite {
 public:
  CSMailBox();
  virtual ~CSMailBox();

  CSMailBox(const CSMailBox& from);

  inline CSMailBox& operator=(const CSMailBox& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMailBox& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMailBox* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMailBox* other);

  // implements Message ----------------------------------------------

  CSMailBox* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMailBox& from);
  void MergeFrom(const CSMailBox& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 GroupID = 1;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIDFieldNumber = 1;
  inline ::google::protobuf::uint64 groupid() const;
  inline void set_groupid(::google::protobuf::uint64 value);

  // repeated .vmsg.CSMailSep MailSep = 2;
  inline int mailsep_size() const;
  inline void clear_mailsep();
  static const int kMailSepFieldNumber = 2;
  inline const ::vmsg::CSMailSep& mailsep(int index) const;
  inline ::vmsg::CSMailSep* mutable_mailsep(int index);
  inline ::vmsg::CSMailSep* add_mailsep();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailSep >&
      mailsep() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailSep >*
      mutable_mailsep();

  // repeated .vmsg.CSGrpMailBreif GrpMailLst = 3;
  inline int grpmaillst_size() const;
  inline void clear_grpmaillst();
  static const int kGrpMailLstFieldNumber = 3;
  inline const ::vmsg::CSGrpMailBreif& grpmaillst(int index) const;
  inline ::vmsg::CSGrpMailBreif* mutable_grpmaillst(int index);
  inline ::vmsg::CSGrpMailBreif* add_grpmaillst();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSGrpMailBreif >&
      grpmaillst() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSGrpMailBreif >*
      mutable_grpmaillst();

  // @@protoc_insertion_point(class_scope:vmsg.CSMailBox)
 private:
  inline void set_has_groupid();
  inline void clear_has_groupid();

  ::google::protobuf::uint64 groupid_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailSep > mailsep_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSGrpMailBreif > grpmaillst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMailMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMailMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMailMsg_2eproto();
  friend void protobuf_ShutdownFile_CSMailMsg_2eproto();

  void InitAsDefaultInstance();
  static CSMailBox* default_instance_;
};
// -------------------------------------------------------------------

class CSQueryMailRsp : public ::google::protobuf::MessageLite {
 public:
  CSQueryMailRsp();
  virtual ~CSQueryMailRsp();

  CSQueryMailRsp(const CSQueryMailRsp& from);

  inline CSQueryMailRsp& operator=(const CSQueryMailRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSQueryMailRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQueryMailRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQueryMailRsp* other);

  // implements Message ----------------------------------------------

  CSQueryMailRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQueryMailRsp& from);
  void MergeFrom(const CSQueryMailRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSMail SelfMailLst = 1;
  inline int selfmaillst_size() const;
  inline void clear_selfmaillst();
  static const int kSelfMailLstFieldNumber = 1;
  inline const ::vmsg::CSMail& selfmaillst(int index) const;
  inline ::vmsg::CSMail* mutable_selfmaillst(int index);
  inline ::vmsg::CSMail* add_selfmaillst();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSMail >&
      selfmaillst() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSMail >*
      mutable_selfmaillst();

  // repeated .vmsg.CSMailBox MailBox = 2;
  inline int mailbox_size() const;
  inline void clear_mailbox();
  static const int kMailBoxFieldNumber = 2;
  inline const ::vmsg::CSMailBox& mailbox(int index) const;
  inline ::vmsg::CSMailBox* mutable_mailbox(int index);
  inline ::vmsg::CSMailBox* add_mailbox();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailBox >&
      mailbox() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailBox >*
      mutable_mailbox();

  // @@protoc_insertion_point(class_scope:vmsg.CSQueryMailRsp)
 private:

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSMail > selfmaillst_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailBox > mailbox_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMailMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMailMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMailMsg_2eproto();
  friend void protobuf_ShutdownFile_CSMailMsg_2eproto();

  void InitAsDefaultInstance();
  static CSQueryMailRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSReadMailRqst : public ::google::protobuf::MessageLite {
 public:
  CSReadMailRqst();
  virtual ~CSReadMailRqst();

  CSReadMailRqst(const CSReadMailRqst& from);

  inline CSReadMailRqst& operator=(const CSReadMailRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSReadMailRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSReadMailRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSReadMailRqst* other);

  // implements Message ----------------------------------------------

  CSReadMailRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSReadMailRqst& from);
  void MergeFrom(const CSReadMailRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 MailID = 1;
  inline bool has_mailid() const;
  inline void clear_mailid();
  static const int kMailIDFieldNumber = 1;
  inline ::google::protobuf::uint64 mailid() const;
  inline void set_mailid(::google::protobuf::uint64 value);

  // required uint64 GroupID = 2;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIDFieldNumber = 2;
  inline ::google::protobuf::uint64 groupid() const;
  inline void set_groupid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSReadMailRqst)
 private:
  inline void set_has_mailid();
  inline void clear_has_mailid();
  inline void set_has_groupid();
  inline void clear_has_groupid();

  ::google::protobuf::uint64 mailid_;
  ::google::protobuf::uint64 groupid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMailMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMailMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMailMsg_2eproto();
  friend void protobuf_ShutdownFile_CSMailMsg_2eproto();

  void InitAsDefaultInstance();
  static CSReadMailRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSOneMail : public ::google::protobuf::MessageLite {
 public:
  CSOneMail();
  virtual ~CSOneMail();

  CSOneMail(const CSOneMail& from);

  inline CSOneMail& operator=(const CSOneMail& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSOneMail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSOneMail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSOneMail* other);

  // implements Message ----------------------------------------------

  CSOneMail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSOneMail& from);
  void MergeFrom(const CSOneMail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 MailID = 1;
  inline bool has_mailid() const;
  inline void clear_mailid();
  static const int kMailIDFieldNumber = 1;
  inline ::google::protobuf::uint64 mailid() const;
  inline void set_mailid(::google::protobuf::uint64 value);

  // required uint64 GroupID = 2;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIDFieldNumber = 2;
  inline ::google::protobuf::uint64 groupid() const;
  inline void set_groupid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSOneMail)
 private:
  inline void set_has_mailid();
  inline void clear_has_mailid();
  inline void set_has_groupid();
  inline void clear_has_groupid();

  ::google::protobuf::uint64 mailid_;
  ::google::protobuf::uint64 groupid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMailMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMailMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMailMsg_2eproto();
  friend void protobuf_ShutdownFile_CSMailMsg_2eproto();

  void InitAsDefaultInstance();
  static CSOneMail* default_instance_;
};
// -------------------------------------------------------------------

class CSGetAttachRqst : public ::google::protobuf::MessageLite {
 public:
  CSGetAttachRqst();
  virtual ~CSGetAttachRqst();

  CSGetAttachRqst(const CSGetAttachRqst& from);

  inline CSGetAttachRqst& operator=(const CSGetAttachRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSGetAttachRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetAttachRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetAttachRqst* other);

  // implements Message ----------------------------------------------

  CSGetAttachRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetAttachRqst& from);
  void MergeFrom(const CSGetAttachRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSOneMail MailLst = 1;
  inline int maillst_size() const;
  inline void clear_maillst();
  static const int kMailLstFieldNumber = 1;
  inline const ::vmsg::CSOneMail& maillst(int index) const;
  inline ::vmsg::CSOneMail* mutable_maillst(int index);
  inline ::vmsg::CSOneMail* add_maillst();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSOneMail >&
      maillst() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSOneMail >*
      mutable_maillst();

  // @@protoc_insertion_point(class_scope:vmsg.CSGetAttachRqst)
 private:

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSOneMail > maillst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMailMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMailMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMailMsg_2eproto();
  friend void protobuf_ShutdownFile_CSMailMsg_2eproto();

  void InitAsDefaultInstance();
  static CSGetAttachRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSGetAttachRsp : public ::google::protobuf::MessageLite {
 public:
  CSGetAttachRsp();
  virtual ~CSGetAttachRsp();

  CSGetAttachRsp(const CSGetAttachRsp& from);

  inline CSGetAttachRsp& operator=(const CSGetAttachRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSGetAttachRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGetAttachRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGetAttachRsp* other);

  // implements Message ----------------------------------------------

  CSGetAttachRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGetAttachRsp& from);
  void MergeFrom(const CSGetAttachRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 MailIDLst = 1;
  inline int mailidlst_size() const;
  inline void clear_mailidlst();
  static const int kMailIDLstFieldNumber = 1;
  inline ::google::protobuf::uint64 mailidlst(int index) const;
  inline void set_mailidlst(int index, ::google::protobuf::uint64 value);
  inline void add_mailidlst(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      mailidlst() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_mailidlst();

  // @@protoc_insertion_point(class_scope:vmsg.CSGetAttachRsp)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > mailidlst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMailMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMailMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMailMsg_2eproto();
  friend void protobuf_ShutdownFile_CSMailMsg_2eproto();

  void InitAsDefaultInstance();
  static CSGetAttachRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSDeleteMailRqst : public ::google::protobuf::MessageLite {
 public:
  CSDeleteMailRqst();
  virtual ~CSDeleteMailRqst();

  CSDeleteMailRqst(const CSDeleteMailRqst& from);

  inline CSDeleteMailRqst& operator=(const CSDeleteMailRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSDeleteMailRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDeleteMailRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDeleteMailRqst* other);

  // implements Message ----------------------------------------------

  CSDeleteMailRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDeleteMailRqst& from);
  void MergeFrom(const CSDeleteMailRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 MailID = 1;
  inline bool has_mailid() const;
  inline void clear_mailid();
  static const int kMailIDFieldNumber = 1;
  inline ::google::protobuf::uint64 mailid() const;
  inline void set_mailid(::google::protobuf::uint64 value);

  // required uint64 GroupID = 2;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIDFieldNumber = 2;
  inline ::google::protobuf::uint64 groupid() const;
  inline void set_groupid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSDeleteMailRqst)
 private:
  inline void set_has_mailid();
  inline void clear_has_mailid();
  inline void set_has_groupid();
  inline void clear_has_groupid();

  ::google::protobuf::uint64 mailid_;
  ::google::protobuf::uint64 groupid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMailMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMailMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMailMsg_2eproto();
  friend void protobuf_ShutdownFile_CSMailMsg_2eproto();

  void InitAsDefaultInstance();
  static CSDeleteMailRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSDeleteMailRsp : public ::google::protobuf::MessageLite {
 public:
  CSDeleteMailRsp();
  virtual ~CSDeleteMailRsp();

  CSDeleteMailRsp(const CSDeleteMailRsp& from);

  inline CSDeleteMailRsp& operator=(const CSDeleteMailRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSDeleteMailRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDeleteMailRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDeleteMailRsp* other);

  // implements Message ----------------------------------------------

  CSDeleteMailRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDeleteMailRsp& from);
  void MergeFrom(const CSDeleteMailRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 MailID = 1;
  inline bool has_mailid() const;
  inline void clear_mailid();
  static const int kMailIDFieldNumber = 1;
  inline ::google::protobuf::uint64 mailid() const;
  inline void set_mailid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSDeleteMailRsp)
 private:
  inline void set_has_mailid();
  inline void clear_has_mailid();

  ::google::protobuf::uint64 mailid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMailMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMailMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMailMsg_2eproto();
  friend void protobuf_ShutdownFile_CSMailMsg_2eproto();

  void InitAsDefaultInstance();
  static CSDeleteMailRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSReadMailRsp : public ::google::protobuf::MessageLite {
 public:
  CSReadMailRsp();
  virtual ~CSReadMailRsp();

  CSReadMailRsp(const CSReadMailRsp& from);

  inline CSReadMailRsp& operator=(const CSReadMailRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSReadMailRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSReadMailRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSReadMailRsp* other);

  // implements Message ----------------------------------------------

  CSReadMailRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSReadMailRsp& from);
  void MergeFrom(const CSReadMailRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 MailID = 1;
  inline bool has_mailid() const;
  inline void clear_mailid();
  static const int kMailIDFieldNumber = 1;
  inline ::google::protobuf::uint64 mailid() const;
  inline void set_mailid(::google::protobuf::uint64 value);

  // required bytes MailBody = 3;
  inline bool has_mailbody() const;
  inline void clear_mailbody();
  static const int kMailBodyFieldNumber = 3;
  inline const ::std::string& mailbody() const;
  inline void set_mailbody(const ::std::string& value);
  inline void set_mailbody(const char* value);
  inline void set_mailbody(const void* value, size_t size);
  inline ::std::string* mutable_mailbody();
  inline ::std::string* release_mailbody();
  inline void set_allocated_mailbody(::std::string* mailbody);

  // repeated .vmsg.CSMailAttach Attach = 4;
  inline int attach_size() const;
  inline void clear_attach();
  static const int kAttachFieldNumber = 4;
  inline const ::vmsg::CSMailAttach& attach(int index) const;
  inline ::vmsg::CSMailAttach* mutable_attach(int index);
  inline ::vmsg::CSMailAttach* add_attach();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailAttach >&
      attach() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailAttach >*
      mutable_attach();

  // @@protoc_insertion_point(class_scope:vmsg.CSReadMailRsp)
 private:
  inline void set_has_mailid();
  inline void clear_has_mailid();
  inline void set_has_mailbody();
  inline void clear_has_mailbody();

  ::google::protobuf::uint64 mailid_;
  ::std::string* mailbody_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailAttach > attach_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMailMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMailMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMailMsg_2eproto();
  friend void protobuf_ShutdownFile_CSMailMsg_2eproto();

  void InitAsDefaultInstance();
  static CSReadMailRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSMailRequest : public ::google::protobuf::MessageLite {
 public:
  CSMailRequest();
  virtual ~CSMailRequest();

  CSMailRequest(const CSMailRequest& from);

  inline CSMailRequest& operator=(const CSMailRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMailRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMailRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMailRequest* other);

  // implements Message ----------------------------------------------

  CSMailRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMailRequest& from);
  void MergeFrom(const CSMailRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSReadMailRqst ReadMail_Rqst = 1;
  inline bool has_readmail_rqst() const;
  inline void clear_readmail_rqst();
  static const int kReadMailRqstFieldNumber = 1;
  inline const ::vmsg::CSReadMailRqst& readmail_rqst() const;
  inline ::vmsg::CSReadMailRqst* mutable_readmail_rqst();
  inline ::vmsg::CSReadMailRqst* release_readmail_rqst();
  inline void set_allocated_readmail_rqst(::vmsg::CSReadMailRqst* readmail_rqst);

  // optional .vmsg.CSGetAttachRqst GetAttach_Rqst = 2;
  inline bool has_getattach_rqst() const;
  inline void clear_getattach_rqst();
  static const int kGetAttachRqstFieldNumber = 2;
  inline const ::vmsg::CSGetAttachRqst& getattach_rqst() const;
  inline ::vmsg::CSGetAttachRqst* mutable_getattach_rqst();
  inline ::vmsg::CSGetAttachRqst* release_getattach_rqst();
  inline void set_allocated_getattach_rqst(::vmsg::CSGetAttachRqst* getattach_rqst);

  // optional .vmsg.CSDeleteMailRqst DeleteMail_Rqst = 3;
  inline bool has_deletemail_rqst() const;
  inline void clear_deletemail_rqst();
  static const int kDeleteMailRqstFieldNumber = 3;
  inline const ::vmsg::CSDeleteMailRqst& deletemail_rqst() const;
  inline ::vmsg::CSDeleteMailRqst* mutable_deletemail_rqst();
  inline ::vmsg::CSDeleteMailRqst* release_deletemail_rqst();
  inline void set_allocated_deletemail_rqst(::vmsg::CSDeleteMailRqst* deletemail_rqst);

  // @@protoc_insertion_point(class_scope:vmsg.CSMailRequest)
 private:
  inline void set_has_readmail_rqst();
  inline void clear_has_readmail_rqst();
  inline void set_has_getattach_rqst();
  inline void clear_has_getattach_rqst();
  inline void set_has_deletemail_rqst();
  inline void clear_has_deletemail_rqst();

  ::vmsg::CSReadMailRqst* readmail_rqst_;
  ::vmsg::CSGetAttachRqst* getattach_rqst_;
  ::vmsg::CSDeleteMailRqst* deletemail_rqst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMailMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMailMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMailMsg_2eproto();
  friend void protobuf_ShutdownFile_CSMailMsg_2eproto();

  void InitAsDefaultInstance();
  static CSMailRequest* default_instance_;
};
// -------------------------------------------------------------------

class CSMailRespond : public ::google::protobuf::MessageLite {
 public:
  CSMailRespond();
  virtual ~CSMailRespond();

  CSMailRespond(const CSMailRespond& from);

  inline CSMailRespond& operator=(const CSMailRespond& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMailRespond& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMailRespond* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMailRespond* other);

  // implements Message ----------------------------------------------

  CSMailRespond* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMailRespond& from);
  void MergeFrom(const CSMailRespond& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSQueryMailRsp QueryMail_Rsp = 1;
  inline bool has_querymail_rsp() const;
  inline void clear_querymail_rsp();
  static const int kQueryMailRspFieldNumber = 1;
  inline const ::vmsg::CSQueryMailRsp& querymail_rsp() const;
  inline ::vmsg::CSQueryMailRsp* mutable_querymail_rsp();
  inline ::vmsg::CSQueryMailRsp* release_querymail_rsp();
  inline void set_allocated_querymail_rsp(::vmsg::CSQueryMailRsp* querymail_rsp);

  // optional .vmsg.CSReadMailRsp ReadMail_Rsp = 2;
  inline bool has_readmail_rsp() const;
  inline void clear_readmail_rsp();
  static const int kReadMailRspFieldNumber = 2;
  inline const ::vmsg::CSReadMailRsp& readmail_rsp() const;
  inline ::vmsg::CSReadMailRsp* mutable_readmail_rsp();
  inline ::vmsg::CSReadMailRsp* release_readmail_rsp();
  inline void set_allocated_readmail_rsp(::vmsg::CSReadMailRsp* readmail_rsp);

  // optional .vmsg.CSGetAttachRsp GetAttach_Rsp = 3;
  inline bool has_getattach_rsp() const;
  inline void clear_getattach_rsp();
  static const int kGetAttachRspFieldNumber = 3;
  inline const ::vmsg::CSGetAttachRsp& getattach_rsp() const;
  inline ::vmsg::CSGetAttachRsp* mutable_getattach_rsp();
  inline ::vmsg::CSGetAttachRsp* release_getattach_rsp();
  inline void set_allocated_getattach_rsp(::vmsg::CSGetAttachRsp* getattach_rsp);

  // optional .vmsg.CSDeleteMailRsp DeleteMail_Rsp = 4;
  inline bool has_deletemail_rsp() const;
  inline void clear_deletemail_rsp();
  static const int kDeleteMailRspFieldNumber = 4;
  inline const ::vmsg::CSDeleteMailRsp& deletemail_rsp() const;
  inline ::vmsg::CSDeleteMailRsp* mutable_deletemail_rsp();
  inline ::vmsg::CSDeleteMailRsp* release_deletemail_rsp();
  inline void set_allocated_deletemail_rsp(::vmsg::CSDeleteMailRsp* deletemail_rsp);

  // optional .vmsg.CSQueryMailRsp DeleteAll_Rsp = 5;
  inline bool has_deleteall_rsp() const;
  inline void clear_deleteall_rsp();
  static const int kDeleteAllRspFieldNumber = 5;
  inline const ::vmsg::CSQueryMailRsp& deleteall_rsp() const;
  inline ::vmsg::CSQueryMailRsp* mutable_deleteall_rsp();
  inline ::vmsg::CSQueryMailRsp* release_deleteall_rsp();
  inline void set_allocated_deleteall_rsp(::vmsg::CSQueryMailRsp* deleteall_rsp);

  // @@protoc_insertion_point(class_scope:vmsg.CSMailRespond)
 private:
  inline void set_has_querymail_rsp();
  inline void clear_has_querymail_rsp();
  inline void set_has_readmail_rsp();
  inline void clear_has_readmail_rsp();
  inline void set_has_getattach_rsp();
  inline void clear_has_getattach_rsp();
  inline void set_has_deletemail_rsp();
  inline void clear_has_deletemail_rsp();
  inline void set_has_deleteall_rsp();
  inline void clear_has_deleteall_rsp();

  ::vmsg::CSQueryMailRsp* querymail_rsp_;
  ::vmsg::CSReadMailRsp* readmail_rsp_;
  ::vmsg::CSGetAttachRsp* getattach_rsp_;
  ::vmsg::CSDeleteMailRsp* deletemail_rsp_;
  ::vmsg::CSQueryMailRsp* deleteall_rsp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSMailMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSMailMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSMailMsg_2eproto();
  friend void protobuf_ShutdownFile_CSMailMsg_2eproto();

  void InitAsDefaultInstance();
  static CSMailRespond* default_instance_;
};
// ===================================================================


// ===================================================================

// CSMailAttach

// required uint32 AttachType = 1;
inline bool CSMailAttach::has_attachtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMailAttach::set_has_attachtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMailAttach::clear_has_attachtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMailAttach::clear_attachtype() {
  attachtype_ = 0u;
  clear_has_attachtype();
}
inline ::google::protobuf::uint32 CSMailAttach::attachtype() const {
  return attachtype_;
}
inline void CSMailAttach::set_attachtype(::google::protobuf::uint32 value) {
  set_has_attachtype();
  attachtype_ = value;
}

// required uint32 AttachCfgID = 2;
inline bool CSMailAttach::has_attachcfgid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMailAttach::set_has_attachcfgid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMailAttach::clear_has_attachcfgid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMailAttach::clear_attachcfgid() {
  attachcfgid_ = 0u;
  clear_has_attachcfgid();
}
inline ::google::protobuf::uint32 CSMailAttach::attachcfgid() const {
  return attachcfgid_;
}
inline void CSMailAttach::set_attachcfgid(::google::protobuf::uint32 value) {
  set_has_attachcfgid();
  attachcfgid_ = value;
}

// required uint32 AttachCnt = 3;
inline bool CSMailAttach::has_attachcnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSMailAttach::set_has_attachcnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSMailAttach::clear_has_attachcnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSMailAttach::clear_attachcnt() {
  attachcnt_ = 0u;
  clear_has_attachcnt();
}
inline ::google::protobuf::uint32 CSMailAttach::attachcnt() const {
  return attachcnt_;
}
inline void CSMailAttach::set_attachcnt(::google::protobuf::uint32 value) {
  set_has_attachcnt();
  attachcnt_ = value;
}

// -------------------------------------------------------------------

// CSMail

// required uint64 MailID = 1;
inline bool CSMail::has_mailid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMail::set_has_mailid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMail::clear_has_mailid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMail::clear_mailid() {
  mailid_ = GOOGLE_ULONGLONG(0);
  clear_has_mailid();
}
inline ::google::protobuf::uint64 CSMail::mailid() const {
  return mailid_;
}
inline void CSMail::set_mailid(::google::protobuf::uint64 value) {
  set_has_mailid();
  mailid_ = value;
}

// required string MailHead = 2;
inline bool CSMail::has_mailhead() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMail::set_has_mailhead() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMail::clear_has_mailhead() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMail::clear_mailhead() {
  if (mailhead_ != &::google::protobuf::internal::kEmptyString) {
    mailhead_->clear();
  }
  clear_has_mailhead();
}
inline const ::std::string& CSMail::mailhead() const {
  return *mailhead_;
}
inline void CSMail::set_mailhead(const ::std::string& value) {
  set_has_mailhead();
  if (mailhead_ == &::google::protobuf::internal::kEmptyString) {
    mailhead_ = new ::std::string;
  }
  mailhead_->assign(value);
}
inline void CSMail::set_mailhead(const char* value) {
  set_has_mailhead();
  if (mailhead_ == &::google::protobuf::internal::kEmptyString) {
    mailhead_ = new ::std::string;
  }
  mailhead_->assign(value);
}
inline void CSMail::set_mailhead(const char* value, size_t size) {
  set_has_mailhead();
  if (mailhead_ == &::google::protobuf::internal::kEmptyString) {
    mailhead_ = new ::std::string;
  }
  mailhead_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSMail::mutable_mailhead() {
  set_has_mailhead();
  if (mailhead_ == &::google::protobuf::internal::kEmptyString) {
    mailhead_ = new ::std::string;
  }
  return mailhead_;
}
inline ::std::string* CSMail::release_mailhead() {
  clear_has_mailhead();
  if (mailhead_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mailhead_;
    mailhead_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSMail::set_allocated_mailhead(::std::string* mailhead) {
  if (mailhead_ != &::google::protobuf::internal::kEmptyString) {
    delete mailhead_;
  }
  if (mailhead) {
    set_has_mailhead();
    mailhead_ = mailhead;
  } else {
    clear_has_mailhead();
    mailhead_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 Sender = 3;
inline bool CSMail::has_sender() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSMail::set_has_sender() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSMail::clear_has_sender() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSMail::clear_sender() {
  sender_ = GOOGLE_ULONGLONG(0);
  clear_has_sender();
}
inline ::google::protobuf::uint64 CSMail::sender() const {
  return sender_;
}
inline void CSMail::set_sender(::google::protobuf::uint64 value) {
  set_has_sender();
  sender_ = value;
}

// required int32 RemainTime = 4;
inline bool CSMail::has_remaintime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSMail::set_has_remaintime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSMail::clear_has_remaintime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSMail::clear_remaintime() {
  remaintime_ = 0;
  clear_has_remaintime();
}
inline ::google::protobuf::int32 CSMail::remaintime() const {
  return remaintime_;
}
inline void CSMail::set_remaintime(::google::protobuf::int32 value) {
  set_has_remaintime();
  remaintime_ = value;
}

// required int32 HadRead = 5;
inline bool CSMail::has_hadread() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSMail::set_has_hadread() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSMail::clear_has_hadread() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSMail::clear_hadread() {
  hadread_ = 0;
  clear_has_hadread();
}
inline ::google::protobuf::int32 CSMail::hadread() const {
  return hadread_;
}
inline void CSMail::set_hadread(::google::protobuf::int32 value) {
  set_has_hadread();
  hadread_ = value;
}

// required int32 HadGetAttach = 6;
inline bool CSMail::has_hadgetattach() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSMail::set_has_hadgetattach() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSMail::clear_has_hadgetattach() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSMail::clear_hadgetattach() {
  hadgetattach_ = 0;
  clear_has_hadgetattach();
}
inline ::google::protobuf::int32 CSMail::hadgetattach() const {
  return hadgetattach_;
}
inline void CSMail::set_hadgetattach(::google::protobuf::int32 value) {
  set_has_hadgetattach();
  hadgetattach_ = value;
}

// required int32 HasAttach = 7;
inline bool CSMail::has_hasattach() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSMail::set_has_hasattach() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSMail::clear_has_hasattach() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSMail::clear_hasattach() {
  hasattach_ = 0;
  clear_has_hasattach();
}
inline ::google::protobuf::int32 CSMail::hasattach() const {
  return hasattach_;
}
inline void CSMail::set_hasattach(::google::protobuf::int32 value) {
  set_has_hasattach();
  hasattach_ = value;
}

// required int32 TimeStamp = 8;
inline bool CSMail::has_timestamp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSMail::set_has_timestamp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSMail::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSMail::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline ::google::protobuf::int32 CSMail::timestamp() const {
  return timestamp_;
}
inline void CSMail::set_timestamp(::google::protobuf::int32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// CSMailSep

// required uint64 MailID = 1;
inline bool CSMailSep::has_mailid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMailSep::set_has_mailid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMailSep::clear_has_mailid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMailSep::clear_mailid() {
  mailid_ = GOOGLE_ULONGLONG(0);
  clear_has_mailid();
}
inline ::google::protobuf::uint64 CSMailSep::mailid() const {
  return mailid_;
}
inline void CSMailSep::set_mailid(::google::protobuf::uint64 value) {
  set_has_mailid();
  mailid_ = value;
}

// required int32 HadRead = 2;
inline bool CSMailSep::has_hadread() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMailSep::set_has_hadread() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMailSep::clear_has_hadread() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMailSep::clear_hadread() {
  hadread_ = 0;
  clear_has_hadread();
}
inline ::google::protobuf::int32 CSMailSep::hadread() const {
  return hadread_;
}
inline void CSMailSep::set_hadread(::google::protobuf::int32 value) {
  set_has_hadread();
  hadread_ = value;
}

// required int32 HadGetAttach = 3;
inline bool CSMailSep::has_hadgetattach() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSMailSep::set_has_hadgetattach() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSMailSep::clear_has_hadgetattach() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSMailSep::clear_hadgetattach() {
  hadgetattach_ = 0;
  clear_has_hadgetattach();
}
inline ::google::protobuf::int32 CSMailSep::hadgetattach() const {
  return hadgetattach_;
}
inline void CSMailSep::set_hadgetattach(::google::protobuf::int32 value) {
  set_has_hadgetattach();
  hadgetattach_ = value;
}

// -------------------------------------------------------------------

// CSGrpMailBreif

// required uint64 MailID = 1;
inline bool CSGrpMailBreif::has_mailid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGrpMailBreif::set_has_mailid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGrpMailBreif::clear_has_mailid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGrpMailBreif::clear_mailid() {
  mailid_ = GOOGLE_ULONGLONG(0);
  clear_has_mailid();
}
inline ::google::protobuf::uint64 CSGrpMailBreif::mailid() const {
  return mailid_;
}
inline void CSGrpMailBreif::set_mailid(::google::protobuf::uint64 value) {
  set_has_mailid();
  mailid_ = value;
}

// required uint64 Sender = 2;
inline bool CSGrpMailBreif::has_sender() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGrpMailBreif::set_has_sender() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGrpMailBreif::clear_has_sender() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGrpMailBreif::clear_sender() {
  sender_ = GOOGLE_ULONGLONG(0);
  clear_has_sender();
}
inline ::google::protobuf::uint64 CSGrpMailBreif::sender() const {
  return sender_;
}
inline void CSGrpMailBreif::set_sender(::google::protobuf::uint64 value) {
  set_has_sender();
  sender_ = value;
}

// required string MailHead = 3;
inline bool CSGrpMailBreif::has_mailhead() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSGrpMailBreif::set_has_mailhead() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSGrpMailBreif::clear_has_mailhead() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSGrpMailBreif::clear_mailhead() {
  if (mailhead_ != &::google::protobuf::internal::kEmptyString) {
    mailhead_->clear();
  }
  clear_has_mailhead();
}
inline const ::std::string& CSGrpMailBreif::mailhead() const {
  return *mailhead_;
}
inline void CSGrpMailBreif::set_mailhead(const ::std::string& value) {
  set_has_mailhead();
  if (mailhead_ == &::google::protobuf::internal::kEmptyString) {
    mailhead_ = new ::std::string;
  }
  mailhead_->assign(value);
}
inline void CSGrpMailBreif::set_mailhead(const char* value) {
  set_has_mailhead();
  if (mailhead_ == &::google::protobuf::internal::kEmptyString) {
    mailhead_ = new ::std::string;
  }
  mailhead_->assign(value);
}
inline void CSGrpMailBreif::set_mailhead(const char* value, size_t size) {
  set_has_mailhead();
  if (mailhead_ == &::google::protobuf::internal::kEmptyString) {
    mailhead_ = new ::std::string;
  }
  mailhead_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSGrpMailBreif::mutable_mailhead() {
  set_has_mailhead();
  if (mailhead_ == &::google::protobuf::internal::kEmptyString) {
    mailhead_ = new ::std::string;
  }
  return mailhead_;
}
inline ::std::string* CSGrpMailBreif::release_mailhead() {
  clear_has_mailhead();
  if (mailhead_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mailhead_;
    mailhead_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSGrpMailBreif::set_allocated_mailhead(::std::string* mailhead) {
  if (mailhead_ != &::google::protobuf::internal::kEmptyString) {
    delete mailhead_;
  }
  if (mailhead) {
    set_has_mailhead();
    mailhead_ = mailhead;
  } else {
    clear_has_mailhead();
    mailhead_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 RemainTime = 4;
inline bool CSGrpMailBreif::has_remaintime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSGrpMailBreif::set_has_remaintime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSGrpMailBreif::clear_has_remaintime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSGrpMailBreif::clear_remaintime() {
  remaintime_ = 0;
  clear_has_remaintime();
}
inline ::google::protobuf::int32 CSGrpMailBreif::remaintime() const {
  return remaintime_;
}
inline void CSGrpMailBreif::set_remaintime(::google::protobuf::int32 value) {
  set_has_remaintime();
  remaintime_ = value;
}

// required int32 HasAttach = 5;
inline bool CSGrpMailBreif::has_hasattach() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSGrpMailBreif::set_has_hasattach() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSGrpMailBreif::clear_has_hasattach() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSGrpMailBreif::clear_hasattach() {
  hasattach_ = 0;
  clear_has_hasattach();
}
inline ::google::protobuf::int32 CSGrpMailBreif::hasattach() const {
  return hasattach_;
}
inline void CSGrpMailBreif::set_hasattach(::google::protobuf::int32 value) {
  set_has_hasattach();
  hasattach_ = value;
}

// required int32 TimeStamp = 6;
inline bool CSGrpMailBreif::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSGrpMailBreif::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSGrpMailBreif::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSGrpMailBreif::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline ::google::protobuf::int32 CSGrpMailBreif::timestamp() const {
  return timestamp_;
}
inline void CSGrpMailBreif::set_timestamp(::google::protobuf::int32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// CSMailBox

// required uint64 GroupID = 1;
inline bool CSMailBox::has_groupid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMailBox::set_has_groupid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMailBox::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMailBox::clear_groupid() {
  groupid_ = GOOGLE_ULONGLONG(0);
  clear_has_groupid();
}
inline ::google::protobuf::uint64 CSMailBox::groupid() const {
  return groupid_;
}
inline void CSMailBox::set_groupid(::google::protobuf::uint64 value) {
  set_has_groupid();
  groupid_ = value;
}

// repeated .vmsg.CSMailSep MailSep = 2;
inline int CSMailBox::mailsep_size() const {
  return mailsep_.size();
}
inline void CSMailBox::clear_mailsep() {
  mailsep_.Clear();
}
inline const ::vmsg::CSMailSep& CSMailBox::mailsep(int index) const {
  return mailsep_.Get(index);
}
inline ::vmsg::CSMailSep* CSMailBox::mutable_mailsep(int index) {
  return mailsep_.Mutable(index);
}
inline ::vmsg::CSMailSep* CSMailBox::add_mailsep() {
  return mailsep_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailSep >&
CSMailBox::mailsep() const {
  return mailsep_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailSep >*
CSMailBox::mutable_mailsep() {
  return &mailsep_;
}

// repeated .vmsg.CSGrpMailBreif GrpMailLst = 3;
inline int CSMailBox::grpmaillst_size() const {
  return grpmaillst_.size();
}
inline void CSMailBox::clear_grpmaillst() {
  grpmaillst_.Clear();
}
inline const ::vmsg::CSGrpMailBreif& CSMailBox::grpmaillst(int index) const {
  return grpmaillst_.Get(index);
}
inline ::vmsg::CSGrpMailBreif* CSMailBox::mutable_grpmaillst(int index) {
  return grpmaillst_.Mutable(index);
}
inline ::vmsg::CSGrpMailBreif* CSMailBox::add_grpmaillst() {
  return grpmaillst_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSGrpMailBreif >&
CSMailBox::grpmaillst() const {
  return grpmaillst_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSGrpMailBreif >*
CSMailBox::mutable_grpmaillst() {
  return &grpmaillst_;
}

// -------------------------------------------------------------------

// CSQueryMailRsp

// repeated .vmsg.CSMail SelfMailLst = 1;
inline int CSQueryMailRsp::selfmaillst_size() const {
  return selfmaillst_.size();
}
inline void CSQueryMailRsp::clear_selfmaillst() {
  selfmaillst_.Clear();
}
inline const ::vmsg::CSMail& CSQueryMailRsp::selfmaillst(int index) const {
  return selfmaillst_.Get(index);
}
inline ::vmsg::CSMail* CSQueryMailRsp::mutable_selfmaillst(int index) {
  return selfmaillst_.Mutable(index);
}
inline ::vmsg::CSMail* CSQueryMailRsp::add_selfmaillst() {
  return selfmaillst_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSMail >&
CSQueryMailRsp::selfmaillst() const {
  return selfmaillst_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSMail >*
CSQueryMailRsp::mutable_selfmaillst() {
  return &selfmaillst_;
}

// repeated .vmsg.CSMailBox MailBox = 2;
inline int CSQueryMailRsp::mailbox_size() const {
  return mailbox_.size();
}
inline void CSQueryMailRsp::clear_mailbox() {
  mailbox_.Clear();
}
inline const ::vmsg::CSMailBox& CSQueryMailRsp::mailbox(int index) const {
  return mailbox_.Get(index);
}
inline ::vmsg::CSMailBox* CSQueryMailRsp::mutable_mailbox(int index) {
  return mailbox_.Mutable(index);
}
inline ::vmsg::CSMailBox* CSQueryMailRsp::add_mailbox() {
  return mailbox_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailBox >&
CSQueryMailRsp::mailbox() const {
  return mailbox_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailBox >*
CSQueryMailRsp::mutable_mailbox() {
  return &mailbox_;
}

// -------------------------------------------------------------------

// CSReadMailRqst

// required uint64 MailID = 1;
inline bool CSReadMailRqst::has_mailid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSReadMailRqst::set_has_mailid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSReadMailRqst::clear_has_mailid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSReadMailRqst::clear_mailid() {
  mailid_ = GOOGLE_ULONGLONG(0);
  clear_has_mailid();
}
inline ::google::protobuf::uint64 CSReadMailRqst::mailid() const {
  return mailid_;
}
inline void CSReadMailRqst::set_mailid(::google::protobuf::uint64 value) {
  set_has_mailid();
  mailid_ = value;
}

// required uint64 GroupID = 2;
inline bool CSReadMailRqst::has_groupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSReadMailRqst::set_has_groupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSReadMailRqst::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSReadMailRqst::clear_groupid() {
  groupid_ = GOOGLE_ULONGLONG(0);
  clear_has_groupid();
}
inline ::google::protobuf::uint64 CSReadMailRqst::groupid() const {
  return groupid_;
}
inline void CSReadMailRqst::set_groupid(::google::protobuf::uint64 value) {
  set_has_groupid();
  groupid_ = value;
}

// -------------------------------------------------------------------

// CSOneMail

// required uint64 MailID = 1;
inline bool CSOneMail::has_mailid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSOneMail::set_has_mailid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSOneMail::clear_has_mailid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSOneMail::clear_mailid() {
  mailid_ = GOOGLE_ULONGLONG(0);
  clear_has_mailid();
}
inline ::google::protobuf::uint64 CSOneMail::mailid() const {
  return mailid_;
}
inline void CSOneMail::set_mailid(::google::protobuf::uint64 value) {
  set_has_mailid();
  mailid_ = value;
}

// required uint64 GroupID = 2;
inline bool CSOneMail::has_groupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSOneMail::set_has_groupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSOneMail::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSOneMail::clear_groupid() {
  groupid_ = GOOGLE_ULONGLONG(0);
  clear_has_groupid();
}
inline ::google::protobuf::uint64 CSOneMail::groupid() const {
  return groupid_;
}
inline void CSOneMail::set_groupid(::google::protobuf::uint64 value) {
  set_has_groupid();
  groupid_ = value;
}

// -------------------------------------------------------------------

// CSGetAttachRqst

// repeated .vmsg.CSOneMail MailLst = 1;
inline int CSGetAttachRqst::maillst_size() const {
  return maillst_.size();
}
inline void CSGetAttachRqst::clear_maillst() {
  maillst_.Clear();
}
inline const ::vmsg::CSOneMail& CSGetAttachRqst::maillst(int index) const {
  return maillst_.Get(index);
}
inline ::vmsg::CSOneMail* CSGetAttachRqst::mutable_maillst(int index) {
  return maillst_.Mutable(index);
}
inline ::vmsg::CSOneMail* CSGetAttachRqst::add_maillst() {
  return maillst_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSOneMail >&
CSGetAttachRqst::maillst() const {
  return maillst_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSOneMail >*
CSGetAttachRqst::mutable_maillst() {
  return &maillst_;
}

// -------------------------------------------------------------------

// CSGetAttachRsp

// repeated uint64 MailIDLst = 1;
inline int CSGetAttachRsp::mailidlst_size() const {
  return mailidlst_.size();
}
inline void CSGetAttachRsp::clear_mailidlst() {
  mailidlst_.Clear();
}
inline ::google::protobuf::uint64 CSGetAttachRsp::mailidlst(int index) const {
  return mailidlst_.Get(index);
}
inline void CSGetAttachRsp::set_mailidlst(int index, ::google::protobuf::uint64 value) {
  mailidlst_.Set(index, value);
}
inline void CSGetAttachRsp::add_mailidlst(::google::protobuf::uint64 value) {
  mailidlst_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
CSGetAttachRsp::mailidlst() const {
  return mailidlst_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
CSGetAttachRsp::mutable_mailidlst() {
  return &mailidlst_;
}

// -------------------------------------------------------------------

// CSDeleteMailRqst

// required uint64 MailID = 1;
inline bool CSDeleteMailRqst::has_mailid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDeleteMailRqst::set_has_mailid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDeleteMailRqst::clear_has_mailid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDeleteMailRqst::clear_mailid() {
  mailid_ = GOOGLE_ULONGLONG(0);
  clear_has_mailid();
}
inline ::google::protobuf::uint64 CSDeleteMailRqst::mailid() const {
  return mailid_;
}
inline void CSDeleteMailRqst::set_mailid(::google::protobuf::uint64 value) {
  set_has_mailid();
  mailid_ = value;
}

// required uint64 GroupID = 2;
inline bool CSDeleteMailRqst::has_groupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSDeleteMailRqst::set_has_groupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSDeleteMailRqst::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSDeleteMailRqst::clear_groupid() {
  groupid_ = GOOGLE_ULONGLONG(0);
  clear_has_groupid();
}
inline ::google::protobuf::uint64 CSDeleteMailRqst::groupid() const {
  return groupid_;
}
inline void CSDeleteMailRqst::set_groupid(::google::protobuf::uint64 value) {
  set_has_groupid();
  groupid_ = value;
}

// -------------------------------------------------------------------

// CSDeleteMailRsp

// required uint64 MailID = 1;
inline bool CSDeleteMailRsp::has_mailid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDeleteMailRsp::set_has_mailid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDeleteMailRsp::clear_has_mailid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDeleteMailRsp::clear_mailid() {
  mailid_ = GOOGLE_ULONGLONG(0);
  clear_has_mailid();
}
inline ::google::protobuf::uint64 CSDeleteMailRsp::mailid() const {
  return mailid_;
}
inline void CSDeleteMailRsp::set_mailid(::google::protobuf::uint64 value) {
  set_has_mailid();
  mailid_ = value;
}

// -------------------------------------------------------------------

// CSReadMailRsp

// required uint64 MailID = 1;
inline bool CSReadMailRsp::has_mailid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSReadMailRsp::set_has_mailid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSReadMailRsp::clear_has_mailid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSReadMailRsp::clear_mailid() {
  mailid_ = GOOGLE_ULONGLONG(0);
  clear_has_mailid();
}
inline ::google::protobuf::uint64 CSReadMailRsp::mailid() const {
  return mailid_;
}
inline void CSReadMailRsp::set_mailid(::google::protobuf::uint64 value) {
  set_has_mailid();
  mailid_ = value;
}

// required bytes MailBody = 3;
inline bool CSReadMailRsp::has_mailbody() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSReadMailRsp::set_has_mailbody() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSReadMailRsp::clear_has_mailbody() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSReadMailRsp::clear_mailbody() {
  if (mailbody_ != &::google::protobuf::internal::kEmptyString) {
    mailbody_->clear();
  }
  clear_has_mailbody();
}
inline const ::std::string& CSReadMailRsp::mailbody() const {
  return *mailbody_;
}
inline void CSReadMailRsp::set_mailbody(const ::std::string& value) {
  set_has_mailbody();
  if (mailbody_ == &::google::protobuf::internal::kEmptyString) {
    mailbody_ = new ::std::string;
  }
  mailbody_->assign(value);
}
inline void CSReadMailRsp::set_mailbody(const char* value) {
  set_has_mailbody();
  if (mailbody_ == &::google::protobuf::internal::kEmptyString) {
    mailbody_ = new ::std::string;
  }
  mailbody_->assign(value);
}
inline void CSReadMailRsp::set_mailbody(const void* value, size_t size) {
  set_has_mailbody();
  if (mailbody_ == &::google::protobuf::internal::kEmptyString) {
    mailbody_ = new ::std::string;
  }
  mailbody_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSReadMailRsp::mutable_mailbody() {
  set_has_mailbody();
  if (mailbody_ == &::google::protobuf::internal::kEmptyString) {
    mailbody_ = new ::std::string;
  }
  return mailbody_;
}
inline ::std::string* CSReadMailRsp::release_mailbody() {
  clear_has_mailbody();
  if (mailbody_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mailbody_;
    mailbody_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSReadMailRsp::set_allocated_mailbody(::std::string* mailbody) {
  if (mailbody_ != &::google::protobuf::internal::kEmptyString) {
    delete mailbody_;
  }
  if (mailbody) {
    set_has_mailbody();
    mailbody_ = mailbody;
  } else {
    clear_has_mailbody();
    mailbody_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .vmsg.CSMailAttach Attach = 4;
inline int CSReadMailRsp::attach_size() const {
  return attach_.size();
}
inline void CSReadMailRsp::clear_attach() {
  attach_.Clear();
}
inline const ::vmsg::CSMailAttach& CSReadMailRsp::attach(int index) const {
  return attach_.Get(index);
}
inline ::vmsg::CSMailAttach* CSReadMailRsp::mutable_attach(int index) {
  return attach_.Mutable(index);
}
inline ::vmsg::CSMailAttach* CSReadMailRsp::add_attach() {
  return attach_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailAttach >&
CSReadMailRsp::attach() const {
  return attach_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailAttach >*
CSReadMailRsp::mutable_attach() {
  return &attach_;
}

// -------------------------------------------------------------------

// CSMailRequest

// optional .vmsg.CSReadMailRqst ReadMail_Rqst = 1;
inline bool CSMailRequest::has_readmail_rqst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMailRequest::set_has_readmail_rqst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMailRequest::clear_has_readmail_rqst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMailRequest::clear_readmail_rqst() {
  if (readmail_rqst_ != NULL) readmail_rqst_->::vmsg::CSReadMailRqst::Clear();
  clear_has_readmail_rqst();
}
inline const ::vmsg::CSReadMailRqst& CSMailRequest::readmail_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return readmail_rqst_ != NULL ? *readmail_rqst_ : *default_instance().readmail_rqst_;
#else
  return readmail_rqst_ != NULL ? *readmail_rqst_ : *default_instance_->readmail_rqst_;
#endif
}
inline ::vmsg::CSReadMailRqst* CSMailRequest::mutable_readmail_rqst() {
  set_has_readmail_rqst();
  if (readmail_rqst_ == NULL) readmail_rqst_ = new ::vmsg::CSReadMailRqst;
  return readmail_rqst_;
}
inline ::vmsg::CSReadMailRqst* CSMailRequest::release_readmail_rqst() {
  clear_has_readmail_rqst();
  ::vmsg::CSReadMailRqst* temp = readmail_rqst_;
  readmail_rqst_ = NULL;
  return temp;
}
inline void CSMailRequest::set_allocated_readmail_rqst(::vmsg::CSReadMailRqst* readmail_rqst) {
  delete readmail_rqst_;
  readmail_rqst_ = readmail_rqst;
  if (readmail_rqst) {
    set_has_readmail_rqst();
  } else {
    clear_has_readmail_rqst();
  }
}

// optional .vmsg.CSGetAttachRqst GetAttach_Rqst = 2;
inline bool CSMailRequest::has_getattach_rqst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMailRequest::set_has_getattach_rqst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMailRequest::clear_has_getattach_rqst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMailRequest::clear_getattach_rqst() {
  if (getattach_rqst_ != NULL) getattach_rqst_->::vmsg::CSGetAttachRqst::Clear();
  clear_has_getattach_rqst();
}
inline const ::vmsg::CSGetAttachRqst& CSMailRequest::getattach_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getattach_rqst_ != NULL ? *getattach_rqst_ : *default_instance().getattach_rqst_;
#else
  return getattach_rqst_ != NULL ? *getattach_rqst_ : *default_instance_->getattach_rqst_;
#endif
}
inline ::vmsg::CSGetAttachRqst* CSMailRequest::mutable_getattach_rqst() {
  set_has_getattach_rqst();
  if (getattach_rqst_ == NULL) getattach_rqst_ = new ::vmsg::CSGetAttachRqst;
  return getattach_rqst_;
}
inline ::vmsg::CSGetAttachRqst* CSMailRequest::release_getattach_rqst() {
  clear_has_getattach_rqst();
  ::vmsg::CSGetAttachRqst* temp = getattach_rqst_;
  getattach_rqst_ = NULL;
  return temp;
}
inline void CSMailRequest::set_allocated_getattach_rqst(::vmsg::CSGetAttachRqst* getattach_rqst) {
  delete getattach_rqst_;
  getattach_rqst_ = getattach_rqst;
  if (getattach_rqst) {
    set_has_getattach_rqst();
  } else {
    clear_has_getattach_rqst();
  }
}

// optional .vmsg.CSDeleteMailRqst DeleteMail_Rqst = 3;
inline bool CSMailRequest::has_deletemail_rqst() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSMailRequest::set_has_deletemail_rqst() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSMailRequest::clear_has_deletemail_rqst() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSMailRequest::clear_deletemail_rqst() {
  if (deletemail_rqst_ != NULL) deletemail_rqst_->::vmsg::CSDeleteMailRqst::Clear();
  clear_has_deletemail_rqst();
}
inline const ::vmsg::CSDeleteMailRqst& CSMailRequest::deletemail_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return deletemail_rqst_ != NULL ? *deletemail_rqst_ : *default_instance().deletemail_rqst_;
#else
  return deletemail_rqst_ != NULL ? *deletemail_rqst_ : *default_instance_->deletemail_rqst_;
#endif
}
inline ::vmsg::CSDeleteMailRqst* CSMailRequest::mutable_deletemail_rqst() {
  set_has_deletemail_rqst();
  if (deletemail_rqst_ == NULL) deletemail_rqst_ = new ::vmsg::CSDeleteMailRqst;
  return deletemail_rqst_;
}
inline ::vmsg::CSDeleteMailRqst* CSMailRequest::release_deletemail_rqst() {
  clear_has_deletemail_rqst();
  ::vmsg::CSDeleteMailRqst* temp = deletemail_rqst_;
  deletemail_rqst_ = NULL;
  return temp;
}
inline void CSMailRequest::set_allocated_deletemail_rqst(::vmsg::CSDeleteMailRqst* deletemail_rqst) {
  delete deletemail_rqst_;
  deletemail_rqst_ = deletemail_rqst;
  if (deletemail_rqst) {
    set_has_deletemail_rqst();
  } else {
    clear_has_deletemail_rqst();
  }
}

// -------------------------------------------------------------------

// CSMailRespond

// optional .vmsg.CSQueryMailRsp QueryMail_Rsp = 1;
inline bool CSMailRespond::has_querymail_rsp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMailRespond::set_has_querymail_rsp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMailRespond::clear_has_querymail_rsp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMailRespond::clear_querymail_rsp() {
  if (querymail_rsp_ != NULL) querymail_rsp_->::vmsg::CSQueryMailRsp::Clear();
  clear_has_querymail_rsp();
}
inline const ::vmsg::CSQueryMailRsp& CSMailRespond::querymail_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return querymail_rsp_ != NULL ? *querymail_rsp_ : *default_instance().querymail_rsp_;
#else
  return querymail_rsp_ != NULL ? *querymail_rsp_ : *default_instance_->querymail_rsp_;
#endif
}
inline ::vmsg::CSQueryMailRsp* CSMailRespond::mutable_querymail_rsp() {
  set_has_querymail_rsp();
  if (querymail_rsp_ == NULL) querymail_rsp_ = new ::vmsg::CSQueryMailRsp;
  return querymail_rsp_;
}
inline ::vmsg::CSQueryMailRsp* CSMailRespond::release_querymail_rsp() {
  clear_has_querymail_rsp();
  ::vmsg::CSQueryMailRsp* temp = querymail_rsp_;
  querymail_rsp_ = NULL;
  return temp;
}
inline void CSMailRespond::set_allocated_querymail_rsp(::vmsg::CSQueryMailRsp* querymail_rsp) {
  delete querymail_rsp_;
  querymail_rsp_ = querymail_rsp;
  if (querymail_rsp) {
    set_has_querymail_rsp();
  } else {
    clear_has_querymail_rsp();
  }
}

// optional .vmsg.CSReadMailRsp ReadMail_Rsp = 2;
inline bool CSMailRespond::has_readmail_rsp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMailRespond::set_has_readmail_rsp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMailRespond::clear_has_readmail_rsp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMailRespond::clear_readmail_rsp() {
  if (readmail_rsp_ != NULL) readmail_rsp_->::vmsg::CSReadMailRsp::Clear();
  clear_has_readmail_rsp();
}
inline const ::vmsg::CSReadMailRsp& CSMailRespond::readmail_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return readmail_rsp_ != NULL ? *readmail_rsp_ : *default_instance().readmail_rsp_;
#else
  return readmail_rsp_ != NULL ? *readmail_rsp_ : *default_instance_->readmail_rsp_;
#endif
}
inline ::vmsg::CSReadMailRsp* CSMailRespond::mutable_readmail_rsp() {
  set_has_readmail_rsp();
  if (readmail_rsp_ == NULL) readmail_rsp_ = new ::vmsg::CSReadMailRsp;
  return readmail_rsp_;
}
inline ::vmsg::CSReadMailRsp* CSMailRespond::release_readmail_rsp() {
  clear_has_readmail_rsp();
  ::vmsg::CSReadMailRsp* temp = readmail_rsp_;
  readmail_rsp_ = NULL;
  return temp;
}
inline void CSMailRespond::set_allocated_readmail_rsp(::vmsg::CSReadMailRsp* readmail_rsp) {
  delete readmail_rsp_;
  readmail_rsp_ = readmail_rsp;
  if (readmail_rsp) {
    set_has_readmail_rsp();
  } else {
    clear_has_readmail_rsp();
  }
}

// optional .vmsg.CSGetAttachRsp GetAttach_Rsp = 3;
inline bool CSMailRespond::has_getattach_rsp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSMailRespond::set_has_getattach_rsp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSMailRespond::clear_has_getattach_rsp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSMailRespond::clear_getattach_rsp() {
  if (getattach_rsp_ != NULL) getattach_rsp_->::vmsg::CSGetAttachRsp::Clear();
  clear_has_getattach_rsp();
}
inline const ::vmsg::CSGetAttachRsp& CSMailRespond::getattach_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getattach_rsp_ != NULL ? *getattach_rsp_ : *default_instance().getattach_rsp_;
#else
  return getattach_rsp_ != NULL ? *getattach_rsp_ : *default_instance_->getattach_rsp_;
#endif
}
inline ::vmsg::CSGetAttachRsp* CSMailRespond::mutable_getattach_rsp() {
  set_has_getattach_rsp();
  if (getattach_rsp_ == NULL) getattach_rsp_ = new ::vmsg::CSGetAttachRsp;
  return getattach_rsp_;
}
inline ::vmsg::CSGetAttachRsp* CSMailRespond::release_getattach_rsp() {
  clear_has_getattach_rsp();
  ::vmsg::CSGetAttachRsp* temp = getattach_rsp_;
  getattach_rsp_ = NULL;
  return temp;
}
inline void CSMailRespond::set_allocated_getattach_rsp(::vmsg::CSGetAttachRsp* getattach_rsp) {
  delete getattach_rsp_;
  getattach_rsp_ = getattach_rsp;
  if (getattach_rsp) {
    set_has_getattach_rsp();
  } else {
    clear_has_getattach_rsp();
  }
}

// optional .vmsg.CSDeleteMailRsp DeleteMail_Rsp = 4;
inline bool CSMailRespond::has_deletemail_rsp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSMailRespond::set_has_deletemail_rsp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSMailRespond::clear_has_deletemail_rsp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSMailRespond::clear_deletemail_rsp() {
  if (deletemail_rsp_ != NULL) deletemail_rsp_->::vmsg::CSDeleteMailRsp::Clear();
  clear_has_deletemail_rsp();
}
inline const ::vmsg::CSDeleteMailRsp& CSMailRespond::deletemail_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return deletemail_rsp_ != NULL ? *deletemail_rsp_ : *default_instance().deletemail_rsp_;
#else
  return deletemail_rsp_ != NULL ? *deletemail_rsp_ : *default_instance_->deletemail_rsp_;
#endif
}
inline ::vmsg::CSDeleteMailRsp* CSMailRespond::mutable_deletemail_rsp() {
  set_has_deletemail_rsp();
  if (deletemail_rsp_ == NULL) deletemail_rsp_ = new ::vmsg::CSDeleteMailRsp;
  return deletemail_rsp_;
}
inline ::vmsg::CSDeleteMailRsp* CSMailRespond::release_deletemail_rsp() {
  clear_has_deletemail_rsp();
  ::vmsg::CSDeleteMailRsp* temp = deletemail_rsp_;
  deletemail_rsp_ = NULL;
  return temp;
}
inline void CSMailRespond::set_allocated_deletemail_rsp(::vmsg::CSDeleteMailRsp* deletemail_rsp) {
  delete deletemail_rsp_;
  deletemail_rsp_ = deletemail_rsp;
  if (deletemail_rsp) {
    set_has_deletemail_rsp();
  } else {
    clear_has_deletemail_rsp();
  }
}

// optional .vmsg.CSQueryMailRsp DeleteAll_Rsp = 5;
inline bool CSMailRespond::has_deleteall_rsp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSMailRespond::set_has_deleteall_rsp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSMailRespond::clear_has_deleteall_rsp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSMailRespond::clear_deleteall_rsp() {
  if (deleteall_rsp_ != NULL) deleteall_rsp_->::vmsg::CSQueryMailRsp::Clear();
  clear_has_deleteall_rsp();
}
inline const ::vmsg::CSQueryMailRsp& CSMailRespond::deleteall_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return deleteall_rsp_ != NULL ? *deleteall_rsp_ : *default_instance().deleteall_rsp_;
#else
  return deleteall_rsp_ != NULL ? *deleteall_rsp_ : *default_instance_->deleteall_rsp_;
#endif
}
inline ::vmsg::CSQueryMailRsp* CSMailRespond::mutable_deleteall_rsp() {
  set_has_deleteall_rsp();
  if (deleteall_rsp_ == NULL) deleteall_rsp_ = new ::vmsg::CSQueryMailRsp;
  return deleteall_rsp_;
}
inline ::vmsg::CSQueryMailRsp* CSMailRespond::release_deleteall_rsp() {
  clear_has_deleteall_rsp();
  ::vmsg::CSQueryMailRsp* temp = deleteall_rsp_;
  deleteall_rsp_ = NULL;
  return temp;
}
inline void CSMailRespond::set_allocated_deleteall_rsp(::vmsg::CSQueryMailRsp* deleteall_rsp) {
  delete deleteall_rsp_;
  deleteall_rsp_ = deleteall_rsp;
  if (deleteall_rsp) {
    set_has_deleteall_rsp();
  } else {
    clear_has_deleteall_rsp();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CSMailMsg_2eproto__INCLUDED
