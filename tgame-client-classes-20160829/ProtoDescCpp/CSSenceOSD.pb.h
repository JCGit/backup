// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSSenceOSD.proto

#ifndef PROTOBUF_CSSenceOSD_2eproto__INCLUDED
#define PROTOBUF_CSSenceOSD_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MsgBase.pb.h"
// @@protoc_insertion_point(includes)

namespace vmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CSSenceOSD_2eproto();
void protobuf_AssignDesc_CSSenceOSD_2eproto();
void protobuf_ShutdownFile_CSSenceOSD_2eproto();

class CSPlayerCommInScene;
class CSScenePoint;
class CSPlayerPosInScene;
class CSPlayerMoveInScene;
class CSPlayerSetPosInScene;
class CSPlayerStartAtk;
class CSPlayerStopAtk;
class CSPlayerSkillInScene;
class CSPlayerStatChangeInScene;
class CSPlayerOSDInfo;
class CSOSDMonstersInfo;
class CSQueryPlayerSceneOSDInfoRsp;
class CSSyncPlayerOSDInfo;
class CSPlayerChangeSceneRqst;
class CSSceneOSDRequest;
class CSSceneOSDRespond;

enum PLAYER_STAT_IN_SCENE {
  PLAYER_IN_SCENE_NORM = 0,
  PLAYER_IN_SCENE_DEAD = 1
};
bool PLAYER_STAT_IN_SCENE_IsValid(int value);
const PLAYER_STAT_IN_SCENE PLAYER_STAT_IN_SCENE_MIN = PLAYER_IN_SCENE_NORM;
const PLAYER_STAT_IN_SCENE PLAYER_STAT_IN_SCENE_MAX = PLAYER_IN_SCENE_DEAD;
const int PLAYER_STAT_IN_SCENE_ARRAYSIZE = PLAYER_STAT_IN_SCENE_MAX + 1;

enum PLAYER_ACTION_IN_SCENE {
  PLAYER_ACTION_IN_SCENE_ENTER = 1,
  PLAYER_ACTION_IN_SCENE_LEAVE = 2,
  PLAYER_ACTION_IN_SCENE_MOVE = 3,
  PLAYER_ACTION_IN_SCENE_SET = 4,
  PLAYER_ACTION_IN_SCENE_STARTATK = 5,
  PLAYER_ACTION_IN_SCENE_STOPATK = 6,
  PLAYER_ACTION_IN_SCENE_SKILL = 7
};
bool PLAYER_ACTION_IN_SCENE_IsValid(int value);
const PLAYER_ACTION_IN_SCENE PLAYER_ACTION_IN_SCENE_MIN = PLAYER_ACTION_IN_SCENE_ENTER;
const PLAYER_ACTION_IN_SCENE PLAYER_ACTION_IN_SCENE_MAX = PLAYER_ACTION_IN_SCENE_SKILL;
const int PLAYER_ACTION_IN_SCENE_ARRAYSIZE = PLAYER_ACTION_IN_SCENE_MAX + 1;

enum MONSTER_ACTION_SCENE {
  MONSTER_ACTION_SCENE_WALK = 1,
  MONSTER_ACTION_SCENE_HIT = 2
};
bool MONSTER_ACTION_SCENE_IsValid(int value);
const MONSTER_ACTION_SCENE MONSTER_ACTION_SCENE_MIN = MONSTER_ACTION_SCENE_WALK;
const MONSTER_ACTION_SCENE MONSTER_ACTION_SCENE_MAX = MONSTER_ACTION_SCENE_HIT;
const int MONSTER_ACTION_SCENE_ARRAYSIZE = MONSTER_ACTION_SCENE_MAX + 1;

// ===================================================================

class CSPlayerCommInScene : public ::google::protobuf::MessageLite {
 public:
  CSPlayerCommInScene();
  virtual ~CSPlayerCommInScene();

  CSPlayerCommInScene(const CSPlayerCommInScene& from);

  inline CSPlayerCommInScene& operator=(const CSPlayerCommInScene& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerCommInScene& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerCommInScene* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerCommInScene* other);

  // implements Message ----------------------------------------------

  CSPlayerCommInScene* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerCommInScene& from);
  void MergeFrom(const CSPlayerCommInScene& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // required string Nick = 2;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 2;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // required uint32 WeaponCfgID = 3;
  inline bool has_weaponcfgid() const;
  inline void clear_weaponcfgid();
  static const int kWeaponCfgIDFieldNumber = 3;
  inline ::google::protobuf::uint32 weaponcfgid() const;
  inline void set_weaponcfgid(::google::protobuf::uint32 value);

  // required uint32 ShowID = 4;
  inline bool has_showid() const;
  inline void clear_showid();
  static const int kShowIDFieldNumber = 4;
  inline ::google::protobuf::uint32 showid() const;
  inline void set_showid(::google::protobuf::uint32 value);

  // required uint32 VipLvl = 5;
  inline bool has_viplvl() const;
  inline void clear_viplvl();
  static const int kVipLvlFieldNumber = 5;
  inline ::google::protobuf::uint32 viplvl() const;
  inline void set_viplvl(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerCommInScene)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_weaponcfgid();
  inline void clear_has_weaponcfgid();
  inline void set_has_showid();
  inline void clear_has_showid();
  inline void set_has_viplvl();
  inline void clear_has_viplvl();

  ::google::protobuf::uint64 uin_;
  ::std::string* nick_;
  ::google::protobuf::uint32 weaponcfgid_;
  ::google::protobuf::uint32 showid_;
  ::google::protobuf::uint32 viplvl_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSSenceOSD_2eproto();
  friend void protobuf_ShutdownFile_CSSenceOSD_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerCommInScene* default_instance_;
};
// -------------------------------------------------------------------

class CSScenePoint : public ::google::protobuf::MessageLite {
 public:
  CSScenePoint();
  virtual ~CSScenePoint();

  CSScenePoint(const CSScenePoint& from);

  inline CSScenePoint& operator=(const CSScenePoint& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSScenePoint& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSScenePoint* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSScenePoint* other);

  // implements Message ----------------------------------------------

  CSScenePoint* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSScenePoint& from);
  void MergeFrom(const CSScenePoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 XPos = 1;
  inline bool has_xpos() const;
  inline void clear_xpos();
  static const int kXPosFieldNumber = 1;
  inline ::google::protobuf::int32 xpos() const;
  inline void set_xpos(::google::protobuf::int32 value);

  // required int32 YPos = 2;
  inline bool has_ypos() const;
  inline void clear_ypos();
  static const int kYPosFieldNumber = 2;
  inline ::google::protobuf::int32 ypos() const;
  inline void set_ypos(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSScenePoint)
 private:
  inline void set_has_xpos();
  inline void clear_has_xpos();
  inline void set_has_ypos();
  inline void clear_has_ypos();

  ::google::protobuf::int32 xpos_;
  ::google::protobuf::int32 ypos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSSenceOSD_2eproto();
  friend void protobuf_ShutdownFile_CSSenceOSD_2eproto();

  void InitAsDefaultInstance();
  static CSScenePoint* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerPosInScene : public ::google::protobuf::MessageLite {
 public:
  CSPlayerPosInScene();
  virtual ~CSPlayerPosInScene();

  CSPlayerPosInScene(const CSPlayerPosInScene& from);

  inline CSPlayerPosInScene& operator=(const CSPlayerPosInScene& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerPosInScene& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerPosInScene* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerPosInScene* other);

  // implements Message ----------------------------------------------

  CSPlayerPosInScene* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerPosInScene& from);
  void MergeFrom(const CSPlayerPosInScene& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSPlayerCommInScene Comm = 1;
  inline bool has_comm() const;
  inline void clear_comm();
  static const int kCommFieldNumber = 1;
  inline const ::vmsg::CSPlayerCommInScene& comm() const;
  inline ::vmsg::CSPlayerCommInScene* mutable_comm();
  inline ::vmsg::CSPlayerCommInScene* release_comm();
  inline void set_allocated_comm(::vmsg::CSPlayerCommInScene* comm);

  // optional .vmsg.CSScenePoint ScenePoint = 2;
  inline bool has_scenepoint() const;
  inline void clear_scenepoint();
  static const int kScenePointFieldNumber = 2;
  inline const ::vmsg::CSScenePoint& scenepoint() const;
  inline ::vmsg::CSScenePoint* mutable_scenepoint();
  inline ::vmsg::CSScenePoint* release_scenepoint();
  inline void set_allocated_scenepoint(::vmsg::CSScenePoint* scenepoint);

  // required .vmsg.CSScenePoint Direct = 3;
  inline bool has_direct() const;
  inline void clear_direct();
  static const int kDirectFieldNumber = 3;
  inline const ::vmsg::CSScenePoint& direct() const;
  inline ::vmsg::CSScenePoint* mutable_direct();
  inline ::vmsg::CSScenePoint* release_direct();
  inline void set_allocated_direct(::vmsg::CSScenePoint* direct);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerPosInScene)
 private:
  inline void set_has_comm();
  inline void clear_has_comm();
  inline void set_has_scenepoint();
  inline void clear_has_scenepoint();
  inline void set_has_direct();
  inline void clear_has_direct();

  ::vmsg::CSPlayerCommInScene* comm_;
  ::vmsg::CSScenePoint* scenepoint_;
  ::vmsg::CSScenePoint* direct_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSSenceOSD_2eproto();
  friend void protobuf_ShutdownFile_CSSenceOSD_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerPosInScene* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerMoveInScene : public ::google::protobuf::MessageLite {
 public:
  CSPlayerMoveInScene();
  virtual ~CSPlayerMoveInScene();

  CSPlayerMoveInScene(const CSPlayerMoveInScene& from);

  inline CSPlayerMoveInScene& operator=(const CSPlayerMoveInScene& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerMoveInScene& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerMoveInScene* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerMoveInScene* other);

  // implements Message ----------------------------------------------

  CSPlayerMoveInScene* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerMoveInScene& from);
  void MergeFrom(const CSPlayerMoveInScene& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // required .vmsg.CSScenePoint Direct = 2;
  inline bool has_direct() const;
  inline void clear_direct();
  static const int kDirectFieldNumber = 2;
  inline const ::vmsg::CSScenePoint& direct() const;
  inline ::vmsg::CSScenePoint* mutable_direct();
  inline ::vmsg::CSScenePoint* release_direct();
  inline void set_allocated_direct(::vmsg::CSScenePoint* direct);

  // required .vmsg.CSScenePoint ScenePoint = 3;
  inline bool has_scenepoint() const;
  inline void clear_scenepoint();
  static const int kScenePointFieldNumber = 3;
  inline const ::vmsg::CSScenePoint& scenepoint() const;
  inline ::vmsg::CSScenePoint* mutable_scenepoint();
  inline ::vmsg::CSScenePoint* release_scenepoint();
  inline void set_allocated_scenepoint(::vmsg::CSScenePoint* scenepoint);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerMoveInScene)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_direct();
  inline void clear_has_direct();
  inline void set_has_scenepoint();
  inline void clear_has_scenepoint();

  ::google::protobuf::uint64 uin_;
  ::vmsg::CSScenePoint* direct_;
  ::vmsg::CSScenePoint* scenepoint_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSSenceOSD_2eproto();
  friend void protobuf_ShutdownFile_CSSenceOSD_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerMoveInScene* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerSetPosInScene : public ::google::protobuf::MessageLite {
 public:
  CSPlayerSetPosInScene();
  virtual ~CSPlayerSetPosInScene();

  CSPlayerSetPosInScene(const CSPlayerSetPosInScene& from);

  inline CSPlayerSetPosInScene& operator=(const CSPlayerSetPosInScene& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerSetPosInScene& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerSetPosInScene* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerSetPosInScene* other);

  // implements Message ----------------------------------------------

  CSPlayerSetPosInScene* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerSetPosInScene& from);
  void MergeFrom(const CSPlayerSetPosInScene& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // required .vmsg.CSScenePoint Direct = 2;
  inline bool has_direct() const;
  inline void clear_direct();
  static const int kDirectFieldNumber = 2;
  inline const ::vmsg::CSScenePoint& direct() const;
  inline ::vmsg::CSScenePoint* mutable_direct();
  inline ::vmsg::CSScenePoint* release_direct();
  inline void set_allocated_direct(::vmsg::CSScenePoint* direct);

  // required .vmsg.CSScenePoint ScenePoint = 3;
  inline bool has_scenepoint() const;
  inline void clear_scenepoint();
  static const int kScenePointFieldNumber = 3;
  inline const ::vmsg::CSScenePoint& scenepoint() const;
  inline ::vmsg::CSScenePoint* mutable_scenepoint();
  inline ::vmsg::CSScenePoint* release_scenepoint();
  inline void set_allocated_scenepoint(::vmsg::CSScenePoint* scenepoint);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerSetPosInScene)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_direct();
  inline void clear_has_direct();
  inline void set_has_scenepoint();
  inline void clear_has_scenepoint();

  ::google::protobuf::uint64 uin_;
  ::vmsg::CSScenePoint* direct_;
  ::vmsg::CSScenePoint* scenepoint_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSSenceOSD_2eproto();
  friend void protobuf_ShutdownFile_CSSenceOSD_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerSetPosInScene* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerStartAtk : public ::google::protobuf::MessageLite {
 public:
  CSPlayerStartAtk();
  virtual ~CSPlayerStartAtk();

  CSPlayerStartAtk(const CSPlayerStartAtk& from);

  inline CSPlayerStartAtk& operator=(const CSPlayerStartAtk& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerStartAtk& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerStartAtk* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerStartAtk* other);

  // implements Message ----------------------------------------------

  CSPlayerStartAtk* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerStartAtk& from);
  void MergeFrom(const CSPlayerStartAtk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // required .vmsg.CSScenePoint Direct = 2;
  inline bool has_direct() const;
  inline void clear_direct();
  static const int kDirectFieldNumber = 2;
  inline const ::vmsg::CSScenePoint& direct() const;
  inline ::vmsg::CSScenePoint* mutable_direct();
  inline ::vmsg::CSScenePoint* release_direct();
  inline void set_allocated_direct(::vmsg::CSScenePoint* direct);

  // required .vmsg.CSScenePoint ScenePoint = 3;
  inline bool has_scenepoint() const;
  inline void clear_scenepoint();
  static const int kScenePointFieldNumber = 3;
  inline const ::vmsg::CSScenePoint& scenepoint() const;
  inline ::vmsg::CSScenePoint* mutable_scenepoint();
  inline ::vmsg::CSScenePoint* release_scenepoint();
  inline void set_allocated_scenepoint(::vmsg::CSScenePoint* scenepoint);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerStartAtk)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_direct();
  inline void clear_has_direct();
  inline void set_has_scenepoint();
  inline void clear_has_scenepoint();

  ::google::protobuf::uint64 uin_;
  ::vmsg::CSScenePoint* direct_;
  ::vmsg::CSScenePoint* scenepoint_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSSenceOSD_2eproto();
  friend void protobuf_ShutdownFile_CSSenceOSD_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerStartAtk* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerStopAtk : public ::google::protobuf::MessageLite {
 public:
  CSPlayerStopAtk();
  virtual ~CSPlayerStopAtk();

  CSPlayerStopAtk(const CSPlayerStopAtk& from);

  inline CSPlayerStopAtk& operator=(const CSPlayerStopAtk& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerStopAtk& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerStopAtk* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerStopAtk* other);

  // implements Message ----------------------------------------------

  CSPlayerStopAtk* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerStopAtk& from);
  void MergeFrom(const CSPlayerStopAtk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // required .vmsg.CSScenePoint Direct = 2;
  inline bool has_direct() const;
  inline void clear_direct();
  static const int kDirectFieldNumber = 2;
  inline const ::vmsg::CSScenePoint& direct() const;
  inline ::vmsg::CSScenePoint* mutable_direct();
  inline ::vmsg::CSScenePoint* release_direct();
  inline void set_allocated_direct(::vmsg::CSScenePoint* direct);

  // required .vmsg.CSScenePoint ScenePoint = 3;
  inline bool has_scenepoint() const;
  inline void clear_scenepoint();
  static const int kScenePointFieldNumber = 3;
  inline const ::vmsg::CSScenePoint& scenepoint() const;
  inline ::vmsg::CSScenePoint* mutable_scenepoint();
  inline ::vmsg::CSScenePoint* release_scenepoint();
  inline void set_allocated_scenepoint(::vmsg::CSScenePoint* scenepoint);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerStopAtk)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_direct();
  inline void clear_has_direct();
  inline void set_has_scenepoint();
  inline void clear_has_scenepoint();

  ::google::protobuf::uint64 uin_;
  ::vmsg::CSScenePoint* direct_;
  ::vmsg::CSScenePoint* scenepoint_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSSenceOSD_2eproto();
  friend void protobuf_ShutdownFile_CSSenceOSD_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerStopAtk* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerSkillInScene : public ::google::protobuf::MessageLite {
 public:
  CSPlayerSkillInScene();
  virtual ~CSPlayerSkillInScene();

  CSPlayerSkillInScene(const CSPlayerSkillInScene& from);

  inline CSPlayerSkillInScene& operator=(const CSPlayerSkillInScene& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerSkillInScene& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerSkillInScene* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerSkillInScene* other);

  // implements Message ----------------------------------------------

  CSPlayerSkillInScene* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerSkillInScene& from);
  void MergeFrom(const CSPlayerSkillInScene& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // required .vmsg.CSScenePoint Direct = 2;
  inline bool has_direct() const;
  inline void clear_direct();
  static const int kDirectFieldNumber = 2;
  inline const ::vmsg::CSScenePoint& direct() const;
  inline ::vmsg::CSScenePoint* mutable_direct();
  inline ::vmsg::CSScenePoint* release_direct();
  inline void set_allocated_direct(::vmsg::CSScenePoint* direct);

  // required .vmsg.CSScenePoint ScenePoint = 3;
  inline bool has_scenepoint() const;
  inline void clear_scenepoint();
  static const int kScenePointFieldNumber = 3;
  inline const ::vmsg::CSScenePoint& scenepoint() const;
  inline ::vmsg::CSScenePoint* mutable_scenepoint();
  inline ::vmsg::CSScenePoint* release_scenepoint();
  inline void set_allocated_scenepoint(::vmsg::CSScenePoint* scenepoint);

  // required uint32 SkillID = 4;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillIDFieldNumber = 4;
  inline ::google::protobuf::uint32 skillid() const;
  inline void set_skillid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerSkillInScene)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_direct();
  inline void clear_has_direct();
  inline void set_has_scenepoint();
  inline void clear_has_scenepoint();
  inline void set_has_skillid();
  inline void clear_has_skillid();

  ::google::protobuf::uint64 uin_;
  ::vmsg::CSScenePoint* direct_;
  ::vmsg::CSScenePoint* scenepoint_;
  ::google::protobuf::uint32 skillid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSSenceOSD_2eproto();
  friend void protobuf_ShutdownFile_CSSenceOSD_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerSkillInScene* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerStatChangeInScene : public ::google::protobuf::MessageLite {
 public:
  CSPlayerStatChangeInScene();
  virtual ~CSPlayerStatChangeInScene();

  CSPlayerStatChangeInScene(const CSPlayerStatChangeInScene& from);

  inline CSPlayerStatChangeInScene& operator=(const CSPlayerStatChangeInScene& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerStatChangeInScene& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerStatChangeInScene* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerStatChangeInScene* other);

  // implements Message ----------------------------------------------

  CSPlayerStatChangeInScene* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerStatChangeInScene& from);
  void MergeFrom(const CSPlayerStatChangeInScene& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // required uint32 Stat = 2;
  inline bool has_stat() const;
  inline void clear_stat();
  static const int kStatFieldNumber = 2;
  inline ::google::protobuf::uint32 stat() const;
  inline void set_stat(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerStatChangeInScene)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_stat();
  inline void clear_has_stat();

  ::google::protobuf::uint64 uin_;
  ::google::protobuf::uint32 stat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSSenceOSD_2eproto();
  friend void protobuf_ShutdownFile_CSSenceOSD_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerStatChangeInScene* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerOSDInfo : public ::google::protobuf::MessageLite {
 public:
  CSPlayerOSDInfo();
  virtual ~CSPlayerOSDInfo();

  CSPlayerOSDInfo(const CSPlayerOSDInfo& from);

  inline CSPlayerOSDInfo& operator=(const CSPlayerOSDInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerOSDInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerOSDInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerOSDInfo* other);

  // implements Message ----------------------------------------------

  CSPlayerOSDInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerOSDInfo& from);
  void MergeFrom(const CSPlayerOSDInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional .vmsg.CSPlayerPosInScene PlayerEnterScene = 2;
  inline bool has_playerenterscene() const;
  inline void clear_playerenterscene();
  static const int kPlayerEnterSceneFieldNumber = 2;
  inline const ::vmsg::CSPlayerPosInScene& playerenterscene() const;
  inline ::vmsg::CSPlayerPosInScene* mutable_playerenterscene();
  inline ::vmsg::CSPlayerPosInScene* release_playerenterscene();
  inline void set_allocated_playerenterscene(::vmsg::CSPlayerPosInScene* playerenterscene);

  // optional uint64 PlayerLeaveSceneUin = 3;
  inline bool has_playerleavesceneuin() const;
  inline void clear_playerleavesceneuin();
  static const int kPlayerLeaveSceneUinFieldNumber = 3;
  inline ::google::protobuf::uint64 playerleavesceneuin() const;
  inline void set_playerleavesceneuin(::google::protobuf::uint64 value);

  // optional .vmsg.CSPlayerMoveInScene PlayerMoveInScene = 4;
  inline bool has_playermoveinscene() const;
  inline void clear_playermoveinscene();
  static const int kPlayerMoveInSceneFieldNumber = 4;
  inline const ::vmsg::CSPlayerMoveInScene& playermoveinscene() const;
  inline ::vmsg::CSPlayerMoveInScene* mutable_playermoveinscene();
  inline ::vmsg::CSPlayerMoveInScene* release_playermoveinscene();
  inline void set_allocated_playermoveinscene(::vmsg::CSPlayerMoveInScene* playermoveinscene);

  // optional .vmsg.CSPlayerSetPosInScene PlayerSetPosInScene = 5;
  inline bool has_playersetposinscene() const;
  inline void clear_playersetposinscene();
  static const int kPlayerSetPosInSceneFieldNumber = 5;
  inline const ::vmsg::CSPlayerSetPosInScene& playersetposinscene() const;
  inline ::vmsg::CSPlayerSetPosInScene* mutable_playersetposinscene();
  inline ::vmsg::CSPlayerSetPosInScene* release_playersetposinscene();
  inline void set_allocated_playersetposinscene(::vmsg::CSPlayerSetPosInScene* playersetposinscene);

  // optional .vmsg.CSPlayerStartAtk PlayerStartAtk = 6;
  inline bool has_playerstartatk() const;
  inline void clear_playerstartatk();
  static const int kPlayerStartAtkFieldNumber = 6;
  inline const ::vmsg::CSPlayerStartAtk& playerstartatk() const;
  inline ::vmsg::CSPlayerStartAtk* mutable_playerstartatk();
  inline ::vmsg::CSPlayerStartAtk* release_playerstartatk();
  inline void set_allocated_playerstartatk(::vmsg::CSPlayerStartAtk* playerstartatk);

  // optional .vmsg.CSPlayerStopAtk PlayerStopAtk = 7;
  inline bool has_playerstopatk() const;
  inline void clear_playerstopatk();
  static const int kPlayerStopAtkFieldNumber = 7;
  inline const ::vmsg::CSPlayerStopAtk& playerstopatk() const;
  inline ::vmsg::CSPlayerStopAtk* mutable_playerstopatk();
  inline ::vmsg::CSPlayerStopAtk* release_playerstopatk();
  inline void set_allocated_playerstopatk(::vmsg::CSPlayerStopAtk* playerstopatk);

  // optional .vmsg.CSPlayerSkillInScene PlayerSkill = 8;
  inline bool has_playerskill() const;
  inline void clear_playerskill();
  static const int kPlayerSkillFieldNumber = 8;
  inline const ::vmsg::CSPlayerSkillInScene& playerskill() const;
  inline ::vmsg::CSPlayerSkillInScene* mutable_playerskill();
  inline ::vmsg::CSPlayerSkillInScene* release_playerskill();
  inline void set_allocated_playerskill(::vmsg::CSPlayerSkillInScene* playerskill);

  // optional .vmsg.CSPlayerStatChangeInScene PlayerStatChange = 9;
  inline bool has_playerstatchange() const;
  inline void clear_playerstatchange();
  static const int kPlayerStatChangeFieldNumber = 9;
  inline const ::vmsg::CSPlayerStatChangeInScene& playerstatchange() const;
  inline ::vmsg::CSPlayerStatChangeInScene* mutable_playerstatchange();
  inline ::vmsg::CSPlayerStatChangeInScene* release_playerstatchange();
  inline void set_allocated_playerstatchange(::vmsg::CSPlayerStatChangeInScene* playerstatchange);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerOSDInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_playerenterscene();
  inline void clear_has_playerenterscene();
  inline void set_has_playerleavesceneuin();
  inline void clear_has_playerleavesceneuin();
  inline void set_has_playermoveinscene();
  inline void clear_has_playermoveinscene();
  inline void set_has_playersetposinscene();
  inline void clear_has_playersetposinscene();
  inline void set_has_playerstartatk();
  inline void clear_has_playerstartatk();
  inline void set_has_playerstopatk();
  inline void clear_has_playerstopatk();
  inline void set_has_playerskill();
  inline void clear_has_playerskill();
  inline void set_has_playerstatchange();
  inline void clear_has_playerstatchange();

  ::vmsg::CSPlayerPosInScene* playerenterscene_;
  ::google::protobuf::uint64 playerleavesceneuin_;
  ::vmsg::CSPlayerMoveInScene* playermoveinscene_;
  ::vmsg::CSPlayerSetPosInScene* playersetposinscene_;
  ::vmsg::CSPlayerStartAtk* playerstartatk_;
  ::vmsg::CSPlayerStopAtk* playerstopatk_;
  ::vmsg::CSPlayerSkillInScene* playerskill_;
  ::vmsg::CSPlayerStatChangeInScene* playerstatchange_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSSenceOSD_2eproto();
  friend void protobuf_ShutdownFile_CSSenceOSD_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerOSDInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSOSDMonstersInfo : public ::google::protobuf::MessageLite {
 public:
  CSOSDMonstersInfo();
  virtual ~CSOSDMonstersInfo();

  CSOSDMonstersInfo(const CSOSDMonstersInfo& from);

  inline CSOSDMonstersInfo& operator=(const CSOSDMonstersInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSOSDMonstersInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSOSDMonstersInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSOSDMonstersInfo* other);

  // implements Message ----------------------------------------------

  CSOSDMonstersInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSOSDMonstersInfo& from);
  void MergeFrom(const CSOSDMonstersInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 MonsterID = 1;
  inline bool has_monsterid() const;
  inline void clear_monsterid();
  static const int kMonsterIDFieldNumber = 1;
  inline ::google::protobuf::uint32 monsterid() const;
  inline void set_monsterid(::google::protobuf::uint32 value);

  // required .vmsg.CSScenePoint ScenePoint = 2;
  inline bool has_scenepoint() const;
  inline void clear_scenepoint();
  static const int kScenePointFieldNumber = 2;
  inline const ::vmsg::CSScenePoint& scenepoint() const;
  inline ::vmsg::CSScenePoint* mutable_scenepoint();
  inline ::vmsg::CSScenePoint* release_scenepoint();
  inline void set_allocated_scenepoint(::vmsg::CSScenePoint* scenepoint);

  // required uint32 MOnsterType = 3;
  inline bool has_monstertype() const;
  inline void clear_monstertype();
  static const int kMOnsterTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 monstertype() const;
  inline void set_monstertype(::google::protobuf::uint32 value);

  // required uint32 HP = 4;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHPFieldNumber = 4;
  inline ::google::protobuf::uint32 hp() const;
  inline void set_hp(::google::protobuf::uint32 value);

  // required uint32 Lv = 5;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 5;
  inline ::google::protobuf::uint32 lv() const;
  inline void set_lv(::google::protobuf::uint32 value);

  // required uint32 Channel = 6;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 6;
  inline ::google::protobuf::uint32 channel() const;
  inline void set_channel(::google::protobuf::uint32 value);

  // required uint32 Wave = 7;
  inline bool has_wave() const;
  inline void clear_wave();
  static const int kWaveFieldNumber = 7;
  inline ::google::protobuf::uint32 wave() const;
  inline void set_wave(::google::protobuf::uint32 value);

  // required uint32 Action = 8;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 8;
  inline ::google::protobuf::uint32 action() const;
  inline void set_action(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSOSDMonstersInfo)
 private:
  inline void set_has_monsterid();
  inline void clear_has_monsterid();
  inline void set_has_scenepoint();
  inline void clear_has_scenepoint();
  inline void set_has_monstertype();
  inline void clear_has_monstertype();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_wave();
  inline void clear_has_wave();
  inline void set_has_action();
  inline void clear_has_action();

  ::vmsg::CSScenePoint* scenepoint_;
  ::google::protobuf::uint32 monsterid_;
  ::google::protobuf::uint32 monstertype_;
  ::google::protobuf::uint32 hp_;
  ::google::protobuf::uint32 lv_;
  ::google::protobuf::uint32 channel_;
  ::google::protobuf::uint32 wave_;
  ::google::protobuf::uint32 action_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSSenceOSD_2eproto();
  friend void protobuf_ShutdownFile_CSSenceOSD_2eproto();

  void InitAsDefaultInstance();
  static CSOSDMonstersInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSQueryPlayerSceneOSDInfoRsp : public ::google::protobuf::MessageLite {
 public:
  CSQueryPlayerSceneOSDInfoRsp();
  virtual ~CSQueryPlayerSceneOSDInfoRsp();

  CSQueryPlayerSceneOSDInfoRsp(const CSQueryPlayerSceneOSDInfoRsp& from);

  inline CSQueryPlayerSceneOSDInfoRsp& operator=(const CSQueryPlayerSceneOSDInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSQueryPlayerSceneOSDInfoRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQueryPlayerSceneOSDInfoRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQueryPlayerSceneOSDInfoRsp* other);

  // implements Message ----------------------------------------------

  CSQueryPlayerSceneOSDInfoRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQueryPlayerSceneOSDInfoRsp& from);
  void MergeFrom(const CSQueryPlayerSceneOSDInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSPlayerPosInScene PlayersPos = 1;
  inline int playerspos_size() const;
  inline void clear_playerspos();
  static const int kPlayersPosFieldNumber = 1;
  inline const ::vmsg::CSPlayerPosInScene& playerspos(int index) const;
  inline ::vmsg::CSPlayerPosInScene* mutable_playerspos(int index);
  inline ::vmsg::CSPlayerPosInScene* add_playerspos();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerPosInScene >&
      playerspos() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerPosInScene >*
      mutable_playerspos();

  // repeated .vmsg.CSOSDMonstersInfo MonsterOSDInfos = 2;
  inline int monsterosdinfos_size() const;
  inline void clear_monsterosdinfos();
  static const int kMonsterOSDInfosFieldNumber = 2;
  inline const ::vmsg::CSOSDMonstersInfo& monsterosdinfos(int index) const;
  inline ::vmsg::CSOSDMonstersInfo* mutable_monsterosdinfos(int index);
  inline ::vmsg::CSOSDMonstersInfo* add_monsterosdinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSOSDMonstersInfo >&
      monsterosdinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSOSDMonstersInfo >*
      mutable_monsterosdinfos();

  // @@protoc_insertion_point(class_scope:vmsg.CSQueryPlayerSceneOSDInfoRsp)
 private:

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerPosInScene > playerspos_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSOSDMonstersInfo > monsterosdinfos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSSenceOSD_2eproto();
  friend void protobuf_ShutdownFile_CSSenceOSD_2eproto();

  void InitAsDefaultInstance();
  static CSQueryPlayerSceneOSDInfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSSyncPlayerOSDInfo : public ::google::protobuf::MessageLite {
 public:
  CSSyncPlayerOSDInfo();
  virtual ~CSSyncPlayerOSDInfo();

  CSSyncPlayerOSDInfo(const CSSyncPlayerOSDInfo& from);

  inline CSSyncPlayerOSDInfo& operator=(const CSSyncPlayerOSDInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSSyncPlayerOSDInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSyncPlayerOSDInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSyncPlayerOSDInfo* other);

  // implements Message ----------------------------------------------

  CSSyncPlayerOSDInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSyncPlayerOSDInfo& from);
  void MergeFrom(const CSSyncPlayerOSDInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSPlayerOSDInfo PlayerOSDInfos = 1;
  inline int playerosdinfos_size() const;
  inline void clear_playerosdinfos();
  static const int kPlayerOSDInfosFieldNumber = 1;
  inline const ::vmsg::CSPlayerOSDInfo& playerosdinfos(int index) const;
  inline ::vmsg::CSPlayerOSDInfo* mutable_playerosdinfos(int index);
  inline ::vmsg::CSPlayerOSDInfo* add_playerosdinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerOSDInfo >&
      playerosdinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerOSDInfo >*
      mutable_playerosdinfos();

  // @@protoc_insertion_point(class_scope:vmsg.CSSyncPlayerOSDInfo)
 private:

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerOSDInfo > playerosdinfos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSSenceOSD_2eproto();
  friend void protobuf_ShutdownFile_CSSenceOSD_2eproto();

  void InitAsDefaultInstance();
  static CSSyncPlayerOSDInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerChangeSceneRqst : public ::google::protobuf::MessageLite {
 public:
  CSPlayerChangeSceneRqst();
  virtual ~CSPlayerChangeSceneRqst();

  CSPlayerChangeSceneRqst(const CSPlayerChangeSceneRqst& from);

  inline CSPlayerChangeSceneRqst& operator=(const CSPlayerChangeSceneRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerChangeSceneRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerChangeSceneRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerChangeSceneRqst* other);

  // implements Message ----------------------------------------------

  CSPlayerChangeSceneRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerChangeSceneRqst& from);
  void MergeFrom(const CSPlayerChangeSceneRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 NewSceneID = 1;
  inline bool has_newsceneid() const;
  inline void clear_newsceneid();
  static const int kNewSceneIDFieldNumber = 1;
  inline ::google::protobuf::uint32 newsceneid() const;
  inline void set_newsceneid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerChangeSceneRqst)
 private:
  inline void set_has_newsceneid();
  inline void clear_has_newsceneid();

  ::google::protobuf::uint32 newsceneid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSSenceOSD_2eproto();
  friend void protobuf_ShutdownFile_CSSenceOSD_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerChangeSceneRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSSceneOSDRequest : public ::google::protobuf::MessageLite {
 public:
  CSSceneOSDRequest();
  virtual ~CSSceneOSDRequest();

  CSSceneOSDRequest(const CSSceneOSDRequest& from);

  inline CSSceneOSDRequest& operator=(const CSSceneOSDRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSSceneOSDRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSceneOSDRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSceneOSDRequest* other);

  // implements Message ----------------------------------------------

  CSSceneOSDRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSceneOSDRequest& from);
  void MergeFrom(const CSSceneOSDRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSPlayerMoveInScene PlayerMove_Rqst = 1;
  inline bool has_playermove_rqst() const;
  inline void clear_playermove_rqst();
  static const int kPlayerMoveRqstFieldNumber = 1;
  inline const ::vmsg::CSPlayerMoveInScene& playermove_rqst() const;
  inline ::vmsg::CSPlayerMoveInScene* mutable_playermove_rqst();
  inline ::vmsg::CSPlayerMoveInScene* release_playermove_rqst();
  inline void set_allocated_playermove_rqst(::vmsg::CSPlayerMoveInScene* playermove_rqst);

  // optional .vmsg.CSPlayerSetPosInScene PlayerSetPos_Rqst = 2;
  inline bool has_playersetpos_rqst() const;
  inline void clear_playersetpos_rqst();
  static const int kPlayerSetPosRqstFieldNumber = 2;
  inline const ::vmsg::CSPlayerSetPosInScene& playersetpos_rqst() const;
  inline ::vmsg::CSPlayerSetPosInScene* mutable_playersetpos_rqst();
  inline ::vmsg::CSPlayerSetPosInScene* release_playersetpos_rqst();
  inline void set_allocated_playersetpos_rqst(::vmsg::CSPlayerSetPosInScene* playersetpos_rqst);

  // optional .vmsg.CSPlayerChangeSceneRqst PlayerChangeScene_Rqst = 3;
  inline bool has_playerchangescene_rqst() const;
  inline void clear_playerchangescene_rqst();
  static const int kPlayerChangeSceneRqstFieldNumber = 3;
  inline const ::vmsg::CSPlayerChangeSceneRqst& playerchangescene_rqst() const;
  inline ::vmsg::CSPlayerChangeSceneRqst* mutable_playerchangescene_rqst();
  inline ::vmsg::CSPlayerChangeSceneRqst* release_playerchangescene_rqst();
  inline void set_allocated_playerchangescene_rqst(::vmsg::CSPlayerChangeSceneRqst* playerchangescene_rqst);

  // optional .vmsg.CSPlayerStartAtk PlayerStartAtk_Rqst = 4;
  inline bool has_playerstartatk_rqst() const;
  inline void clear_playerstartatk_rqst();
  static const int kPlayerStartAtkRqstFieldNumber = 4;
  inline const ::vmsg::CSPlayerStartAtk& playerstartatk_rqst() const;
  inline ::vmsg::CSPlayerStartAtk* mutable_playerstartatk_rqst();
  inline ::vmsg::CSPlayerStartAtk* release_playerstartatk_rqst();
  inline void set_allocated_playerstartatk_rqst(::vmsg::CSPlayerStartAtk* playerstartatk_rqst);

  // optional .vmsg.CSPlayerStopAtk PlayerStopAtk_Rqst = 5;
  inline bool has_playerstopatk_rqst() const;
  inline void clear_playerstopatk_rqst();
  static const int kPlayerStopAtkRqstFieldNumber = 5;
  inline const ::vmsg::CSPlayerStopAtk& playerstopatk_rqst() const;
  inline ::vmsg::CSPlayerStopAtk* mutable_playerstopatk_rqst();
  inline ::vmsg::CSPlayerStopAtk* release_playerstopatk_rqst();
  inline void set_allocated_playerstopatk_rqst(::vmsg::CSPlayerStopAtk* playerstopatk_rqst);

  // optional .vmsg.CSPlayerSkillInScene PlayerSkill_Rqst = 6;
  inline bool has_playerskill_rqst() const;
  inline void clear_playerskill_rqst();
  static const int kPlayerSkillRqstFieldNumber = 6;
  inline const ::vmsg::CSPlayerSkillInScene& playerskill_rqst() const;
  inline ::vmsg::CSPlayerSkillInScene* mutable_playerskill_rqst();
  inline ::vmsg::CSPlayerSkillInScene* release_playerskill_rqst();
  inline void set_allocated_playerskill_rqst(::vmsg::CSPlayerSkillInScene* playerskill_rqst);

  // @@protoc_insertion_point(class_scope:vmsg.CSSceneOSDRequest)
 private:
  inline void set_has_playermove_rqst();
  inline void clear_has_playermove_rqst();
  inline void set_has_playersetpos_rqst();
  inline void clear_has_playersetpos_rqst();
  inline void set_has_playerchangescene_rqst();
  inline void clear_has_playerchangescene_rqst();
  inline void set_has_playerstartatk_rqst();
  inline void clear_has_playerstartatk_rqst();
  inline void set_has_playerstopatk_rqst();
  inline void clear_has_playerstopatk_rqst();
  inline void set_has_playerskill_rqst();
  inline void clear_has_playerskill_rqst();

  ::vmsg::CSPlayerMoveInScene* playermove_rqst_;
  ::vmsg::CSPlayerSetPosInScene* playersetpos_rqst_;
  ::vmsg::CSPlayerChangeSceneRqst* playerchangescene_rqst_;
  ::vmsg::CSPlayerStartAtk* playerstartatk_rqst_;
  ::vmsg::CSPlayerStopAtk* playerstopatk_rqst_;
  ::vmsg::CSPlayerSkillInScene* playerskill_rqst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSSenceOSD_2eproto();
  friend void protobuf_ShutdownFile_CSSenceOSD_2eproto();

  void InitAsDefaultInstance();
  static CSSceneOSDRequest* default_instance_;
};
// -------------------------------------------------------------------

class CSSceneOSDRespond : public ::google::protobuf::MessageLite {
 public:
  CSSceneOSDRespond();
  virtual ~CSSceneOSDRespond();

  CSSceneOSDRespond(const CSSceneOSDRespond& from);

  inline CSSceneOSDRespond& operator=(const CSSceneOSDRespond& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSSceneOSDRespond& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSceneOSDRespond* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSceneOSDRespond* other);

  // implements Message ----------------------------------------------

  CSSceneOSDRespond* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSceneOSDRespond& from);
  void MergeFrom(const CSSceneOSDRespond& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSQueryPlayerSceneOSDInfoRsp QueryPlayerSceneOSDInfo_Rsp = 1;
  inline bool has_queryplayersceneosdinfo_rsp() const;
  inline void clear_queryplayersceneosdinfo_rsp();
  static const int kQueryPlayerSceneOSDInfoRspFieldNumber = 1;
  inline const ::vmsg::CSQueryPlayerSceneOSDInfoRsp& queryplayersceneosdinfo_rsp() const;
  inline ::vmsg::CSQueryPlayerSceneOSDInfoRsp* mutable_queryplayersceneosdinfo_rsp();
  inline ::vmsg::CSQueryPlayerSceneOSDInfoRsp* release_queryplayersceneosdinfo_rsp();
  inline void set_allocated_queryplayersceneosdinfo_rsp(::vmsg::CSQueryPlayerSceneOSDInfoRsp* queryplayersceneosdinfo_rsp);

  // optional .vmsg.CSSyncPlayerOSDInfo SyncPlayerOSDInfo_Push = 2;
  inline bool has_syncplayerosdinfo_push() const;
  inline void clear_syncplayerosdinfo_push();
  static const int kSyncPlayerOSDInfoPushFieldNumber = 2;
  inline const ::vmsg::CSSyncPlayerOSDInfo& syncplayerosdinfo_push() const;
  inline ::vmsg::CSSyncPlayerOSDInfo* mutable_syncplayerosdinfo_push();
  inline ::vmsg::CSSyncPlayerOSDInfo* release_syncplayerosdinfo_push();
  inline void set_allocated_syncplayerosdinfo_push(::vmsg::CSSyncPlayerOSDInfo* syncplayerosdinfo_push);

  // @@protoc_insertion_point(class_scope:vmsg.CSSceneOSDRespond)
 private:
  inline void set_has_queryplayersceneosdinfo_rsp();
  inline void clear_has_queryplayersceneosdinfo_rsp();
  inline void set_has_syncplayerosdinfo_push();
  inline void clear_has_syncplayerosdinfo_push();

  ::vmsg::CSQueryPlayerSceneOSDInfoRsp* queryplayersceneosdinfo_rsp_;
  ::vmsg::CSSyncPlayerOSDInfo* syncplayerosdinfo_push_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSSenceOSD_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSSenceOSD_2eproto();
  friend void protobuf_ShutdownFile_CSSenceOSD_2eproto();

  void InitAsDefaultInstance();
  static CSSceneOSDRespond* default_instance_;
};
// ===================================================================


// ===================================================================

// CSPlayerCommInScene

// required uint64 Uin = 1;
inline bool CSPlayerCommInScene::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerCommInScene::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerCommInScene::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerCommInScene::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSPlayerCommInScene::uin() const {
  return uin_;
}
inline void CSPlayerCommInScene::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
}

// required string Nick = 2;
inline bool CSPlayerCommInScene::has_nick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerCommInScene::set_has_nick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerCommInScene::clear_has_nick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerCommInScene::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& CSPlayerCommInScene::nick() const {
  return *nick_;
}
inline void CSPlayerCommInScene::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void CSPlayerCommInScene::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void CSPlayerCommInScene::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSPlayerCommInScene::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* CSPlayerCommInScene::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSPlayerCommInScene::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 WeaponCfgID = 3;
inline bool CSPlayerCommInScene::has_weaponcfgid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPlayerCommInScene::set_has_weaponcfgid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPlayerCommInScene::clear_has_weaponcfgid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPlayerCommInScene::clear_weaponcfgid() {
  weaponcfgid_ = 0u;
  clear_has_weaponcfgid();
}
inline ::google::protobuf::uint32 CSPlayerCommInScene::weaponcfgid() const {
  return weaponcfgid_;
}
inline void CSPlayerCommInScene::set_weaponcfgid(::google::protobuf::uint32 value) {
  set_has_weaponcfgid();
  weaponcfgid_ = value;
}

// required uint32 ShowID = 4;
inline bool CSPlayerCommInScene::has_showid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPlayerCommInScene::set_has_showid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPlayerCommInScene::clear_has_showid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPlayerCommInScene::clear_showid() {
  showid_ = 0u;
  clear_has_showid();
}
inline ::google::protobuf::uint32 CSPlayerCommInScene::showid() const {
  return showid_;
}
inline void CSPlayerCommInScene::set_showid(::google::protobuf::uint32 value) {
  set_has_showid();
  showid_ = value;
}

// required uint32 VipLvl = 5;
inline bool CSPlayerCommInScene::has_viplvl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPlayerCommInScene::set_has_viplvl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPlayerCommInScene::clear_has_viplvl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPlayerCommInScene::clear_viplvl() {
  viplvl_ = 0u;
  clear_has_viplvl();
}
inline ::google::protobuf::uint32 CSPlayerCommInScene::viplvl() const {
  return viplvl_;
}
inline void CSPlayerCommInScene::set_viplvl(::google::protobuf::uint32 value) {
  set_has_viplvl();
  viplvl_ = value;
}

// -------------------------------------------------------------------

// CSScenePoint

// required int32 XPos = 1;
inline bool CSScenePoint::has_xpos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSScenePoint::set_has_xpos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSScenePoint::clear_has_xpos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSScenePoint::clear_xpos() {
  xpos_ = 0;
  clear_has_xpos();
}
inline ::google::protobuf::int32 CSScenePoint::xpos() const {
  return xpos_;
}
inline void CSScenePoint::set_xpos(::google::protobuf::int32 value) {
  set_has_xpos();
  xpos_ = value;
}

// required int32 YPos = 2;
inline bool CSScenePoint::has_ypos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSScenePoint::set_has_ypos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSScenePoint::clear_has_ypos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSScenePoint::clear_ypos() {
  ypos_ = 0;
  clear_has_ypos();
}
inline ::google::protobuf::int32 CSScenePoint::ypos() const {
  return ypos_;
}
inline void CSScenePoint::set_ypos(::google::protobuf::int32 value) {
  set_has_ypos();
  ypos_ = value;
}

// -------------------------------------------------------------------

// CSPlayerPosInScene

// required .vmsg.CSPlayerCommInScene Comm = 1;
inline bool CSPlayerPosInScene::has_comm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerPosInScene::set_has_comm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerPosInScene::clear_has_comm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerPosInScene::clear_comm() {
  if (comm_ != NULL) comm_->::vmsg::CSPlayerCommInScene::Clear();
  clear_has_comm();
}
inline const ::vmsg::CSPlayerCommInScene& CSPlayerPosInScene::comm() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return comm_ != NULL ? *comm_ : *default_instance().comm_;
#else
  return comm_ != NULL ? *comm_ : *default_instance_->comm_;
#endif
}
inline ::vmsg::CSPlayerCommInScene* CSPlayerPosInScene::mutable_comm() {
  set_has_comm();
  if (comm_ == NULL) comm_ = new ::vmsg::CSPlayerCommInScene;
  return comm_;
}
inline ::vmsg::CSPlayerCommInScene* CSPlayerPosInScene::release_comm() {
  clear_has_comm();
  ::vmsg::CSPlayerCommInScene* temp = comm_;
  comm_ = NULL;
  return temp;
}
inline void CSPlayerPosInScene::set_allocated_comm(::vmsg::CSPlayerCommInScene* comm) {
  delete comm_;
  comm_ = comm;
  if (comm) {
    set_has_comm();
  } else {
    clear_has_comm();
  }
}

// optional .vmsg.CSScenePoint ScenePoint = 2;
inline bool CSPlayerPosInScene::has_scenepoint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerPosInScene::set_has_scenepoint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerPosInScene::clear_has_scenepoint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerPosInScene::clear_scenepoint() {
  if (scenepoint_ != NULL) scenepoint_->::vmsg::CSScenePoint::Clear();
  clear_has_scenepoint();
}
inline const ::vmsg::CSScenePoint& CSPlayerPosInScene::scenepoint() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return scenepoint_ != NULL ? *scenepoint_ : *default_instance().scenepoint_;
#else
  return scenepoint_ != NULL ? *scenepoint_ : *default_instance_->scenepoint_;
#endif
}
inline ::vmsg::CSScenePoint* CSPlayerPosInScene::mutable_scenepoint() {
  set_has_scenepoint();
  if (scenepoint_ == NULL) scenepoint_ = new ::vmsg::CSScenePoint;
  return scenepoint_;
}
inline ::vmsg::CSScenePoint* CSPlayerPosInScene::release_scenepoint() {
  clear_has_scenepoint();
  ::vmsg::CSScenePoint* temp = scenepoint_;
  scenepoint_ = NULL;
  return temp;
}
inline void CSPlayerPosInScene::set_allocated_scenepoint(::vmsg::CSScenePoint* scenepoint) {
  delete scenepoint_;
  scenepoint_ = scenepoint;
  if (scenepoint) {
    set_has_scenepoint();
  } else {
    clear_has_scenepoint();
  }
}

// required .vmsg.CSScenePoint Direct = 3;
inline bool CSPlayerPosInScene::has_direct() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPlayerPosInScene::set_has_direct() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPlayerPosInScene::clear_has_direct() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPlayerPosInScene::clear_direct() {
  if (direct_ != NULL) direct_->::vmsg::CSScenePoint::Clear();
  clear_has_direct();
}
inline const ::vmsg::CSScenePoint& CSPlayerPosInScene::direct() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return direct_ != NULL ? *direct_ : *default_instance().direct_;
#else
  return direct_ != NULL ? *direct_ : *default_instance_->direct_;
#endif
}
inline ::vmsg::CSScenePoint* CSPlayerPosInScene::mutable_direct() {
  set_has_direct();
  if (direct_ == NULL) direct_ = new ::vmsg::CSScenePoint;
  return direct_;
}
inline ::vmsg::CSScenePoint* CSPlayerPosInScene::release_direct() {
  clear_has_direct();
  ::vmsg::CSScenePoint* temp = direct_;
  direct_ = NULL;
  return temp;
}
inline void CSPlayerPosInScene::set_allocated_direct(::vmsg::CSScenePoint* direct) {
  delete direct_;
  direct_ = direct;
  if (direct) {
    set_has_direct();
  } else {
    clear_has_direct();
  }
}

// -------------------------------------------------------------------

// CSPlayerMoveInScene

// required uint64 Uin = 1;
inline bool CSPlayerMoveInScene::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerMoveInScene::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerMoveInScene::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerMoveInScene::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSPlayerMoveInScene::uin() const {
  return uin_;
}
inline void CSPlayerMoveInScene::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
}

// required .vmsg.CSScenePoint Direct = 2;
inline bool CSPlayerMoveInScene::has_direct() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerMoveInScene::set_has_direct() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerMoveInScene::clear_has_direct() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerMoveInScene::clear_direct() {
  if (direct_ != NULL) direct_->::vmsg::CSScenePoint::Clear();
  clear_has_direct();
}
inline const ::vmsg::CSScenePoint& CSPlayerMoveInScene::direct() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return direct_ != NULL ? *direct_ : *default_instance().direct_;
#else
  return direct_ != NULL ? *direct_ : *default_instance_->direct_;
#endif
}
inline ::vmsg::CSScenePoint* CSPlayerMoveInScene::mutable_direct() {
  set_has_direct();
  if (direct_ == NULL) direct_ = new ::vmsg::CSScenePoint;
  return direct_;
}
inline ::vmsg::CSScenePoint* CSPlayerMoveInScene::release_direct() {
  clear_has_direct();
  ::vmsg::CSScenePoint* temp = direct_;
  direct_ = NULL;
  return temp;
}
inline void CSPlayerMoveInScene::set_allocated_direct(::vmsg::CSScenePoint* direct) {
  delete direct_;
  direct_ = direct;
  if (direct) {
    set_has_direct();
  } else {
    clear_has_direct();
  }
}

// required .vmsg.CSScenePoint ScenePoint = 3;
inline bool CSPlayerMoveInScene::has_scenepoint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPlayerMoveInScene::set_has_scenepoint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPlayerMoveInScene::clear_has_scenepoint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPlayerMoveInScene::clear_scenepoint() {
  if (scenepoint_ != NULL) scenepoint_->::vmsg::CSScenePoint::Clear();
  clear_has_scenepoint();
}
inline const ::vmsg::CSScenePoint& CSPlayerMoveInScene::scenepoint() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return scenepoint_ != NULL ? *scenepoint_ : *default_instance().scenepoint_;
#else
  return scenepoint_ != NULL ? *scenepoint_ : *default_instance_->scenepoint_;
#endif
}
inline ::vmsg::CSScenePoint* CSPlayerMoveInScene::mutable_scenepoint() {
  set_has_scenepoint();
  if (scenepoint_ == NULL) scenepoint_ = new ::vmsg::CSScenePoint;
  return scenepoint_;
}
inline ::vmsg::CSScenePoint* CSPlayerMoveInScene::release_scenepoint() {
  clear_has_scenepoint();
  ::vmsg::CSScenePoint* temp = scenepoint_;
  scenepoint_ = NULL;
  return temp;
}
inline void CSPlayerMoveInScene::set_allocated_scenepoint(::vmsg::CSScenePoint* scenepoint) {
  delete scenepoint_;
  scenepoint_ = scenepoint;
  if (scenepoint) {
    set_has_scenepoint();
  } else {
    clear_has_scenepoint();
  }
}

// -------------------------------------------------------------------

// CSPlayerSetPosInScene

// required uint64 Uin = 1;
inline bool CSPlayerSetPosInScene::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerSetPosInScene::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerSetPosInScene::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerSetPosInScene::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSPlayerSetPosInScene::uin() const {
  return uin_;
}
inline void CSPlayerSetPosInScene::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
}

// required .vmsg.CSScenePoint Direct = 2;
inline bool CSPlayerSetPosInScene::has_direct() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerSetPosInScene::set_has_direct() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerSetPosInScene::clear_has_direct() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerSetPosInScene::clear_direct() {
  if (direct_ != NULL) direct_->::vmsg::CSScenePoint::Clear();
  clear_has_direct();
}
inline const ::vmsg::CSScenePoint& CSPlayerSetPosInScene::direct() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return direct_ != NULL ? *direct_ : *default_instance().direct_;
#else
  return direct_ != NULL ? *direct_ : *default_instance_->direct_;
#endif
}
inline ::vmsg::CSScenePoint* CSPlayerSetPosInScene::mutable_direct() {
  set_has_direct();
  if (direct_ == NULL) direct_ = new ::vmsg::CSScenePoint;
  return direct_;
}
inline ::vmsg::CSScenePoint* CSPlayerSetPosInScene::release_direct() {
  clear_has_direct();
  ::vmsg::CSScenePoint* temp = direct_;
  direct_ = NULL;
  return temp;
}
inline void CSPlayerSetPosInScene::set_allocated_direct(::vmsg::CSScenePoint* direct) {
  delete direct_;
  direct_ = direct;
  if (direct) {
    set_has_direct();
  } else {
    clear_has_direct();
  }
}

// required .vmsg.CSScenePoint ScenePoint = 3;
inline bool CSPlayerSetPosInScene::has_scenepoint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPlayerSetPosInScene::set_has_scenepoint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPlayerSetPosInScene::clear_has_scenepoint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPlayerSetPosInScene::clear_scenepoint() {
  if (scenepoint_ != NULL) scenepoint_->::vmsg::CSScenePoint::Clear();
  clear_has_scenepoint();
}
inline const ::vmsg::CSScenePoint& CSPlayerSetPosInScene::scenepoint() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return scenepoint_ != NULL ? *scenepoint_ : *default_instance().scenepoint_;
#else
  return scenepoint_ != NULL ? *scenepoint_ : *default_instance_->scenepoint_;
#endif
}
inline ::vmsg::CSScenePoint* CSPlayerSetPosInScene::mutable_scenepoint() {
  set_has_scenepoint();
  if (scenepoint_ == NULL) scenepoint_ = new ::vmsg::CSScenePoint;
  return scenepoint_;
}
inline ::vmsg::CSScenePoint* CSPlayerSetPosInScene::release_scenepoint() {
  clear_has_scenepoint();
  ::vmsg::CSScenePoint* temp = scenepoint_;
  scenepoint_ = NULL;
  return temp;
}
inline void CSPlayerSetPosInScene::set_allocated_scenepoint(::vmsg::CSScenePoint* scenepoint) {
  delete scenepoint_;
  scenepoint_ = scenepoint;
  if (scenepoint) {
    set_has_scenepoint();
  } else {
    clear_has_scenepoint();
  }
}

// -------------------------------------------------------------------

// CSPlayerStartAtk

// required uint64 Uin = 1;
inline bool CSPlayerStartAtk::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerStartAtk::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerStartAtk::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerStartAtk::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSPlayerStartAtk::uin() const {
  return uin_;
}
inline void CSPlayerStartAtk::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
}

// required .vmsg.CSScenePoint Direct = 2;
inline bool CSPlayerStartAtk::has_direct() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerStartAtk::set_has_direct() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerStartAtk::clear_has_direct() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerStartAtk::clear_direct() {
  if (direct_ != NULL) direct_->::vmsg::CSScenePoint::Clear();
  clear_has_direct();
}
inline const ::vmsg::CSScenePoint& CSPlayerStartAtk::direct() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return direct_ != NULL ? *direct_ : *default_instance().direct_;
#else
  return direct_ != NULL ? *direct_ : *default_instance_->direct_;
#endif
}
inline ::vmsg::CSScenePoint* CSPlayerStartAtk::mutable_direct() {
  set_has_direct();
  if (direct_ == NULL) direct_ = new ::vmsg::CSScenePoint;
  return direct_;
}
inline ::vmsg::CSScenePoint* CSPlayerStartAtk::release_direct() {
  clear_has_direct();
  ::vmsg::CSScenePoint* temp = direct_;
  direct_ = NULL;
  return temp;
}
inline void CSPlayerStartAtk::set_allocated_direct(::vmsg::CSScenePoint* direct) {
  delete direct_;
  direct_ = direct;
  if (direct) {
    set_has_direct();
  } else {
    clear_has_direct();
  }
}

// required .vmsg.CSScenePoint ScenePoint = 3;
inline bool CSPlayerStartAtk::has_scenepoint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPlayerStartAtk::set_has_scenepoint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPlayerStartAtk::clear_has_scenepoint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPlayerStartAtk::clear_scenepoint() {
  if (scenepoint_ != NULL) scenepoint_->::vmsg::CSScenePoint::Clear();
  clear_has_scenepoint();
}
inline const ::vmsg::CSScenePoint& CSPlayerStartAtk::scenepoint() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return scenepoint_ != NULL ? *scenepoint_ : *default_instance().scenepoint_;
#else
  return scenepoint_ != NULL ? *scenepoint_ : *default_instance_->scenepoint_;
#endif
}
inline ::vmsg::CSScenePoint* CSPlayerStartAtk::mutable_scenepoint() {
  set_has_scenepoint();
  if (scenepoint_ == NULL) scenepoint_ = new ::vmsg::CSScenePoint;
  return scenepoint_;
}
inline ::vmsg::CSScenePoint* CSPlayerStartAtk::release_scenepoint() {
  clear_has_scenepoint();
  ::vmsg::CSScenePoint* temp = scenepoint_;
  scenepoint_ = NULL;
  return temp;
}
inline void CSPlayerStartAtk::set_allocated_scenepoint(::vmsg::CSScenePoint* scenepoint) {
  delete scenepoint_;
  scenepoint_ = scenepoint;
  if (scenepoint) {
    set_has_scenepoint();
  } else {
    clear_has_scenepoint();
  }
}

// -------------------------------------------------------------------

// CSPlayerStopAtk

// required uint64 Uin = 1;
inline bool CSPlayerStopAtk::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerStopAtk::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerStopAtk::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerStopAtk::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSPlayerStopAtk::uin() const {
  return uin_;
}
inline void CSPlayerStopAtk::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
}

// required .vmsg.CSScenePoint Direct = 2;
inline bool CSPlayerStopAtk::has_direct() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerStopAtk::set_has_direct() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerStopAtk::clear_has_direct() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerStopAtk::clear_direct() {
  if (direct_ != NULL) direct_->::vmsg::CSScenePoint::Clear();
  clear_has_direct();
}
inline const ::vmsg::CSScenePoint& CSPlayerStopAtk::direct() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return direct_ != NULL ? *direct_ : *default_instance().direct_;
#else
  return direct_ != NULL ? *direct_ : *default_instance_->direct_;
#endif
}
inline ::vmsg::CSScenePoint* CSPlayerStopAtk::mutable_direct() {
  set_has_direct();
  if (direct_ == NULL) direct_ = new ::vmsg::CSScenePoint;
  return direct_;
}
inline ::vmsg::CSScenePoint* CSPlayerStopAtk::release_direct() {
  clear_has_direct();
  ::vmsg::CSScenePoint* temp = direct_;
  direct_ = NULL;
  return temp;
}
inline void CSPlayerStopAtk::set_allocated_direct(::vmsg::CSScenePoint* direct) {
  delete direct_;
  direct_ = direct;
  if (direct) {
    set_has_direct();
  } else {
    clear_has_direct();
  }
}

// required .vmsg.CSScenePoint ScenePoint = 3;
inline bool CSPlayerStopAtk::has_scenepoint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPlayerStopAtk::set_has_scenepoint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPlayerStopAtk::clear_has_scenepoint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPlayerStopAtk::clear_scenepoint() {
  if (scenepoint_ != NULL) scenepoint_->::vmsg::CSScenePoint::Clear();
  clear_has_scenepoint();
}
inline const ::vmsg::CSScenePoint& CSPlayerStopAtk::scenepoint() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return scenepoint_ != NULL ? *scenepoint_ : *default_instance().scenepoint_;
#else
  return scenepoint_ != NULL ? *scenepoint_ : *default_instance_->scenepoint_;
#endif
}
inline ::vmsg::CSScenePoint* CSPlayerStopAtk::mutable_scenepoint() {
  set_has_scenepoint();
  if (scenepoint_ == NULL) scenepoint_ = new ::vmsg::CSScenePoint;
  return scenepoint_;
}
inline ::vmsg::CSScenePoint* CSPlayerStopAtk::release_scenepoint() {
  clear_has_scenepoint();
  ::vmsg::CSScenePoint* temp = scenepoint_;
  scenepoint_ = NULL;
  return temp;
}
inline void CSPlayerStopAtk::set_allocated_scenepoint(::vmsg::CSScenePoint* scenepoint) {
  delete scenepoint_;
  scenepoint_ = scenepoint;
  if (scenepoint) {
    set_has_scenepoint();
  } else {
    clear_has_scenepoint();
  }
}

// -------------------------------------------------------------------

// CSPlayerSkillInScene

// required uint64 Uin = 1;
inline bool CSPlayerSkillInScene::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerSkillInScene::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerSkillInScene::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerSkillInScene::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSPlayerSkillInScene::uin() const {
  return uin_;
}
inline void CSPlayerSkillInScene::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
}

// required .vmsg.CSScenePoint Direct = 2;
inline bool CSPlayerSkillInScene::has_direct() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerSkillInScene::set_has_direct() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerSkillInScene::clear_has_direct() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerSkillInScene::clear_direct() {
  if (direct_ != NULL) direct_->::vmsg::CSScenePoint::Clear();
  clear_has_direct();
}
inline const ::vmsg::CSScenePoint& CSPlayerSkillInScene::direct() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return direct_ != NULL ? *direct_ : *default_instance().direct_;
#else
  return direct_ != NULL ? *direct_ : *default_instance_->direct_;
#endif
}
inline ::vmsg::CSScenePoint* CSPlayerSkillInScene::mutable_direct() {
  set_has_direct();
  if (direct_ == NULL) direct_ = new ::vmsg::CSScenePoint;
  return direct_;
}
inline ::vmsg::CSScenePoint* CSPlayerSkillInScene::release_direct() {
  clear_has_direct();
  ::vmsg::CSScenePoint* temp = direct_;
  direct_ = NULL;
  return temp;
}
inline void CSPlayerSkillInScene::set_allocated_direct(::vmsg::CSScenePoint* direct) {
  delete direct_;
  direct_ = direct;
  if (direct) {
    set_has_direct();
  } else {
    clear_has_direct();
  }
}

// required .vmsg.CSScenePoint ScenePoint = 3;
inline bool CSPlayerSkillInScene::has_scenepoint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPlayerSkillInScene::set_has_scenepoint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPlayerSkillInScene::clear_has_scenepoint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPlayerSkillInScene::clear_scenepoint() {
  if (scenepoint_ != NULL) scenepoint_->::vmsg::CSScenePoint::Clear();
  clear_has_scenepoint();
}
inline const ::vmsg::CSScenePoint& CSPlayerSkillInScene::scenepoint() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return scenepoint_ != NULL ? *scenepoint_ : *default_instance().scenepoint_;
#else
  return scenepoint_ != NULL ? *scenepoint_ : *default_instance_->scenepoint_;
#endif
}
inline ::vmsg::CSScenePoint* CSPlayerSkillInScene::mutable_scenepoint() {
  set_has_scenepoint();
  if (scenepoint_ == NULL) scenepoint_ = new ::vmsg::CSScenePoint;
  return scenepoint_;
}
inline ::vmsg::CSScenePoint* CSPlayerSkillInScene::release_scenepoint() {
  clear_has_scenepoint();
  ::vmsg::CSScenePoint* temp = scenepoint_;
  scenepoint_ = NULL;
  return temp;
}
inline void CSPlayerSkillInScene::set_allocated_scenepoint(::vmsg::CSScenePoint* scenepoint) {
  delete scenepoint_;
  scenepoint_ = scenepoint;
  if (scenepoint) {
    set_has_scenepoint();
  } else {
    clear_has_scenepoint();
  }
}

// required uint32 SkillID = 4;
inline bool CSPlayerSkillInScene::has_skillid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPlayerSkillInScene::set_has_skillid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPlayerSkillInScene::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPlayerSkillInScene::clear_skillid() {
  skillid_ = 0u;
  clear_has_skillid();
}
inline ::google::protobuf::uint32 CSPlayerSkillInScene::skillid() const {
  return skillid_;
}
inline void CSPlayerSkillInScene::set_skillid(::google::protobuf::uint32 value) {
  set_has_skillid();
  skillid_ = value;
}

// -------------------------------------------------------------------

// CSPlayerStatChangeInScene

// required uint64 Uin = 1;
inline bool CSPlayerStatChangeInScene::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerStatChangeInScene::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerStatChangeInScene::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerStatChangeInScene::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSPlayerStatChangeInScene::uin() const {
  return uin_;
}
inline void CSPlayerStatChangeInScene::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
}

// required uint32 Stat = 2;
inline bool CSPlayerStatChangeInScene::has_stat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerStatChangeInScene::set_has_stat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerStatChangeInScene::clear_has_stat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerStatChangeInScene::clear_stat() {
  stat_ = 0u;
  clear_has_stat();
}
inline ::google::protobuf::uint32 CSPlayerStatChangeInScene::stat() const {
  return stat_;
}
inline void CSPlayerStatChangeInScene::set_stat(::google::protobuf::uint32 value) {
  set_has_stat();
  stat_ = value;
}

// -------------------------------------------------------------------

// CSPlayerOSDInfo

// required uint32 Type = 1;
inline bool CSPlayerOSDInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerOSDInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerOSDInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerOSDInfo::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSPlayerOSDInfo::type() const {
  return type_;
}
inline void CSPlayerOSDInfo::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional .vmsg.CSPlayerPosInScene PlayerEnterScene = 2;
inline bool CSPlayerOSDInfo::has_playerenterscene() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerOSDInfo::set_has_playerenterscene() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerOSDInfo::clear_has_playerenterscene() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerOSDInfo::clear_playerenterscene() {
  if (playerenterscene_ != NULL) playerenterscene_->::vmsg::CSPlayerPosInScene::Clear();
  clear_has_playerenterscene();
}
inline const ::vmsg::CSPlayerPosInScene& CSPlayerOSDInfo::playerenterscene() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerenterscene_ != NULL ? *playerenterscene_ : *default_instance().playerenterscene_;
#else
  return playerenterscene_ != NULL ? *playerenterscene_ : *default_instance_->playerenterscene_;
#endif
}
inline ::vmsg::CSPlayerPosInScene* CSPlayerOSDInfo::mutable_playerenterscene() {
  set_has_playerenterscene();
  if (playerenterscene_ == NULL) playerenterscene_ = new ::vmsg::CSPlayerPosInScene;
  return playerenterscene_;
}
inline ::vmsg::CSPlayerPosInScene* CSPlayerOSDInfo::release_playerenterscene() {
  clear_has_playerenterscene();
  ::vmsg::CSPlayerPosInScene* temp = playerenterscene_;
  playerenterscene_ = NULL;
  return temp;
}
inline void CSPlayerOSDInfo::set_allocated_playerenterscene(::vmsg::CSPlayerPosInScene* playerenterscene) {
  delete playerenterscene_;
  playerenterscene_ = playerenterscene;
  if (playerenterscene) {
    set_has_playerenterscene();
  } else {
    clear_has_playerenterscene();
  }
}

// optional uint64 PlayerLeaveSceneUin = 3;
inline bool CSPlayerOSDInfo::has_playerleavesceneuin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPlayerOSDInfo::set_has_playerleavesceneuin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPlayerOSDInfo::clear_has_playerleavesceneuin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPlayerOSDInfo::clear_playerleavesceneuin() {
  playerleavesceneuin_ = GOOGLE_ULONGLONG(0);
  clear_has_playerleavesceneuin();
}
inline ::google::protobuf::uint64 CSPlayerOSDInfo::playerleavesceneuin() const {
  return playerleavesceneuin_;
}
inline void CSPlayerOSDInfo::set_playerleavesceneuin(::google::protobuf::uint64 value) {
  set_has_playerleavesceneuin();
  playerleavesceneuin_ = value;
}

// optional .vmsg.CSPlayerMoveInScene PlayerMoveInScene = 4;
inline bool CSPlayerOSDInfo::has_playermoveinscene() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPlayerOSDInfo::set_has_playermoveinscene() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPlayerOSDInfo::clear_has_playermoveinscene() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPlayerOSDInfo::clear_playermoveinscene() {
  if (playermoveinscene_ != NULL) playermoveinscene_->::vmsg::CSPlayerMoveInScene::Clear();
  clear_has_playermoveinscene();
}
inline const ::vmsg::CSPlayerMoveInScene& CSPlayerOSDInfo::playermoveinscene() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playermoveinscene_ != NULL ? *playermoveinscene_ : *default_instance().playermoveinscene_;
#else
  return playermoveinscene_ != NULL ? *playermoveinscene_ : *default_instance_->playermoveinscene_;
#endif
}
inline ::vmsg::CSPlayerMoveInScene* CSPlayerOSDInfo::mutable_playermoveinscene() {
  set_has_playermoveinscene();
  if (playermoveinscene_ == NULL) playermoveinscene_ = new ::vmsg::CSPlayerMoveInScene;
  return playermoveinscene_;
}
inline ::vmsg::CSPlayerMoveInScene* CSPlayerOSDInfo::release_playermoveinscene() {
  clear_has_playermoveinscene();
  ::vmsg::CSPlayerMoveInScene* temp = playermoveinscene_;
  playermoveinscene_ = NULL;
  return temp;
}
inline void CSPlayerOSDInfo::set_allocated_playermoveinscene(::vmsg::CSPlayerMoveInScene* playermoveinscene) {
  delete playermoveinscene_;
  playermoveinscene_ = playermoveinscene;
  if (playermoveinscene) {
    set_has_playermoveinscene();
  } else {
    clear_has_playermoveinscene();
  }
}

// optional .vmsg.CSPlayerSetPosInScene PlayerSetPosInScene = 5;
inline bool CSPlayerOSDInfo::has_playersetposinscene() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPlayerOSDInfo::set_has_playersetposinscene() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPlayerOSDInfo::clear_has_playersetposinscene() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPlayerOSDInfo::clear_playersetposinscene() {
  if (playersetposinscene_ != NULL) playersetposinscene_->::vmsg::CSPlayerSetPosInScene::Clear();
  clear_has_playersetposinscene();
}
inline const ::vmsg::CSPlayerSetPosInScene& CSPlayerOSDInfo::playersetposinscene() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playersetposinscene_ != NULL ? *playersetposinscene_ : *default_instance().playersetposinscene_;
#else
  return playersetposinscene_ != NULL ? *playersetposinscene_ : *default_instance_->playersetposinscene_;
#endif
}
inline ::vmsg::CSPlayerSetPosInScene* CSPlayerOSDInfo::mutable_playersetposinscene() {
  set_has_playersetposinscene();
  if (playersetposinscene_ == NULL) playersetposinscene_ = new ::vmsg::CSPlayerSetPosInScene;
  return playersetposinscene_;
}
inline ::vmsg::CSPlayerSetPosInScene* CSPlayerOSDInfo::release_playersetposinscene() {
  clear_has_playersetposinscene();
  ::vmsg::CSPlayerSetPosInScene* temp = playersetposinscene_;
  playersetposinscene_ = NULL;
  return temp;
}
inline void CSPlayerOSDInfo::set_allocated_playersetposinscene(::vmsg::CSPlayerSetPosInScene* playersetposinscene) {
  delete playersetposinscene_;
  playersetposinscene_ = playersetposinscene;
  if (playersetposinscene) {
    set_has_playersetposinscene();
  } else {
    clear_has_playersetposinscene();
  }
}

// optional .vmsg.CSPlayerStartAtk PlayerStartAtk = 6;
inline bool CSPlayerOSDInfo::has_playerstartatk() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSPlayerOSDInfo::set_has_playerstartatk() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSPlayerOSDInfo::clear_has_playerstartatk() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSPlayerOSDInfo::clear_playerstartatk() {
  if (playerstartatk_ != NULL) playerstartatk_->::vmsg::CSPlayerStartAtk::Clear();
  clear_has_playerstartatk();
}
inline const ::vmsg::CSPlayerStartAtk& CSPlayerOSDInfo::playerstartatk() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerstartatk_ != NULL ? *playerstartatk_ : *default_instance().playerstartatk_;
#else
  return playerstartatk_ != NULL ? *playerstartatk_ : *default_instance_->playerstartatk_;
#endif
}
inline ::vmsg::CSPlayerStartAtk* CSPlayerOSDInfo::mutable_playerstartatk() {
  set_has_playerstartatk();
  if (playerstartatk_ == NULL) playerstartatk_ = new ::vmsg::CSPlayerStartAtk;
  return playerstartatk_;
}
inline ::vmsg::CSPlayerStartAtk* CSPlayerOSDInfo::release_playerstartatk() {
  clear_has_playerstartatk();
  ::vmsg::CSPlayerStartAtk* temp = playerstartatk_;
  playerstartatk_ = NULL;
  return temp;
}
inline void CSPlayerOSDInfo::set_allocated_playerstartatk(::vmsg::CSPlayerStartAtk* playerstartatk) {
  delete playerstartatk_;
  playerstartatk_ = playerstartatk;
  if (playerstartatk) {
    set_has_playerstartatk();
  } else {
    clear_has_playerstartatk();
  }
}

// optional .vmsg.CSPlayerStopAtk PlayerStopAtk = 7;
inline bool CSPlayerOSDInfo::has_playerstopatk() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSPlayerOSDInfo::set_has_playerstopatk() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSPlayerOSDInfo::clear_has_playerstopatk() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSPlayerOSDInfo::clear_playerstopatk() {
  if (playerstopatk_ != NULL) playerstopatk_->::vmsg::CSPlayerStopAtk::Clear();
  clear_has_playerstopatk();
}
inline const ::vmsg::CSPlayerStopAtk& CSPlayerOSDInfo::playerstopatk() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerstopatk_ != NULL ? *playerstopatk_ : *default_instance().playerstopatk_;
#else
  return playerstopatk_ != NULL ? *playerstopatk_ : *default_instance_->playerstopatk_;
#endif
}
inline ::vmsg::CSPlayerStopAtk* CSPlayerOSDInfo::mutable_playerstopatk() {
  set_has_playerstopatk();
  if (playerstopatk_ == NULL) playerstopatk_ = new ::vmsg::CSPlayerStopAtk;
  return playerstopatk_;
}
inline ::vmsg::CSPlayerStopAtk* CSPlayerOSDInfo::release_playerstopatk() {
  clear_has_playerstopatk();
  ::vmsg::CSPlayerStopAtk* temp = playerstopatk_;
  playerstopatk_ = NULL;
  return temp;
}
inline void CSPlayerOSDInfo::set_allocated_playerstopatk(::vmsg::CSPlayerStopAtk* playerstopatk) {
  delete playerstopatk_;
  playerstopatk_ = playerstopatk;
  if (playerstopatk) {
    set_has_playerstopatk();
  } else {
    clear_has_playerstopatk();
  }
}

// optional .vmsg.CSPlayerSkillInScene PlayerSkill = 8;
inline bool CSPlayerOSDInfo::has_playerskill() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSPlayerOSDInfo::set_has_playerskill() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSPlayerOSDInfo::clear_has_playerskill() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSPlayerOSDInfo::clear_playerskill() {
  if (playerskill_ != NULL) playerskill_->::vmsg::CSPlayerSkillInScene::Clear();
  clear_has_playerskill();
}
inline const ::vmsg::CSPlayerSkillInScene& CSPlayerOSDInfo::playerskill() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerskill_ != NULL ? *playerskill_ : *default_instance().playerskill_;
#else
  return playerskill_ != NULL ? *playerskill_ : *default_instance_->playerskill_;
#endif
}
inline ::vmsg::CSPlayerSkillInScene* CSPlayerOSDInfo::mutable_playerskill() {
  set_has_playerskill();
  if (playerskill_ == NULL) playerskill_ = new ::vmsg::CSPlayerSkillInScene;
  return playerskill_;
}
inline ::vmsg::CSPlayerSkillInScene* CSPlayerOSDInfo::release_playerskill() {
  clear_has_playerskill();
  ::vmsg::CSPlayerSkillInScene* temp = playerskill_;
  playerskill_ = NULL;
  return temp;
}
inline void CSPlayerOSDInfo::set_allocated_playerskill(::vmsg::CSPlayerSkillInScene* playerskill) {
  delete playerskill_;
  playerskill_ = playerskill;
  if (playerskill) {
    set_has_playerskill();
  } else {
    clear_has_playerskill();
  }
}

// optional .vmsg.CSPlayerStatChangeInScene PlayerStatChange = 9;
inline bool CSPlayerOSDInfo::has_playerstatchange() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSPlayerOSDInfo::set_has_playerstatchange() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSPlayerOSDInfo::clear_has_playerstatchange() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSPlayerOSDInfo::clear_playerstatchange() {
  if (playerstatchange_ != NULL) playerstatchange_->::vmsg::CSPlayerStatChangeInScene::Clear();
  clear_has_playerstatchange();
}
inline const ::vmsg::CSPlayerStatChangeInScene& CSPlayerOSDInfo::playerstatchange() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerstatchange_ != NULL ? *playerstatchange_ : *default_instance().playerstatchange_;
#else
  return playerstatchange_ != NULL ? *playerstatchange_ : *default_instance_->playerstatchange_;
#endif
}
inline ::vmsg::CSPlayerStatChangeInScene* CSPlayerOSDInfo::mutable_playerstatchange() {
  set_has_playerstatchange();
  if (playerstatchange_ == NULL) playerstatchange_ = new ::vmsg::CSPlayerStatChangeInScene;
  return playerstatchange_;
}
inline ::vmsg::CSPlayerStatChangeInScene* CSPlayerOSDInfo::release_playerstatchange() {
  clear_has_playerstatchange();
  ::vmsg::CSPlayerStatChangeInScene* temp = playerstatchange_;
  playerstatchange_ = NULL;
  return temp;
}
inline void CSPlayerOSDInfo::set_allocated_playerstatchange(::vmsg::CSPlayerStatChangeInScene* playerstatchange) {
  delete playerstatchange_;
  playerstatchange_ = playerstatchange;
  if (playerstatchange) {
    set_has_playerstatchange();
  } else {
    clear_has_playerstatchange();
  }
}

// -------------------------------------------------------------------

// CSOSDMonstersInfo

// required uint32 MonsterID = 1;
inline bool CSOSDMonstersInfo::has_monsterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSOSDMonstersInfo::set_has_monsterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSOSDMonstersInfo::clear_has_monsterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSOSDMonstersInfo::clear_monsterid() {
  monsterid_ = 0u;
  clear_has_monsterid();
}
inline ::google::protobuf::uint32 CSOSDMonstersInfo::monsterid() const {
  return monsterid_;
}
inline void CSOSDMonstersInfo::set_monsterid(::google::protobuf::uint32 value) {
  set_has_monsterid();
  monsterid_ = value;
}

// required .vmsg.CSScenePoint ScenePoint = 2;
inline bool CSOSDMonstersInfo::has_scenepoint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSOSDMonstersInfo::set_has_scenepoint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSOSDMonstersInfo::clear_has_scenepoint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSOSDMonstersInfo::clear_scenepoint() {
  if (scenepoint_ != NULL) scenepoint_->::vmsg::CSScenePoint::Clear();
  clear_has_scenepoint();
}
inline const ::vmsg::CSScenePoint& CSOSDMonstersInfo::scenepoint() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return scenepoint_ != NULL ? *scenepoint_ : *default_instance().scenepoint_;
#else
  return scenepoint_ != NULL ? *scenepoint_ : *default_instance_->scenepoint_;
#endif
}
inline ::vmsg::CSScenePoint* CSOSDMonstersInfo::mutable_scenepoint() {
  set_has_scenepoint();
  if (scenepoint_ == NULL) scenepoint_ = new ::vmsg::CSScenePoint;
  return scenepoint_;
}
inline ::vmsg::CSScenePoint* CSOSDMonstersInfo::release_scenepoint() {
  clear_has_scenepoint();
  ::vmsg::CSScenePoint* temp = scenepoint_;
  scenepoint_ = NULL;
  return temp;
}
inline void CSOSDMonstersInfo::set_allocated_scenepoint(::vmsg::CSScenePoint* scenepoint) {
  delete scenepoint_;
  scenepoint_ = scenepoint;
  if (scenepoint) {
    set_has_scenepoint();
  } else {
    clear_has_scenepoint();
  }
}

// required uint32 MOnsterType = 3;
inline bool CSOSDMonstersInfo::has_monstertype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSOSDMonstersInfo::set_has_monstertype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSOSDMonstersInfo::clear_has_monstertype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSOSDMonstersInfo::clear_monstertype() {
  monstertype_ = 0u;
  clear_has_monstertype();
}
inline ::google::protobuf::uint32 CSOSDMonstersInfo::monstertype() const {
  return monstertype_;
}
inline void CSOSDMonstersInfo::set_monstertype(::google::protobuf::uint32 value) {
  set_has_monstertype();
  monstertype_ = value;
}

// required uint32 HP = 4;
inline bool CSOSDMonstersInfo::has_hp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSOSDMonstersInfo::set_has_hp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSOSDMonstersInfo::clear_has_hp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSOSDMonstersInfo::clear_hp() {
  hp_ = 0u;
  clear_has_hp();
}
inline ::google::protobuf::uint32 CSOSDMonstersInfo::hp() const {
  return hp_;
}
inline void CSOSDMonstersInfo::set_hp(::google::protobuf::uint32 value) {
  set_has_hp();
  hp_ = value;
}

// required uint32 Lv = 5;
inline bool CSOSDMonstersInfo::has_lv() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSOSDMonstersInfo::set_has_lv() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSOSDMonstersInfo::clear_has_lv() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSOSDMonstersInfo::clear_lv() {
  lv_ = 0u;
  clear_has_lv();
}
inline ::google::protobuf::uint32 CSOSDMonstersInfo::lv() const {
  return lv_;
}
inline void CSOSDMonstersInfo::set_lv(::google::protobuf::uint32 value) {
  set_has_lv();
  lv_ = value;
}

// required uint32 Channel = 6;
inline bool CSOSDMonstersInfo::has_channel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSOSDMonstersInfo::set_has_channel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSOSDMonstersInfo::clear_has_channel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSOSDMonstersInfo::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 CSOSDMonstersInfo::channel() const {
  return channel_;
}
inline void CSOSDMonstersInfo::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
}

// required uint32 Wave = 7;
inline bool CSOSDMonstersInfo::has_wave() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSOSDMonstersInfo::set_has_wave() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSOSDMonstersInfo::clear_has_wave() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSOSDMonstersInfo::clear_wave() {
  wave_ = 0u;
  clear_has_wave();
}
inline ::google::protobuf::uint32 CSOSDMonstersInfo::wave() const {
  return wave_;
}
inline void CSOSDMonstersInfo::set_wave(::google::protobuf::uint32 value) {
  set_has_wave();
  wave_ = value;
}

// required uint32 Action = 8;
inline bool CSOSDMonstersInfo::has_action() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSOSDMonstersInfo::set_has_action() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSOSDMonstersInfo::clear_has_action() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSOSDMonstersInfo::clear_action() {
  action_ = 0u;
  clear_has_action();
}
inline ::google::protobuf::uint32 CSOSDMonstersInfo::action() const {
  return action_;
}
inline void CSOSDMonstersInfo::set_action(::google::protobuf::uint32 value) {
  set_has_action();
  action_ = value;
}

// -------------------------------------------------------------------

// CSQueryPlayerSceneOSDInfoRsp

// repeated .vmsg.CSPlayerPosInScene PlayersPos = 1;
inline int CSQueryPlayerSceneOSDInfoRsp::playerspos_size() const {
  return playerspos_.size();
}
inline void CSQueryPlayerSceneOSDInfoRsp::clear_playerspos() {
  playerspos_.Clear();
}
inline const ::vmsg::CSPlayerPosInScene& CSQueryPlayerSceneOSDInfoRsp::playerspos(int index) const {
  return playerspos_.Get(index);
}
inline ::vmsg::CSPlayerPosInScene* CSQueryPlayerSceneOSDInfoRsp::mutable_playerspos(int index) {
  return playerspos_.Mutable(index);
}
inline ::vmsg::CSPlayerPosInScene* CSQueryPlayerSceneOSDInfoRsp::add_playerspos() {
  return playerspos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerPosInScene >&
CSQueryPlayerSceneOSDInfoRsp::playerspos() const {
  return playerspos_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerPosInScene >*
CSQueryPlayerSceneOSDInfoRsp::mutable_playerspos() {
  return &playerspos_;
}

// repeated .vmsg.CSOSDMonstersInfo MonsterOSDInfos = 2;
inline int CSQueryPlayerSceneOSDInfoRsp::monsterosdinfos_size() const {
  return monsterosdinfos_.size();
}
inline void CSQueryPlayerSceneOSDInfoRsp::clear_monsterosdinfos() {
  monsterosdinfos_.Clear();
}
inline const ::vmsg::CSOSDMonstersInfo& CSQueryPlayerSceneOSDInfoRsp::monsterosdinfos(int index) const {
  return monsterosdinfos_.Get(index);
}
inline ::vmsg::CSOSDMonstersInfo* CSQueryPlayerSceneOSDInfoRsp::mutable_monsterosdinfos(int index) {
  return monsterosdinfos_.Mutable(index);
}
inline ::vmsg::CSOSDMonstersInfo* CSQueryPlayerSceneOSDInfoRsp::add_monsterosdinfos() {
  return monsterosdinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSOSDMonstersInfo >&
CSQueryPlayerSceneOSDInfoRsp::monsterosdinfos() const {
  return monsterosdinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSOSDMonstersInfo >*
CSQueryPlayerSceneOSDInfoRsp::mutable_monsterosdinfos() {
  return &monsterosdinfos_;
}

// -------------------------------------------------------------------

// CSSyncPlayerOSDInfo

// repeated .vmsg.CSPlayerOSDInfo PlayerOSDInfos = 1;
inline int CSSyncPlayerOSDInfo::playerosdinfos_size() const {
  return playerosdinfos_.size();
}
inline void CSSyncPlayerOSDInfo::clear_playerosdinfos() {
  playerosdinfos_.Clear();
}
inline const ::vmsg::CSPlayerOSDInfo& CSSyncPlayerOSDInfo::playerosdinfos(int index) const {
  return playerosdinfos_.Get(index);
}
inline ::vmsg::CSPlayerOSDInfo* CSSyncPlayerOSDInfo::mutable_playerosdinfos(int index) {
  return playerosdinfos_.Mutable(index);
}
inline ::vmsg::CSPlayerOSDInfo* CSSyncPlayerOSDInfo::add_playerosdinfos() {
  return playerosdinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerOSDInfo >&
CSSyncPlayerOSDInfo::playerosdinfos() const {
  return playerosdinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerOSDInfo >*
CSSyncPlayerOSDInfo::mutable_playerosdinfos() {
  return &playerosdinfos_;
}

// -------------------------------------------------------------------

// CSPlayerChangeSceneRqst

// required uint32 NewSceneID = 1;
inline bool CSPlayerChangeSceneRqst::has_newsceneid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerChangeSceneRqst::set_has_newsceneid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerChangeSceneRqst::clear_has_newsceneid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerChangeSceneRqst::clear_newsceneid() {
  newsceneid_ = 0u;
  clear_has_newsceneid();
}
inline ::google::protobuf::uint32 CSPlayerChangeSceneRqst::newsceneid() const {
  return newsceneid_;
}
inline void CSPlayerChangeSceneRqst::set_newsceneid(::google::protobuf::uint32 value) {
  set_has_newsceneid();
  newsceneid_ = value;
}

// -------------------------------------------------------------------

// CSSceneOSDRequest

// optional .vmsg.CSPlayerMoveInScene PlayerMove_Rqst = 1;
inline bool CSSceneOSDRequest::has_playermove_rqst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSceneOSDRequest::set_has_playermove_rqst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSceneOSDRequest::clear_has_playermove_rqst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSceneOSDRequest::clear_playermove_rqst() {
  if (playermove_rqst_ != NULL) playermove_rqst_->::vmsg::CSPlayerMoveInScene::Clear();
  clear_has_playermove_rqst();
}
inline const ::vmsg::CSPlayerMoveInScene& CSSceneOSDRequest::playermove_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playermove_rqst_ != NULL ? *playermove_rqst_ : *default_instance().playermove_rqst_;
#else
  return playermove_rqst_ != NULL ? *playermove_rqst_ : *default_instance_->playermove_rqst_;
#endif
}
inline ::vmsg::CSPlayerMoveInScene* CSSceneOSDRequest::mutable_playermove_rqst() {
  set_has_playermove_rqst();
  if (playermove_rqst_ == NULL) playermove_rqst_ = new ::vmsg::CSPlayerMoveInScene;
  return playermove_rqst_;
}
inline ::vmsg::CSPlayerMoveInScene* CSSceneOSDRequest::release_playermove_rqst() {
  clear_has_playermove_rqst();
  ::vmsg::CSPlayerMoveInScene* temp = playermove_rqst_;
  playermove_rqst_ = NULL;
  return temp;
}
inline void CSSceneOSDRequest::set_allocated_playermove_rqst(::vmsg::CSPlayerMoveInScene* playermove_rqst) {
  delete playermove_rqst_;
  playermove_rqst_ = playermove_rqst;
  if (playermove_rqst) {
    set_has_playermove_rqst();
  } else {
    clear_has_playermove_rqst();
  }
}

// optional .vmsg.CSPlayerSetPosInScene PlayerSetPos_Rqst = 2;
inline bool CSSceneOSDRequest::has_playersetpos_rqst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSSceneOSDRequest::set_has_playersetpos_rqst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSSceneOSDRequest::clear_has_playersetpos_rqst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSSceneOSDRequest::clear_playersetpos_rqst() {
  if (playersetpos_rqst_ != NULL) playersetpos_rqst_->::vmsg::CSPlayerSetPosInScene::Clear();
  clear_has_playersetpos_rqst();
}
inline const ::vmsg::CSPlayerSetPosInScene& CSSceneOSDRequest::playersetpos_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playersetpos_rqst_ != NULL ? *playersetpos_rqst_ : *default_instance().playersetpos_rqst_;
#else
  return playersetpos_rqst_ != NULL ? *playersetpos_rqst_ : *default_instance_->playersetpos_rqst_;
#endif
}
inline ::vmsg::CSPlayerSetPosInScene* CSSceneOSDRequest::mutable_playersetpos_rqst() {
  set_has_playersetpos_rqst();
  if (playersetpos_rqst_ == NULL) playersetpos_rqst_ = new ::vmsg::CSPlayerSetPosInScene;
  return playersetpos_rqst_;
}
inline ::vmsg::CSPlayerSetPosInScene* CSSceneOSDRequest::release_playersetpos_rqst() {
  clear_has_playersetpos_rqst();
  ::vmsg::CSPlayerSetPosInScene* temp = playersetpos_rqst_;
  playersetpos_rqst_ = NULL;
  return temp;
}
inline void CSSceneOSDRequest::set_allocated_playersetpos_rqst(::vmsg::CSPlayerSetPosInScene* playersetpos_rqst) {
  delete playersetpos_rqst_;
  playersetpos_rqst_ = playersetpos_rqst;
  if (playersetpos_rqst) {
    set_has_playersetpos_rqst();
  } else {
    clear_has_playersetpos_rqst();
  }
}

// optional .vmsg.CSPlayerChangeSceneRqst PlayerChangeScene_Rqst = 3;
inline bool CSSceneOSDRequest::has_playerchangescene_rqst() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSSceneOSDRequest::set_has_playerchangescene_rqst() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSSceneOSDRequest::clear_has_playerchangescene_rqst() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSSceneOSDRequest::clear_playerchangescene_rqst() {
  if (playerchangescene_rqst_ != NULL) playerchangescene_rqst_->::vmsg::CSPlayerChangeSceneRqst::Clear();
  clear_has_playerchangescene_rqst();
}
inline const ::vmsg::CSPlayerChangeSceneRqst& CSSceneOSDRequest::playerchangescene_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerchangescene_rqst_ != NULL ? *playerchangescene_rqst_ : *default_instance().playerchangescene_rqst_;
#else
  return playerchangescene_rqst_ != NULL ? *playerchangescene_rqst_ : *default_instance_->playerchangescene_rqst_;
#endif
}
inline ::vmsg::CSPlayerChangeSceneRqst* CSSceneOSDRequest::mutable_playerchangescene_rqst() {
  set_has_playerchangescene_rqst();
  if (playerchangescene_rqst_ == NULL) playerchangescene_rqst_ = new ::vmsg::CSPlayerChangeSceneRqst;
  return playerchangescene_rqst_;
}
inline ::vmsg::CSPlayerChangeSceneRqst* CSSceneOSDRequest::release_playerchangescene_rqst() {
  clear_has_playerchangescene_rqst();
  ::vmsg::CSPlayerChangeSceneRqst* temp = playerchangescene_rqst_;
  playerchangescene_rqst_ = NULL;
  return temp;
}
inline void CSSceneOSDRequest::set_allocated_playerchangescene_rqst(::vmsg::CSPlayerChangeSceneRqst* playerchangescene_rqst) {
  delete playerchangescene_rqst_;
  playerchangescene_rqst_ = playerchangescene_rqst;
  if (playerchangescene_rqst) {
    set_has_playerchangescene_rqst();
  } else {
    clear_has_playerchangescene_rqst();
  }
}

// optional .vmsg.CSPlayerStartAtk PlayerStartAtk_Rqst = 4;
inline bool CSSceneOSDRequest::has_playerstartatk_rqst() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSSceneOSDRequest::set_has_playerstartatk_rqst() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSSceneOSDRequest::clear_has_playerstartatk_rqst() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSSceneOSDRequest::clear_playerstartatk_rqst() {
  if (playerstartatk_rqst_ != NULL) playerstartatk_rqst_->::vmsg::CSPlayerStartAtk::Clear();
  clear_has_playerstartatk_rqst();
}
inline const ::vmsg::CSPlayerStartAtk& CSSceneOSDRequest::playerstartatk_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerstartatk_rqst_ != NULL ? *playerstartatk_rqst_ : *default_instance().playerstartatk_rqst_;
#else
  return playerstartatk_rqst_ != NULL ? *playerstartatk_rqst_ : *default_instance_->playerstartatk_rqst_;
#endif
}
inline ::vmsg::CSPlayerStartAtk* CSSceneOSDRequest::mutable_playerstartatk_rqst() {
  set_has_playerstartatk_rqst();
  if (playerstartatk_rqst_ == NULL) playerstartatk_rqst_ = new ::vmsg::CSPlayerStartAtk;
  return playerstartatk_rqst_;
}
inline ::vmsg::CSPlayerStartAtk* CSSceneOSDRequest::release_playerstartatk_rqst() {
  clear_has_playerstartatk_rqst();
  ::vmsg::CSPlayerStartAtk* temp = playerstartatk_rqst_;
  playerstartatk_rqst_ = NULL;
  return temp;
}
inline void CSSceneOSDRequest::set_allocated_playerstartatk_rqst(::vmsg::CSPlayerStartAtk* playerstartatk_rqst) {
  delete playerstartatk_rqst_;
  playerstartatk_rqst_ = playerstartatk_rqst;
  if (playerstartatk_rqst) {
    set_has_playerstartatk_rqst();
  } else {
    clear_has_playerstartatk_rqst();
  }
}

// optional .vmsg.CSPlayerStopAtk PlayerStopAtk_Rqst = 5;
inline bool CSSceneOSDRequest::has_playerstopatk_rqst() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSSceneOSDRequest::set_has_playerstopatk_rqst() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSSceneOSDRequest::clear_has_playerstopatk_rqst() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSSceneOSDRequest::clear_playerstopatk_rqst() {
  if (playerstopatk_rqst_ != NULL) playerstopatk_rqst_->::vmsg::CSPlayerStopAtk::Clear();
  clear_has_playerstopatk_rqst();
}
inline const ::vmsg::CSPlayerStopAtk& CSSceneOSDRequest::playerstopatk_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerstopatk_rqst_ != NULL ? *playerstopatk_rqst_ : *default_instance().playerstopatk_rqst_;
#else
  return playerstopatk_rqst_ != NULL ? *playerstopatk_rqst_ : *default_instance_->playerstopatk_rqst_;
#endif
}
inline ::vmsg::CSPlayerStopAtk* CSSceneOSDRequest::mutable_playerstopatk_rqst() {
  set_has_playerstopatk_rqst();
  if (playerstopatk_rqst_ == NULL) playerstopatk_rqst_ = new ::vmsg::CSPlayerStopAtk;
  return playerstopatk_rqst_;
}
inline ::vmsg::CSPlayerStopAtk* CSSceneOSDRequest::release_playerstopatk_rqst() {
  clear_has_playerstopatk_rqst();
  ::vmsg::CSPlayerStopAtk* temp = playerstopatk_rqst_;
  playerstopatk_rqst_ = NULL;
  return temp;
}
inline void CSSceneOSDRequest::set_allocated_playerstopatk_rqst(::vmsg::CSPlayerStopAtk* playerstopatk_rqst) {
  delete playerstopatk_rqst_;
  playerstopatk_rqst_ = playerstopatk_rqst;
  if (playerstopatk_rqst) {
    set_has_playerstopatk_rqst();
  } else {
    clear_has_playerstopatk_rqst();
  }
}

// optional .vmsg.CSPlayerSkillInScene PlayerSkill_Rqst = 6;
inline bool CSSceneOSDRequest::has_playerskill_rqst() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSSceneOSDRequest::set_has_playerskill_rqst() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSSceneOSDRequest::clear_has_playerskill_rqst() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSSceneOSDRequest::clear_playerskill_rqst() {
  if (playerskill_rqst_ != NULL) playerskill_rqst_->::vmsg::CSPlayerSkillInScene::Clear();
  clear_has_playerskill_rqst();
}
inline const ::vmsg::CSPlayerSkillInScene& CSSceneOSDRequest::playerskill_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerskill_rqst_ != NULL ? *playerskill_rqst_ : *default_instance().playerskill_rqst_;
#else
  return playerskill_rqst_ != NULL ? *playerskill_rqst_ : *default_instance_->playerskill_rqst_;
#endif
}
inline ::vmsg::CSPlayerSkillInScene* CSSceneOSDRequest::mutable_playerskill_rqst() {
  set_has_playerskill_rqst();
  if (playerskill_rqst_ == NULL) playerskill_rqst_ = new ::vmsg::CSPlayerSkillInScene;
  return playerskill_rqst_;
}
inline ::vmsg::CSPlayerSkillInScene* CSSceneOSDRequest::release_playerskill_rqst() {
  clear_has_playerskill_rqst();
  ::vmsg::CSPlayerSkillInScene* temp = playerskill_rqst_;
  playerskill_rqst_ = NULL;
  return temp;
}
inline void CSSceneOSDRequest::set_allocated_playerskill_rqst(::vmsg::CSPlayerSkillInScene* playerskill_rqst) {
  delete playerskill_rqst_;
  playerskill_rqst_ = playerskill_rqst;
  if (playerskill_rqst) {
    set_has_playerskill_rqst();
  } else {
    clear_has_playerskill_rqst();
  }
}

// -------------------------------------------------------------------

// CSSceneOSDRespond

// optional .vmsg.CSQueryPlayerSceneOSDInfoRsp QueryPlayerSceneOSDInfo_Rsp = 1;
inline bool CSSceneOSDRespond::has_queryplayersceneosdinfo_rsp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSceneOSDRespond::set_has_queryplayersceneosdinfo_rsp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSceneOSDRespond::clear_has_queryplayersceneosdinfo_rsp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSceneOSDRespond::clear_queryplayersceneosdinfo_rsp() {
  if (queryplayersceneosdinfo_rsp_ != NULL) queryplayersceneosdinfo_rsp_->::vmsg::CSQueryPlayerSceneOSDInfoRsp::Clear();
  clear_has_queryplayersceneosdinfo_rsp();
}
inline const ::vmsg::CSQueryPlayerSceneOSDInfoRsp& CSSceneOSDRespond::queryplayersceneosdinfo_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return queryplayersceneosdinfo_rsp_ != NULL ? *queryplayersceneosdinfo_rsp_ : *default_instance().queryplayersceneosdinfo_rsp_;
#else
  return queryplayersceneosdinfo_rsp_ != NULL ? *queryplayersceneosdinfo_rsp_ : *default_instance_->queryplayersceneosdinfo_rsp_;
#endif
}
inline ::vmsg::CSQueryPlayerSceneOSDInfoRsp* CSSceneOSDRespond::mutable_queryplayersceneosdinfo_rsp() {
  set_has_queryplayersceneosdinfo_rsp();
  if (queryplayersceneosdinfo_rsp_ == NULL) queryplayersceneosdinfo_rsp_ = new ::vmsg::CSQueryPlayerSceneOSDInfoRsp;
  return queryplayersceneosdinfo_rsp_;
}
inline ::vmsg::CSQueryPlayerSceneOSDInfoRsp* CSSceneOSDRespond::release_queryplayersceneosdinfo_rsp() {
  clear_has_queryplayersceneosdinfo_rsp();
  ::vmsg::CSQueryPlayerSceneOSDInfoRsp* temp = queryplayersceneosdinfo_rsp_;
  queryplayersceneosdinfo_rsp_ = NULL;
  return temp;
}
inline void CSSceneOSDRespond::set_allocated_queryplayersceneosdinfo_rsp(::vmsg::CSQueryPlayerSceneOSDInfoRsp* queryplayersceneosdinfo_rsp) {
  delete queryplayersceneosdinfo_rsp_;
  queryplayersceneosdinfo_rsp_ = queryplayersceneosdinfo_rsp;
  if (queryplayersceneosdinfo_rsp) {
    set_has_queryplayersceneosdinfo_rsp();
  } else {
    clear_has_queryplayersceneosdinfo_rsp();
  }
}

// optional .vmsg.CSSyncPlayerOSDInfo SyncPlayerOSDInfo_Push = 2;
inline bool CSSceneOSDRespond::has_syncplayerosdinfo_push() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSSceneOSDRespond::set_has_syncplayerosdinfo_push() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSSceneOSDRespond::clear_has_syncplayerosdinfo_push() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSSceneOSDRespond::clear_syncplayerosdinfo_push() {
  if (syncplayerosdinfo_push_ != NULL) syncplayerosdinfo_push_->::vmsg::CSSyncPlayerOSDInfo::Clear();
  clear_has_syncplayerosdinfo_push();
}
inline const ::vmsg::CSSyncPlayerOSDInfo& CSSceneOSDRespond::syncplayerosdinfo_push() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return syncplayerosdinfo_push_ != NULL ? *syncplayerosdinfo_push_ : *default_instance().syncplayerosdinfo_push_;
#else
  return syncplayerosdinfo_push_ != NULL ? *syncplayerosdinfo_push_ : *default_instance_->syncplayerosdinfo_push_;
#endif
}
inline ::vmsg::CSSyncPlayerOSDInfo* CSSceneOSDRespond::mutable_syncplayerosdinfo_push() {
  set_has_syncplayerosdinfo_push();
  if (syncplayerosdinfo_push_ == NULL) syncplayerosdinfo_push_ = new ::vmsg::CSSyncPlayerOSDInfo;
  return syncplayerosdinfo_push_;
}
inline ::vmsg::CSSyncPlayerOSDInfo* CSSceneOSDRespond::release_syncplayerosdinfo_push() {
  clear_has_syncplayerosdinfo_push();
  ::vmsg::CSSyncPlayerOSDInfo* temp = syncplayerosdinfo_push_;
  syncplayerosdinfo_push_ = NULL;
  return temp;
}
inline void CSSceneOSDRespond::set_allocated_syncplayerosdinfo_push(::vmsg::CSSyncPlayerOSDInfo* syncplayerosdinfo_push) {
  delete syncplayerosdinfo_push_;
  syncplayerosdinfo_push_ = syncplayerosdinfo_push;
  if (syncplayerosdinfo_push) {
    set_has_syncplayerosdinfo_push();
  } else {
    clear_has_syncplayerosdinfo_push();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CSSenceOSD_2eproto__INCLUDED
