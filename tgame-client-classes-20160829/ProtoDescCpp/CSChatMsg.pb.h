// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSChatMsg.proto

#ifndef PROTOBUF_CSChatMsg_2eproto__INCLUDED
#define PROTOBUF_CSChatMsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MsgBase.pb.h"
// @@protoc_insertion_point(includes)

namespace vmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CSChatMsg_2eproto();
void protobuf_AssignDesc_CSChatMsg_2eproto();
void protobuf_ShutdownFile_CSChatMsg_2eproto();

class CSChatSendMsgRqst;
class CSChatInfo;
class CSChatMsgNotify;
class CSChatRequest;
class CSChatRespond;

enum CHAT_CHANNEL_TYPE {
  CHAT_CHANNEL_WORLD = 1,
  CHAT_CHANNEL_GUILD = 2,
  CHAT_CHANNEL_SECRET = 3
};
bool CHAT_CHANNEL_TYPE_IsValid(int value);
const CHAT_CHANNEL_TYPE CHAT_CHANNEL_TYPE_MIN = CHAT_CHANNEL_WORLD;
const CHAT_CHANNEL_TYPE CHAT_CHANNEL_TYPE_MAX = CHAT_CHANNEL_SECRET;
const int CHAT_CHANNEL_TYPE_ARRAYSIZE = CHAT_CHANNEL_TYPE_MAX + 1;

// ===================================================================

class CSChatSendMsgRqst : public ::google::protobuf::MessageLite {
 public:
  CSChatSendMsgRqst();
  virtual ~CSChatSendMsgRqst();

  CSChatSendMsgRqst(const CSChatSendMsgRqst& from);

  inline CSChatSendMsgRqst& operator=(const CSChatSendMsgRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSChatSendMsgRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChatSendMsgRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChatSendMsgRqst* other);

  // implements Message ----------------------------------------------

  CSChatSendMsgRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChatSendMsgRqst& from);
  void MergeFrom(const CSChatSendMsgRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ChannelType = 1;
  inline bool has_channeltype() const;
  inline void clear_channeltype();
  static const int kChannelTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 channeltype() const;
  inline void set_channeltype(::google::protobuf::uint32 value);

  // required string MsgContent = 2;
  inline bool has_msgcontent() const;
  inline void clear_msgcontent();
  static const int kMsgContentFieldNumber = 2;
  inline const ::std::string& msgcontent() const;
  inline void set_msgcontent(const ::std::string& value);
  inline void set_msgcontent(const char* value);
  inline void set_msgcontent(const char* value, size_t size);
  inline ::std::string* mutable_msgcontent();
  inline ::std::string* release_msgcontent();
  inline void set_allocated_msgcontent(::std::string* msgcontent);

  // optional uint64 ReceiveUin = 3;
  inline bool has_receiveuin() const;
  inline void clear_receiveuin();
  static const int kReceiveUinFieldNumber = 3;
  inline ::google::protobuf::uint64 receiveuin() const;
  inline void set_receiveuin(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSChatSendMsgRqst)
 private:
  inline void set_has_channeltype();
  inline void clear_has_channeltype();
  inline void set_has_msgcontent();
  inline void clear_has_msgcontent();
  inline void set_has_receiveuin();
  inline void clear_has_receiveuin();

  ::std::string* msgcontent_;
  ::google::protobuf::uint64 receiveuin_;
  ::google::protobuf::uint32 channeltype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSChatMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSChatMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSChatMsg_2eproto();
  friend void protobuf_ShutdownFile_CSChatMsg_2eproto();

  void InitAsDefaultInstance();
  static CSChatSendMsgRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSChatInfo : public ::google::protobuf::MessageLite {
 public:
  CSChatInfo();
  virtual ~CSChatInfo();

  CSChatInfo(const CSChatInfo& from);

  inline CSChatInfo& operator=(const CSChatInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSChatInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChatInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChatInfo* other);

  // implements Message ----------------------------------------------

  CSChatInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChatInfo& from);
  void MergeFrom(const CSChatInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string SenderNick = 1;
  inline bool has_sendernick() const;
  inline void clear_sendernick();
  static const int kSenderNickFieldNumber = 1;
  inline const ::std::string& sendernick() const;
  inline void set_sendernick(const ::std::string& value);
  inline void set_sendernick(const char* value);
  inline void set_sendernick(const char* value, size_t size);
  inline ::std::string* mutable_sendernick();
  inline ::std::string* release_sendernick();
  inline void set_allocated_sendernick(::std::string* sendernick);

  // required uint64 SenderUin = 2;
  inline bool has_senderuin() const;
  inline void clear_senderuin();
  static const int kSenderUinFieldNumber = 2;
  inline ::google::protobuf::uint64 senderuin() const;
  inline void set_senderuin(::google::protobuf::uint64 value);

  // required uint32 SendTime = 3;
  inline bool has_sendtime() const;
  inline void clear_sendtime();
  static const int kSendTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 sendtime() const;
  inline void set_sendtime(::google::protobuf::uint32 value);

  // required string MsgContent = 4;
  inline bool has_msgcontent() const;
  inline void clear_msgcontent();
  static const int kMsgContentFieldNumber = 4;
  inline const ::std::string& msgcontent() const;
  inline void set_msgcontent(const ::std::string& value);
  inline void set_msgcontent(const char* value);
  inline void set_msgcontent(const char* value, size_t size);
  inline ::std::string* mutable_msgcontent();
  inline ::std::string* release_msgcontent();
  inline void set_allocated_msgcontent(::std::string* msgcontent);

  // required uint32 VipLv = 5;
  inline bool has_viplv() const;
  inline void clear_viplv();
  static const int kVipLvFieldNumber = 5;
  inline ::google::protobuf::uint32 viplv() const;
  inline void set_viplv(::google::protobuf::uint32 value);

  // optional uint32 ShowID = 6;
  inline bool has_showid() const;
  inline void clear_showid();
  static const int kShowIDFieldNumber = 6;
  inline ::google::protobuf::uint32 showid() const;
  inline void set_showid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSChatInfo)
 private:
  inline void set_has_sendernick();
  inline void clear_has_sendernick();
  inline void set_has_senderuin();
  inline void clear_has_senderuin();
  inline void set_has_sendtime();
  inline void clear_has_sendtime();
  inline void set_has_msgcontent();
  inline void clear_has_msgcontent();
  inline void set_has_viplv();
  inline void clear_has_viplv();
  inline void set_has_showid();
  inline void clear_has_showid();

  ::std::string* sendernick_;
  ::google::protobuf::uint64 senderuin_;
  ::std::string* msgcontent_;
  ::google::protobuf::uint32 sendtime_;
  ::google::protobuf::uint32 viplv_;
  ::google::protobuf::uint32 showid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSChatMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSChatMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSChatMsg_2eproto();
  friend void protobuf_ShutdownFile_CSChatMsg_2eproto();

  void InitAsDefaultInstance();
  static CSChatInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSChatMsgNotify : public ::google::protobuf::MessageLite {
 public:
  CSChatMsgNotify();
  virtual ~CSChatMsgNotify();

  CSChatMsgNotify(const CSChatMsgNotify& from);

  inline CSChatMsgNotify& operator=(const CSChatMsgNotify& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSChatMsgNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChatMsgNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChatMsgNotify* other);

  // implements Message ----------------------------------------------

  CSChatMsgNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChatMsgNotify& from);
  void MergeFrom(const CSChatMsgNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ChannelType = 1;
  inline bool has_channeltype() const;
  inline void clear_channeltype();
  static const int kChannelTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 channeltype() const;
  inline void set_channeltype(::google::protobuf::uint32 value);

  // repeated .vmsg.CSChatInfo ChatInfos = 2;
  inline int chatinfos_size() const;
  inline void clear_chatinfos();
  static const int kChatInfosFieldNumber = 2;
  inline const ::vmsg::CSChatInfo& chatinfos(int index) const;
  inline ::vmsg::CSChatInfo* mutable_chatinfos(int index);
  inline ::vmsg::CSChatInfo* add_chatinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSChatInfo >&
      chatinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSChatInfo >*
      mutable_chatinfos();

  // @@protoc_insertion_point(class_scope:vmsg.CSChatMsgNotify)
 private:
  inline void set_has_channeltype();
  inline void clear_has_channeltype();

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSChatInfo > chatinfos_;
  ::google::protobuf::uint32 channeltype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSChatMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSChatMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSChatMsg_2eproto();
  friend void protobuf_ShutdownFile_CSChatMsg_2eproto();

  void InitAsDefaultInstance();
  static CSChatMsgNotify* default_instance_;
};
// -------------------------------------------------------------------

class CSChatRequest : public ::google::protobuf::MessageLite {
 public:
  CSChatRequest();
  virtual ~CSChatRequest();

  CSChatRequest(const CSChatRequest& from);

  inline CSChatRequest& operator=(const CSChatRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSChatRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChatRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChatRequest* other);

  // implements Message ----------------------------------------------

  CSChatRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChatRequest& from);
  void MergeFrom(const CSChatRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSChatSendMsgRqst SendMsg_Rqst = 1;
  inline bool has_sendmsg_rqst() const;
  inline void clear_sendmsg_rqst();
  static const int kSendMsgRqstFieldNumber = 1;
  inline const ::vmsg::CSChatSendMsgRqst& sendmsg_rqst() const;
  inline ::vmsg::CSChatSendMsgRqst* mutable_sendmsg_rqst();
  inline ::vmsg::CSChatSendMsgRqst* release_sendmsg_rqst();
  inline void set_allocated_sendmsg_rqst(::vmsg::CSChatSendMsgRqst* sendmsg_rqst);

  // @@protoc_insertion_point(class_scope:vmsg.CSChatRequest)
 private:
  inline void set_has_sendmsg_rqst();
  inline void clear_has_sendmsg_rqst();

  ::vmsg::CSChatSendMsgRqst* sendmsg_rqst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSChatMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSChatMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSChatMsg_2eproto();
  friend void protobuf_ShutdownFile_CSChatMsg_2eproto();

  void InitAsDefaultInstance();
  static CSChatRequest* default_instance_;
};
// -------------------------------------------------------------------

class CSChatRespond : public ::google::protobuf::MessageLite {
 public:
  CSChatRespond();
  virtual ~CSChatRespond();

  CSChatRespond(const CSChatRespond& from);

  inline CSChatRespond& operator=(const CSChatRespond& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSChatRespond& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChatRespond* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChatRespond* other);

  // implements Message ----------------------------------------------

  CSChatRespond* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChatRespond& from);
  void MergeFrom(const CSChatRespond& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSChatMsgNotify ChatMsg_Notify = 1;
  inline bool has_chatmsg_notify() const;
  inline void clear_chatmsg_notify();
  static const int kChatMsgNotifyFieldNumber = 1;
  inline const ::vmsg::CSChatMsgNotify& chatmsg_notify() const;
  inline ::vmsg::CSChatMsgNotify* mutable_chatmsg_notify();
  inline ::vmsg::CSChatMsgNotify* release_chatmsg_notify();
  inline void set_allocated_chatmsg_notify(::vmsg::CSChatMsgNotify* chatmsg_notify);

  // @@protoc_insertion_point(class_scope:vmsg.CSChatRespond)
 private:
  inline void set_has_chatmsg_notify();
  inline void clear_has_chatmsg_notify();

  ::vmsg::CSChatMsgNotify* chatmsg_notify_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSChatMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSChatMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSChatMsg_2eproto();
  friend void protobuf_ShutdownFile_CSChatMsg_2eproto();

  void InitAsDefaultInstance();
  static CSChatRespond* default_instance_;
};
// ===================================================================


// ===================================================================

// CSChatSendMsgRqst

// required uint32 ChannelType = 1;
inline bool CSChatSendMsgRqst::has_channeltype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSChatSendMsgRqst::set_has_channeltype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSChatSendMsgRqst::clear_has_channeltype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSChatSendMsgRqst::clear_channeltype() {
  channeltype_ = 0u;
  clear_has_channeltype();
}
inline ::google::protobuf::uint32 CSChatSendMsgRqst::channeltype() const {
  return channeltype_;
}
inline void CSChatSendMsgRqst::set_channeltype(::google::protobuf::uint32 value) {
  set_has_channeltype();
  channeltype_ = value;
}

// required string MsgContent = 2;
inline bool CSChatSendMsgRqst::has_msgcontent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSChatSendMsgRqst::set_has_msgcontent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSChatSendMsgRqst::clear_has_msgcontent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSChatSendMsgRqst::clear_msgcontent() {
  if (msgcontent_ != &::google::protobuf::internal::kEmptyString) {
    msgcontent_->clear();
  }
  clear_has_msgcontent();
}
inline const ::std::string& CSChatSendMsgRqst::msgcontent() const {
  return *msgcontent_;
}
inline void CSChatSendMsgRqst::set_msgcontent(const ::std::string& value) {
  set_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    msgcontent_ = new ::std::string;
  }
  msgcontent_->assign(value);
}
inline void CSChatSendMsgRqst::set_msgcontent(const char* value) {
  set_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    msgcontent_ = new ::std::string;
  }
  msgcontent_->assign(value);
}
inline void CSChatSendMsgRqst::set_msgcontent(const char* value, size_t size) {
  set_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    msgcontent_ = new ::std::string;
  }
  msgcontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSChatSendMsgRqst::mutable_msgcontent() {
  set_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    msgcontent_ = new ::std::string;
  }
  return msgcontent_;
}
inline ::std::string* CSChatSendMsgRqst::release_msgcontent() {
  clear_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msgcontent_;
    msgcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSChatSendMsgRqst::set_allocated_msgcontent(::std::string* msgcontent) {
  if (msgcontent_ != &::google::protobuf::internal::kEmptyString) {
    delete msgcontent_;
  }
  if (msgcontent) {
    set_has_msgcontent();
    msgcontent_ = msgcontent;
  } else {
    clear_has_msgcontent();
    msgcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 ReceiveUin = 3;
inline bool CSChatSendMsgRqst::has_receiveuin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSChatSendMsgRqst::set_has_receiveuin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSChatSendMsgRqst::clear_has_receiveuin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSChatSendMsgRqst::clear_receiveuin() {
  receiveuin_ = GOOGLE_ULONGLONG(0);
  clear_has_receiveuin();
}
inline ::google::protobuf::uint64 CSChatSendMsgRqst::receiveuin() const {
  return receiveuin_;
}
inline void CSChatSendMsgRqst::set_receiveuin(::google::protobuf::uint64 value) {
  set_has_receiveuin();
  receiveuin_ = value;
}

// -------------------------------------------------------------------

// CSChatInfo

// required string SenderNick = 1;
inline bool CSChatInfo::has_sendernick() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSChatInfo::set_has_sendernick() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSChatInfo::clear_has_sendernick() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSChatInfo::clear_sendernick() {
  if (sendernick_ != &::google::protobuf::internal::kEmptyString) {
    sendernick_->clear();
  }
  clear_has_sendernick();
}
inline const ::std::string& CSChatInfo::sendernick() const {
  return *sendernick_;
}
inline void CSChatInfo::set_sendernick(const ::std::string& value) {
  set_has_sendernick();
  if (sendernick_ == &::google::protobuf::internal::kEmptyString) {
    sendernick_ = new ::std::string;
  }
  sendernick_->assign(value);
}
inline void CSChatInfo::set_sendernick(const char* value) {
  set_has_sendernick();
  if (sendernick_ == &::google::protobuf::internal::kEmptyString) {
    sendernick_ = new ::std::string;
  }
  sendernick_->assign(value);
}
inline void CSChatInfo::set_sendernick(const char* value, size_t size) {
  set_has_sendernick();
  if (sendernick_ == &::google::protobuf::internal::kEmptyString) {
    sendernick_ = new ::std::string;
  }
  sendernick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSChatInfo::mutable_sendernick() {
  set_has_sendernick();
  if (sendernick_ == &::google::protobuf::internal::kEmptyString) {
    sendernick_ = new ::std::string;
  }
  return sendernick_;
}
inline ::std::string* CSChatInfo::release_sendernick() {
  clear_has_sendernick();
  if (sendernick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sendernick_;
    sendernick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSChatInfo::set_allocated_sendernick(::std::string* sendernick) {
  if (sendernick_ != &::google::protobuf::internal::kEmptyString) {
    delete sendernick_;
  }
  if (sendernick) {
    set_has_sendernick();
    sendernick_ = sendernick;
  } else {
    clear_has_sendernick();
    sendernick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 SenderUin = 2;
inline bool CSChatInfo::has_senderuin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSChatInfo::set_has_senderuin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSChatInfo::clear_has_senderuin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSChatInfo::clear_senderuin() {
  senderuin_ = GOOGLE_ULONGLONG(0);
  clear_has_senderuin();
}
inline ::google::protobuf::uint64 CSChatInfo::senderuin() const {
  return senderuin_;
}
inline void CSChatInfo::set_senderuin(::google::protobuf::uint64 value) {
  set_has_senderuin();
  senderuin_ = value;
}

// required uint32 SendTime = 3;
inline bool CSChatInfo::has_sendtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSChatInfo::set_has_sendtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSChatInfo::clear_has_sendtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSChatInfo::clear_sendtime() {
  sendtime_ = 0u;
  clear_has_sendtime();
}
inline ::google::protobuf::uint32 CSChatInfo::sendtime() const {
  return sendtime_;
}
inline void CSChatInfo::set_sendtime(::google::protobuf::uint32 value) {
  set_has_sendtime();
  sendtime_ = value;
}

// required string MsgContent = 4;
inline bool CSChatInfo::has_msgcontent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSChatInfo::set_has_msgcontent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSChatInfo::clear_has_msgcontent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSChatInfo::clear_msgcontent() {
  if (msgcontent_ != &::google::protobuf::internal::kEmptyString) {
    msgcontent_->clear();
  }
  clear_has_msgcontent();
}
inline const ::std::string& CSChatInfo::msgcontent() const {
  return *msgcontent_;
}
inline void CSChatInfo::set_msgcontent(const ::std::string& value) {
  set_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    msgcontent_ = new ::std::string;
  }
  msgcontent_->assign(value);
}
inline void CSChatInfo::set_msgcontent(const char* value) {
  set_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    msgcontent_ = new ::std::string;
  }
  msgcontent_->assign(value);
}
inline void CSChatInfo::set_msgcontent(const char* value, size_t size) {
  set_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    msgcontent_ = new ::std::string;
  }
  msgcontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSChatInfo::mutable_msgcontent() {
  set_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    msgcontent_ = new ::std::string;
  }
  return msgcontent_;
}
inline ::std::string* CSChatInfo::release_msgcontent() {
  clear_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msgcontent_;
    msgcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSChatInfo::set_allocated_msgcontent(::std::string* msgcontent) {
  if (msgcontent_ != &::google::protobuf::internal::kEmptyString) {
    delete msgcontent_;
  }
  if (msgcontent) {
    set_has_msgcontent();
    msgcontent_ = msgcontent;
  } else {
    clear_has_msgcontent();
    msgcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 VipLv = 5;
inline bool CSChatInfo::has_viplv() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSChatInfo::set_has_viplv() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSChatInfo::clear_has_viplv() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSChatInfo::clear_viplv() {
  viplv_ = 0u;
  clear_has_viplv();
}
inline ::google::protobuf::uint32 CSChatInfo::viplv() const {
  return viplv_;
}
inline void CSChatInfo::set_viplv(::google::protobuf::uint32 value) {
  set_has_viplv();
  viplv_ = value;
}

// optional uint32 ShowID = 6;
inline bool CSChatInfo::has_showid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSChatInfo::set_has_showid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSChatInfo::clear_has_showid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSChatInfo::clear_showid() {
  showid_ = 0u;
  clear_has_showid();
}
inline ::google::protobuf::uint32 CSChatInfo::showid() const {
  return showid_;
}
inline void CSChatInfo::set_showid(::google::protobuf::uint32 value) {
  set_has_showid();
  showid_ = value;
}

// -------------------------------------------------------------------

// CSChatMsgNotify

// required uint32 ChannelType = 1;
inline bool CSChatMsgNotify::has_channeltype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSChatMsgNotify::set_has_channeltype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSChatMsgNotify::clear_has_channeltype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSChatMsgNotify::clear_channeltype() {
  channeltype_ = 0u;
  clear_has_channeltype();
}
inline ::google::protobuf::uint32 CSChatMsgNotify::channeltype() const {
  return channeltype_;
}
inline void CSChatMsgNotify::set_channeltype(::google::protobuf::uint32 value) {
  set_has_channeltype();
  channeltype_ = value;
}

// repeated .vmsg.CSChatInfo ChatInfos = 2;
inline int CSChatMsgNotify::chatinfos_size() const {
  return chatinfos_.size();
}
inline void CSChatMsgNotify::clear_chatinfos() {
  chatinfos_.Clear();
}
inline const ::vmsg::CSChatInfo& CSChatMsgNotify::chatinfos(int index) const {
  return chatinfos_.Get(index);
}
inline ::vmsg::CSChatInfo* CSChatMsgNotify::mutable_chatinfos(int index) {
  return chatinfos_.Mutable(index);
}
inline ::vmsg::CSChatInfo* CSChatMsgNotify::add_chatinfos() {
  return chatinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSChatInfo >&
CSChatMsgNotify::chatinfos() const {
  return chatinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSChatInfo >*
CSChatMsgNotify::mutable_chatinfos() {
  return &chatinfos_;
}

// -------------------------------------------------------------------

// CSChatRequest

// optional .vmsg.CSChatSendMsgRqst SendMsg_Rqst = 1;
inline bool CSChatRequest::has_sendmsg_rqst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSChatRequest::set_has_sendmsg_rqst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSChatRequest::clear_has_sendmsg_rqst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSChatRequest::clear_sendmsg_rqst() {
  if (sendmsg_rqst_ != NULL) sendmsg_rqst_->::vmsg::CSChatSendMsgRqst::Clear();
  clear_has_sendmsg_rqst();
}
inline const ::vmsg::CSChatSendMsgRqst& CSChatRequest::sendmsg_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sendmsg_rqst_ != NULL ? *sendmsg_rqst_ : *default_instance().sendmsg_rqst_;
#else
  return sendmsg_rqst_ != NULL ? *sendmsg_rqst_ : *default_instance_->sendmsg_rqst_;
#endif
}
inline ::vmsg::CSChatSendMsgRqst* CSChatRequest::mutable_sendmsg_rqst() {
  set_has_sendmsg_rqst();
  if (sendmsg_rqst_ == NULL) sendmsg_rqst_ = new ::vmsg::CSChatSendMsgRqst;
  return sendmsg_rqst_;
}
inline ::vmsg::CSChatSendMsgRqst* CSChatRequest::release_sendmsg_rqst() {
  clear_has_sendmsg_rqst();
  ::vmsg::CSChatSendMsgRqst* temp = sendmsg_rqst_;
  sendmsg_rqst_ = NULL;
  return temp;
}
inline void CSChatRequest::set_allocated_sendmsg_rqst(::vmsg::CSChatSendMsgRqst* sendmsg_rqst) {
  delete sendmsg_rqst_;
  sendmsg_rqst_ = sendmsg_rqst;
  if (sendmsg_rqst) {
    set_has_sendmsg_rqst();
  } else {
    clear_has_sendmsg_rqst();
  }
}

// -------------------------------------------------------------------

// CSChatRespond

// optional .vmsg.CSChatMsgNotify ChatMsg_Notify = 1;
inline bool CSChatRespond::has_chatmsg_notify() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSChatRespond::set_has_chatmsg_notify() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSChatRespond::clear_has_chatmsg_notify() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSChatRespond::clear_chatmsg_notify() {
  if (chatmsg_notify_ != NULL) chatmsg_notify_->::vmsg::CSChatMsgNotify::Clear();
  clear_has_chatmsg_notify();
}
inline const ::vmsg::CSChatMsgNotify& CSChatRespond::chatmsg_notify() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return chatmsg_notify_ != NULL ? *chatmsg_notify_ : *default_instance().chatmsg_notify_;
#else
  return chatmsg_notify_ != NULL ? *chatmsg_notify_ : *default_instance_->chatmsg_notify_;
#endif
}
inline ::vmsg::CSChatMsgNotify* CSChatRespond::mutable_chatmsg_notify() {
  set_has_chatmsg_notify();
  if (chatmsg_notify_ == NULL) chatmsg_notify_ = new ::vmsg::CSChatMsgNotify;
  return chatmsg_notify_;
}
inline ::vmsg::CSChatMsgNotify* CSChatRespond::release_chatmsg_notify() {
  clear_has_chatmsg_notify();
  ::vmsg::CSChatMsgNotify* temp = chatmsg_notify_;
  chatmsg_notify_ = NULL;
  return temp;
}
inline void CSChatRespond::set_allocated_chatmsg_notify(::vmsg::CSChatMsgNotify* chatmsg_notify) {
  delete chatmsg_notify_;
  chatmsg_notify_ = chatmsg_notify;
  if (chatmsg_notify) {
    set_has_chatmsg_notify();
  } else {
    clear_has_chatmsg_notify();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CSChatMsg_2eproto__INCLUDED
