// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSEquipItemMsg.proto

#ifndef PROTOBUF_CSEquipItemMsg_2eproto__INCLUDED
#define PROTOBUF_CSEquipItemMsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MsgBase.pb.h"
#include "ShareByClient.pb.h"
// @@protoc_insertion_point(includes)

namespace vmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CSEquipItemMsg_2eproto();
void protobuf_AssignDesc_CSEquipItemMsg_2eproto();
void protobuf_ShutdownFile_CSEquipItemMsg_2eproto();

class CSEquipInfo;
class CSItemInfo;
class CSAwardElement;
class CSWeapon;
class CSInbattleWeaponElmt;

// ===================================================================

class CSEquipInfo : public ::google::protobuf::MessageLite {
 public:
  CSEquipInfo();
  virtual ~CSEquipInfo();

  CSEquipInfo(const CSEquipInfo& from);

  inline CSEquipInfo& operator=(const CSEquipInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEquipInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEquipInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEquipInfo* other);

  // implements Message ----------------------------------------------

  CSEquipInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEquipInfo& from);
  void MergeFrom(const CSEquipInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 EquipID = 1;
  inline bool has_equipid() const;
  inline void clear_equipid();
  static const int kEquipIDFieldNumber = 1;
  inline ::google::protobuf::uint32 equipid() const;
  inline void set_equipid(::google::protobuf::uint32 value);

  // required uint64 EquipGUID = 2;
  inline bool has_equipguid() const;
  inline void clear_equipguid();
  static const int kEquipGUIDFieldNumber = 2;
  inline ::google::protobuf::uint64 equipguid() const;
  inline void set_equipguid(::google::protobuf::uint64 value);

  // required uint32 Level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint32 Quality = 4;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 4;
  inline ::google::protobuf::uint32 quality() const;
  inline void set_quality(::google::protobuf::uint32 value);

  // required uint64 Exp = 5;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 5;
  inline ::google::protobuf::uint64 exp() const;
  inline void set_exp(::google::protobuf::uint64 value);

  // required uint64 TotalExp = 6;
  inline bool has_totalexp() const;
  inline void clear_totalexp();
  static const int kTotalExpFieldNumber = 6;
  inline ::google::protobuf::uint64 totalexp() const;
  inline void set_totalexp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSEquipInfo)
 private:
  inline void set_has_equipid();
  inline void clear_has_equipid();
  inline void set_has_equipguid();
  inline void clear_has_equipguid();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_totalexp();
  inline void clear_has_totalexp();

  ::google::protobuf::uint64 equipguid_;
  ::google::protobuf::uint32 equipid_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint64 exp_;
  ::google::protobuf::uint64 totalexp_;
  ::google::protobuf::uint32 quality_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSEquipItemMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSEquipItemMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSEquipItemMsg_2eproto();
  friend void protobuf_ShutdownFile_CSEquipItemMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEquipInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSItemInfo : public ::google::protobuf::MessageLite {
 public:
  CSItemInfo();
  virtual ~CSItemInfo();

  CSItemInfo(const CSItemInfo& from);

  inline CSItemInfo& operator=(const CSItemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSItemInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSItemInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSItemInfo* other);

  // implements Message ----------------------------------------------

  CSItemInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSItemInfo& from);
  void MergeFrom(const CSItemInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ItemCfgID = 1;
  inline bool has_itemcfgid() const;
  inline void clear_itemcfgid();
  static const int kItemCfgIDFieldNumber = 1;
  inline ::google::protobuf::uint32 itemcfgid() const;
  inline void set_itemcfgid(::google::protobuf::uint32 value);

  // required uint32 ItemCnt = 2;
  inline bool has_itemcnt() const;
  inline void clear_itemcnt();
  static const int kItemCntFieldNumber = 2;
  inline ::google::protobuf::uint32 itemcnt() const;
  inline void set_itemcnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSItemInfo)
 private:
  inline void set_has_itemcfgid();
  inline void clear_has_itemcfgid();
  inline void set_has_itemcnt();
  inline void clear_has_itemcnt();

  ::google::protobuf::uint32 itemcfgid_;
  ::google::protobuf::uint32 itemcnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSEquipItemMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSEquipItemMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSEquipItemMsg_2eproto();
  friend void protobuf_ShutdownFile_CSEquipItemMsg_2eproto();

  void InitAsDefaultInstance();
  static CSItemInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSAwardElement : public ::google::protobuf::MessageLite {
 public:
  CSAwardElement();
  virtual ~CSAwardElement();

  CSAwardElement(const CSAwardElement& from);

  inline CSAwardElement& operator=(const CSAwardElement& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSAwardElement& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAwardElement* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAwardElement* other);

  // implements Message ----------------------------------------------

  CSAwardElement* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAwardElement& from);
  void MergeFrom(const CSAwardElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ElementType = 1;
  inline bool has_elementtype() const;
  inline void clear_elementtype();
  static const int kElementTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 elementtype() const;
  inline void set_elementtype(::google::protobuf::uint32 value);

  // required uint32 ElementID = 2;
  inline bool has_elementid() const;
  inline void clear_elementid();
  static const int kElementIDFieldNumber = 2;
  inline ::google::protobuf::uint32 elementid() const;
  inline void set_elementid(::google::protobuf::uint32 value);

  // required uint32 ElementCnt = 3;
  inline bool has_elementcnt() const;
  inline void clear_elementcnt();
  static const int kElementCntFieldNumber = 3;
  inline ::google::protobuf::uint32 elementcnt() const;
  inline void set_elementcnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSAwardElement)
 private:
  inline void set_has_elementtype();
  inline void clear_has_elementtype();
  inline void set_has_elementid();
  inline void clear_has_elementid();
  inline void set_has_elementcnt();
  inline void clear_has_elementcnt();

  ::google::protobuf::uint32 elementtype_;
  ::google::protobuf::uint32 elementid_;
  ::google::protobuf::uint32 elementcnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSEquipItemMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSEquipItemMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSEquipItemMsg_2eproto();
  friend void protobuf_ShutdownFile_CSEquipItemMsg_2eproto();

  void InitAsDefaultInstance();
  static CSAwardElement* default_instance_;
};
// -------------------------------------------------------------------

class CSWeapon : public ::google::protobuf::MessageLite {
 public:
  CSWeapon();
  virtual ~CSWeapon();

  CSWeapon(const CSWeapon& from);

  inline CSWeapon& operator=(const CSWeapon& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWeapon& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWeapon* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWeapon* other);

  // implements Message ----------------------------------------------

  CSWeapon* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWeapon& from);
  void MergeFrom(const CSWeapon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 WeaponGUID = 1;
  inline bool has_weaponguid() const;
  inline void clear_weaponguid();
  static const int kWeaponGUIDFieldNumber = 1;
  inline ::google::protobuf::uint64 weaponguid() const;
  inline void set_weaponguid(::google::protobuf::uint64 value);

  // required uint32 CfgID = 2;
  inline bool has_cfgid() const;
  inline void clear_cfgid();
  static const int kCfgIDFieldNumber = 2;
  inline ::google::protobuf::uint32 cfgid() const;
  inline void set_cfgid(::google::protobuf::uint32 value);

  // required uint32 Level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint64 Exp = 4;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 4;
  inline ::google::protobuf::uint64 exp() const;
  inline void set_exp(::google::protobuf::uint64 value);

  // required uint64 TotalExp = 5;
  inline bool has_totalexp() const;
  inline void clear_totalexp();
  static const int kTotalExpFieldNumber = 5;
  inline ::google::protobuf::uint64 totalexp() const;
  inline void set_totalexp(::google::protobuf::uint64 value);

  // required uint32 Quality = 6;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 6;
  inline ::google::protobuf::uint32 quality() const;
  inline void set_quality(::google::protobuf::uint32 value);

  // required uint32 State = 7;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 7;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSWeapon)
 private:
  inline void set_has_weaponguid();
  inline void clear_has_weaponguid();
  inline void set_has_cfgid();
  inline void clear_has_cfgid();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_totalexp();
  inline void clear_has_totalexp();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::uint64 weaponguid_;
  ::google::protobuf::uint32 cfgid_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint64 exp_;
  ::google::protobuf::uint64 totalexp_;
  ::google::protobuf::uint32 quality_;
  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSEquipItemMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSEquipItemMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSEquipItemMsg_2eproto();
  friend void protobuf_ShutdownFile_CSEquipItemMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWeapon* default_instance_;
};
// -------------------------------------------------------------------

class CSInbattleWeaponElmt : public ::google::protobuf::MessageLite {
 public:
  CSInbattleWeaponElmt();
  virtual ~CSInbattleWeaponElmt();

  CSInbattleWeaponElmt(const CSInbattleWeaponElmt& from);

  inline CSInbattleWeaponElmt& operator=(const CSInbattleWeaponElmt& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSInbattleWeaponElmt& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSInbattleWeaponElmt* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSInbattleWeaponElmt* other);

  // implements Message ----------------------------------------------

  CSInbattleWeaponElmt* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSInbattleWeaponElmt& from);
  void MergeFrom(const CSInbattleWeaponElmt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSWeapon Weapon = 1;
  inline bool has_weapon() const;
  inline void clear_weapon();
  static const int kWeaponFieldNumber = 1;
  inline const ::vmsg::CSWeapon& weapon() const;
  inline ::vmsg::CSWeapon* mutable_weapon();
  inline ::vmsg::CSWeapon* release_weapon();
  inline void set_allocated_weapon(::vmsg::CSWeapon* weapon);

  // required int32 BagIdx = 2;
  inline bool has_bagidx() const;
  inline void clear_bagidx();
  static const int kBagIdxFieldNumber = 2;
  inline ::google::protobuf::int32 bagidx() const;
  inline void set_bagidx(::google::protobuf::int32 value);

  // required int32 ArrayIdx = 3;
  inline bool has_arrayidx() const;
  inline void clear_arrayidx();
  static const int kArrayIdxFieldNumber = 3;
  inline ::google::protobuf::int32 arrayidx() const;
  inline void set_arrayidx(::google::protobuf::int32 value);

  // required int32 State = 4;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 4;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSInbattleWeaponElmt)
 private:
  inline void set_has_weapon();
  inline void clear_has_weapon();
  inline void set_has_bagidx();
  inline void clear_has_bagidx();
  inline void set_has_arrayidx();
  inline void clear_has_arrayidx();
  inline void set_has_state();
  inline void clear_has_state();

  ::vmsg::CSWeapon* weapon_;
  ::google::protobuf::int32 bagidx_;
  ::google::protobuf::int32 arrayidx_;
  ::google::protobuf::int32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSEquipItemMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSEquipItemMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSEquipItemMsg_2eproto();
  friend void protobuf_ShutdownFile_CSEquipItemMsg_2eproto();

  void InitAsDefaultInstance();
  static CSInbattleWeaponElmt* default_instance_;
};
// ===================================================================


// ===================================================================

// CSEquipInfo

// required uint32 EquipID = 1;
inline bool CSEquipInfo::has_equipid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEquipInfo::set_has_equipid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEquipInfo::clear_has_equipid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEquipInfo::clear_equipid() {
  equipid_ = 0u;
  clear_has_equipid();
}
inline ::google::protobuf::uint32 CSEquipInfo::equipid() const {
  return equipid_;
}
inline void CSEquipInfo::set_equipid(::google::protobuf::uint32 value) {
  set_has_equipid();
  equipid_ = value;
}

// required uint64 EquipGUID = 2;
inline bool CSEquipInfo::has_equipguid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSEquipInfo::set_has_equipguid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSEquipInfo::clear_has_equipguid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSEquipInfo::clear_equipguid() {
  equipguid_ = GOOGLE_ULONGLONG(0);
  clear_has_equipguid();
}
inline ::google::protobuf::uint64 CSEquipInfo::equipguid() const {
  return equipguid_;
}
inline void CSEquipInfo::set_equipguid(::google::protobuf::uint64 value) {
  set_has_equipguid();
  equipguid_ = value;
}

// required uint32 Level = 3;
inline bool CSEquipInfo::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSEquipInfo::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSEquipInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSEquipInfo::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 CSEquipInfo::level() const {
  return level_;
}
inline void CSEquipInfo::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// required uint32 Quality = 4;
inline bool CSEquipInfo::has_quality() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSEquipInfo::set_has_quality() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSEquipInfo::clear_has_quality() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSEquipInfo::clear_quality() {
  quality_ = 0u;
  clear_has_quality();
}
inline ::google::protobuf::uint32 CSEquipInfo::quality() const {
  return quality_;
}
inline void CSEquipInfo::set_quality(::google::protobuf::uint32 value) {
  set_has_quality();
  quality_ = value;
}

// required uint64 Exp = 5;
inline bool CSEquipInfo::has_exp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSEquipInfo::set_has_exp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSEquipInfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSEquipInfo::clear_exp() {
  exp_ = GOOGLE_ULONGLONG(0);
  clear_has_exp();
}
inline ::google::protobuf::uint64 CSEquipInfo::exp() const {
  return exp_;
}
inline void CSEquipInfo::set_exp(::google::protobuf::uint64 value) {
  set_has_exp();
  exp_ = value;
}

// required uint64 TotalExp = 6;
inline bool CSEquipInfo::has_totalexp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSEquipInfo::set_has_totalexp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSEquipInfo::clear_has_totalexp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSEquipInfo::clear_totalexp() {
  totalexp_ = GOOGLE_ULONGLONG(0);
  clear_has_totalexp();
}
inline ::google::protobuf::uint64 CSEquipInfo::totalexp() const {
  return totalexp_;
}
inline void CSEquipInfo::set_totalexp(::google::protobuf::uint64 value) {
  set_has_totalexp();
  totalexp_ = value;
}

// -------------------------------------------------------------------

// CSItemInfo

// required uint32 ItemCfgID = 1;
inline bool CSItemInfo::has_itemcfgid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSItemInfo::set_has_itemcfgid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSItemInfo::clear_has_itemcfgid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSItemInfo::clear_itemcfgid() {
  itemcfgid_ = 0u;
  clear_has_itemcfgid();
}
inline ::google::protobuf::uint32 CSItemInfo::itemcfgid() const {
  return itemcfgid_;
}
inline void CSItemInfo::set_itemcfgid(::google::protobuf::uint32 value) {
  set_has_itemcfgid();
  itemcfgid_ = value;
}

// required uint32 ItemCnt = 2;
inline bool CSItemInfo::has_itemcnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSItemInfo::set_has_itemcnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSItemInfo::clear_has_itemcnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSItemInfo::clear_itemcnt() {
  itemcnt_ = 0u;
  clear_has_itemcnt();
}
inline ::google::protobuf::uint32 CSItemInfo::itemcnt() const {
  return itemcnt_;
}
inline void CSItemInfo::set_itemcnt(::google::protobuf::uint32 value) {
  set_has_itemcnt();
  itemcnt_ = value;
}

// -------------------------------------------------------------------

// CSAwardElement

// required uint32 ElementType = 1;
inline bool CSAwardElement::has_elementtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAwardElement::set_has_elementtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAwardElement::clear_has_elementtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAwardElement::clear_elementtype() {
  elementtype_ = 0u;
  clear_has_elementtype();
}
inline ::google::protobuf::uint32 CSAwardElement::elementtype() const {
  return elementtype_;
}
inline void CSAwardElement::set_elementtype(::google::protobuf::uint32 value) {
  set_has_elementtype();
  elementtype_ = value;
}

// required uint32 ElementID = 2;
inline bool CSAwardElement::has_elementid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSAwardElement::set_has_elementid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSAwardElement::clear_has_elementid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSAwardElement::clear_elementid() {
  elementid_ = 0u;
  clear_has_elementid();
}
inline ::google::protobuf::uint32 CSAwardElement::elementid() const {
  return elementid_;
}
inline void CSAwardElement::set_elementid(::google::protobuf::uint32 value) {
  set_has_elementid();
  elementid_ = value;
}

// required uint32 ElementCnt = 3;
inline bool CSAwardElement::has_elementcnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSAwardElement::set_has_elementcnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSAwardElement::clear_has_elementcnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSAwardElement::clear_elementcnt() {
  elementcnt_ = 0u;
  clear_has_elementcnt();
}
inline ::google::protobuf::uint32 CSAwardElement::elementcnt() const {
  return elementcnt_;
}
inline void CSAwardElement::set_elementcnt(::google::protobuf::uint32 value) {
  set_has_elementcnt();
  elementcnt_ = value;
}

// -------------------------------------------------------------------

// CSWeapon

// required uint64 WeaponGUID = 1;
inline bool CSWeapon::has_weaponguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWeapon::set_has_weaponguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWeapon::clear_has_weaponguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWeapon::clear_weaponguid() {
  weaponguid_ = GOOGLE_ULONGLONG(0);
  clear_has_weaponguid();
}
inline ::google::protobuf::uint64 CSWeapon::weaponguid() const {
  return weaponguid_;
}
inline void CSWeapon::set_weaponguid(::google::protobuf::uint64 value) {
  set_has_weaponguid();
  weaponguid_ = value;
}

// required uint32 CfgID = 2;
inline bool CSWeapon::has_cfgid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWeapon::set_has_cfgid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWeapon::clear_has_cfgid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWeapon::clear_cfgid() {
  cfgid_ = 0u;
  clear_has_cfgid();
}
inline ::google::protobuf::uint32 CSWeapon::cfgid() const {
  return cfgid_;
}
inline void CSWeapon::set_cfgid(::google::protobuf::uint32 value) {
  set_has_cfgid();
  cfgid_ = value;
}

// required uint32 Level = 3;
inline bool CSWeapon::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSWeapon::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSWeapon::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSWeapon::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 CSWeapon::level() const {
  return level_;
}
inline void CSWeapon::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// required uint64 Exp = 4;
inline bool CSWeapon::has_exp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSWeapon::set_has_exp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSWeapon::clear_has_exp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSWeapon::clear_exp() {
  exp_ = GOOGLE_ULONGLONG(0);
  clear_has_exp();
}
inline ::google::protobuf::uint64 CSWeapon::exp() const {
  return exp_;
}
inline void CSWeapon::set_exp(::google::protobuf::uint64 value) {
  set_has_exp();
  exp_ = value;
}

// required uint64 TotalExp = 5;
inline bool CSWeapon::has_totalexp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSWeapon::set_has_totalexp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSWeapon::clear_has_totalexp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSWeapon::clear_totalexp() {
  totalexp_ = GOOGLE_ULONGLONG(0);
  clear_has_totalexp();
}
inline ::google::protobuf::uint64 CSWeapon::totalexp() const {
  return totalexp_;
}
inline void CSWeapon::set_totalexp(::google::protobuf::uint64 value) {
  set_has_totalexp();
  totalexp_ = value;
}

// required uint32 Quality = 6;
inline bool CSWeapon::has_quality() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSWeapon::set_has_quality() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSWeapon::clear_has_quality() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSWeapon::clear_quality() {
  quality_ = 0u;
  clear_has_quality();
}
inline ::google::protobuf::uint32 CSWeapon::quality() const {
  return quality_;
}
inline void CSWeapon::set_quality(::google::protobuf::uint32 value) {
  set_has_quality();
  quality_ = value;
}

// required uint32 State = 7;
inline bool CSWeapon::has_state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSWeapon::set_has_state() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSWeapon::clear_has_state() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSWeapon::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 CSWeapon::state() const {
  return state_;
}
inline void CSWeapon::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// CSInbattleWeaponElmt

// required .vmsg.CSWeapon Weapon = 1;
inline bool CSInbattleWeaponElmt::has_weapon() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSInbattleWeaponElmt::set_has_weapon() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSInbattleWeaponElmt::clear_has_weapon() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSInbattleWeaponElmt::clear_weapon() {
  if (weapon_ != NULL) weapon_->::vmsg::CSWeapon::Clear();
  clear_has_weapon();
}
inline const ::vmsg::CSWeapon& CSInbattleWeaponElmt::weapon() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return weapon_ != NULL ? *weapon_ : *default_instance().weapon_;
#else
  return weapon_ != NULL ? *weapon_ : *default_instance_->weapon_;
#endif
}
inline ::vmsg::CSWeapon* CSInbattleWeaponElmt::mutable_weapon() {
  set_has_weapon();
  if (weapon_ == NULL) weapon_ = new ::vmsg::CSWeapon;
  return weapon_;
}
inline ::vmsg::CSWeapon* CSInbattleWeaponElmt::release_weapon() {
  clear_has_weapon();
  ::vmsg::CSWeapon* temp = weapon_;
  weapon_ = NULL;
  return temp;
}
inline void CSInbattleWeaponElmt::set_allocated_weapon(::vmsg::CSWeapon* weapon) {
  delete weapon_;
  weapon_ = weapon;
  if (weapon) {
    set_has_weapon();
  } else {
    clear_has_weapon();
  }
}

// required int32 BagIdx = 2;
inline bool CSInbattleWeaponElmt::has_bagidx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSInbattleWeaponElmt::set_has_bagidx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSInbattleWeaponElmt::clear_has_bagidx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSInbattleWeaponElmt::clear_bagidx() {
  bagidx_ = 0;
  clear_has_bagidx();
}
inline ::google::protobuf::int32 CSInbattleWeaponElmt::bagidx() const {
  return bagidx_;
}
inline void CSInbattleWeaponElmt::set_bagidx(::google::protobuf::int32 value) {
  set_has_bagidx();
  bagidx_ = value;
}

// required int32 ArrayIdx = 3;
inline bool CSInbattleWeaponElmt::has_arrayidx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSInbattleWeaponElmt::set_has_arrayidx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSInbattleWeaponElmt::clear_has_arrayidx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSInbattleWeaponElmt::clear_arrayidx() {
  arrayidx_ = 0;
  clear_has_arrayidx();
}
inline ::google::protobuf::int32 CSInbattleWeaponElmt::arrayidx() const {
  return arrayidx_;
}
inline void CSInbattleWeaponElmt::set_arrayidx(::google::protobuf::int32 value) {
  set_has_arrayidx();
  arrayidx_ = value;
}

// required int32 State = 4;
inline bool CSInbattleWeaponElmt::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSInbattleWeaponElmt::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSInbattleWeaponElmt::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSInbattleWeaponElmt::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 CSInbattleWeaponElmt::state() const {
  return state_;
}
inline void CSInbattleWeaponElmt::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CSEquipItemMsg_2eproto__INCLUDED
