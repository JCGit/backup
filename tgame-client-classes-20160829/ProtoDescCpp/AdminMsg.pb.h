// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AdminMsg.proto

#ifndef PROTOBUF_AdminMsg_2eproto__INCLUDED
#define PROTOBUF_AdminMsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MsgBase.pb.h"
#include "CSMailMsg.pb.h"
#include "ShareByClient.pb.h"
// @@protoc_insertion_point(includes)

namespace vmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_AdminMsg_2eproto();
void protobuf_AssignDesc_AdminMsg_2eproto();
void protobuf_ShutdownFile_AdminMsg_2eproto();

class CSAdminAddGold;
class CSAdminAddItemRqst;
class CSAdminSendMailRqst;
class CSAdminSendMailGrpRqst;
class CSAdminAddArenaMoney;
class CSAdminForbidPlayer;
class CSAdminRequest;
class CSAdminRespond;

// ===================================================================

class CSAdminAddGold : public ::google::protobuf::MessageLite {
 public:
  CSAdminAddGold();
  virtual ~CSAdminAddGold();

  CSAdminAddGold(const CSAdminAddGold& from);

  inline CSAdminAddGold& operator=(const CSAdminAddGold& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSAdminAddGold& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAdminAddGold* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAdminAddGold* other);

  // implements Message ----------------------------------------------

  CSAdminAddGold* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAdminAddGold& from);
  void MergeFrom(const CSAdminAddGold& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 GoldCnt = 1;
  inline bool has_goldcnt() const;
  inline void clear_goldcnt();
  static const int kGoldCntFieldNumber = 1;
  inline ::google::protobuf::uint32 goldcnt() const;
  inline void set_goldcnt(::google::protobuf::uint32 value);

  // required uint32 Reason = 2;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 2;
  inline ::google::protobuf::uint32 reason() const;
  inline void set_reason(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSAdminAddGold)
 private:
  inline void set_has_goldcnt();
  inline void clear_has_goldcnt();
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::uint32 goldcnt_;
  ::google::protobuf::uint32 reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_AdminMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_AdminMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_AdminMsg_2eproto();
  friend void protobuf_ShutdownFile_AdminMsg_2eproto();

  void InitAsDefaultInstance();
  static CSAdminAddGold* default_instance_;
};
// -------------------------------------------------------------------

class CSAdminAddItemRqst : public ::google::protobuf::MessageLite {
 public:
  CSAdminAddItemRqst();
  virtual ~CSAdminAddItemRqst();

  CSAdminAddItemRqst(const CSAdminAddItemRqst& from);

  inline CSAdminAddItemRqst& operator=(const CSAdminAddItemRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSAdminAddItemRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAdminAddItemRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAdminAddItemRqst* other);

  // implements Message ----------------------------------------------

  CSAdminAddItemRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAdminAddItemRqst& from);
  void MergeFrom(const CSAdminAddItemRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ItemID = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIDFieldNumber = 1;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // required uint32 ItemCnt = 2;
  inline bool has_itemcnt() const;
  inline void clear_itemcnt();
  static const int kItemCntFieldNumber = 2;
  inline ::google::protobuf::uint32 itemcnt() const;
  inline void set_itemcnt(::google::protobuf::uint32 value);

  // required uint32 Reason = 3;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 3;
  inline ::google::protobuf::uint32 reason() const;
  inline void set_reason(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSAdminAddItemRqst)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_itemcnt();
  inline void clear_has_itemcnt();
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::uint32 itemid_;
  ::google::protobuf::uint32 itemcnt_;
  ::google::protobuf::uint32 reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_AdminMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_AdminMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_AdminMsg_2eproto();
  friend void protobuf_ShutdownFile_AdminMsg_2eproto();

  void InitAsDefaultInstance();
  static CSAdminAddItemRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSAdminSendMailRqst : public ::google::protobuf::MessageLite {
 public:
  CSAdminSendMailRqst();
  virtual ~CSAdminSendMailRqst();

  CSAdminSendMailRqst(const CSAdminSendMailRqst& from);

  inline CSAdminSendMailRqst& operator=(const CSAdminSendMailRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSAdminSendMailRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAdminSendMailRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAdminSendMailRqst* other);

  // implements Message ----------------------------------------------

  CSAdminSendMailRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAdminSendMailRqst& from);
  void MergeFrom(const CSAdminSendMailRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 SenderUin = 1;
  inline bool has_senderuin() const;
  inline void clear_senderuin();
  static const int kSenderUinFieldNumber = 1;
  inline ::google::protobuf::uint64 senderuin() const;
  inline void set_senderuin(::google::protobuf::uint64 value);

  // required string MailHead = 2;
  inline bool has_mailhead() const;
  inline void clear_mailhead();
  static const int kMailHeadFieldNumber = 2;
  inline const ::std::string& mailhead() const;
  inline void set_mailhead(const ::std::string& value);
  inline void set_mailhead(const char* value);
  inline void set_mailhead(const char* value, size_t size);
  inline ::std::string* mutable_mailhead();
  inline ::std::string* release_mailhead();
  inline void set_allocated_mailhead(::std::string* mailhead);

  // required string MailBody = 3;
  inline bool has_mailbody() const;
  inline void clear_mailbody();
  static const int kMailBodyFieldNumber = 3;
  inline const ::std::string& mailbody() const;
  inline void set_mailbody(const ::std::string& value);
  inline void set_mailbody(const char* value);
  inline void set_mailbody(const char* value, size_t size);
  inline ::std::string* mutable_mailbody();
  inline ::std::string* release_mailbody();
  inline void set_allocated_mailbody(::std::string* mailbody);

  // repeated .vmsg.CSMailAttach AttachLst = 4;
  inline int attachlst_size() const;
  inline void clear_attachlst();
  static const int kAttachLstFieldNumber = 4;
  inline const ::vmsg::CSMailAttach& attachlst(int index) const;
  inline ::vmsg::CSMailAttach* mutable_attachlst(int index);
  inline ::vmsg::CSMailAttach* add_attachlst();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailAttach >&
      attachlst() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailAttach >*
      mutable_attachlst();

  // @@protoc_insertion_point(class_scope:vmsg.CSAdminSendMailRqst)
 private:
  inline void set_has_senderuin();
  inline void clear_has_senderuin();
  inline void set_has_mailhead();
  inline void clear_has_mailhead();
  inline void set_has_mailbody();
  inline void clear_has_mailbody();

  ::google::protobuf::uint64 senderuin_;
  ::std::string* mailhead_;
  ::std::string* mailbody_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailAttach > attachlst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_AdminMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_AdminMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_AdminMsg_2eproto();
  friend void protobuf_ShutdownFile_AdminMsg_2eproto();

  void InitAsDefaultInstance();
  static CSAdminSendMailRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSAdminSendMailGrpRqst : public ::google::protobuf::MessageLite {
 public:
  CSAdminSendMailGrpRqst();
  virtual ~CSAdminSendMailGrpRqst();

  CSAdminSendMailGrpRqst(const CSAdminSendMailGrpRqst& from);

  inline CSAdminSendMailGrpRqst& operator=(const CSAdminSendMailGrpRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSAdminSendMailGrpRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAdminSendMailGrpRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAdminSendMailGrpRqst* other);

  // implements Message ----------------------------------------------

  CSAdminSendMailGrpRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAdminSendMailGrpRqst& from);
  void MergeFrom(const CSAdminSendMailGrpRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 SenderUin = 1;
  inline bool has_senderuin() const;
  inline void clear_senderuin();
  static const int kSenderUinFieldNumber = 1;
  inline ::google::protobuf::uint64 senderuin() const;
  inline void set_senderuin(::google::protobuf::uint64 value);

  // required uint64 ReceiveGrpID = 2;
  inline bool has_receivegrpid() const;
  inline void clear_receivegrpid();
  static const int kReceiveGrpIDFieldNumber = 2;
  inline ::google::protobuf::uint64 receivegrpid() const;
  inline void set_receivegrpid(::google::protobuf::uint64 value);

  // required string MailHead = 3;
  inline bool has_mailhead() const;
  inline void clear_mailhead();
  static const int kMailHeadFieldNumber = 3;
  inline const ::std::string& mailhead() const;
  inline void set_mailhead(const ::std::string& value);
  inline void set_mailhead(const char* value);
  inline void set_mailhead(const char* value, size_t size);
  inline ::std::string* mutable_mailhead();
  inline ::std::string* release_mailhead();
  inline void set_allocated_mailhead(::std::string* mailhead);

  // required string MailBody = 4;
  inline bool has_mailbody() const;
  inline void clear_mailbody();
  static const int kMailBodyFieldNumber = 4;
  inline const ::std::string& mailbody() const;
  inline void set_mailbody(const ::std::string& value);
  inline void set_mailbody(const char* value);
  inline void set_mailbody(const char* value, size_t size);
  inline ::std::string* mutable_mailbody();
  inline ::std::string* release_mailbody();
  inline void set_allocated_mailbody(::std::string* mailbody);

  // repeated .vmsg.CSMailAttach AttachLst = 5;
  inline int attachlst_size() const;
  inline void clear_attachlst();
  static const int kAttachLstFieldNumber = 5;
  inline const ::vmsg::CSMailAttach& attachlst(int index) const;
  inline ::vmsg::CSMailAttach* mutable_attachlst(int index);
  inline ::vmsg::CSMailAttach* add_attachlst();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailAttach >&
      attachlst() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailAttach >*
      mutable_attachlst();

  // @@protoc_insertion_point(class_scope:vmsg.CSAdminSendMailGrpRqst)
 private:
  inline void set_has_senderuin();
  inline void clear_has_senderuin();
  inline void set_has_receivegrpid();
  inline void clear_has_receivegrpid();
  inline void set_has_mailhead();
  inline void clear_has_mailhead();
  inline void set_has_mailbody();
  inline void clear_has_mailbody();

  ::google::protobuf::uint64 senderuin_;
  ::google::protobuf::uint64 receivegrpid_;
  ::std::string* mailhead_;
  ::std::string* mailbody_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailAttach > attachlst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_AdminMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_AdminMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_AdminMsg_2eproto();
  friend void protobuf_ShutdownFile_AdminMsg_2eproto();

  void InitAsDefaultInstance();
  static CSAdminSendMailGrpRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSAdminAddArenaMoney : public ::google::protobuf::MessageLite {
 public:
  CSAdminAddArenaMoney();
  virtual ~CSAdminAddArenaMoney();

  CSAdminAddArenaMoney(const CSAdminAddArenaMoney& from);

  inline CSAdminAddArenaMoney& operator=(const CSAdminAddArenaMoney& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSAdminAddArenaMoney& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAdminAddArenaMoney* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAdminAddArenaMoney* other);

  // implements Message ----------------------------------------------

  CSAdminAddArenaMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAdminAddArenaMoney& from);
  void MergeFrom(const CSAdminAddArenaMoney& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 MoneyNum = 1;
  inline bool has_moneynum() const;
  inline void clear_moneynum();
  static const int kMoneyNumFieldNumber = 1;
  inline ::google::protobuf::uint32 moneynum() const;
  inline void set_moneynum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSAdminAddArenaMoney)
 private:
  inline void set_has_moneynum();
  inline void clear_has_moneynum();

  ::google::protobuf::uint32 moneynum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_AdminMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_AdminMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_AdminMsg_2eproto();
  friend void protobuf_ShutdownFile_AdminMsg_2eproto();

  void InitAsDefaultInstance();
  static CSAdminAddArenaMoney* default_instance_;
};
// -------------------------------------------------------------------

class CSAdminForbidPlayer : public ::google::protobuf::MessageLite {
 public:
  CSAdminForbidPlayer();
  virtual ~CSAdminForbidPlayer();

  CSAdminForbidPlayer(const CSAdminForbidPlayer& from);

  inline CSAdminForbidPlayer& operator=(const CSAdminForbidPlayer& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSAdminForbidPlayer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAdminForbidPlayer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAdminForbidPlayer* other);

  // implements Message ----------------------------------------------

  CSAdminForbidPlayer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAdminForbidPlayer& from);
  void MergeFrom(const CSAdminForbidPlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 TimeInSec = 1;
  inline bool has_timeinsec() const;
  inline void clear_timeinsec();
  static const int kTimeInSecFieldNumber = 1;
  inline ::google::protobuf::uint32 timeinsec() const;
  inline void set_timeinsec(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSAdminForbidPlayer)
 private:
  inline void set_has_timeinsec();
  inline void clear_has_timeinsec();

  ::google::protobuf::uint32 timeinsec_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_AdminMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_AdminMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_AdminMsg_2eproto();
  friend void protobuf_ShutdownFile_AdminMsg_2eproto();

  void InitAsDefaultInstance();
  static CSAdminForbidPlayer* default_instance_;
};
// -------------------------------------------------------------------

class CSAdminRequest : public ::google::protobuf::MessageLite {
 public:
  CSAdminRequest();
  virtual ~CSAdminRequest();

  CSAdminRequest(const CSAdminRequest& from);

  inline CSAdminRequest& operator=(const CSAdminRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSAdminRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAdminRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAdminRequest* other);

  // implements Message ----------------------------------------------

  CSAdminRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAdminRequest& from);
  void MergeFrom(const CSAdminRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // required uint32 ZoneID = 2;
  inline bool has_zoneid() const;
  inline void clear_zoneid();
  static const int kZoneIDFieldNumber = 2;
  inline ::google::protobuf::uint32 zoneid() const;
  inline void set_zoneid(::google::protobuf::uint32 value);

  // optional uint32 AddCoin = 3;
  inline bool has_addcoin() const;
  inline void clear_addcoin();
  static const int kAddCoinFieldNumber = 3;
  inline ::google::protobuf::uint32 addcoin() const;
  inline void set_addcoin(::google::protobuf::uint32 value);

  // optional .vmsg.CSAdminAddGold AddGold = 4;
  inline bool has_addgold() const;
  inline void clear_addgold();
  static const int kAddGoldFieldNumber = 4;
  inline const ::vmsg::CSAdminAddGold& addgold() const;
  inline ::vmsg::CSAdminAddGold* mutable_addgold();
  inline ::vmsg::CSAdminAddGold* release_addgold();
  inline void set_allocated_addgold(::vmsg::CSAdminAddGold* addgold);

  // optional .vmsg.CSAdminAddItemRqst AddItem = 5;
  inline bool has_additem() const;
  inline void clear_additem();
  static const int kAddItemFieldNumber = 5;
  inline const ::vmsg::CSAdminAddItemRqst& additem() const;
  inline ::vmsg::CSAdminAddItemRqst* mutable_additem();
  inline ::vmsg::CSAdminAddItemRqst* release_additem();
  inline void set_allocated_additem(::vmsg::CSAdminAddItemRqst* additem);

  // optional uint32 AddEquip = 6;
  inline bool has_addequip() const;
  inline void clear_addequip();
  static const int kAddEquipFieldNumber = 6;
  inline ::google::protobuf::uint32 addequip() const;
  inline void set_addequip(::google::protobuf::uint32 value);

  // optional uint32 AddExp = 7;
  inline bool has_addexp() const;
  inline void clear_addexp();
  static const int kAddExpFieldNumber = 7;
  inline ::google::protobuf::uint32 addexp() const;
  inline void set_addexp(::google::protobuf::uint32 value);

  // optional uint32 AddWeapon = 8;
  inline bool has_addweapon() const;
  inline void clear_addweapon();
  static const int kAddWeaponFieldNumber = 8;
  inline ::google::protobuf::uint32 addweapon() const;
  inline void set_addweapon(::google::protobuf::uint32 value);

  // optional .vmsg.CSAdminSendMailRqst SendMail = 9;
  inline bool has_sendmail() const;
  inline void clear_sendmail();
  static const int kSendMailFieldNumber = 9;
  inline const ::vmsg::CSAdminSendMailRqst& sendmail() const;
  inline ::vmsg::CSAdminSendMailRqst* mutable_sendmail();
  inline ::vmsg::CSAdminSendMailRqst* release_sendmail();
  inline void set_allocated_sendmail(::vmsg::CSAdminSendMailRqst* sendmail);

  // optional .vmsg.CSAdminSendMailGrpRqst SendGrpMail = 10;
  inline bool has_sendgrpmail() const;
  inline void clear_sendgrpmail();
  static const int kSendGrpMailFieldNumber = 10;
  inline const ::vmsg::CSAdminSendMailGrpRqst& sendgrpmail() const;
  inline ::vmsg::CSAdminSendMailGrpRqst* mutable_sendgrpmail();
  inline ::vmsg::CSAdminSendMailGrpRqst* release_sendgrpmail();
  inline void set_allocated_sendgrpmail(::vmsg::CSAdminSendMailGrpRqst* sendgrpmail);

  // optional .vmsg.CSAdminAddArenaMoney AddArenaMoney = 11;
  inline bool has_addarenamoney() const;
  inline void clear_addarenamoney();
  static const int kAddArenaMoneyFieldNumber = 11;
  inline const ::vmsg::CSAdminAddArenaMoney& addarenamoney() const;
  inline ::vmsg::CSAdminAddArenaMoney* mutable_addarenamoney();
  inline ::vmsg::CSAdminAddArenaMoney* release_addarenamoney();
  inline void set_allocated_addarenamoney(::vmsg::CSAdminAddArenaMoney* addarenamoney);

  // optional uint32 PassWarMap = 12;
  inline bool has_passwarmap() const;
  inline void clear_passwarmap();
  static const int kPassWarMapFieldNumber = 12;
  inline ::google::protobuf::uint32 passwarmap() const;
  inline void set_passwarmap(::google::protobuf::uint32 value);

  // optional uint32 ReceiveTask = 13;
  inline bool has_receivetask() const;
  inline void clear_receivetask();
  static const int kReceiveTaskFieldNumber = 13;
  inline ::google::protobuf::uint32 receivetask() const;
  inline void set_receivetask(::google::protobuf::uint32 value);

  // optional string NotifyContent = 14;
  inline bool has_notifycontent() const;
  inline void clear_notifycontent();
  static const int kNotifyContentFieldNumber = 14;
  inline const ::std::string& notifycontent() const;
  inline void set_notifycontent(const ::std::string& value);
  inline void set_notifycontent(const char* value);
  inline void set_notifycontent(const char* value, size_t size);
  inline ::std::string* mutable_notifycontent();
  inline ::std::string* release_notifycontent();
  inline void set_allocated_notifycontent(::std::string* notifycontent);

  // optional .vmsg.CSAdminForbidPlayer ForbideRqst = 15;
  inline bool has_forbiderqst() const;
  inline void clear_forbiderqst();
  static const int kForbideRqstFieldNumber = 15;
  inline const ::vmsg::CSAdminForbidPlayer& forbiderqst() const;
  inline ::vmsg::CSAdminForbidPlayer* mutable_forbiderqst();
  inline ::vmsg::CSAdminForbidPlayer* release_forbiderqst();
  inline void set_allocated_forbiderqst(::vmsg::CSAdminForbidPlayer* forbiderqst);

  // @@protoc_insertion_point(class_scope:vmsg.CSAdminRequest)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_zoneid();
  inline void clear_has_zoneid();
  inline void set_has_addcoin();
  inline void clear_has_addcoin();
  inline void set_has_addgold();
  inline void clear_has_addgold();
  inline void set_has_additem();
  inline void clear_has_additem();
  inline void set_has_addequip();
  inline void clear_has_addequip();
  inline void set_has_addexp();
  inline void clear_has_addexp();
  inline void set_has_addweapon();
  inline void clear_has_addweapon();
  inline void set_has_sendmail();
  inline void clear_has_sendmail();
  inline void set_has_sendgrpmail();
  inline void clear_has_sendgrpmail();
  inline void set_has_addarenamoney();
  inline void clear_has_addarenamoney();
  inline void set_has_passwarmap();
  inline void clear_has_passwarmap();
  inline void set_has_receivetask();
  inline void clear_has_receivetask();
  inline void set_has_notifycontent();
  inline void clear_has_notifycontent();
  inline void set_has_forbiderqst();
  inline void clear_has_forbiderqst();

  ::google::protobuf::uint64 uin_;
  ::google::protobuf::uint32 zoneid_;
  ::google::protobuf::uint32 addcoin_;
  ::vmsg::CSAdminAddGold* addgold_;
  ::vmsg::CSAdminAddItemRqst* additem_;
  ::google::protobuf::uint32 addequip_;
  ::google::protobuf::uint32 addexp_;
  ::vmsg::CSAdminSendMailRqst* sendmail_;
  ::vmsg::CSAdminSendMailGrpRqst* sendgrpmail_;
  ::google::protobuf::uint32 addweapon_;
  ::google::protobuf::uint32 passwarmap_;
  ::vmsg::CSAdminAddArenaMoney* addarenamoney_;
  ::std::string* notifycontent_;
  ::vmsg::CSAdminForbidPlayer* forbiderqst_;
  ::google::protobuf::uint32 receivetask_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_AdminMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_AdminMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_AdminMsg_2eproto();
  friend void protobuf_ShutdownFile_AdminMsg_2eproto();

  void InitAsDefaultInstance();
  static CSAdminRequest* default_instance_;
};
// -------------------------------------------------------------------

class CSAdminRespond : public ::google::protobuf::MessageLite {
 public:
  CSAdminRespond();
  virtual ~CSAdminRespond();

  CSAdminRespond(const CSAdminRespond& from);

  inline CSAdminRespond& operator=(const CSAdminRespond& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSAdminRespond& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAdminRespond* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAdminRespond* other);

  // implements Message ----------------------------------------------

  CSAdminRespond* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAdminRespond& from);
  void MergeFrom(const CSAdminRespond& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSQueryMailRsp QueryMail_Rsp = 1;
  inline bool has_querymail_rsp() const;
  inline void clear_querymail_rsp();
  static const int kQueryMailRspFieldNumber = 1;
  inline const ::vmsg::CSQueryMailRsp& querymail_rsp() const;
  inline ::vmsg::CSQueryMailRsp* mutable_querymail_rsp();
  inline ::vmsg::CSQueryMailRsp* release_querymail_rsp();
  inline void set_allocated_querymail_rsp(::vmsg::CSQueryMailRsp* querymail_rsp);

  // optional .vmsg.CSReadMailRsp ReadMail_Rsp = 2;
  inline bool has_readmail_rsp() const;
  inline void clear_readmail_rsp();
  static const int kReadMailRspFieldNumber = 2;
  inline const ::vmsg::CSReadMailRsp& readmail_rsp() const;
  inline ::vmsg::CSReadMailRsp* mutable_readmail_rsp();
  inline ::vmsg::CSReadMailRsp* release_readmail_rsp();
  inline void set_allocated_readmail_rsp(::vmsg::CSReadMailRsp* readmail_rsp);

  // optional .vmsg.CSGetAttachRsp GetAttach_Rsp = 3;
  inline bool has_getattach_rsp() const;
  inline void clear_getattach_rsp();
  static const int kGetAttachRspFieldNumber = 3;
  inline const ::vmsg::CSGetAttachRsp& getattach_rsp() const;
  inline ::vmsg::CSGetAttachRsp* mutable_getattach_rsp();
  inline ::vmsg::CSGetAttachRsp* release_getattach_rsp();
  inline void set_allocated_getattach_rsp(::vmsg::CSGetAttachRsp* getattach_rsp);

  // optional .vmsg.CSDeleteMailRsp DeleteMail_Rsp = 4;
  inline bool has_deletemail_rsp() const;
  inline void clear_deletemail_rsp();
  static const int kDeleteMailRspFieldNumber = 4;
  inline const ::vmsg::CSDeleteMailRsp& deletemail_rsp() const;
  inline ::vmsg::CSDeleteMailRsp* mutable_deletemail_rsp();
  inline ::vmsg::CSDeleteMailRsp* release_deletemail_rsp();
  inline void set_allocated_deletemail_rsp(::vmsg::CSDeleteMailRsp* deletemail_rsp);

  // @@protoc_insertion_point(class_scope:vmsg.CSAdminRespond)
 private:
  inline void set_has_querymail_rsp();
  inline void clear_has_querymail_rsp();
  inline void set_has_readmail_rsp();
  inline void clear_has_readmail_rsp();
  inline void set_has_getattach_rsp();
  inline void clear_has_getattach_rsp();
  inline void set_has_deletemail_rsp();
  inline void clear_has_deletemail_rsp();

  ::vmsg::CSQueryMailRsp* querymail_rsp_;
  ::vmsg::CSReadMailRsp* readmail_rsp_;
  ::vmsg::CSGetAttachRsp* getattach_rsp_;
  ::vmsg::CSDeleteMailRsp* deletemail_rsp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_AdminMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_AdminMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_AdminMsg_2eproto();
  friend void protobuf_ShutdownFile_AdminMsg_2eproto();

  void InitAsDefaultInstance();
  static CSAdminRespond* default_instance_;
};
// ===================================================================


// ===================================================================

// CSAdminAddGold

// required uint32 GoldCnt = 1;
inline bool CSAdminAddGold::has_goldcnt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAdminAddGold::set_has_goldcnt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAdminAddGold::clear_has_goldcnt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAdminAddGold::clear_goldcnt() {
  goldcnt_ = 0u;
  clear_has_goldcnt();
}
inline ::google::protobuf::uint32 CSAdminAddGold::goldcnt() const {
  return goldcnt_;
}
inline void CSAdminAddGold::set_goldcnt(::google::protobuf::uint32 value) {
  set_has_goldcnt();
  goldcnt_ = value;
}

// required uint32 Reason = 2;
inline bool CSAdminAddGold::has_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSAdminAddGold::set_has_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSAdminAddGold::clear_has_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSAdminAddGold::clear_reason() {
  reason_ = 0u;
  clear_has_reason();
}
inline ::google::protobuf::uint32 CSAdminAddGold::reason() const {
  return reason_;
}
inline void CSAdminAddGold::set_reason(::google::protobuf::uint32 value) {
  set_has_reason();
  reason_ = value;
}

// -------------------------------------------------------------------

// CSAdminAddItemRqst

// required uint32 ItemID = 1;
inline bool CSAdminAddItemRqst::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAdminAddItemRqst::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAdminAddItemRqst::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAdminAddItemRqst::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 CSAdminAddItemRqst::itemid() const {
  return itemid_;
}
inline void CSAdminAddItemRqst::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
}

// required uint32 ItemCnt = 2;
inline bool CSAdminAddItemRqst::has_itemcnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSAdminAddItemRqst::set_has_itemcnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSAdminAddItemRqst::clear_has_itemcnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSAdminAddItemRqst::clear_itemcnt() {
  itemcnt_ = 0u;
  clear_has_itemcnt();
}
inline ::google::protobuf::uint32 CSAdminAddItemRqst::itemcnt() const {
  return itemcnt_;
}
inline void CSAdminAddItemRqst::set_itemcnt(::google::protobuf::uint32 value) {
  set_has_itemcnt();
  itemcnt_ = value;
}

// required uint32 Reason = 3;
inline bool CSAdminAddItemRqst::has_reason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSAdminAddItemRqst::set_has_reason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSAdminAddItemRqst::clear_has_reason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSAdminAddItemRqst::clear_reason() {
  reason_ = 0u;
  clear_has_reason();
}
inline ::google::protobuf::uint32 CSAdminAddItemRqst::reason() const {
  return reason_;
}
inline void CSAdminAddItemRqst::set_reason(::google::protobuf::uint32 value) {
  set_has_reason();
  reason_ = value;
}

// -------------------------------------------------------------------

// CSAdminSendMailRqst

// required uint64 SenderUin = 1;
inline bool CSAdminSendMailRqst::has_senderuin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAdminSendMailRqst::set_has_senderuin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAdminSendMailRqst::clear_has_senderuin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAdminSendMailRqst::clear_senderuin() {
  senderuin_ = GOOGLE_ULONGLONG(0);
  clear_has_senderuin();
}
inline ::google::protobuf::uint64 CSAdminSendMailRqst::senderuin() const {
  return senderuin_;
}
inline void CSAdminSendMailRqst::set_senderuin(::google::protobuf::uint64 value) {
  set_has_senderuin();
  senderuin_ = value;
}

// required string MailHead = 2;
inline bool CSAdminSendMailRqst::has_mailhead() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSAdminSendMailRqst::set_has_mailhead() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSAdminSendMailRqst::clear_has_mailhead() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSAdminSendMailRqst::clear_mailhead() {
  if (mailhead_ != &::google::protobuf::internal::kEmptyString) {
    mailhead_->clear();
  }
  clear_has_mailhead();
}
inline const ::std::string& CSAdminSendMailRqst::mailhead() const {
  return *mailhead_;
}
inline void CSAdminSendMailRqst::set_mailhead(const ::std::string& value) {
  set_has_mailhead();
  if (mailhead_ == &::google::protobuf::internal::kEmptyString) {
    mailhead_ = new ::std::string;
  }
  mailhead_->assign(value);
}
inline void CSAdminSendMailRqst::set_mailhead(const char* value) {
  set_has_mailhead();
  if (mailhead_ == &::google::protobuf::internal::kEmptyString) {
    mailhead_ = new ::std::string;
  }
  mailhead_->assign(value);
}
inline void CSAdminSendMailRqst::set_mailhead(const char* value, size_t size) {
  set_has_mailhead();
  if (mailhead_ == &::google::protobuf::internal::kEmptyString) {
    mailhead_ = new ::std::string;
  }
  mailhead_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSAdminSendMailRqst::mutable_mailhead() {
  set_has_mailhead();
  if (mailhead_ == &::google::protobuf::internal::kEmptyString) {
    mailhead_ = new ::std::string;
  }
  return mailhead_;
}
inline ::std::string* CSAdminSendMailRqst::release_mailhead() {
  clear_has_mailhead();
  if (mailhead_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mailhead_;
    mailhead_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSAdminSendMailRqst::set_allocated_mailhead(::std::string* mailhead) {
  if (mailhead_ != &::google::protobuf::internal::kEmptyString) {
    delete mailhead_;
  }
  if (mailhead) {
    set_has_mailhead();
    mailhead_ = mailhead;
  } else {
    clear_has_mailhead();
    mailhead_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string MailBody = 3;
inline bool CSAdminSendMailRqst::has_mailbody() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSAdminSendMailRqst::set_has_mailbody() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSAdminSendMailRqst::clear_has_mailbody() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSAdminSendMailRqst::clear_mailbody() {
  if (mailbody_ != &::google::protobuf::internal::kEmptyString) {
    mailbody_->clear();
  }
  clear_has_mailbody();
}
inline const ::std::string& CSAdminSendMailRqst::mailbody() const {
  return *mailbody_;
}
inline void CSAdminSendMailRqst::set_mailbody(const ::std::string& value) {
  set_has_mailbody();
  if (mailbody_ == &::google::protobuf::internal::kEmptyString) {
    mailbody_ = new ::std::string;
  }
  mailbody_->assign(value);
}
inline void CSAdminSendMailRqst::set_mailbody(const char* value) {
  set_has_mailbody();
  if (mailbody_ == &::google::protobuf::internal::kEmptyString) {
    mailbody_ = new ::std::string;
  }
  mailbody_->assign(value);
}
inline void CSAdminSendMailRqst::set_mailbody(const char* value, size_t size) {
  set_has_mailbody();
  if (mailbody_ == &::google::protobuf::internal::kEmptyString) {
    mailbody_ = new ::std::string;
  }
  mailbody_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSAdminSendMailRqst::mutable_mailbody() {
  set_has_mailbody();
  if (mailbody_ == &::google::protobuf::internal::kEmptyString) {
    mailbody_ = new ::std::string;
  }
  return mailbody_;
}
inline ::std::string* CSAdminSendMailRqst::release_mailbody() {
  clear_has_mailbody();
  if (mailbody_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mailbody_;
    mailbody_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSAdminSendMailRqst::set_allocated_mailbody(::std::string* mailbody) {
  if (mailbody_ != &::google::protobuf::internal::kEmptyString) {
    delete mailbody_;
  }
  if (mailbody) {
    set_has_mailbody();
    mailbody_ = mailbody;
  } else {
    clear_has_mailbody();
    mailbody_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .vmsg.CSMailAttach AttachLst = 4;
inline int CSAdminSendMailRqst::attachlst_size() const {
  return attachlst_.size();
}
inline void CSAdminSendMailRqst::clear_attachlst() {
  attachlst_.Clear();
}
inline const ::vmsg::CSMailAttach& CSAdminSendMailRqst::attachlst(int index) const {
  return attachlst_.Get(index);
}
inline ::vmsg::CSMailAttach* CSAdminSendMailRqst::mutable_attachlst(int index) {
  return attachlst_.Mutable(index);
}
inline ::vmsg::CSMailAttach* CSAdminSendMailRqst::add_attachlst() {
  return attachlst_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailAttach >&
CSAdminSendMailRqst::attachlst() const {
  return attachlst_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailAttach >*
CSAdminSendMailRqst::mutable_attachlst() {
  return &attachlst_;
}

// -------------------------------------------------------------------

// CSAdminSendMailGrpRqst

// required uint64 SenderUin = 1;
inline bool CSAdminSendMailGrpRqst::has_senderuin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAdminSendMailGrpRqst::set_has_senderuin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAdminSendMailGrpRqst::clear_has_senderuin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAdminSendMailGrpRqst::clear_senderuin() {
  senderuin_ = GOOGLE_ULONGLONG(0);
  clear_has_senderuin();
}
inline ::google::protobuf::uint64 CSAdminSendMailGrpRqst::senderuin() const {
  return senderuin_;
}
inline void CSAdminSendMailGrpRqst::set_senderuin(::google::protobuf::uint64 value) {
  set_has_senderuin();
  senderuin_ = value;
}

// required uint64 ReceiveGrpID = 2;
inline bool CSAdminSendMailGrpRqst::has_receivegrpid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSAdminSendMailGrpRqst::set_has_receivegrpid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSAdminSendMailGrpRqst::clear_has_receivegrpid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSAdminSendMailGrpRqst::clear_receivegrpid() {
  receivegrpid_ = GOOGLE_ULONGLONG(0);
  clear_has_receivegrpid();
}
inline ::google::protobuf::uint64 CSAdminSendMailGrpRqst::receivegrpid() const {
  return receivegrpid_;
}
inline void CSAdminSendMailGrpRqst::set_receivegrpid(::google::protobuf::uint64 value) {
  set_has_receivegrpid();
  receivegrpid_ = value;
}

// required string MailHead = 3;
inline bool CSAdminSendMailGrpRqst::has_mailhead() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSAdminSendMailGrpRqst::set_has_mailhead() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSAdminSendMailGrpRqst::clear_has_mailhead() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSAdminSendMailGrpRqst::clear_mailhead() {
  if (mailhead_ != &::google::protobuf::internal::kEmptyString) {
    mailhead_->clear();
  }
  clear_has_mailhead();
}
inline const ::std::string& CSAdminSendMailGrpRqst::mailhead() const {
  return *mailhead_;
}
inline void CSAdminSendMailGrpRqst::set_mailhead(const ::std::string& value) {
  set_has_mailhead();
  if (mailhead_ == &::google::protobuf::internal::kEmptyString) {
    mailhead_ = new ::std::string;
  }
  mailhead_->assign(value);
}
inline void CSAdminSendMailGrpRqst::set_mailhead(const char* value) {
  set_has_mailhead();
  if (mailhead_ == &::google::protobuf::internal::kEmptyString) {
    mailhead_ = new ::std::string;
  }
  mailhead_->assign(value);
}
inline void CSAdminSendMailGrpRqst::set_mailhead(const char* value, size_t size) {
  set_has_mailhead();
  if (mailhead_ == &::google::protobuf::internal::kEmptyString) {
    mailhead_ = new ::std::string;
  }
  mailhead_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSAdminSendMailGrpRqst::mutable_mailhead() {
  set_has_mailhead();
  if (mailhead_ == &::google::protobuf::internal::kEmptyString) {
    mailhead_ = new ::std::string;
  }
  return mailhead_;
}
inline ::std::string* CSAdminSendMailGrpRqst::release_mailhead() {
  clear_has_mailhead();
  if (mailhead_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mailhead_;
    mailhead_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSAdminSendMailGrpRqst::set_allocated_mailhead(::std::string* mailhead) {
  if (mailhead_ != &::google::protobuf::internal::kEmptyString) {
    delete mailhead_;
  }
  if (mailhead) {
    set_has_mailhead();
    mailhead_ = mailhead;
  } else {
    clear_has_mailhead();
    mailhead_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string MailBody = 4;
inline bool CSAdminSendMailGrpRqst::has_mailbody() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSAdminSendMailGrpRqst::set_has_mailbody() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSAdminSendMailGrpRqst::clear_has_mailbody() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSAdminSendMailGrpRqst::clear_mailbody() {
  if (mailbody_ != &::google::protobuf::internal::kEmptyString) {
    mailbody_->clear();
  }
  clear_has_mailbody();
}
inline const ::std::string& CSAdminSendMailGrpRqst::mailbody() const {
  return *mailbody_;
}
inline void CSAdminSendMailGrpRqst::set_mailbody(const ::std::string& value) {
  set_has_mailbody();
  if (mailbody_ == &::google::protobuf::internal::kEmptyString) {
    mailbody_ = new ::std::string;
  }
  mailbody_->assign(value);
}
inline void CSAdminSendMailGrpRqst::set_mailbody(const char* value) {
  set_has_mailbody();
  if (mailbody_ == &::google::protobuf::internal::kEmptyString) {
    mailbody_ = new ::std::string;
  }
  mailbody_->assign(value);
}
inline void CSAdminSendMailGrpRqst::set_mailbody(const char* value, size_t size) {
  set_has_mailbody();
  if (mailbody_ == &::google::protobuf::internal::kEmptyString) {
    mailbody_ = new ::std::string;
  }
  mailbody_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSAdminSendMailGrpRqst::mutable_mailbody() {
  set_has_mailbody();
  if (mailbody_ == &::google::protobuf::internal::kEmptyString) {
    mailbody_ = new ::std::string;
  }
  return mailbody_;
}
inline ::std::string* CSAdminSendMailGrpRqst::release_mailbody() {
  clear_has_mailbody();
  if (mailbody_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mailbody_;
    mailbody_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSAdminSendMailGrpRqst::set_allocated_mailbody(::std::string* mailbody) {
  if (mailbody_ != &::google::protobuf::internal::kEmptyString) {
    delete mailbody_;
  }
  if (mailbody) {
    set_has_mailbody();
    mailbody_ = mailbody;
  } else {
    clear_has_mailbody();
    mailbody_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .vmsg.CSMailAttach AttachLst = 5;
inline int CSAdminSendMailGrpRqst::attachlst_size() const {
  return attachlst_.size();
}
inline void CSAdminSendMailGrpRqst::clear_attachlst() {
  attachlst_.Clear();
}
inline const ::vmsg::CSMailAttach& CSAdminSendMailGrpRqst::attachlst(int index) const {
  return attachlst_.Get(index);
}
inline ::vmsg::CSMailAttach* CSAdminSendMailGrpRqst::mutable_attachlst(int index) {
  return attachlst_.Mutable(index);
}
inline ::vmsg::CSMailAttach* CSAdminSendMailGrpRqst::add_attachlst() {
  return attachlst_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailAttach >&
CSAdminSendMailGrpRqst::attachlst() const {
  return attachlst_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSMailAttach >*
CSAdminSendMailGrpRqst::mutable_attachlst() {
  return &attachlst_;
}

// -------------------------------------------------------------------

// CSAdminAddArenaMoney

// required uint32 MoneyNum = 1;
inline bool CSAdminAddArenaMoney::has_moneynum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAdminAddArenaMoney::set_has_moneynum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAdminAddArenaMoney::clear_has_moneynum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAdminAddArenaMoney::clear_moneynum() {
  moneynum_ = 0u;
  clear_has_moneynum();
}
inline ::google::protobuf::uint32 CSAdminAddArenaMoney::moneynum() const {
  return moneynum_;
}
inline void CSAdminAddArenaMoney::set_moneynum(::google::protobuf::uint32 value) {
  set_has_moneynum();
  moneynum_ = value;
}

// -------------------------------------------------------------------

// CSAdminForbidPlayer

// required uint32 TimeInSec = 1;
inline bool CSAdminForbidPlayer::has_timeinsec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAdminForbidPlayer::set_has_timeinsec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAdminForbidPlayer::clear_has_timeinsec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAdminForbidPlayer::clear_timeinsec() {
  timeinsec_ = 0u;
  clear_has_timeinsec();
}
inline ::google::protobuf::uint32 CSAdminForbidPlayer::timeinsec() const {
  return timeinsec_;
}
inline void CSAdminForbidPlayer::set_timeinsec(::google::protobuf::uint32 value) {
  set_has_timeinsec();
  timeinsec_ = value;
}

// -------------------------------------------------------------------

// CSAdminRequest

// required uint64 Uin = 1;
inline bool CSAdminRequest::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAdminRequest::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAdminRequest::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAdminRequest::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSAdminRequest::uin() const {
  return uin_;
}
inline void CSAdminRequest::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
}

// required uint32 ZoneID = 2;
inline bool CSAdminRequest::has_zoneid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSAdminRequest::set_has_zoneid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSAdminRequest::clear_has_zoneid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSAdminRequest::clear_zoneid() {
  zoneid_ = 0u;
  clear_has_zoneid();
}
inline ::google::protobuf::uint32 CSAdminRequest::zoneid() const {
  return zoneid_;
}
inline void CSAdminRequest::set_zoneid(::google::protobuf::uint32 value) {
  set_has_zoneid();
  zoneid_ = value;
}

// optional uint32 AddCoin = 3;
inline bool CSAdminRequest::has_addcoin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSAdminRequest::set_has_addcoin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSAdminRequest::clear_has_addcoin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSAdminRequest::clear_addcoin() {
  addcoin_ = 0u;
  clear_has_addcoin();
}
inline ::google::protobuf::uint32 CSAdminRequest::addcoin() const {
  return addcoin_;
}
inline void CSAdminRequest::set_addcoin(::google::protobuf::uint32 value) {
  set_has_addcoin();
  addcoin_ = value;
}

// optional .vmsg.CSAdminAddGold AddGold = 4;
inline bool CSAdminRequest::has_addgold() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSAdminRequest::set_has_addgold() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSAdminRequest::clear_has_addgold() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSAdminRequest::clear_addgold() {
  if (addgold_ != NULL) addgold_->::vmsg::CSAdminAddGold::Clear();
  clear_has_addgold();
}
inline const ::vmsg::CSAdminAddGold& CSAdminRequest::addgold() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return addgold_ != NULL ? *addgold_ : *default_instance().addgold_;
#else
  return addgold_ != NULL ? *addgold_ : *default_instance_->addgold_;
#endif
}
inline ::vmsg::CSAdminAddGold* CSAdminRequest::mutable_addgold() {
  set_has_addgold();
  if (addgold_ == NULL) addgold_ = new ::vmsg::CSAdminAddGold;
  return addgold_;
}
inline ::vmsg::CSAdminAddGold* CSAdminRequest::release_addgold() {
  clear_has_addgold();
  ::vmsg::CSAdminAddGold* temp = addgold_;
  addgold_ = NULL;
  return temp;
}
inline void CSAdminRequest::set_allocated_addgold(::vmsg::CSAdminAddGold* addgold) {
  delete addgold_;
  addgold_ = addgold;
  if (addgold) {
    set_has_addgold();
  } else {
    clear_has_addgold();
  }
}

// optional .vmsg.CSAdminAddItemRqst AddItem = 5;
inline bool CSAdminRequest::has_additem() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSAdminRequest::set_has_additem() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSAdminRequest::clear_has_additem() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSAdminRequest::clear_additem() {
  if (additem_ != NULL) additem_->::vmsg::CSAdminAddItemRqst::Clear();
  clear_has_additem();
}
inline const ::vmsg::CSAdminAddItemRqst& CSAdminRequest::additem() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return additem_ != NULL ? *additem_ : *default_instance().additem_;
#else
  return additem_ != NULL ? *additem_ : *default_instance_->additem_;
#endif
}
inline ::vmsg::CSAdminAddItemRqst* CSAdminRequest::mutable_additem() {
  set_has_additem();
  if (additem_ == NULL) additem_ = new ::vmsg::CSAdminAddItemRqst;
  return additem_;
}
inline ::vmsg::CSAdminAddItemRqst* CSAdminRequest::release_additem() {
  clear_has_additem();
  ::vmsg::CSAdminAddItemRqst* temp = additem_;
  additem_ = NULL;
  return temp;
}
inline void CSAdminRequest::set_allocated_additem(::vmsg::CSAdminAddItemRqst* additem) {
  delete additem_;
  additem_ = additem;
  if (additem) {
    set_has_additem();
  } else {
    clear_has_additem();
  }
}

// optional uint32 AddEquip = 6;
inline bool CSAdminRequest::has_addequip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSAdminRequest::set_has_addequip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSAdminRequest::clear_has_addequip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSAdminRequest::clear_addequip() {
  addequip_ = 0u;
  clear_has_addequip();
}
inline ::google::protobuf::uint32 CSAdminRequest::addequip() const {
  return addequip_;
}
inline void CSAdminRequest::set_addequip(::google::protobuf::uint32 value) {
  set_has_addequip();
  addequip_ = value;
}

// optional uint32 AddExp = 7;
inline bool CSAdminRequest::has_addexp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSAdminRequest::set_has_addexp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSAdminRequest::clear_has_addexp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSAdminRequest::clear_addexp() {
  addexp_ = 0u;
  clear_has_addexp();
}
inline ::google::protobuf::uint32 CSAdminRequest::addexp() const {
  return addexp_;
}
inline void CSAdminRequest::set_addexp(::google::protobuf::uint32 value) {
  set_has_addexp();
  addexp_ = value;
}

// optional uint32 AddWeapon = 8;
inline bool CSAdminRequest::has_addweapon() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSAdminRequest::set_has_addweapon() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSAdminRequest::clear_has_addweapon() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSAdminRequest::clear_addweapon() {
  addweapon_ = 0u;
  clear_has_addweapon();
}
inline ::google::protobuf::uint32 CSAdminRequest::addweapon() const {
  return addweapon_;
}
inline void CSAdminRequest::set_addweapon(::google::protobuf::uint32 value) {
  set_has_addweapon();
  addweapon_ = value;
}

// optional .vmsg.CSAdminSendMailRqst SendMail = 9;
inline bool CSAdminRequest::has_sendmail() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSAdminRequest::set_has_sendmail() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSAdminRequest::clear_has_sendmail() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSAdminRequest::clear_sendmail() {
  if (sendmail_ != NULL) sendmail_->::vmsg::CSAdminSendMailRqst::Clear();
  clear_has_sendmail();
}
inline const ::vmsg::CSAdminSendMailRqst& CSAdminRequest::sendmail() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sendmail_ != NULL ? *sendmail_ : *default_instance().sendmail_;
#else
  return sendmail_ != NULL ? *sendmail_ : *default_instance_->sendmail_;
#endif
}
inline ::vmsg::CSAdminSendMailRqst* CSAdminRequest::mutable_sendmail() {
  set_has_sendmail();
  if (sendmail_ == NULL) sendmail_ = new ::vmsg::CSAdminSendMailRqst;
  return sendmail_;
}
inline ::vmsg::CSAdminSendMailRqst* CSAdminRequest::release_sendmail() {
  clear_has_sendmail();
  ::vmsg::CSAdminSendMailRqst* temp = sendmail_;
  sendmail_ = NULL;
  return temp;
}
inline void CSAdminRequest::set_allocated_sendmail(::vmsg::CSAdminSendMailRqst* sendmail) {
  delete sendmail_;
  sendmail_ = sendmail;
  if (sendmail) {
    set_has_sendmail();
  } else {
    clear_has_sendmail();
  }
}

// optional .vmsg.CSAdminSendMailGrpRqst SendGrpMail = 10;
inline bool CSAdminRequest::has_sendgrpmail() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CSAdminRequest::set_has_sendgrpmail() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CSAdminRequest::clear_has_sendgrpmail() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CSAdminRequest::clear_sendgrpmail() {
  if (sendgrpmail_ != NULL) sendgrpmail_->::vmsg::CSAdminSendMailGrpRqst::Clear();
  clear_has_sendgrpmail();
}
inline const ::vmsg::CSAdminSendMailGrpRqst& CSAdminRequest::sendgrpmail() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sendgrpmail_ != NULL ? *sendgrpmail_ : *default_instance().sendgrpmail_;
#else
  return sendgrpmail_ != NULL ? *sendgrpmail_ : *default_instance_->sendgrpmail_;
#endif
}
inline ::vmsg::CSAdminSendMailGrpRqst* CSAdminRequest::mutable_sendgrpmail() {
  set_has_sendgrpmail();
  if (sendgrpmail_ == NULL) sendgrpmail_ = new ::vmsg::CSAdminSendMailGrpRqst;
  return sendgrpmail_;
}
inline ::vmsg::CSAdminSendMailGrpRqst* CSAdminRequest::release_sendgrpmail() {
  clear_has_sendgrpmail();
  ::vmsg::CSAdminSendMailGrpRqst* temp = sendgrpmail_;
  sendgrpmail_ = NULL;
  return temp;
}
inline void CSAdminRequest::set_allocated_sendgrpmail(::vmsg::CSAdminSendMailGrpRqst* sendgrpmail) {
  delete sendgrpmail_;
  sendgrpmail_ = sendgrpmail;
  if (sendgrpmail) {
    set_has_sendgrpmail();
  } else {
    clear_has_sendgrpmail();
  }
}

// optional .vmsg.CSAdminAddArenaMoney AddArenaMoney = 11;
inline bool CSAdminRequest::has_addarenamoney() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CSAdminRequest::set_has_addarenamoney() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CSAdminRequest::clear_has_addarenamoney() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CSAdminRequest::clear_addarenamoney() {
  if (addarenamoney_ != NULL) addarenamoney_->::vmsg::CSAdminAddArenaMoney::Clear();
  clear_has_addarenamoney();
}
inline const ::vmsg::CSAdminAddArenaMoney& CSAdminRequest::addarenamoney() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return addarenamoney_ != NULL ? *addarenamoney_ : *default_instance().addarenamoney_;
#else
  return addarenamoney_ != NULL ? *addarenamoney_ : *default_instance_->addarenamoney_;
#endif
}
inline ::vmsg::CSAdminAddArenaMoney* CSAdminRequest::mutable_addarenamoney() {
  set_has_addarenamoney();
  if (addarenamoney_ == NULL) addarenamoney_ = new ::vmsg::CSAdminAddArenaMoney;
  return addarenamoney_;
}
inline ::vmsg::CSAdminAddArenaMoney* CSAdminRequest::release_addarenamoney() {
  clear_has_addarenamoney();
  ::vmsg::CSAdminAddArenaMoney* temp = addarenamoney_;
  addarenamoney_ = NULL;
  return temp;
}
inline void CSAdminRequest::set_allocated_addarenamoney(::vmsg::CSAdminAddArenaMoney* addarenamoney) {
  delete addarenamoney_;
  addarenamoney_ = addarenamoney;
  if (addarenamoney) {
    set_has_addarenamoney();
  } else {
    clear_has_addarenamoney();
  }
}

// optional uint32 PassWarMap = 12;
inline bool CSAdminRequest::has_passwarmap() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CSAdminRequest::set_has_passwarmap() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CSAdminRequest::clear_has_passwarmap() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CSAdminRequest::clear_passwarmap() {
  passwarmap_ = 0u;
  clear_has_passwarmap();
}
inline ::google::protobuf::uint32 CSAdminRequest::passwarmap() const {
  return passwarmap_;
}
inline void CSAdminRequest::set_passwarmap(::google::protobuf::uint32 value) {
  set_has_passwarmap();
  passwarmap_ = value;
}

// optional uint32 ReceiveTask = 13;
inline bool CSAdminRequest::has_receivetask() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CSAdminRequest::set_has_receivetask() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CSAdminRequest::clear_has_receivetask() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CSAdminRequest::clear_receivetask() {
  receivetask_ = 0u;
  clear_has_receivetask();
}
inline ::google::protobuf::uint32 CSAdminRequest::receivetask() const {
  return receivetask_;
}
inline void CSAdminRequest::set_receivetask(::google::protobuf::uint32 value) {
  set_has_receivetask();
  receivetask_ = value;
}

// optional string NotifyContent = 14;
inline bool CSAdminRequest::has_notifycontent() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CSAdminRequest::set_has_notifycontent() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CSAdminRequest::clear_has_notifycontent() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CSAdminRequest::clear_notifycontent() {
  if (notifycontent_ != &::google::protobuf::internal::kEmptyString) {
    notifycontent_->clear();
  }
  clear_has_notifycontent();
}
inline const ::std::string& CSAdminRequest::notifycontent() const {
  return *notifycontent_;
}
inline void CSAdminRequest::set_notifycontent(const ::std::string& value) {
  set_has_notifycontent();
  if (notifycontent_ == &::google::protobuf::internal::kEmptyString) {
    notifycontent_ = new ::std::string;
  }
  notifycontent_->assign(value);
}
inline void CSAdminRequest::set_notifycontent(const char* value) {
  set_has_notifycontent();
  if (notifycontent_ == &::google::protobuf::internal::kEmptyString) {
    notifycontent_ = new ::std::string;
  }
  notifycontent_->assign(value);
}
inline void CSAdminRequest::set_notifycontent(const char* value, size_t size) {
  set_has_notifycontent();
  if (notifycontent_ == &::google::protobuf::internal::kEmptyString) {
    notifycontent_ = new ::std::string;
  }
  notifycontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSAdminRequest::mutable_notifycontent() {
  set_has_notifycontent();
  if (notifycontent_ == &::google::protobuf::internal::kEmptyString) {
    notifycontent_ = new ::std::string;
  }
  return notifycontent_;
}
inline ::std::string* CSAdminRequest::release_notifycontent() {
  clear_has_notifycontent();
  if (notifycontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notifycontent_;
    notifycontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSAdminRequest::set_allocated_notifycontent(::std::string* notifycontent) {
  if (notifycontent_ != &::google::protobuf::internal::kEmptyString) {
    delete notifycontent_;
  }
  if (notifycontent) {
    set_has_notifycontent();
    notifycontent_ = notifycontent;
  } else {
    clear_has_notifycontent();
    notifycontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .vmsg.CSAdminForbidPlayer ForbideRqst = 15;
inline bool CSAdminRequest::has_forbiderqst() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CSAdminRequest::set_has_forbiderqst() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CSAdminRequest::clear_has_forbiderqst() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CSAdminRequest::clear_forbiderqst() {
  if (forbiderqst_ != NULL) forbiderqst_->::vmsg::CSAdminForbidPlayer::Clear();
  clear_has_forbiderqst();
}
inline const ::vmsg::CSAdminForbidPlayer& CSAdminRequest::forbiderqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return forbiderqst_ != NULL ? *forbiderqst_ : *default_instance().forbiderqst_;
#else
  return forbiderqst_ != NULL ? *forbiderqst_ : *default_instance_->forbiderqst_;
#endif
}
inline ::vmsg::CSAdminForbidPlayer* CSAdminRequest::mutable_forbiderqst() {
  set_has_forbiderqst();
  if (forbiderqst_ == NULL) forbiderqst_ = new ::vmsg::CSAdminForbidPlayer;
  return forbiderqst_;
}
inline ::vmsg::CSAdminForbidPlayer* CSAdminRequest::release_forbiderqst() {
  clear_has_forbiderqst();
  ::vmsg::CSAdminForbidPlayer* temp = forbiderqst_;
  forbiderqst_ = NULL;
  return temp;
}
inline void CSAdminRequest::set_allocated_forbiderqst(::vmsg::CSAdminForbidPlayer* forbiderqst) {
  delete forbiderqst_;
  forbiderqst_ = forbiderqst;
  if (forbiderqst) {
    set_has_forbiderqst();
  } else {
    clear_has_forbiderqst();
  }
}

// -------------------------------------------------------------------

// CSAdminRespond

// optional .vmsg.CSQueryMailRsp QueryMail_Rsp = 1;
inline bool CSAdminRespond::has_querymail_rsp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAdminRespond::set_has_querymail_rsp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAdminRespond::clear_has_querymail_rsp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAdminRespond::clear_querymail_rsp() {
  if (querymail_rsp_ != NULL) querymail_rsp_->::vmsg::CSQueryMailRsp::Clear();
  clear_has_querymail_rsp();
}
inline const ::vmsg::CSQueryMailRsp& CSAdminRespond::querymail_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return querymail_rsp_ != NULL ? *querymail_rsp_ : *default_instance().querymail_rsp_;
#else
  return querymail_rsp_ != NULL ? *querymail_rsp_ : *default_instance_->querymail_rsp_;
#endif
}
inline ::vmsg::CSQueryMailRsp* CSAdminRespond::mutable_querymail_rsp() {
  set_has_querymail_rsp();
  if (querymail_rsp_ == NULL) querymail_rsp_ = new ::vmsg::CSQueryMailRsp;
  return querymail_rsp_;
}
inline ::vmsg::CSQueryMailRsp* CSAdminRespond::release_querymail_rsp() {
  clear_has_querymail_rsp();
  ::vmsg::CSQueryMailRsp* temp = querymail_rsp_;
  querymail_rsp_ = NULL;
  return temp;
}
inline void CSAdminRespond::set_allocated_querymail_rsp(::vmsg::CSQueryMailRsp* querymail_rsp) {
  delete querymail_rsp_;
  querymail_rsp_ = querymail_rsp;
  if (querymail_rsp) {
    set_has_querymail_rsp();
  } else {
    clear_has_querymail_rsp();
  }
}

// optional .vmsg.CSReadMailRsp ReadMail_Rsp = 2;
inline bool CSAdminRespond::has_readmail_rsp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSAdminRespond::set_has_readmail_rsp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSAdminRespond::clear_has_readmail_rsp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSAdminRespond::clear_readmail_rsp() {
  if (readmail_rsp_ != NULL) readmail_rsp_->::vmsg::CSReadMailRsp::Clear();
  clear_has_readmail_rsp();
}
inline const ::vmsg::CSReadMailRsp& CSAdminRespond::readmail_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return readmail_rsp_ != NULL ? *readmail_rsp_ : *default_instance().readmail_rsp_;
#else
  return readmail_rsp_ != NULL ? *readmail_rsp_ : *default_instance_->readmail_rsp_;
#endif
}
inline ::vmsg::CSReadMailRsp* CSAdminRespond::mutable_readmail_rsp() {
  set_has_readmail_rsp();
  if (readmail_rsp_ == NULL) readmail_rsp_ = new ::vmsg::CSReadMailRsp;
  return readmail_rsp_;
}
inline ::vmsg::CSReadMailRsp* CSAdminRespond::release_readmail_rsp() {
  clear_has_readmail_rsp();
  ::vmsg::CSReadMailRsp* temp = readmail_rsp_;
  readmail_rsp_ = NULL;
  return temp;
}
inline void CSAdminRespond::set_allocated_readmail_rsp(::vmsg::CSReadMailRsp* readmail_rsp) {
  delete readmail_rsp_;
  readmail_rsp_ = readmail_rsp;
  if (readmail_rsp) {
    set_has_readmail_rsp();
  } else {
    clear_has_readmail_rsp();
  }
}

// optional .vmsg.CSGetAttachRsp GetAttach_Rsp = 3;
inline bool CSAdminRespond::has_getattach_rsp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSAdminRespond::set_has_getattach_rsp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSAdminRespond::clear_has_getattach_rsp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSAdminRespond::clear_getattach_rsp() {
  if (getattach_rsp_ != NULL) getattach_rsp_->::vmsg::CSGetAttachRsp::Clear();
  clear_has_getattach_rsp();
}
inline const ::vmsg::CSGetAttachRsp& CSAdminRespond::getattach_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getattach_rsp_ != NULL ? *getattach_rsp_ : *default_instance().getattach_rsp_;
#else
  return getattach_rsp_ != NULL ? *getattach_rsp_ : *default_instance_->getattach_rsp_;
#endif
}
inline ::vmsg::CSGetAttachRsp* CSAdminRespond::mutable_getattach_rsp() {
  set_has_getattach_rsp();
  if (getattach_rsp_ == NULL) getattach_rsp_ = new ::vmsg::CSGetAttachRsp;
  return getattach_rsp_;
}
inline ::vmsg::CSGetAttachRsp* CSAdminRespond::release_getattach_rsp() {
  clear_has_getattach_rsp();
  ::vmsg::CSGetAttachRsp* temp = getattach_rsp_;
  getattach_rsp_ = NULL;
  return temp;
}
inline void CSAdminRespond::set_allocated_getattach_rsp(::vmsg::CSGetAttachRsp* getattach_rsp) {
  delete getattach_rsp_;
  getattach_rsp_ = getattach_rsp;
  if (getattach_rsp) {
    set_has_getattach_rsp();
  } else {
    clear_has_getattach_rsp();
  }
}

// optional .vmsg.CSDeleteMailRsp DeleteMail_Rsp = 4;
inline bool CSAdminRespond::has_deletemail_rsp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSAdminRespond::set_has_deletemail_rsp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSAdminRespond::clear_has_deletemail_rsp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSAdminRespond::clear_deletemail_rsp() {
  if (deletemail_rsp_ != NULL) deletemail_rsp_->::vmsg::CSDeleteMailRsp::Clear();
  clear_has_deletemail_rsp();
}
inline const ::vmsg::CSDeleteMailRsp& CSAdminRespond::deletemail_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return deletemail_rsp_ != NULL ? *deletemail_rsp_ : *default_instance().deletemail_rsp_;
#else
  return deletemail_rsp_ != NULL ? *deletemail_rsp_ : *default_instance_->deletemail_rsp_;
#endif
}
inline ::vmsg::CSDeleteMailRsp* CSAdminRespond::mutable_deletemail_rsp() {
  set_has_deletemail_rsp();
  if (deletemail_rsp_ == NULL) deletemail_rsp_ = new ::vmsg::CSDeleteMailRsp;
  return deletemail_rsp_;
}
inline ::vmsg::CSDeleteMailRsp* CSAdminRespond::release_deletemail_rsp() {
  clear_has_deletemail_rsp();
  ::vmsg::CSDeleteMailRsp* temp = deletemail_rsp_;
  deletemail_rsp_ = NULL;
  return temp;
}
inline void CSAdminRespond::set_allocated_deletemail_rsp(::vmsg::CSDeleteMailRsp* deletemail_rsp) {
  delete deletemail_rsp_;
  deletemail_rsp_ = deletemail_rsp;
  if (deletemail_rsp) {
    set_has_deletemail_rsp();
  } else {
    clear_has_deletemail_rsp();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_AdminMsg_2eproto__INCLUDED
