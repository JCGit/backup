// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ClientSvrMsg.proto

#ifndef PROTOBUF_ClientSvrMsg_2eproto__INCLUDED
#define PROTOBUF_ClientSvrMsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MsgBase.pb.h"
#include "ShareByClient.pb.h"
#include "CSPlayerMsg.pb.h"
#include "CSSenceOSD.pb.h"
#include "AdminMsg.pb.h"
#include "CSBagMsg.pb.h"
#include "CSEquipOpMsg.pb.h"
#include "CSTaskMsg.pb.h"
#include "CSRankMsg.pb.h"
#include "CSGoldMsg.pb.h"
#include "CSItemOpMsg.pb.h"
#include "CSWeaponMsg.pb.h"
#include "CSWarMapMsg.pb.h"
#include "CSFriendMsg.pb.h"
#include "CSGuildMsg.pb.h"
#include "CSMailMsg.pb.h"
#include "CSInfiniteMsg.pb.h"
#include "CSChatMsg.pb.h"
#include "CSCVZMsg.pb.h"
#include "CSServerNotifyMsg.pb.h"
#include "CSDailyGiftMsg.pb.h"
#include "CSArenaMsg.pb.h"
#include "CSStoreMsg.pb.h"
#include "CSQiangHunMsg.pb.h"
#include "CSDebrisMsg.pb.h"
#include "CSActMsg.pb.h"
#include "CSDotaItemMsg.pb.h"
#include "CSCouponMsg.pb.h"
#include "CSPushMsg.pb.h"
#include "CSBossChallengeMsg.pb.h"
#include "CSAccountMsg.pb.h"
// @@protoc_insertion_point(includes)

namespace vmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ClientSvrMsg_2eproto();
void protobuf_AssignDesc_ClientSvrMsg_2eproto();
void protobuf_ShutdownFile_ClientSvrMsg_2eproto();

class CSHeartBeatRqst;
class CSHeartBeatRsp;
class CSCommonErrMsg;
class VCli2LogicSvrMsg;
class VLogicSvr2CliMsg;

enum CS_CMD_ID {
  CS_CMD_ERR = 1,
  CS_CMD_HEART_BEAT = 2,
  SS_CMD_HEART_BEAT = 3,
  CS_CMD_BAG_QUERY = 300,
  CS_CMD_BAG_WEAR_EQUIP = 303,
  CS_CMD_BAG_ENLARGE = 304,
  CS_CMD_BAG_TAKEOFF_EQUIP = 305,
  CS_CMD_BAG_SELL = 306,
  CS_CMD_BAG_STAT_NOTIFY = 307,
  CS_PUSH_BAG_INFO = 308,
  CS_CMD_BAG_BUY_ITEM = 309,
  CS_CMD_BAG_CONSUME_ITEM = 310,
  CS_CMD_QUERY_PLAYERINFO = 500,
  CS_CMD_REG_PLAYERINFO = 501,
  CS_CMD_PLAYER_CHANGE_ARMOR = 502,
  CS_CMD_QUERY_ROLE_LIST = 503,
  CS_CMD_PLAYER_ROLE_LOGIN = 504,
  CS_CMD_PLAYER_ROLE_LOGOUT = 505,
  CS_CMD_PLAYER_MANUAL_NOTIFY = 506,
  CS_CMD_PLAYER_MANUAL_QUERYBUY = 507,
  CS_CMD_PLAYER_MANUAL_BUY = 508,
  CS_CMD_PLAYER_QUERY_MANUAL = 509,
  CS_CMD_PLAYER_QUERY_DETAILINFO = 510,
  CS_CMD_PLAYER_QUERY_FIGHTINFO = 511,
  CS_CMD_PLAYER_EVOLUTION_SKILL = 512,
  CS_CMD_PLAYER_CHANGE_EVOLUTION_SKILL = 513,
  CS_CMD_PLAYER_QUERY_EVOLUTION_INFO = 514,
  CS_CMD_PLAYER_QUERY_EVOLUTIONSKILL_INFO = 515,
  CS_CMD_PLAYER_QUERY_ATTRSTRENGTHEN_INFO = 516,
  CS_CMD_PLAYER_ATTRSTRENGTHEN = 517,
  CS_CMD_PLAYER_LOT_QUERY = 518,
  CS_CMD_PLAYER_LOT = 519,
  CS_CMD_PLAYER_QUERY_AWARDRANK = 520,
  CS_CMD_PLAYER_FETCH_RANKAWARD = 521,
  CS_CMD_PLAYER_TALKWITHNPC = 522,
  CS_CMD_PLAYER_COIN_NOTIFY = 523,
  CS_CMD_PLAYER_LV_UP = 524,
  CS_CMD_PLAYER_VIP_NOTIFY = 525,
  CS_CMD_PLAYER_VIP_AWARD = 526,
  CS_CMD_PLAYER_QUERYVIPINFOS = 527,
  CS_CMD_PLAYER_FIGHTPOWERNOTIFY = 528,
  CS_CMD_PLAYER_QUERYOTHERPLAYER = 529,
  CS_CMD_PLAYER_SETSETTING = 530,
  CS_CMD_PLAYER_QUERY_BLACKMARKET = 531,
  CS_CMD_PLAYER_BUY_BLACKMARKET = 532,
  CS_CMD_PLAYER_RESET_BLACKMARKET = 533,
  CS_CMD_PLAYER_QUICKLOGIN = 534,
  CS_CMD_PLAYER_BUYCOIN = 535,
  CS_CMD_PLAYER_QUERYBUYCOIN = 536,
  CS_CMD_PLAYER_DAILYREG = 537,
  CS_CMD_PLAYER_GETMONTHCARDAWARD = 538,
  CS_CMD_PLAYER_GETMANUALACTAWARD = 539,
  CS_CMD_PLAYER_PUSHMONTHCARD = 540,
  CS_CMD_PLAYER_CLAIM_STORED_MANUAL = 541,
  CS_CMD_PLAYER_BIND_GUEST_ACCOUNT = 542,
  CS_CMD_PLAYER_REG_GUEST_ACCOUNT = 543,
  CS_CMD_PLAYER_VIP_DAILY_AWARD = 544,
  CS_CMD_PLAYER_ENHANCE_MYSELF = 545,
  CS_CMD_PLAYER_CONFIRM_ENFORCE_MYSELF = 546,
  CS_CMD_PLAYER_ENFORCE_MYSELF_QUERY = 547,
  CS_CMD_OSD_GET_PLAYERS_IN_SCENE = 601,
  CS_CMD_OSD_SYNC_PLAYER_IN_SCENE = 602,
  CS_CMD_OSD_MOVE_IN_SCENE = 603,
  CS_CMD_OSD_LEAVE_SCENE = 604,
  CS_CMD_OSD_SETPOS_SCENE = 605,
  CS_CMD_OSD_CHANGE_SCENE = 606,
  CS_CMD_OSD_START_ATK = 607,
  CS_CMD_OSD_STOP_ATK = 608,
  CS_CMD_OSD_SKILL = 609,
  CS_CMD_TASK_RECEIVE = 701,
  CS_CMD_TASK_COMMIT = 702,
  CS_CMD_TASK_QUERY = 703,
  CS_CMD_TASK_NEWSTAT = 704,
  CS_CMD_DAILYTASK_COMMIT = 705,
  CS_CMD_DAILYTASK_QUERY = 706,
  CS_CMD_DAILYTASK_NEWSTAT = 707,
  CS_CMD_DAILYTASK_REFLASH = 708,
  CS_CMD_MILESTONE_COMMIT = 709,
  CS_CMD_MILESTONE_QUERY = 710,
  CS_CMD_MILESTONE_NEWSTAT = 711,
  CS_CMD_DAILYTASK_TRIGGER = 712,
  CS_CMD_RANK_QUERY = 800,
  CS_CMD_RANK_QUERY_MYRANK = 801,
  CS_CMD_RANK_QUERY_ARENAARMYRANK = 802,
  CS_CMD_EQUIPMENT_REFINE = 900,
  CS_CMD_EQUIPMENT_TRANS_REFINE = 901,
  CS_CMD_EQUIPMENT_LVUP = 902,
  CS_CMD_EQUIPMENT_STARSTEP = 903,
  CS_CMD_EQUIPMENT_REFIT = 904,
  CS_CMD_WEAPON_BAG_QUERY = 1001,
  CS_CMD_WEAPON_CHANGE = 1002,
  CS_CMD_WEAPON_TAKEOFF = 1003,
  CS_CMD_WEAPON_LVUP = 1004,
  CS_CMD_WEAPON_STARSTEP = 1005,
  CS_CMD_WEAPON_REFIT = 1006,
  CS_CMD_QUERY_INBATTLE_WEAPONS = 1007,
  CS_CMD_CHANGE_INBATTLE_WEAPONS = 1008,
  CS_CMD_GOLD_QUERY = 1100,
  CS_CMD_GOLD_NOTIFY = 1101,
  CS_CMD_GOLD_BUY = 1102,
  CS_CMD_GOLD_RMBSTORE_BUY = 1103,
  CS_CMD_GOLD_RMBSTORE_QUERY = 1104,
  CS_CMD_APP_AUTHED_BUY = 1105,
  CS_CMD_APP_AUTHED_BUY_SUCCEED_REPORT = 1106,
  CS_CMD_GOLD_QUERY_SINGLE_PRODUCT = 1107,
  CS_CMD_OPEN_PACKAGE = 1201,
  CS_CMD_WARMAP_QUERY = 1301,
  CS_CMD_WARMAP_START = 1302,
  CS_CMD_WARMAP_END = 1303,
  CS_CMD_WARMAP_CARD = 1304,
  CS_CMD_WARMAP_SWEEP = 1305,
  CS_CMD_ELITEWARMAP_START = 1306,
  CS_CMD_ELITEWARMAP_END = 1307,
  CS_CMD_ELITEWARMAP_RESET = 1308,
  CS_CMD_ELITEWARMAP_QUERY = 1309,
  CS_CMD_ELITEWARMAP_SWEEP = 1310,
  CS_CMD_DAILY_INSTANCE_QUERY = 1311,
  CS_CMD_DAILY_INSTANCE_PASS = 1312,
  CS_CMD_BUY_INSTANCE = 1313,
  CS_CMD_CLAIM_STAR_AWARD = 1314,
  CS_CMD_FRIEND_ADD_FRIEND = 1400,
  CS_CMD_FRIEND_DEL_FRIEND = 1401,
  CS_CMD_FRIEND_ADD_BLACK = 1402,
  CS_CMD_FRIEND_QUERY = 1403,
  CS_CMD_FRIEND_BATCH_ADD = 1404,
  CS_CMD_FRIEND_GET_PROPOSE = 1405,
  CS_CMD_FRIEND_ADMIN_ADD = 1406,
  CS_CMD_FRIEND_ADMIN_REFUSE = 1407,
  CS_CMD_FRIEND_ADMIN_CLEAR = 1408,
  CS_CMD_FRIEND_SEND_MANUAL = 1409,
  CS_CMD_FRIEND_RECV_MANUAL = 1410,
  CS_CMD_FRIEND_INVITE_FIGHT = 1411,
  CS_CMD_FRIEND_REQ_NOTIFY = 1412,
  CS_CMD_FRIEND_BAT_RECV_MANUAL = 1413,
  CS_CMD_GUILD_CREATE = 1500,
  CS_CMD_GUILD_QUERY_GUILD = 1501,
  CS_CMD_GUILD_REPLY_JOIN = 1502,
  CS_CMD_GUILD_JOIN = 1503,
  CS_CMD_GUILD_QUERY_MYREQ = 1504,
  CS_CMD_GUILD_LEAVE = 1505,
  CS_CMD_GUILD_KICK = 1506,
  CS_CMD_GUILD_DISMISS = 1507,
  CS_CMD_GUILD_CHG_PRIVI = 1508,
  CS_CMD_GUILD_SEARCH = 1509,
  CS_CMD_GUILD_CHANGE_NOTICE = 1510,
  CS_CMD_GUILD_QUERY_GUILDLST = 1511,
  CS_CMD_GUILD_ALL_GUILD_REQ = 1512,
  CS_CMD_GUILD_DELETE_MYGUILDREQ = 1513,
  CS_CMD_GUILD_ASSIGN_CHAIRMAN = 1514,
  CS_CMD_GUILD_IMPEACH = 1515,
  CS_CMD_GUILD_DAILY_ACT_QUERY = 1516,
  CS_CMD_GUILD_INVITE_MEMBER = 1517,
  CS_CMD_GUILD_DAILY_ACT_START = 1518,
  CS_CMD_GUILD_BUN_END = 1520,
  CS_CMD_GUILD_THIEF_END = 1521,
  CS_CMD_GUILD_BLOCK_END = 1522,
  CS_CMD_GUILD_STAT_NOTIFY = 1523,
  CS_CMD_MAIL_QUERY = 1600,
  CS_CMD_MAIL_READ = 1601,
  CS_CMD_MAIL_DELETE = 1602,
  CS_CMD_MAIL_GET_ATTACH = 1603,
  CS_CMD_MAIL_PUSH_NOTIFY = 1604,
  CS_CMD_MAIL_NEW = 1605,
  CS_CMD_MAIL_DELALL = 1606,
  CS_CMD_INFINIT_END = 1700,
  CS_CMD_INFINIT_START = 1701,
  CS_CMD_INFINIT_BUYGEN = 1702,
  CS_CMD_INFINIT_GENINFO = 1703,
  CS_CMD_NOTHINGLAND_START = 1704,
  CS_CMD_NOTHINGLAND_END = 1705,
  CS_CMD_NOTHINGLAND_MISSION_REPORT = 1706,
  CS_CMD_NOTHINGLAND_UNFINISHED_QUERY = 1707,
  CS_CMD_CHAT_SENDMSG = 1801,
  CS_CMD_CVZ_HITMONSTER = 1900,
  CS_CMD_CVZ_HITED = 1901,
  CS_CMD_CVZ_DESTROYBASE = 1902,
  CS_CMD_CVZ_CONTROL = 1903,
  CS_CMD_CVZ_RMCONTROL = 1904,
  CS_CMD_CVZ_NOTIFYBASE = 1905,
  CS_CMD_CVZ_NOTIFYFAIL = 1906,
  CS_CMD_CVZ_NOTIFYHITMONSTER = 1907,
  CS_CMD_CVZ_NOTIFYHITED = 1908,
  CS_CMD_CVZ_ROOMOK = 1909,
  CS_CMD_CVZ_SUBMITMONSTERS = 1910,
  CS_CMD_CVZ_NOTIFYMONSTERS = 1911,
  CS_CMD_CVZ_NOTIFYRANKINFO = 1912,
  CS_CMD_CVZ_NOTIFYWAVETIME = 1913,
  CS_CMD_CVZ_NOTIFYOVER = 1914,
  CS_CMD_CVZ_NOTIFYMYCONTAWARD = 1915,
  CS_CMD_CVZ_NOTIFYTOTALCONT = 1916,
  CS_CMD_CVZ_RELIVE = 1917,
  CS_CMD_SERVER_NOTIFY = 2000,
  CS_CMD_DAILYGIFT_QUERY = 2100,
  CS_CMD_DAILYGIFT_AWARD = 2101,
  CS_CMD_ARENA_QUERY = 2200,
  CS_CMD_ARENA_QUERY_RECORD = 2201,
  CS_CMD_ARENA_FIND_OPPONENT = 2202,
  CS_CMD_ARENA_GET_AWARD = 2203,
  CS_CMD_ARENA_BUY_FIGHT_NUM = 2204,
  CS_CMD_ARENA_START_FIGHT = 2205,
  CS_CMD_ARENA_END_FIGHT = 2206,
  CS_CMD_ARENA_STORE_QUERY = 2207,
  CS_CMD_ARENA_STORE_BUY = 2208,
  CS_CMD_ARENA_STORE_REFRESH = 2209,
  CS_CMD_ARENA_OPPONENT_INFO = 2210,
  CS_CMD_ARENA_CLEANCD = 2211,
  CS_CMD_STORE_BUY = 2300,
  CS_CMD_PANIC_BUYING = 2301,
  CS_CMD_PANIC_BUYING_QUERY = 2302,
  CS_CMD_BUY_BULLET = 2303,
  CS_CMD_RELIVE_HERO = 2304,
  CS_CMD_QIANGHUN_QUERY = 2400,
  CS_CMD_QIANGHUN_QUERY_LAYER = 2401,
  CS_CMD_QIANGHUN_FLOP = 2402,
  CS_CMD_DEBRIS_QUERYBAG = 2500,
  CS_CMD_DEBRIS_COMPOSE = 2501,
  CS_CMD_ACT_QUERY = 2600,
  CS_CMD_ACT_STAT_NOTIFY = 2601,
  CS_CMD_DOTAITEM_QUERY = 2700,
  CS_CMD_DOTAITEM_COMPOSE = 2701,
  CS_CMD_DOTAITEM_MOSAIC = 2702,
  CS_CMD_DOTAITEM_LVUP = 2703,
  CS_CMD_COUPON = 2800,
  CS_CMD_CLAIM_FIRST_CHARGE = 2801,
  CS_CMD_QUERY_ALL_PKG_STATUS = 2802,
  CS_CMD_CLAIM_SPRING_PKG = 2803,
  CS_CMD_SUM_CHARGE_PKG = 2804,
  CS_CMD_DAILY_LOGIN_PKG = 2805,
  CS_CMD_DAILY_CHARGE_PKG = 2806,
  CS_CMD_GRADE_GEEK_PKG = 2807,
  CS_CMD_FIGHT_GEEK_PKG = 2808,
  CS_CMD_VIP_GIFT_PKG = 2809,
  CS_CMD_DAILY_CONSUME_PKG = 2810,
  CS_CMD_SUM_CONSUME_PKG = 2811,
  CS_CMD_ONLINE_PKG = 2812,
  CS_CMD_NEXTDAY_PKG = 2813,
  CS_CMD_REPORT_UMEM_DEVICE_TOKEN = 2900,
  CS_CMD_BOSS_CHALLENGE_QUERY = 3000,
  CS_CMD_BOSS_CHALLENGE_DAMAGE_REPORT = 3001,
  CS_CMD_BOSS_CHALLENGE_DAMAGE_NOTIFY = 3002,
  CS_CMD_BOSS_CHALLANGE_STATE_NOTIFY = 3003,
  CS_CMD_BOSS_CHALLENGE_DELEGATE = 3004,
  CS_CMD_BOSS_CHALLENGE_ATTEND_OR_LEAVE = 3005,
  CS_CMD_BOSS_CHALLENGE_RELIVE = 3006,
  CS_CMD_ADMIN_MIN = 1000000,
  CS_CMD_ADMIN_ADD_GOLD = 1000001,
  CS_CMD_ADMIN_ADD_ITEM = 1000002,
  CS_CMD_ADMIN_ADD_EQUIP = 1000003,
  CS_CMD_ADMIN_ADD_EXP = 1000004,
  CS_CMD_ADMIN_ADD_COIN = 1000005,
  CS_CMD_ADMIN_ADD_WEAPON = 1000006,
  CS_CMD_ADMIN_MAIL_SEND = 1000007,
  CS_CMD_ADMIN_MAIL_SEND_GRP = 1000008,
  CS_CMD_ADMIN_ADD_ARENA_MONEY = 1000009,
  CS_CMD_ADMIN_PASSWARMAP = 1000010,
  CS_CMD_ADMIN_RECEIVETASK = 1000011,
  CS_CMD_ADMIN_NOTIFY = 1000012,
  CS_CMD_ADMIN_DISABLE_PLAYER = 1000013,
  CS_CMD_ADMIN_SET_PVP_SCORE = 1000014,
  CS_CMD_ADMIN_MAX = 2000000,
  CS_CMD_REG_ACCOUNT = 2000001,
  CS_CMD_AUTH_ACCOUNT = 2000002,
  CS_CMD_CHANGE_PASSWORD = 2000003,
  CMD_SVR_INTERNAL = 10000000,
  CMD_SVR_INTERNAL_GET_TOP_LVLS = 10000001
};
bool CS_CMD_ID_IsValid(int value);
const CS_CMD_ID CS_CMD_ID_MIN = CS_CMD_ERR;
const CS_CMD_ID CS_CMD_ID_MAX = CMD_SVR_INTERNAL_GET_TOP_LVLS;
const int CS_CMD_ID_ARRAYSIZE = CS_CMD_ID_MAX + 1;

enum THING_TYPE {
  THING_TYPE_EXP = 1,
  THING_TYPE_ITEM = 2,
  THING_TYPE_EQUIP = 3,
  THING_TYPE_COIN = 4,
  THING_TYPE_GOLD = 5,
  THING_TYPE_WEAPON = 6,
  THING_TYPE_ARENA_MONEY = 7,
  THING_TYPE_MANUAL = 8,
  THING_TYPE_DEBRIS = 9,
  THING_TYPE_MONTHCARD = 10,
  THING_TYPE_GEN = 11,
  THING_TYPE_DOTAITEM = 12
};
bool THING_TYPE_IsValid(int value);
const THING_TYPE THING_TYPE_MIN = THING_TYPE_EXP;
const THING_TYPE THING_TYPE_MAX = THING_TYPE_DOTAITEM;
const int THING_TYPE_ARRAYSIZE = THING_TYPE_MAX + 1;

enum ITEM_DETAIL_TYPE {
  ITEM_DETAIL_TYPE_WEAPONLVUP = 1,
  ITEM_DETAIL_TYPE_WEAPONSTEPSTAR = 2,
  ITEM_DETAIL_TYPE_ATTRSTRENGTHEN = 3,
  ITEM_DETAIL_TYPE_EVOLUTION = 4
};
bool ITEM_DETAIL_TYPE_IsValid(int value);
const ITEM_DETAIL_TYPE ITEM_DETAIL_TYPE_MIN = ITEM_DETAIL_TYPE_WEAPONLVUP;
const ITEM_DETAIL_TYPE ITEM_DETAIL_TYPE_MAX = ITEM_DETAIL_TYPE_EVOLUTION;
const int ITEM_DETAIL_TYPE_ARRAYSIZE = ITEM_DETAIL_TYPE_MAX + 1;

enum TASK_STAT {
  TASK_STAT_ORG = 1,
  TASK_STAT_RECEIVED = 2,
  TASK_STAT_FINISH = 3,
  TASK_STAT_OVER = 4,
  TASK_STAT_FAIL = 5
};
bool TASK_STAT_IsValid(int value);
const TASK_STAT TASK_STAT_MIN = TASK_STAT_ORG;
const TASK_STAT TASK_STAT_MAX = TASK_STAT_FAIL;
const int TASK_STAT_ARRAYSIZE = TASK_STAT_MAX + 1;

enum TASK_TARGET_TYPE {
  TASK_TARGET_KILL_MONSTER = 1,
  TASK_TARGET_CLEAR_WAR = 2,
  TASK_TARGET_TALK_NPC = 3,
  TASK_TARGET_WEAPONLOTTERY = 4
};
bool TASK_TARGET_TYPE_IsValid(int value);
const TASK_TARGET_TYPE TASK_TARGET_TYPE_MIN = TASK_TARGET_KILL_MONSTER;
const TASK_TARGET_TYPE TASK_TARGET_TYPE_MAX = TASK_TARGET_WEAPONLOTTERY;
const int TASK_TARGET_TYPE_ARRAYSIZE = TASK_TARGET_TYPE_MAX + 1;

enum ATTR_TYPE {
  ATTR_RUNSPEED = 1,
  ATTR_HP = 2,
  ATTR_DEF = 3,
  ATTR_MOVESPEED = 4,
  ATTR_MP = 5,
  ATTR_ATK = 6,
  ATTR_HIT = 7,
  ATTR_LIMITED = 8,
  ATTR_MAX = 255
};
bool ATTR_TYPE_IsValid(int value);
const ATTR_TYPE ATTR_TYPE_MIN = ATTR_RUNSPEED;
const ATTR_TYPE ATTR_TYPE_MAX = ATTR_MAX;
const int ATTR_TYPE_ARRAYSIZE = ATTR_TYPE_MAX + 1;

enum DEF_ATK {
  MAGIC_DEF = 1,
  MAGIC_ATK = 2
};
bool DEF_ATK_IsValid(int value);
const DEF_ATK DEF_ATK_MIN = MAGIC_DEF;
const DEF_ATK DEF_ATK_MAX = MAGIC_ATK;
const int DEF_ATK_ARRAYSIZE = DEF_ATK_MAX + 1;

enum EQUIP_POS {
  EQUIP_POS_RING = 1,
  EQUIP_POS_ARMOR = 2,
  EQUIP_POS_CLOTH = 3,
  EQUIP_POS_SHOE = 4
};
bool EQUIP_POS_IsValid(int value);
const EQUIP_POS EQUIP_POS_MIN = EQUIP_POS_RING;
const EQUIP_POS EQUIP_POS_MAX = EQUIP_POS_SHOE;
const int EQUIP_POS_ARRAYSIZE = EQUIP_POS_MAX + 1;

enum EQUIP_GRADE {
  EQUIP_GRADE_WHITE = 1,
  EQUIP_GRADE_GREEN = 2,
  EQUIP_GRADE_BLUE = 3,
  EQUIP_GRADE_PURPLE = 4,
  EQUIP_GRADE_ORANGE = 5
};
bool EQUIP_GRADE_IsValid(int value);
const EQUIP_GRADE EQUIP_GRADE_MIN = EQUIP_GRADE_WHITE;
const EQUIP_GRADE EQUIP_GRADE_MAX = EQUIP_GRADE_ORANGE;
const int EQUIP_GRADE_ARRAYSIZE = EQUIP_GRADE_MAX + 1;

enum WEAPON_COLOR {
  WEAPON_COLOR_WHITE = 1,
  WEAPON_COLOR_GREEN = 2,
  WEAPON_COLOR_BLUE = 3,
  WEAPON_COLOR_PURPLE = 4,
  WEAPON_COLOR_GOLD = 5
};
bool WEAPON_COLOR_IsValid(int value);
const WEAPON_COLOR WEAPON_COLOR_MIN = WEAPON_COLOR_WHITE;
const WEAPON_COLOR WEAPON_COLOR_MAX = WEAPON_COLOR_GOLD;
const int WEAPON_COLOR_ARRAYSIZE = WEAPON_COLOR_MAX + 1;

enum WEAPON_STATE {
  WEAPON_IDLE = 0,
  WEAPON_IN_BATTLE = 1,
  WEAPON_IN_RENT = 2,
  WEAPON_SEEK_RENT = 3,
  WEAPON_MAJOR_IN_USE = 4
};
bool WEAPON_STATE_IsValid(int value);
const WEAPON_STATE WEAPON_STATE_MIN = WEAPON_IDLE;
const WEAPON_STATE WEAPON_STATE_MAX = WEAPON_MAJOR_IN_USE;
const int WEAPON_STATE_ARRAYSIZE = WEAPON_STATE_MAX + 1;

enum WEAPON_ARRAY_CELL_STATE {
  WEAPON_ARRAY_CELL_LOCKED = 0,
  WEAPON_ARRAY_CELL_UNLOCKED = 1
};
bool WEAPON_ARRAY_CELL_STATE_IsValid(int value);
const WEAPON_ARRAY_CELL_STATE WEAPON_ARRAY_CELL_STATE_MIN = WEAPON_ARRAY_CELL_LOCKED;
const WEAPON_ARRAY_CELL_STATE WEAPON_ARRAY_CELL_STATE_MAX = WEAPON_ARRAY_CELL_UNLOCKED;
const int WEAPON_ARRAY_CELL_STATE_ARRAYSIZE = WEAPON_ARRAY_CELL_STATE_MAX + 1;

enum DAILY_SYS_TYPE {
  DAILY_SYS_WARMAP = 1,
  DAILY_SYS_INFINIT = 2,
  DAILY_SYS_EQUIP = 3,
  DAILY_SYS_WEAPON = 4,
  DAILY_SYS_FRIEND = 5,
  DAILY_SYS_GOLD = 6,
  DAILY_SYS_GUILD = 7,
  DAILY_SYS_ATKDEF = 8,
  DAILY_SYS_EXPLORE = 9,
  DAILY_SYS_ARENA = 10,
  DAILY_SYS_ELITE = 11,
  DAILY_SYS_SHARE = 12
};
bool DAILY_SYS_TYPE_IsValid(int value);
const DAILY_SYS_TYPE DAILY_SYS_TYPE_MIN = DAILY_SYS_WARMAP;
const DAILY_SYS_TYPE DAILY_SYS_TYPE_MAX = DAILY_SYS_SHARE;
const int DAILY_SYS_TYPE_ARRAYSIZE = DAILY_SYS_TYPE_MAX + 1;

enum DAILY_TARGET_TYPE {
  DAILY_TYPE_CLEANWAR_CNT = 1,
  DAILY_TYPE_KILLMONSTER_CNT = 2,
  DAILY_TYPE_NOTHINGLAND_SCORE = 3,
  DAILY_TYPE_NOTHINGLAND_CNT = 4,
  DAILY_TYPE_INFINIT_BUYITEM_CNT = 5,
  DAILY_TYPE_NOTHINGLAND_BOSS_CNT = 6,
  DAILY_TYPE_EQUIP_LVUP_CNT = 7,
  DAILY_TYPE_WEAPON_EATEXP_EXP = 8,
  DAILY_TYPE_WEAPON_EATEXP_CNT = 9,
  DAILY_TYPE_BUY_MANUAL = 10,
  DAILY_TYPE_SENDMANUAL_CNT = 11,
  DAILY_TYPE_RECVMANUAL_CNT = 12,
  DAILY_TYPE_GOLDCARD_CNT = 13,
  DAILY_TYPE_ATKDEF_CNT = 14,
  DAILY_TYPE_ARENA_CNT = 15,
  DAILY_TYPE_ELITE_CNT = 16,
  DAILY_TYPE_SHARE_CNT = 17
};
bool DAILY_TARGET_TYPE_IsValid(int value);
const DAILY_TARGET_TYPE DAILY_TARGET_TYPE_MIN = DAILY_TYPE_CLEANWAR_CNT;
const DAILY_TARGET_TYPE DAILY_TARGET_TYPE_MAX = DAILY_TYPE_SHARE_CNT;
const int DAILY_TARGET_TYPE_ARRAYSIZE = DAILY_TARGET_TYPE_MAX + 1;

enum MILESTONE_TARGET_TYPE {
  MILESTONE_TYPE_CLEANWAR_CNT = 1,
  MILESTONE_TYPE_KILLMONSTER_CNT = 2,
  MILESTONE_TYPE_CHAPTER = 3,
  MILESTONE_TYPE_NOTHINGLAND_SCORE = 4,
  MILESTONE_TYPE_NOTHINGLAND_CNT = 5,
  MILESTONE_TYPE_INFINIT_BUYITEM_CNT = 6,
  MILESTONE_TYPE_NOTHINGLAND_BOSS_CNT = 7,
  MILESTONE_TYPE_EQUIP_LVUP = 8,
  MILESTONE_TYPE_WEAPON_EATEXP_EXP = 9,
  MILESTONE_TYPE_WEAPON_EATEXP_CNT = 10,
  MILESTONE_TYPE_SENDMANUAL_CNT = 11,
  MILESTONE_TYPE_RECVMANUAL_CNT = 12,
  MILESTONE_TYPE_BUY_MANUAL = 13,
  MILESTONE_TYPE_GOLDCARD_CNT = 14,
  MILESTONE_TYPE_ATKDEF_CNT = 15,
  MILESTONE_TYPE_GUILDLV = 16,
  MILESTONE_TYPE_LV = 17,
  MILESTONE_TYPE_FRIENDCNT = 18,
  MILESTONE_TYPE_COIN = 19,
  MILESTONE_TYPE_GOLD = 20,
  MILESTONE_TYPE_EQUIPLV = 21,
  MILESTONE_TYPE_WEAPONESTARSTEP = 22,
  MILESTONE_TYPE_ARENALV = 23
};
bool MILESTONE_TARGET_TYPE_IsValid(int value);
const MILESTONE_TARGET_TYPE MILESTONE_TARGET_TYPE_MIN = MILESTONE_TYPE_CLEANWAR_CNT;
const MILESTONE_TARGET_TYPE MILESTONE_TARGET_TYPE_MAX = MILESTONE_TYPE_ARENALV;
const int MILESTONE_TARGET_TYPE_ARRAYSIZE = MILESTONE_TARGET_TYPE_MAX + 1;

enum RANK_TYPE {
  RANK_TYPE_FIGHTPOWER = 1,
  RANK_TYPE_NOTHINGLANDSCORE = 2,
  RANK_TYPE_WARMAP = 3,
  RANK_TYPE_PAY = 4,
  RANK_TYPE_AWARD_MAX = 5,
  RANK_TYPE_GUILD = 100,
  RANK_TYPE_CVZ = 101,
  RANK_TYPE_ARENA = 102
};
bool RANK_TYPE_IsValid(int value);
const RANK_TYPE RANK_TYPE_MIN = RANK_TYPE_FIGHTPOWER;
const RANK_TYPE RANK_TYPE_MAX = RANK_TYPE_ARENA;
const int RANK_TYPE_ARRAYSIZE = RANK_TYPE_MAX + 1;

enum GEN_STRENGTHEN_TYPE {
  GEN_STRENGTHEN_RANDOM = 0,
  GEN_STRENGTHEN_ATK = 1,
  GEN_STRENGTHEN_DEFNLIFE = 2,
  GEN_STRENGTHEN_SCORE = 3,
  GEN_STRENGTHEN_COIN = 4,
  GEN_STRENGTHEN_WEAPON = 5,
  GEN_STRENGTHEN_RUSH = 6,
  GEN_STRENGTHEN_MAX = 7
};
bool GEN_STRENGTHEN_TYPE_IsValid(int value);
const GEN_STRENGTHEN_TYPE GEN_STRENGTHEN_TYPE_MIN = GEN_STRENGTHEN_RANDOM;
const GEN_STRENGTHEN_TYPE GEN_STRENGTHEN_TYPE_MAX = GEN_STRENGTHEN_MAX;
const int GEN_STRENGTHEN_TYPE_ARRAYSIZE = GEN_STRENGTHEN_TYPE_MAX + 1;

enum CVZ_STAT {
  CVZ_STAT_PREPARE = 1,
  CVZ_STAT_START = 2,
  CVZ_STAT_AWARD = 3,
  CVZ_STAT_OVER = 4
};
bool CVZ_STAT_IsValid(int value);
const CVZ_STAT CVZ_STAT_MIN = CVZ_STAT_PREPARE;
const CVZ_STAT CVZ_STAT_MAX = CVZ_STAT_OVER;
const int CVZ_STAT_ARRAYSIZE = CVZ_STAT_MAX + 1;

enum SCENE_TYPE {
  SCENE_LOGIN = 1,
  SCENE_OSD = 2,
  SCENE_BATTLE = 3,
  SCENE_CVZ = 4,
  SCENE_ENDLESS = 5,
  SCENE_THIEF_DEF = 6,
  SCENE_BALK_CLEAN = 7,
  SCENE_ARENA = 8,
  SCENE_UPDATE_RES = 9,
  SCENE_ENTRY = 10,
  SCENE_NOTHINGWAR = 11,
  SCENE_COINWAR = 12,
  SCENE_WORLD_BOSS = 13,
  SCENE_GUILD_BOSS = 14
};
bool SCENE_TYPE_IsValid(int value);
const SCENE_TYPE SCENE_TYPE_MIN = SCENE_LOGIN;
const SCENE_TYPE SCENE_TYPE_MAX = SCENE_GUILD_BOSS;
const int SCENE_TYPE_ARRAYSIZE = SCENE_TYPE_MAX + 1;

enum VIP_MODULE_ID {
  VIP_MODULE_FRIEND = 1,
  VIP_MODULE_BUYMANUAL = 2,
  VIP_MODULE_BUYCOIN = 3,
  VIP_MODULE_ELITEGOLDRESET = 4,
  VIP_MODULE_ARENAFIGHTCNT = 5,
  VIP_MODULE_BLACKSTORERESET = 6,
  VIP_MODULE_ARENASTORERESET = 7,
  VIP_MODULE_DAILY_INSTANCE = 8,
  VIP_MODULE_WEAPON_LOTTERY = 9,
  VIP_MODULE_BUY_INSTANCE = 10,
  VIP_MODULE_SWEEP_CARD = 11,
  VIP_MODULE_ADVANCED_PLAYER_ENFORCE = 12,
  VIP_MODULE_MASTER_PLAYER_ENFORCE = 13,
  VIP_MODULE_SUPER_PLAYER_ENFORCE = 14
};
bool VIP_MODULE_ID_IsValid(int value);
const VIP_MODULE_ID VIP_MODULE_ID_MIN = VIP_MODULE_FRIEND;
const VIP_MODULE_ID VIP_MODULE_ID_MAX = VIP_MODULE_SUPER_PLAYER_ENFORCE;
const int VIP_MODULE_ID_ARRAYSIZE = VIP_MODULE_ID_MAX + 1;

enum ACT_STAT {
  ACT_STAT_START = 1,
  ACT_STAT_PREPARE = 2,
  ACT_STAT_AWARD = 3,
  ACT_STAT_OVER = 4,
  ACT_STAT_PARTED = 5
};
bool ACT_STAT_IsValid(int value);
const ACT_STAT ACT_STAT_MIN = ACT_STAT_START;
const ACT_STAT ACT_STAT_MAX = ACT_STAT_PARTED;
const int ACT_STAT_ARRAYSIZE = ACT_STAT_MAX + 1;

enum ACT_ID {
  ACT_ID_CVZ = 1,
  ACT_ID_MANUAL = 2,
  ACT_ID_WORLD_BOSS = 3
};
bool ACT_ID_IsValid(int value);
const ACT_ID ACT_ID_MIN = ACT_ID_CVZ;
const ACT_ID ACT_ID_MAX = ACT_ID_WORLD_BOSS;
const int ACT_ID_ARRAYSIZE = ACT_ID_MAX + 1;

enum ACT_LIST_TYPE {
  PLATFORM_PKG_ACT = 0,
  NEWBIE_PKG_ACT = 1,
  FIRST_BUY_PKG_ACT = 2,
  NEW_YEAR_ONESHOT_ACT = 3,
  NEW_YEAR_7DAY_ACT = 4,
  STORE_MANUAL_ACT = 5,
  SUM_CHARGE_ACT = 6,
  DAILY_LOGIN_ACT = 7,
  DAILY_CHARGE_ACT = 8,
  GRADE_GEEK_ACT = 9,
  FIGHT_GEEK_ACT = 10,
  SHARE_GIFT_ACT = 11,
  VIP_GIFT_ACT = 12,
  DAILY_CONSUME_ACT = 13,
  SUM_CONSUME_ACT = 14,
  ONLINE_PKG_AWARD = 15,
  NEXTDAY_PKG_AWARD = 16,
  FIRST_CHARGEDOUBLE_ACT = 100
};
bool ACT_LIST_TYPE_IsValid(int value);
const ACT_LIST_TYPE ACT_LIST_TYPE_MIN = PLATFORM_PKG_ACT;
const ACT_LIST_TYPE ACT_LIST_TYPE_MAX = FIRST_CHARGEDOUBLE_ACT;
const int ACT_LIST_TYPE_ARRAYSIZE = ACT_LIST_TYPE_MAX + 1;

enum ACT_STATUS {
  ACT_NOT_PARTED = 0,
  ACT_PARTED = 1
};
bool ACT_STATUS_IsValid(int value);
const ACT_STATUS ACT_STATUS_MIN = ACT_NOT_PARTED;
const ACT_STATUS ACT_STATUS_MAX = ACT_PARTED;
const int ACT_STATUS_ARRAYSIZE = ACT_STATUS_MAX + 1;

enum ONE_SHOT_GIFT_MASK {
  PLATFORM_PKG = 0,
  NEWBIE_PKG = 1,
  FIRST_BUY_PKG = 2,
  LENOVO_HIGHER_PKG = 3,
  LENOVO_WECHAT_PKG = 4,
  XIAOMI_BAIJIN_PKG = 5,
  XIAOMI_ZUANSHI_PKG = 6,
  SPRING_ON_SHOT_PKG = 7,
  SPRING_DAY_1_PKG = 8,
  SPRING_DAY_2_PKG = 9,
  SPRING_DAY_3_PKG = 10,
  SPRING_DAY_4_PKG = 11,
  SPRING_DAY_5_PKG = 12,
  SPRING_DAY_6_PKG = 13,
  SPRING_DAY_7_PKG = 14,
  SPRING_DAY_8_PKG = 15,
  SPRING_DAY_9_PKG = 16,
  SPRING_DAY_10_PKG = 17,
  SPRING_DAY_11_PKG = 18,
  SPRING_DAY_12_PKG = 19,
  PKG_MAX_BIT = 20
};
bool ONE_SHOT_GIFT_MASK_IsValid(int value);
const ONE_SHOT_GIFT_MASK ONE_SHOT_GIFT_MASK_MIN = PLATFORM_PKG;
const ONE_SHOT_GIFT_MASK ONE_SHOT_GIFT_MASK_MAX = PKG_MAX_BIT;
const int ONE_SHOT_GIFT_MASK_ARRAYSIZE = ONE_SHOT_GIFT_MASK_MAX + 1;

enum BOSS_CHALLENGE_STAT {
  BOSS_CHALLENGE_PREPARE = 1,
  BOSS_CHALLENGE_GOING = 2,
  BOSS_CHALLENGE_OVER = 3,
  BOSS_CHALLENGE_AWARDED = 4,
  BOSS_CHALLENGE_INIT = 5
};
bool BOSS_CHALLENGE_STAT_IsValid(int value);
const BOSS_CHALLENGE_STAT BOSS_CHALLENGE_STAT_MIN = BOSS_CHALLENGE_PREPARE;
const BOSS_CHALLENGE_STAT BOSS_CHALLENGE_STAT_MAX = BOSS_CHALLENGE_INIT;
const int BOSS_CHALLENGE_STAT_ARRAYSIZE = BOSS_CHALLENGE_STAT_MAX + 1;

enum BOSS_CHALLENGE_TYPE {
  BOSS_CHALLENGE_WORLD = 1,
  BOSS_CHALLENGE_GUILD = 2
};
bool BOSS_CHALLENGE_TYPE_IsValid(int value);
const BOSS_CHALLENGE_TYPE BOSS_CHALLENGE_TYPE_MIN = BOSS_CHALLENGE_WORLD;
const BOSS_CHALLENGE_TYPE BOSS_CHALLENGE_TYPE_MAX = BOSS_CHALLENGE_GUILD;
const int BOSS_CHALLENGE_TYPE_ARRAYSIZE = BOSS_CHALLENGE_TYPE_MAX + 1;

enum SPEICIAL_ITEM_ID {
  ITEM_RELIVE_ID = 17004,
  ITEM_ARMO_ID = 17005,
  ITEM_SWEEP_ID = 1,
  RMB_STORE_ITEM_SWEEP_ID = 11,
  RMB_STORE_ITEM_EQUIP_EXP_PKG = 10,
  RMB_STORE_ITEM_GUN_EXP_PKG = 9,
  RMB_STORE_MONTHCARD_ID = 1
};
bool SPEICIAL_ITEM_ID_IsValid(int value);
const SPEICIAL_ITEM_ID SPEICIAL_ITEM_ID_MIN = ITEM_SWEEP_ID;
const SPEICIAL_ITEM_ID SPEICIAL_ITEM_ID_MAX = ITEM_ARMO_ID;
const int SPEICIAL_ITEM_ID_ARRAYSIZE = SPEICIAL_ITEM_ID_MAX + 1;

enum PLAYER_ENFORCE_TYPE {
  REGULAR_PLAYER_ENFORCE = 1,
  ADVANCED_PLAYER_ENFORCE = 2,
  MASTER_PLAYER_ENFORCE = 3,
  SUPER_PLAYER_ENFOCE = 4
};
bool PLAYER_ENFORCE_TYPE_IsValid(int value);
const PLAYER_ENFORCE_TYPE PLAYER_ENFORCE_TYPE_MIN = REGULAR_PLAYER_ENFORCE;
const PLAYER_ENFORCE_TYPE PLAYER_ENFORCE_TYPE_MAX = SUPER_PLAYER_ENFOCE;
const int PLAYER_ENFORCE_TYPE_ARRAYSIZE = PLAYER_ENFORCE_TYPE_MAX + 1;

// ===================================================================

class CSHeartBeatRqst : public ::google::protobuf::MessageLite {
 public:
  CSHeartBeatRqst();
  virtual ~CSHeartBeatRqst();

  CSHeartBeatRqst(const CSHeartBeatRqst& from);

  inline CSHeartBeatRqst& operator=(const CSHeartBeatRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSHeartBeatRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSHeartBeatRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSHeartBeatRqst* other);

  // implements Message ----------------------------------------------

  CSHeartBeatRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSHeartBeatRqst& from);
  void MergeFrom(const CSHeartBeatRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Reserved = 1;
  inline bool has_reserved() const;
  inline void clear_reserved();
  static const int kReservedFieldNumber = 1;
  inline ::google::protobuf::uint32 reserved() const;
  inline void set_reserved(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSHeartBeatRqst)
 private:
  inline void set_has_reserved();
  inline void clear_has_reserved();

  ::google::protobuf::uint32 reserved_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ClientSvrMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ClientSvrMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_ClientSvrMsg_2eproto();
  friend void protobuf_ShutdownFile_ClientSvrMsg_2eproto();

  void InitAsDefaultInstance();
  static CSHeartBeatRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSHeartBeatRsp : public ::google::protobuf::MessageLite {
 public:
  CSHeartBeatRsp();
  virtual ~CSHeartBeatRsp();

  CSHeartBeatRsp(const CSHeartBeatRsp& from);

  inline CSHeartBeatRsp& operator=(const CSHeartBeatRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSHeartBeatRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSHeartBeatRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSHeartBeatRsp* other);

  // implements Message ----------------------------------------------

  CSHeartBeatRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSHeartBeatRsp& from);
  void MergeFrom(const CSHeartBeatRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Svr_Time = 1;
  inline bool has_svr_time() const;
  inline void clear_svr_time();
  static const int kSvrTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 svr_time() const;
  inline void set_svr_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSHeartBeatRsp)
 private:
  inline void set_has_svr_time();
  inline void clear_has_svr_time();

  ::google::protobuf::uint32 svr_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ClientSvrMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ClientSvrMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_ClientSvrMsg_2eproto();
  friend void protobuf_ShutdownFile_ClientSvrMsg_2eproto();

  void InitAsDefaultInstance();
  static CSHeartBeatRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSCommonErrMsg : public ::google::protobuf::MessageLite {
 public:
  CSCommonErrMsg();
  virtual ~CSCommonErrMsg();

  CSCommonErrMsg(const CSCommonErrMsg& from);

  inline CSCommonErrMsg& operator=(const CSCommonErrMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSCommonErrMsg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSCommonErrMsg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSCommonErrMsg* other);

  // implements Message ----------------------------------------------

  CSCommonErrMsg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSCommonErrMsg& from);
  void MergeFrom(const CSCommonErrMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 RqstCmdID = 1;
  inline bool has_rqstcmdid() const;
  inline void clear_rqstcmdid();
  static const int kRqstCmdIDFieldNumber = 1;
  inline ::google::protobuf::uint32 rqstcmdid() const;
  inline void set_rqstcmdid(::google::protobuf::uint32 value);

  // required uint32 ErrorCode = 2;
  inline bool has_errorcode() const;
  inline void clear_errorcode();
  static const int kErrorCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 errorcode() const;
  inline void set_errorcode(::google::protobuf::uint32 value);

  // optional int32 opt1 = 3;
  inline bool has_opt1() const;
  inline void clear_opt1();
  static const int kOpt1FieldNumber = 3;
  inline ::google::protobuf::int32 opt1() const;
  inline void set_opt1(::google::protobuf::int32 value);

  // optional int32 opt2 = 4;
  inline bool has_opt2() const;
  inline void clear_opt2();
  static const int kOpt2FieldNumber = 4;
  inline ::google::protobuf::int32 opt2() const;
  inline void set_opt2(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSCommonErrMsg)
 private:
  inline void set_has_rqstcmdid();
  inline void clear_has_rqstcmdid();
  inline void set_has_errorcode();
  inline void clear_has_errorcode();
  inline void set_has_opt1();
  inline void clear_has_opt1();
  inline void set_has_opt2();
  inline void clear_has_opt2();

  ::google::protobuf::uint32 rqstcmdid_;
  ::google::protobuf::uint32 errorcode_;
  ::google::protobuf::int32 opt1_;
  ::google::protobuf::int32 opt2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ClientSvrMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ClientSvrMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_ClientSvrMsg_2eproto();
  friend void protobuf_ShutdownFile_ClientSvrMsg_2eproto();

  void InitAsDefaultInstance();
  static CSCommonErrMsg* default_instance_;
};
// -------------------------------------------------------------------

class VCli2LogicSvrMsg : public ::google::protobuf::MessageLite {
 public:
  VCli2LogicSvrMsg();
  virtual ~VCli2LogicSvrMsg();

  VCli2LogicSvrMsg(const VCli2LogicSvrMsg& from);

  inline VCli2LogicSvrMsg& operator=(const VCli2LogicSvrMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const VCli2LogicSvrMsg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VCli2LogicSvrMsg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VCli2LogicSvrMsg* other);

  // implements Message ----------------------------------------------

  VCli2LogicSvrMsg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VCli2LogicSvrMsg& from);
  void MergeFrom(const VCli2LogicSvrMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.MsgHead Msg_Head = 1;
  inline bool has_msg_head() const;
  inline void clear_msg_head();
  static const int kMsgHeadFieldNumber = 1;
  inline const ::vmsg::MsgHead& msg_head() const;
  inline ::vmsg::MsgHead* mutable_msg_head();
  inline ::vmsg::MsgHead* release_msg_head();
  inline void set_allocated_msg_head(::vmsg::MsgHead* msg_head);

  // optional .vmsg.CSBagRequest BagRqst = 3;
  inline bool has_bagrqst() const;
  inline void clear_bagrqst();
  static const int kBagRqstFieldNumber = 3;
  inline const ::vmsg::CSBagRequest& bagrqst() const;
  inline ::vmsg::CSBagRequest* mutable_bagrqst();
  inline ::vmsg::CSBagRequest* release_bagrqst();
  inline void set_allocated_bagrqst(::vmsg::CSBagRequest* bagrqst);

  // optional .vmsg.CSPlayerRequest PlayerRequest = 5;
  inline bool has_playerrequest() const;
  inline void clear_playerrequest();
  static const int kPlayerRequestFieldNumber = 5;
  inline const ::vmsg::CSPlayerRequest& playerrequest() const;
  inline ::vmsg::CSPlayerRequest* mutable_playerrequest();
  inline ::vmsg::CSPlayerRequest* release_playerrequest();
  inline void set_allocated_playerrequest(::vmsg::CSPlayerRequest* playerrequest);

  // optional .vmsg.CSSceneOSDRequest SceneOSDRequest = 6;
  inline bool has_sceneosdrequest() const;
  inline void clear_sceneosdrequest();
  static const int kSceneOSDRequestFieldNumber = 6;
  inline const ::vmsg::CSSceneOSDRequest& sceneosdrequest() const;
  inline ::vmsg::CSSceneOSDRequest* mutable_sceneosdrequest();
  inline ::vmsg::CSSceneOSDRequest* release_sceneosdrequest();
  inline void set_allocated_sceneosdrequest(::vmsg::CSSceneOSDRequest* sceneosdrequest);

  // optional .vmsg.CSEquipRequest EquipRequest = 7;
  inline bool has_equiprequest() const;
  inline void clear_equiprequest();
  static const int kEquipRequestFieldNumber = 7;
  inline const ::vmsg::CSEquipRequest& equiprequest() const;
  inline ::vmsg::CSEquipRequest* mutable_equiprequest();
  inline ::vmsg::CSEquipRequest* release_equiprequest();
  inline void set_allocated_equiprequest(::vmsg::CSEquipRequest* equiprequest);

  // optional .vmsg.CSTaskRequest TaskRequest = 8;
  inline bool has_taskrequest() const;
  inline void clear_taskrequest();
  static const int kTaskRequestFieldNumber = 8;
  inline const ::vmsg::CSTaskRequest& taskrequest() const;
  inline ::vmsg::CSTaskRequest* mutable_taskrequest();
  inline ::vmsg::CSTaskRequest* release_taskrequest();
  inline void set_allocated_taskrequest(::vmsg::CSTaskRequest* taskrequest);

  // optional .vmsg.CSRankRequest RankRequest = 9;
  inline bool has_rankrequest() const;
  inline void clear_rankrequest();
  static const int kRankRequestFieldNumber = 9;
  inline const ::vmsg::CSRankRequest& rankrequest() const;
  inline ::vmsg::CSRankRequest* mutable_rankrequest();
  inline ::vmsg::CSRankRequest* release_rankrequest();
  inline void set_allocated_rankrequest(::vmsg::CSRankRequest* rankrequest);

  // optional .vmsg.CSWeaponRequest WeaponRequest = 10;
  inline bool has_weaponrequest() const;
  inline void clear_weaponrequest();
  static const int kWeaponRequestFieldNumber = 10;
  inline const ::vmsg::CSWeaponRequest& weaponrequest() const;
  inline ::vmsg::CSWeaponRequest* mutable_weaponrequest();
  inline ::vmsg::CSWeaponRequest* release_weaponrequest();
  inline void set_allocated_weaponrequest(::vmsg::CSWeaponRequest* weaponrequest);

  // optional .vmsg.CSGoldRequest GoldRequest = 11;
  inline bool has_goldrequest() const;
  inline void clear_goldrequest();
  static const int kGoldRequestFieldNumber = 11;
  inline const ::vmsg::CSGoldRequest& goldrequest() const;
  inline ::vmsg::CSGoldRequest* mutable_goldrequest();
  inline ::vmsg::CSGoldRequest* release_goldrequest();
  inline void set_allocated_goldrequest(::vmsg::CSGoldRequest* goldrequest);

  // optional .vmsg.CSItemRequest ItemRequest = 12;
  inline bool has_itemrequest() const;
  inline void clear_itemrequest();
  static const int kItemRequestFieldNumber = 12;
  inline const ::vmsg::CSItemRequest& itemrequest() const;
  inline ::vmsg::CSItemRequest* mutable_itemrequest();
  inline ::vmsg::CSItemRequest* release_itemrequest();
  inline void set_allocated_itemrequest(::vmsg::CSItemRequest* itemrequest);

  // optional .vmsg.CSWarMapRequest WarMapRequest = 13;
  inline bool has_warmaprequest() const;
  inline void clear_warmaprequest();
  static const int kWarMapRequestFieldNumber = 13;
  inline const ::vmsg::CSWarMapRequest& warmaprequest() const;
  inline ::vmsg::CSWarMapRequest* mutable_warmaprequest();
  inline ::vmsg::CSWarMapRequest* release_warmaprequest();
  inline void set_allocated_warmaprequest(::vmsg::CSWarMapRequest* warmaprequest);

  // optional .vmsg.CSFriendRequest FriendRequest = 14;
  inline bool has_friendrequest() const;
  inline void clear_friendrequest();
  static const int kFriendRequestFieldNumber = 14;
  inline const ::vmsg::CSFriendRequest& friendrequest() const;
  inline ::vmsg::CSFriendRequest* mutable_friendrequest();
  inline ::vmsg::CSFriendRequest* release_friendrequest();
  inline void set_allocated_friendrequest(::vmsg::CSFriendRequest* friendrequest);

  // optional .vmsg.CSGuildRequest GuildRequest = 15;
  inline bool has_guildrequest() const;
  inline void clear_guildrequest();
  static const int kGuildRequestFieldNumber = 15;
  inline const ::vmsg::CSGuildRequest& guildrequest() const;
  inline ::vmsg::CSGuildRequest* mutable_guildrequest();
  inline ::vmsg::CSGuildRequest* release_guildrequest();
  inline void set_allocated_guildrequest(::vmsg::CSGuildRequest* guildrequest);

  // optional .vmsg.CSMailRequest MailRequest = 16;
  inline bool has_mailrequest() const;
  inline void clear_mailrequest();
  static const int kMailRequestFieldNumber = 16;
  inline const ::vmsg::CSMailRequest& mailrequest() const;
  inline ::vmsg::CSMailRequest* mutable_mailrequest();
  inline ::vmsg::CSMailRequest* release_mailrequest();
  inline void set_allocated_mailrequest(::vmsg::CSMailRequest* mailrequest);

  // optional .vmsg.CSInfiniteRequest InfiniteRequest = 17;
  inline bool has_infiniterequest() const;
  inline void clear_infiniterequest();
  static const int kInfiniteRequestFieldNumber = 17;
  inline const ::vmsg::CSInfiniteRequest& infiniterequest() const;
  inline ::vmsg::CSInfiniteRequest* mutable_infiniterequest();
  inline ::vmsg::CSInfiniteRequest* release_infiniterequest();
  inline void set_allocated_infiniterequest(::vmsg::CSInfiniteRequest* infiniterequest);

  // optional .vmsg.CSChatRequest ChatRequest = 18;
  inline bool has_chatrequest() const;
  inline void clear_chatrequest();
  static const int kChatRequestFieldNumber = 18;
  inline const ::vmsg::CSChatRequest& chatrequest() const;
  inline ::vmsg::CSChatRequest* mutable_chatrequest();
  inline ::vmsg::CSChatRequest* release_chatrequest();
  inline void set_allocated_chatrequest(::vmsg::CSChatRequest* chatrequest);

  // optional .vmsg.CSCVZRequest CVZRequest = 19;
  inline bool has_cvzrequest() const;
  inline void clear_cvzrequest();
  static const int kCVZRequestFieldNumber = 19;
  inline const ::vmsg::CSCVZRequest& cvzrequest() const;
  inline ::vmsg::CSCVZRequest* mutable_cvzrequest();
  inline ::vmsg::CSCVZRequest* release_cvzrequest();
  inline void set_allocated_cvzrequest(::vmsg::CSCVZRequest* cvzrequest);

  // optional .vmsg.CSServerNotifyRequest ServerNotifyRequest = 20;
  inline bool has_servernotifyrequest() const;
  inline void clear_servernotifyrequest();
  static const int kServerNotifyRequestFieldNumber = 20;
  inline const ::vmsg::CSServerNotifyRequest& servernotifyrequest() const;
  inline ::vmsg::CSServerNotifyRequest* mutable_servernotifyrequest();
  inline ::vmsg::CSServerNotifyRequest* release_servernotifyrequest();
  inline void set_allocated_servernotifyrequest(::vmsg::CSServerNotifyRequest* servernotifyrequest);

  // optional .vmsg.CSDailyGiftRequest DailyGiftRequest = 21;
  inline bool has_dailygiftrequest() const;
  inline void clear_dailygiftrequest();
  static const int kDailyGiftRequestFieldNumber = 21;
  inline const ::vmsg::CSDailyGiftRequest& dailygiftrequest() const;
  inline ::vmsg::CSDailyGiftRequest* mutable_dailygiftrequest();
  inline ::vmsg::CSDailyGiftRequest* release_dailygiftrequest();
  inline void set_allocated_dailygiftrequest(::vmsg::CSDailyGiftRequest* dailygiftrequest);

  // optional .vmsg.CSArenaRequest ArenaRequest = 22;
  inline bool has_arenarequest() const;
  inline void clear_arenarequest();
  static const int kArenaRequestFieldNumber = 22;
  inline const ::vmsg::CSArenaRequest& arenarequest() const;
  inline ::vmsg::CSArenaRequest* mutable_arenarequest();
  inline ::vmsg::CSArenaRequest* release_arenarequest();
  inline void set_allocated_arenarequest(::vmsg::CSArenaRequest* arenarequest);

  // optional .vmsg.CSStoreRequest StoreRequest = 23;
  inline bool has_storerequest() const;
  inline void clear_storerequest();
  static const int kStoreRequestFieldNumber = 23;
  inline const ::vmsg::CSStoreRequest& storerequest() const;
  inline ::vmsg::CSStoreRequest* mutable_storerequest();
  inline ::vmsg::CSStoreRequest* release_storerequest();
  inline void set_allocated_storerequest(::vmsg::CSStoreRequest* storerequest);

  // optional .vmsg.CSQiangHunRequest QiangHunRequest = 24;
  inline bool has_qianghunrequest() const;
  inline void clear_qianghunrequest();
  static const int kQiangHunRequestFieldNumber = 24;
  inline const ::vmsg::CSQiangHunRequest& qianghunrequest() const;
  inline ::vmsg::CSQiangHunRequest* mutable_qianghunrequest();
  inline ::vmsg::CSQiangHunRequest* release_qianghunrequest();
  inline void set_allocated_qianghunrequest(::vmsg::CSQiangHunRequest* qianghunrequest);

  // optional .vmsg.CSDebrisRequest DebrisRequest = 25;
  inline bool has_debrisrequest() const;
  inline void clear_debrisrequest();
  static const int kDebrisRequestFieldNumber = 25;
  inline const ::vmsg::CSDebrisRequest& debrisrequest() const;
  inline ::vmsg::CSDebrisRequest* mutable_debrisrequest();
  inline ::vmsg::CSDebrisRequest* release_debrisrequest();
  inline void set_allocated_debrisrequest(::vmsg::CSDebrisRequest* debrisrequest);

  // optional .vmsg.CSActRequest ActRequest = 26;
  inline bool has_actrequest() const;
  inline void clear_actrequest();
  static const int kActRequestFieldNumber = 26;
  inline const ::vmsg::CSActRequest& actrequest() const;
  inline ::vmsg::CSActRequest* mutable_actrequest();
  inline ::vmsg::CSActRequest* release_actrequest();
  inline void set_allocated_actrequest(::vmsg::CSActRequest* actrequest);

  // optional .vmsg.CSDotaItemRequest DotaItemRequest = 27;
  inline bool has_dotaitemrequest() const;
  inline void clear_dotaitemrequest();
  static const int kDotaItemRequestFieldNumber = 27;
  inline const ::vmsg::CSDotaItemRequest& dotaitemrequest() const;
  inline ::vmsg::CSDotaItemRequest* mutable_dotaitemrequest();
  inline ::vmsg::CSDotaItemRequest* release_dotaitemrequest();
  inline void set_allocated_dotaitemrequest(::vmsg::CSDotaItemRequest* dotaitemrequest);

  // optional .vmsg.CSCouponRequest CouponRequest = 28;
  inline bool has_couponrequest() const;
  inline void clear_couponrequest();
  static const int kCouponRequestFieldNumber = 28;
  inline const ::vmsg::CSCouponRequest& couponrequest() const;
  inline ::vmsg::CSCouponRequest* mutable_couponrequest();
  inline ::vmsg::CSCouponRequest* release_couponrequest();
  inline void set_allocated_couponrequest(::vmsg::CSCouponRequest* couponrequest);

  // optional .vmsg.CSPanicBuyingStoreRequest PanicBuyingRequst = 29;
  inline bool has_panicbuyingrequst() const;
  inline void clear_panicbuyingrequst();
  static const int kPanicBuyingRequstFieldNumber = 29;
  inline const ::vmsg::CSPanicBuyingStoreRequest& panicbuyingrequst() const;
  inline ::vmsg::CSPanicBuyingStoreRequest* mutable_panicbuyingrequst();
  inline ::vmsg::CSPanicBuyingStoreRequest* release_panicbuyingrequst();
  inline void set_allocated_panicbuyingrequst(::vmsg::CSPanicBuyingStoreRequest* panicbuyingrequst);

  // optional .vmsg.CSUMemDeviceTokenReport DeviceTokenReport = 30;
  inline bool has_devicetokenreport() const;
  inline void clear_devicetokenreport();
  static const int kDeviceTokenReportFieldNumber = 30;
  inline const ::vmsg::CSUMemDeviceTokenReport& devicetokenreport() const;
  inline ::vmsg::CSUMemDeviceTokenReport* mutable_devicetokenreport();
  inline ::vmsg::CSUMemDeviceTokenReport* release_devicetokenreport();
  inline void set_allocated_devicetokenreport(::vmsg::CSUMemDeviceTokenReport* devicetokenreport);

  // optional .vmsg.CSBossChallengeRqst BossChallengeRqst = 31;
  inline bool has_bosschallengerqst() const;
  inline void clear_bosschallengerqst();
  static const int kBossChallengeRqstFieldNumber = 31;
  inline const ::vmsg::CSBossChallengeRqst& bosschallengerqst() const;
  inline ::vmsg::CSBossChallengeRqst* mutable_bosschallengerqst();
  inline ::vmsg::CSBossChallengeRqst* release_bosschallengerqst();
  inline void set_allocated_bosschallengerqst(::vmsg::CSBossChallengeRqst* bosschallengerqst);

  // optional .vmsg.CSHeartBeatRqst HeartBeat_Rqst = 100;
  inline bool has_heartbeat_rqst() const;
  inline void clear_heartbeat_rqst();
  static const int kHeartBeatRqstFieldNumber = 100;
  inline const ::vmsg::CSHeartBeatRqst& heartbeat_rqst() const;
  inline ::vmsg::CSHeartBeatRqst* mutable_heartbeat_rqst();
  inline ::vmsg::CSHeartBeatRqst* release_heartbeat_rqst();
  inline void set_allocated_heartbeat_rqst(::vmsg::CSHeartBeatRqst* heartbeat_rqst);

  // optional .vmsg.CSAdminRequest AdminRequest = 101;
  inline bool has_adminrequest() const;
  inline void clear_adminrequest();
  static const int kAdminRequestFieldNumber = 101;
  inline const ::vmsg::CSAdminRequest& adminrequest() const;
  inline ::vmsg::CSAdminRequest* mutable_adminrequest();
  inline ::vmsg::CSAdminRequest* release_adminrequest();
  inline void set_allocated_adminrequest(::vmsg::CSAdminRequest* adminrequest);

  // optional .vmsg.CSAccountRquest Account_Rqst = 102;
  inline bool has_account_rqst() const;
  inline void clear_account_rqst();
  static const int kAccountRqstFieldNumber = 102;
  inline const ::vmsg::CSAccountRquest& account_rqst() const;
  inline ::vmsg::CSAccountRquest* mutable_account_rqst();
  inline ::vmsg::CSAccountRquest* release_account_rqst();
  inline void set_allocated_account_rqst(::vmsg::CSAccountRquest* account_rqst);

  // @@protoc_insertion_point(class_scope:vmsg.VCli2LogicSvrMsg)
 private:
  inline void set_has_msg_head();
  inline void clear_has_msg_head();
  inline void set_has_bagrqst();
  inline void clear_has_bagrqst();
  inline void set_has_playerrequest();
  inline void clear_has_playerrequest();
  inline void set_has_sceneosdrequest();
  inline void clear_has_sceneosdrequest();
  inline void set_has_equiprequest();
  inline void clear_has_equiprequest();
  inline void set_has_taskrequest();
  inline void clear_has_taskrequest();
  inline void set_has_rankrequest();
  inline void clear_has_rankrequest();
  inline void set_has_weaponrequest();
  inline void clear_has_weaponrequest();
  inline void set_has_goldrequest();
  inline void clear_has_goldrequest();
  inline void set_has_itemrequest();
  inline void clear_has_itemrequest();
  inline void set_has_warmaprequest();
  inline void clear_has_warmaprequest();
  inline void set_has_friendrequest();
  inline void clear_has_friendrequest();
  inline void set_has_guildrequest();
  inline void clear_has_guildrequest();
  inline void set_has_mailrequest();
  inline void clear_has_mailrequest();
  inline void set_has_infiniterequest();
  inline void clear_has_infiniterequest();
  inline void set_has_chatrequest();
  inline void clear_has_chatrequest();
  inline void set_has_cvzrequest();
  inline void clear_has_cvzrequest();
  inline void set_has_servernotifyrequest();
  inline void clear_has_servernotifyrequest();
  inline void set_has_dailygiftrequest();
  inline void clear_has_dailygiftrequest();
  inline void set_has_arenarequest();
  inline void clear_has_arenarequest();
  inline void set_has_storerequest();
  inline void clear_has_storerequest();
  inline void set_has_qianghunrequest();
  inline void clear_has_qianghunrequest();
  inline void set_has_debrisrequest();
  inline void clear_has_debrisrequest();
  inline void set_has_actrequest();
  inline void clear_has_actrequest();
  inline void set_has_dotaitemrequest();
  inline void clear_has_dotaitemrequest();
  inline void set_has_couponrequest();
  inline void clear_has_couponrequest();
  inline void set_has_panicbuyingrequst();
  inline void clear_has_panicbuyingrequst();
  inline void set_has_devicetokenreport();
  inline void clear_has_devicetokenreport();
  inline void set_has_bosschallengerqst();
  inline void clear_has_bosschallengerqst();
  inline void set_has_heartbeat_rqst();
  inline void clear_has_heartbeat_rqst();
  inline void set_has_adminrequest();
  inline void clear_has_adminrequest();
  inline void set_has_account_rqst();
  inline void clear_has_account_rqst();

  ::vmsg::MsgHead* msg_head_;
  ::vmsg::CSBagRequest* bagrqst_;
  ::vmsg::CSPlayerRequest* playerrequest_;
  ::vmsg::CSSceneOSDRequest* sceneosdrequest_;
  ::vmsg::CSEquipRequest* equiprequest_;
  ::vmsg::CSTaskRequest* taskrequest_;
  ::vmsg::CSRankRequest* rankrequest_;
  ::vmsg::CSWeaponRequest* weaponrequest_;
  ::vmsg::CSGoldRequest* goldrequest_;
  ::vmsg::CSItemRequest* itemrequest_;
  ::vmsg::CSWarMapRequest* warmaprequest_;
  ::vmsg::CSFriendRequest* friendrequest_;
  ::vmsg::CSGuildRequest* guildrequest_;
  ::vmsg::CSMailRequest* mailrequest_;
  ::vmsg::CSInfiniteRequest* infiniterequest_;
  ::vmsg::CSChatRequest* chatrequest_;
  ::vmsg::CSCVZRequest* cvzrequest_;
  ::vmsg::CSServerNotifyRequest* servernotifyrequest_;
  ::vmsg::CSDailyGiftRequest* dailygiftrequest_;
  ::vmsg::CSArenaRequest* arenarequest_;
  ::vmsg::CSStoreRequest* storerequest_;
  ::vmsg::CSQiangHunRequest* qianghunrequest_;
  ::vmsg::CSDebrisRequest* debrisrequest_;
  ::vmsg::CSActRequest* actrequest_;
  ::vmsg::CSDotaItemRequest* dotaitemrequest_;
  ::vmsg::CSCouponRequest* couponrequest_;
  ::vmsg::CSPanicBuyingStoreRequest* panicbuyingrequst_;
  ::vmsg::CSUMemDeviceTokenReport* devicetokenreport_;
  ::vmsg::CSBossChallengeRqst* bosschallengerqst_;
  ::vmsg::CSHeartBeatRqst* heartbeat_rqst_;
  ::vmsg::CSAdminRequest* adminrequest_;
  ::vmsg::CSAccountRquest* account_rqst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(32 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ClientSvrMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ClientSvrMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_ClientSvrMsg_2eproto();
  friend void protobuf_ShutdownFile_ClientSvrMsg_2eproto();

  void InitAsDefaultInstance();
  static VCli2LogicSvrMsg* default_instance_;
};
// -------------------------------------------------------------------

class VLogicSvr2CliMsg : public ::google::protobuf::MessageLite {
 public:
  VLogicSvr2CliMsg();
  virtual ~VLogicSvr2CliMsg();

  VLogicSvr2CliMsg(const VLogicSvr2CliMsg& from);

  inline VLogicSvr2CliMsg& operator=(const VLogicSvr2CliMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const VLogicSvr2CliMsg& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VLogicSvr2CliMsg* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VLogicSvr2CliMsg* other);

  // implements Message ----------------------------------------------

  VLogicSvr2CliMsg* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VLogicSvr2CliMsg& from);
  void MergeFrom(const VLogicSvr2CliMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.MsgHead Msg_Head = 1;
  inline bool has_msg_head() const;
  inline void clear_msg_head();
  static const int kMsgHeadFieldNumber = 1;
  inline const ::vmsg::MsgHead& msg_head() const;
  inline ::vmsg::MsgHead* mutable_msg_head();
  inline ::vmsg::MsgHead* release_msg_head();
  inline void set_allocated_msg_head(::vmsg::MsgHead* msg_head);

  // optional .vmsg.CSCommonErrMsg ErrMsg = 2;
  inline bool has_errmsg() const;
  inline void clear_errmsg();
  static const int kErrMsgFieldNumber = 2;
  inline const ::vmsg::CSCommonErrMsg& errmsg() const;
  inline ::vmsg::CSCommonErrMsg* mutable_errmsg();
  inline ::vmsg::CSCommonErrMsg* release_errmsg();
  inline void set_allocated_errmsg(::vmsg::CSCommonErrMsg* errmsg);

  // optional .vmsg.CSBagRespond BagRespond = 3;
  inline bool has_bagrespond() const;
  inline void clear_bagrespond();
  static const int kBagRespondFieldNumber = 3;
  inline const ::vmsg::CSBagRespond& bagrespond() const;
  inline ::vmsg::CSBagRespond* mutable_bagrespond();
  inline ::vmsg::CSBagRespond* release_bagrespond();
  inline void set_allocated_bagrespond(::vmsg::CSBagRespond* bagrespond);

  // optional .vmsg.CSPlayerRespond PlayerRespond = 5;
  inline bool has_playerrespond() const;
  inline void clear_playerrespond();
  static const int kPlayerRespondFieldNumber = 5;
  inline const ::vmsg::CSPlayerRespond& playerrespond() const;
  inline ::vmsg::CSPlayerRespond* mutable_playerrespond();
  inline ::vmsg::CSPlayerRespond* release_playerrespond();
  inline void set_allocated_playerrespond(::vmsg::CSPlayerRespond* playerrespond);

  // optional .vmsg.CSSceneOSDRespond SceneOSDRespond = 6;
  inline bool has_sceneosdrespond() const;
  inline void clear_sceneosdrespond();
  static const int kSceneOSDRespondFieldNumber = 6;
  inline const ::vmsg::CSSceneOSDRespond& sceneosdrespond() const;
  inline ::vmsg::CSSceneOSDRespond* mutable_sceneosdrespond();
  inline ::vmsg::CSSceneOSDRespond* release_sceneosdrespond();
  inline void set_allocated_sceneosdrespond(::vmsg::CSSceneOSDRespond* sceneosdrespond);

  // optional .vmsg.CSEquipRespond EquipRespond = 7;
  inline bool has_equiprespond() const;
  inline void clear_equiprespond();
  static const int kEquipRespondFieldNumber = 7;
  inline const ::vmsg::CSEquipRespond& equiprespond() const;
  inline ::vmsg::CSEquipRespond* mutable_equiprespond();
  inline ::vmsg::CSEquipRespond* release_equiprespond();
  inline void set_allocated_equiprespond(::vmsg::CSEquipRespond* equiprespond);

  // optional .vmsg.CSTaskRespond TaskRespond = 8;
  inline bool has_taskrespond() const;
  inline void clear_taskrespond();
  static const int kTaskRespondFieldNumber = 8;
  inline const ::vmsg::CSTaskRespond& taskrespond() const;
  inline ::vmsg::CSTaskRespond* mutable_taskrespond();
  inline ::vmsg::CSTaskRespond* release_taskrespond();
  inline void set_allocated_taskrespond(::vmsg::CSTaskRespond* taskrespond);

  // optional .vmsg.CSRankRespond RankRespond = 9;
  inline bool has_rankrespond() const;
  inline void clear_rankrespond();
  static const int kRankRespondFieldNumber = 9;
  inline const ::vmsg::CSRankRespond& rankrespond() const;
  inline ::vmsg::CSRankRespond* mutable_rankrespond();
  inline ::vmsg::CSRankRespond* release_rankrespond();
  inline void set_allocated_rankrespond(::vmsg::CSRankRespond* rankrespond);

  // optional .vmsg.CSWeaponRespond WeaponRespond = 10;
  inline bool has_weaponrespond() const;
  inline void clear_weaponrespond();
  static const int kWeaponRespondFieldNumber = 10;
  inline const ::vmsg::CSWeaponRespond& weaponrespond() const;
  inline ::vmsg::CSWeaponRespond* mutable_weaponrespond();
  inline ::vmsg::CSWeaponRespond* release_weaponrespond();
  inline void set_allocated_weaponrespond(::vmsg::CSWeaponRespond* weaponrespond);

  // optional .vmsg.CSGoldRespond GoldRespond = 11;
  inline bool has_goldrespond() const;
  inline void clear_goldrespond();
  static const int kGoldRespondFieldNumber = 11;
  inline const ::vmsg::CSGoldRespond& goldrespond() const;
  inline ::vmsg::CSGoldRespond* mutable_goldrespond();
  inline ::vmsg::CSGoldRespond* release_goldrespond();
  inline void set_allocated_goldrespond(::vmsg::CSGoldRespond* goldrespond);

  // optional .vmsg.CSItemRespond ItemRespond = 12;
  inline bool has_itemrespond() const;
  inline void clear_itemrespond();
  static const int kItemRespondFieldNumber = 12;
  inline const ::vmsg::CSItemRespond& itemrespond() const;
  inline ::vmsg::CSItemRespond* mutable_itemrespond();
  inline ::vmsg::CSItemRespond* release_itemrespond();
  inline void set_allocated_itemrespond(::vmsg::CSItemRespond* itemrespond);

  // optional .vmsg.CSWarMapRespond WarMapRespond = 13;
  inline bool has_warmaprespond() const;
  inline void clear_warmaprespond();
  static const int kWarMapRespondFieldNumber = 13;
  inline const ::vmsg::CSWarMapRespond& warmaprespond() const;
  inline ::vmsg::CSWarMapRespond* mutable_warmaprespond();
  inline ::vmsg::CSWarMapRespond* release_warmaprespond();
  inline void set_allocated_warmaprespond(::vmsg::CSWarMapRespond* warmaprespond);

  // optional .vmsg.CSFriendRespond FriendRespond = 14;
  inline bool has_friendrespond() const;
  inline void clear_friendrespond();
  static const int kFriendRespondFieldNumber = 14;
  inline const ::vmsg::CSFriendRespond& friendrespond() const;
  inline ::vmsg::CSFriendRespond* mutable_friendrespond();
  inline ::vmsg::CSFriendRespond* release_friendrespond();
  inline void set_allocated_friendrespond(::vmsg::CSFriendRespond* friendrespond);

  // optional .vmsg.CSGuildRespond GuildRespond = 15;
  inline bool has_guildrespond() const;
  inline void clear_guildrespond();
  static const int kGuildRespondFieldNumber = 15;
  inline const ::vmsg::CSGuildRespond& guildrespond() const;
  inline ::vmsg::CSGuildRespond* mutable_guildrespond();
  inline ::vmsg::CSGuildRespond* release_guildrespond();
  inline void set_allocated_guildrespond(::vmsg::CSGuildRespond* guildrespond);

  // optional .vmsg.CSMailRespond MailRespond = 16;
  inline bool has_mailrespond() const;
  inline void clear_mailrespond();
  static const int kMailRespondFieldNumber = 16;
  inline const ::vmsg::CSMailRespond& mailrespond() const;
  inline ::vmsg::CSMailRespond* mutable_mailrespond();
  inline ::vmsg::CSMailRespond* release_mailrespond();
  inline void set_allocated_mailrespond(::vmsg::CSMailRespond* mailrespond);

  // optional .vmsg.CSInfiniteRespond InfiniteRespond = 17;
  inline bool has_infiniterespond() const;
  inline void clear_infiniterespond();
  static const int kInfiniteRespondFieldNumber = 17;
  inline const ::vmsg::CSInfiniteRespond& infiniterespond() const;
  inline ::vmsg::CSInfiniteRespond* mutable_infiniterespond();
  inline ::vmsg::CSInfiniteRespond* release_infiniterespond();
  inline void set_allocated_infiniterespond(::vmsg::CSInfiniteRespond* infiniterespond);

  // optional .vmsg.CSChatRespond ChatRespond = 18;
  inline bool has_chatrespond() const;
  inline void clear_chatrespond();
  static const int kChatRespondFieldNumber = 18;
  inline const ::vmsg::CSChatRespond& chatrespond() const;
  inline ::vmsg::CSChatRespond* mutable_chatrespond();
  inline ::vmsg::CSChatRespond* release_chatrespond();
  inline void set_allocated_chatrespond(::vmsg::CSChatRespond* chatrespond);

  // optional .vmsg.CSCVZRespond CVZRespond = 19;
  inline bool has_cvzrespond() const;
  inline void clear_cvzrespond();
  static const int kCVZRespondFieldNumber = 19;
  inline const ::vmsg::CSCVZRespond& cvzrespond() const;
  inline ::vmsg::CSCVZRespond* mutable_cvzrespond();
  inline ::vmsg::CSCVZRespond* release_cvzrespond();
  inline void set_allocated_cvzrespond(::vmsg::CSCVZRespond* cvzrespond);

  // optional .vmsg.CSServerNotifyRespond ServerNotifyRespond = 20;
  inline bool has_servernotifyrespond() const;
  inline void clear_servernotifyrespond();
  static const int kServerNotifyRespondFieldNumber = 20;
  inline const ::vmsg::CSServerNotifyRespond& servernotifyrespond() const;
  inline ::vmsg::CSServerNotifyRespond* mutable_servernotifyrespond();
  inline ::vmsg::CSServerNotifyRespond* release_servernotifyrespond();
  inline void set_allocated_servernotifyrespond(::vmsg::CSServerNotifyRespond* servernotifyrespond);

  // optional .vmsg.CSDailyGiftRespond DailyGiftRespond = 21;
  inline bool has_dailygiftrespond() const;
  inline void clear_dailygiftrespond();
  static const int kDailyGiftRespondFieldNumber = 21;
  inline const ::vmsg::CSDailyGiftRespond& dailygiftrespond() const;
  inline ::vmsg::CSDailyGiftRespond* mutable_dailygiftrespond();
  inline ::vmsg::CSDailyGiftRespond* release_dailygiftrespond();
  inline void set_allocated_dailygiftrespond(::vmsg::CSDailyGiftRespond* dailygiftrespond);

  // optional .vmsg.CSArenaRespond ArenaRespond = 22;
  inline bool has_arenarespond() const;
  inline void clear_arenarespond();
  static const int kArenaRespondFieldNumber = 22;
  inline const ::vmsg::CSArenaRespond& arenarespond() const;
  inline ::vmsg::CSArenaRespond* mutable_arenarespond();
  inline ::vmsg::CSArenaRespond* release_arenarespond();
  inline void set_allocated_arenarespond(::vmsg::CSArenaRespond* arenarespond);

  // optional .vmsg.CSStoreRespond StoreRespond = 23;
  inline bool has_storerespond() const;
  inline void clear_storerespond();
  static const int kStoreRespondFieldNumber = 23;
  inline const ::vmsg::CSStoreRespond& storerespond() const;
  inline ::vmsg::CSStoreRespond* mutable_storerespond();
  inline ::vmsg::CSStoreRespond* release_storerespond();
  inline void set_allocated_storerespond(::vmsg::CSStoreRespond* storerespond);

  // optional .vmsg.CSQiangHunRespond QiangHunRespond = 24;
  inline bool has_qianghunrespond() const;
  inline void clear_qianghunrespond();
  static const int kQiangHunRespondFieldNumber = 24;
  inline const ::vmsg::CSQiangHunRespond& qianghunrespond() const;
  inline ::vmsg::CSQiangHunRespond* mutable_qianghunrespond();
  inline ::vmsg::CSQiangHunRespond* release_qianghunrespond();
  inline void set_allocated_qianghunrespond(::vmsg::CSQiangHunRespond* qianghunrespond);

  // optional .vmsg.CSDebrisRespond DebrisRespond = 25;
  inline bool has_debrisrespond() const;
  inline void clear_debrisrespond();
  static const int kDebrisRespondFieldNumber = 25;
  inline const ::vmsg::CSDebrisRespond& debrisrespond() const;
  inline ::vmsg::CSDebrisRespond* mutable_debrisrespond();
  inline ::vmsg::CSDebrisRespond* release_debrisrespond();
  inline void set_allocated_debrisrespond(::vmsg::CSDebrisRespond* debrisrespond);

  // optional .vmsg.CSActRespond ActRespond = 26;
  inline bool has_actrespond() const;
  inline void clear_actrespond();
  static const int kActRespondFieldNumber = 26;
  inline const ::vmsg::CSActRespond& actrespond() const;
  inline ::vmsg::CSActRespond* mutable_actrespond();
  inline ::vmsg::CSActRespond* release_actrespond();
  inline void set_allocated_actrespond(::vmsg::CSActRespond* actrespond);

  // optional .vmsg.CSDotaItemRespond DotaItemRespond = 27;
  inline bool has_dotaitemrespond() const;
  inline void clear_dotaitemrespond();
  static const int kDotaItemRespondFieldNumber = 27;
  inline const ::vmsg::CSDotaItemRespond& dotaitemrespond() const;
  inline ::vmsg::CSDotaItemRespond* mutable_dotaitemrespond();
  inline ::vmsg::CSDotaItemRespond* release_dotaitemrespond();
  inline void set_allocated_dotaitemrespond(::vmsg::CSDotaItemRespond* dotaitemrespond);

  // optional .vmsg.CSCouponRespond CouponRespond = 28;
  inline bool has_couponrespond() const;
  inline void clear_couponrespond();
  static const int kCouponRespondFieldNumber = 28;
  inline const ::vmsg::CSCouponRespond& couponrespond() const;
  inline ::vmsg::CSCouponRespond* mutable_couponrespond();
  inline ::vmsg::CSCouponRespond* release_couponrespond();
  inline void set_allocated_couponrespond(::vmsg::CSCouponRespond* couponrespond);

  // optional .vmsg.CSPanicBuyingStoreResponse PanicBuyingRespond = 29;
  inline bool has_panicbuyingrespond() const;
  inline void clear_panicbuyingrespond();
  static const int kPanicBuyingRespondFieldNumber = 29;
  inline const ::vmsg::CSPanicBuyingStoreResponse& panicbuyingrespond() const;
  inline ::vmsg::CSPanicBuyingStoreResponse* mutable_panicbuyingrespond();
  inline ::vmsg::CSPanicBuyingStoreResponse* release_panicbuyingrespond();
  inline void set_allocated_panicbuyingrespond(::vmsg::CSPanicBuyingStoreResponse* panicbuyingrespond);

  // optional .vmsg.CSBossChallengeRsp BossChallengeRsp = 30;
  inline bool has_bosschallengersp() const;
  inline void clear_bosschallengersp();
  static const int kBossChallengeRspFieldNumber = 30;
  inline const ::vmsg::CSBossChallengeRsp& bosschallengersp() const;
  inline ::vmsg::CSBossChallengeRsp* mutable_bosschallengersp();
  inline ::vmsg::CSBossChallengeRsp* release_bosschallengersp();
  inline void set_allocated_bosschallengersp(::vmsg::CSBossChallengeRsp* bosschallengersp);

  // optional int32 CheckNick_Rsp = 99;
  inline bool has_checknick_rsp() const;
  inline void clear_checknick_rsp();
  static const int kCheckNickRspFieldNumber = 99;
  inline ::google::protobuf::int32 checknick_rsp() const;
  inline void set_checknick_rsp(::google::protobuf::int32 value);

  // optional .vmsg.CSHeartBeatRsp HeartBeat_Rsp = 100;
  inline bool has_heartbeat_rsp() const;
  inline void clear_heartbeat_rsp();
  static const int kHeartBeatRspFieldNumber = 100;
  inline const ::vmsg::CSHeartBeatRsp& heartbeat_rsp() const;
  inline ::vmsg::CSHeartBeatRsp* mutable_heartbeat_rsp();
  inline ::vmsg::CSHeartBeatRsp* release_heartbeat_rsp();
  inline void set_allocated_heartbeat_rsp(::vmsg::CSHeartBeatRsp* heartbeat_rsp);

  // optional .vmsg.CSAdminRespond AdminRespond = 101;
  inline bool has_adminrespond() const;
  inline void clear_adminrespond();
  static const int kAdminRespondFieldNumber = 101;
  inline const ::vmsg::CSAdminRespond& adminrespond() const;
  inline ::vmsg::CSAdminRespond* mutable_adminrespond();
  inline ::vmsg::CSAdminRespond* release_adminrespond();
  inline void set_allocated_adminrespond(::vmsg::CSAdminRespond* adminrespond);

  // optional .vmsg.CSAccountRespond Account_Rsp = 102;
  inline bool has_account_rsp() const;
  inline void clear_account_rsp();
  static const int kAccountRspFieldNumber = 102;
  inline const ::vmsg::CSAccountRespond& account_rsp() const;
  inline ::vmsg::CSAccountRespond* mutable_account_rsp();
  inline ::vmsg::CSAccountRespond* release_account_rsp();
  inline void set_allocated_account_rsp(::vmsg::CSAccountRespond* account_rsp);

  // @@protoc_insertion_point(class_scope:vmsg.VLogicSvr2CliMsg)
 private:
  inline void set_has_msg_head();
  inline void clear_has_msg_head();
  inline void set_has_errmsg();
  inline void clear_has_errmsg();
  inline void set_has_bagrespond();
  inline void clear_has_bagrespond();
  inline void set_has_playerrespond();
  inline void clear_has_playerrespond();
  inline void set_has_sceneosdrespond();
  inline void clear_has_sceneosdrespond();
  inline void set_has_equiprespond();
  inline void clear_has_equiprespond();
  inline void set_has_taskrespond();
  inline void clear_has_taskrespond();
  inline void set_has_rankrespond();
  inline void clear_has_rankrespond();
  inline void set_has_weaponrespond();
  inline void clear_has_weaponrespond();
  inline void set_has_goldrespond();
  inline void clear_has_goldrespond();
  inline void set_has_itemrespond();
  inline void clear_has_itemrespond();
  inline void set_has_warmaprespond();
  inline void clear_has_warmaprespond();
  inline void set_has_friendrespond();
  inline void clear_has_friendrespond();
  inline void set_has_guildrespond();
  inline void clear_has_guildrespond();
  inline void set_has_mailrespond();
  inline void clear_has_mailrespond();
  inline void set_has_infiniterespond();
  inline void clear_has_infiniterespond();
  inline void set_has_chatrespond();
  inline void clear_has_chatrespond();
  inline void set_has_cvzrespond();
  inline void clear_has_cvzrespond();
  inline void set_has_servernotifyrespond();
  inline void clear_has_servernotifyrespond();
  inline void set_has_dailygiftrespond();
  inline void clear_has_dailygiftrespond();
  inline void set_has_arenarespond();
  inline void clear_has_arenarespond();
  inline void set_has_storerespond();
  inline void clear_has_storerespond();
  inline void set_has_qianghunrespond();
  inline void clear_has_qianghunrespond();
  inline void set_has_debrisrespond();
  inline void clear_has_debrisrespond();
  inline void set_has_actrespond();
  inline void clear_has_actrespond();
  inline void set_has_dotaitemrespond();
  inline void clear_has_dotaitemrespond();
  inline void set_has_couponrespond();
  inline void clear_has_couponrespond();
  inline void set_has_panicbuyingrespond();
  inline void clear_has_panicbuyingrespond();
  inline void set_has_bosschallengersp();
  inline void clear_has_bosschallengersp();
  inline void set_has_checknick_rsp();
  inline void clear_has_checknick_rsp();
  inline void set_has_heartbeat_rsp();
  inline void clear_has_heartbeat_rsp();
  inline void set_has_adminrespond();
  inline void clear_has_adminrespond();
  inline void set_has_account_rsp();
  inline void clear_has_account_rsp();

  ::vmsg::MsgHead* msg_head_;
  ::vmsg::CSCommonErrMsg* errmsg_;
  ::vmsg::CSBagRespond* bagrespond_;
  ::vmsg::CSPlayerRespond* playerrespond_;
  ::vmsg::CSSceneOSDRespond* sceneosdrespond_;
  ::vmsg::CSEquipRespond* equiprespond_;
  ::vmsg::CSTaskRespond* taskrespond_;
  ::vmsg::CSRankRespond* rankrespond_;
  ::vmsg::CSWeaponRespond* weaponrespond_;
  ::vmsg::CSGoldRespond* goldrespond_;
  ::vmsg::CSItemRespond* itemrespond_;
  ::vmsg::CSWarMapRespond* warmaprespond_;
  ::vmsg::CSFriendRespond* friendrespond_;
  ::vmsg::CSGuildRespond* guildrespond_;
  ::vmsg::CSMailRespond* mailrespond_;
  ::vmsg::CSInfiniteRespond* infiniterespond_;
  ::vmsg::CSChatRespond* chatrespond_;
  ::vmsg::CSCVZRespond* cvzrespond_;
  ::vmsg::CSServerNotifyRespond* servernotifyrespond_;
  ::vmsg::CSDailyGiftRespond* dailygiftrespond_;
  ::vmsg::CSArenaRespond* arenarespond_;
  ::vmsg::CSStoreRespond* storerespond_;
  ::vmsg::CSQiangHunRespond* qianghunrespond_;
  ::vmsg::CSDebrisRespond* debrisrespond_;
  ::vmsg::CSActRespond* actrespond_;
  ::vmsg::CSDotaItemRespond* dotaitemrespond_;
  ::vmsg::CSCouponRespond* couponrespond_;
  ::vmsg::CSPanicBuyingStoreResponse* panicbuyingrespond_;
  ::vmsg::CSBossChallengeRsp* bosschallengersp_;
  ::vmsg::CSHeartBeatRsp* heartbeat_rsp_;
  ::vmsg::CSAdminRespond* adminrespond_;
  ::vmsg::CSAccountRespond* account_rsp_;
  ::google::protobuf::int32 checknick_rsp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(33 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ClientSvrMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ClientSvrMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_ClientSvrMsg_2eproto();
  friend void protobuf_ShutdownFile_ClientSvrMsg_2eproto();

  void InitAsDefaultInstance();
  static VLogicSvr2CliMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// CSHeartBeatRqst

// required uint32 Reserved = 1;
inline bool CSHeartBeatRqst::has_reserved() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSHeartBeatRqst::set_has_reserved() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSHeartBeatRqst::clear_has_reserved() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSHeartBeatRqst::clear_reserved() {
  reserved_ = 0u;
  clear_has_reserved();
}
inline ::google::protobuf::uint32 CSHeartBeatRqst::reserved() const {
  return reserved_;
}
inline void CSHeartBeatRqst::set_reserved(::google::protobuf::uint32 value) {
  set_has_reserved();
  reserved_ = value;
}

// -------------------------------------------------------------------

// CSHeartBeatRsp

// required uint32 Svr_Time = 1;
inline bool CSHeartBeatRsp::has_svr_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSHeartBeatRsp::set_has_svr_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSHeartBeatRsp::clear_has_svr_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSHeartBeatRsp::clear_svr_time() {
  svr_time_ = 0u;
  clear_has_svr_time();
}
inline ::google::protobuf::uint32 CSHeartBeatRsp::svr_time() const {
  return svr_time_;
}
inline void CSHeartBeatRsp::set_svr_time(::google::protobuf::uint32 value) {
  set_has_svr_time();
  svr_time_ = value;
}

// -------------------------------------------------------------------

// CSCommonErrMsg

// required uint32 RqstCmdID = 1;
inline bool CSCommonErrMsg::has_rqstcmdid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSCommonErrMsg::set_has_rqstcmdid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSCommonErrMsg::clear_has_rqstcmdid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSCommonErrMsg::clear_rqstcmdid() {
  rqstcmdid_ = 0u;
  clear_has_rqstcmdid();
}
inline ::google::protobuf::uint32 CSCommonErrMsg::rqstcmdid() const {
  return rqstcmdid_;
}
inline void CSCommonErrMsg::set_rqstcmdid(::google::protobuf::uint32 value) {
  set_has_rqstcmdid();
  rqstcmdid_ = value;
}

// required uint32 ErrorCode = 2;
inline bool CSCommonErrMsg::has_errorcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSCommonErrMsg::set_has_errorcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSCommonErrMsg::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSCommonErrMsg::clear_errorcode() {
  errorcode_ = 0u;
  clear_has_errorcode();
}
inline ::google::protobuf::uint32 CSCommonErrMsg::errorcode() const {
  return errorcode_;
}
inline void CSCommonErrMsg::set_errorcode(::google::protobuf::uint32 value) {
  set_has_errorcode();
  errorcode_ = value;
}

// optional int32 opt1 = 3;
inline bool CSCommonErrMsg::has_opt1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSCommonErrMsg::set_has_opt1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSCommonErrMsg::clear_has_opt1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSCommonErrMsg::clear_opt1() {
  opt1_ = 0;
  clear_has_opt1();
}
inline ::google::protobuf::int32 CSCommonErrMsg::opt1() const {
  return opt1_;
}
inline void CSCommonErrMsg::set_opt1(::google::protobuf::int32 value) {
  set_has_opt1();
  opt1_ = value;
}

// optional int32 opt2 = 4;
inline bool CSCommonErrMsg::has_opt2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSCommonErrMsg::set_has_opt2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSCommonErrMsg::clear_has_opt2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSCommonErrMsg::clear_opt2() {
  opt2_ = 0;
  clear_has_opt2();
}
inline ::google::protobuf::int32 CSCommonErrMsg::opt2() const {
  return opt2_;
}
inline void CSCommonErrMsg::set_opt2(::google::protobuf::int32 value) {
  set_has_opt2();
  opt2_ = value;
}

// -------------------------------------------------------------------

// VCli2LogicSvrMsg

// required .vmsg.MsgHead Msg_Head = 1;
inline bool VCli2LogicSvrMsg::has_msg_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_msg_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VCli2LogicSvrMsg::clear_has_msg_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VCli2LogicSvrMsg::clear_msg_head() {
  if (msg_head_ != NULL) msg_head_->::vmsg::MsgHead::Clear();
  clear_has_msg_head();
}
inline const ::vmsg::MsgHead& VCli2LogicSvrMsg::msg_head() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return msg_head_ != NULL ? *msg_head_ : *default_instance().msg_head_;
#else
  return msg_head_ != NULL ? *msg_head_ : *default_instance_->msg_head_;
#endif
}
inline ::vmsg::MsgHead* VCli2LogicSvrMsg::mutable_msg_head() {
  set_has_msg_head();
  if (msg_head_ == NULL) msg_head_ = new ::vmsg::MsgHead;
  return msg_head_;
}
inline ::vmsg::MsgHead* VCli2LogicSvrMsg::release_msg_head() {
  clear_has_msg_head();
  ::vmsg::MsgHead* temp = msg_head_;
  msg_head_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_msg_head(::vmsg::MsgHead* msg_head) {
  delete msg_head_;
  msg_head_ = msg_head;
  if (msg_head) {
    set_has_msg_head();
  } else {
    clear_has_msg_head();
  }
}

// optional .vmsg.CSBagRequest BagRqst = 3;
inline bool VCli2LogicSvrMsg::has_bagrqst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_bagrqst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VCli2LogicSvrMsg::clear_has_bagrqst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VCli2LogicSvrMsg::clear_bagrqst() {
  if (bagrqst_ != NULL) bagrqst_->::vmsg::CSBagRequest::Clear();
  clear_has_bagrqst();
}
inline const ::vmsg::CSBagRequest& VCli2LogicSvrMsg::bagrqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bagrqst_ != NULL ? *bagrqst_ : *default_instance().bagrqst_;
#else
  return bagrqst_ != NULL ? *bagrqst_ : *default_instance_->bagrqst_;
#endif
}
inline ::vmsg::CSBagRequest* VCli2LogicSvrMsg::mutable_bagrqst() {
  set_has_bagrqst();
  if (bagrqst_ == NULL) bagrqst_ = new ::vmsg::CSBagRequest;
  return bagrqst_;
}
inline ::vmsg::CSBagRequest* VCli2LogicSvrMsg::release_bagrqst() {
  clear_has_bagrqst();
  ::vmsg::CSBagRequest* temp = bagrqst_;
  bagrqst_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_bagrqst(::vmsg::CSBagRequest* bagrqst) {
  delete bagrqst_;
  bagrqst_ = bagrqst;
  if (bagrqst) {
    set_has_bagrqst();
  } else {
    clear_has_bagrqst();
  }
}

// optional .vmsg.CSPlayerRequest PlayerRequest = 5;
inline bool VCli2LogicSvrMsg::has_playerrequest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_playerrequest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VCli2LogicSvrMsg::clear_has_playerrequest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VCli2LogicSvrMsg::clear_playerrequest() {
  if (playerrequest_ != NULL) playerrequest_->::vmsg::CSPlayerRequest::Clear();
  clear_has_playerrequest();
}
inline const ::vmsg::CSPlayerRequest& VCli2LogicSvrMsg::playerrequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerrequest_ != NULL ? *playerrequest_ : *default_instance().playerrequest_;
#else
  return playerrequest_ != NULL ? *playerrequest_ : *default_instance_->playerrequest_;
#endif
}
inline ::vmsg::CSPlayerRequest* VCli2LogicSvrMsg::mutable_playerrequest() {
  set_has_playerrequest();
  if (playerrequest_ == NULL) playerrequest_ = new ::vmsg::CSPlayerRequest;
  return playerrequest_;
}
inline ::vmsg::CSPlayerRequest* VCli2LogicSvrMsg::release_playerrequest() {
  clear_has_playerrequest();
  ::vmsg::CSPlayerRequest* temp = playerrequest_;
  playerrequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_playerrequest(::vmsg::CSPlayerRequest* playerrequest) {
  delete playerrequest_;
  playerrequest_ = playerrequest;
  if (playerrequest) {
    set_has_playerrequest();
  } else {
    clear_has_playerrequest();
  }
}

// optional .vmsg.CSSceneOSDRequest SceneOSDRequest = 6;
inline bool VCli2LogicSvrMsg::has_sceneosdrequest() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_sceneosdrequest() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VCli2LogicSvrMsg::clear_has_sceneosdrequest() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VCli2LogicSvrMsg::clear_sceneosdrequest() {
  if (sceneosdrequest_ != NULL) sceneosdrequest_->::vmsg::CSSceneOSDRequest::Clear();
  clear_has_sceneosdrequest();
}
inline const ::vmsg::CSSceneOSDRequest& VCli2LogicSvrMsg::sceneosdrequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sceneosdrequest_ != NULL ? *sceneosdrequest_ : *default_instance().sceneosdrequest_;
#else
  return sceneosdrequest_ != NULL ? *sceneosdrequest_ : *default_instance_->sceneosdrequest_;
#endif
}
inline ::vmsg::CSSceneOSDRequest* VCli2LogicSvrMsg::mutable_sceneosdrequest() {
  set_has_sceneosdrequest();
  if (sceneosdrequest_ == NULL) sceneosdrequest_ = new ::vmsg::CSSceneOSDRequest;
  return sceneosdrequest_;
}
inline ::vmsg::CSSceneOSDRequest* VCli2LogicSvrMsg::release_sceneosdrequest() {
  clear_has_sceneosdrequest();
  ::vmsg::CSSceneOSDRequest* temp = sceneosdrequest_;
  sceneosdrequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_sceneosdrequest(::vmsg::CSSceneOSDRequest* sceneosdrequest) {
  delete sceneosdrequest_;
  sceneosdrequest_ = sceneosdrequest;
  if (sceneosdrequest) {
    set_has_sceneosdrequest();
  } else {
    clear_has_sceneosdrequest();
  }
}

// optional .vmsg.CSEquipRequest EquipRequest = 7;
inline bool VCli2LogicSvrMsg::has_equiprequest() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_equiprequest() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VCli2LogicSvrMsg::clear_has_equiprequest() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VCli2LogicSvrMsg::clear_equiprequest() {
  if (equiprequest_ != NULL) equiprequest_->::vmsg::CSEquipRequest::Clear();
  clear_has_equiprequest();
}
inline const ::vmsg::CSEquipRequest& VCli2LogicSvrMsg::equiprequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equiprequest_ != NULL ? *equiprequest_ : *default_instance().equiprequest_;
#else
  return equiprequest_ != NULL ? *equiprequest_ : *default_instance_->equiprequest_;
#endif
}
inline ::vmsg::CSEquipRequest* VCli2LogicSvrMsg::mutable_equiprequest() {
  set_has_equiprequest();
  if (equiprequest_ == NULL) equiprequest_ = new ::vmsg::CSEquipRequest;
  return equiprequest_;
}
inline ::vmsg::CSEquipRequest* VCli2LogicSvrMsg::release_equiprequest() {
  clear_has_equiprequest();
  ::vmsg::CSEquipRequest* temp = equiprequest_;
  equiprequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_equiprequest(::vmsg::CSEquipRequest* equiprequest) {
  delete equiprequest_;
  equiprequest_ = equiprequest;
  if (equiprequest) {
    set_has_equiprequest();
  } else {
    clear_has_equiprequest();
  }
}

// optional .vmsg.CSTaskRequest TaskRequest = 8;
inline bool VCli2LogicSvrMsg::has_taskrequest() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_taskrequest() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VCli2LogicSvrMsg::clear_has_taskrequest() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VCli2LogicSvrMsg::clear_taskrequest() {
  if (taskrequest_ != NULL) taskrequest_->::vmsg::CSTaskRequest::Clear();
  clear_has_taskrequest();
}
inline const ::vmsg::CSTaskRequest& VCli2LogicSvrMsg::taskrequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return taskrequest_ != NULL ? *taskrequest_ : *default_instance().taskrequest_;
#else
  return taskrequest_ != NULL ? *taskrequest_ : *default_instance_->taskrequest_;
#endif
}
inline ::vmsg::CSTaskRequest* VCli2LogicSvrMsg::mutable_taskrequest() {
  set_has_taskrequest();
  if (taskrequest_ == NULL) taskrequest_ = new ::vmsg::CSTaskRequest;
  return taskrequest_;
}
inline ::vmsg::CSTaskRequest* VCli2LogicSvrMsg::release_taskrequest() {
  clear_has_taskrequest();
  ::vmsg::CSTaskRequest* temp = taskrequest_;
  taskrequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_taskrequest(::vmsg::CSTaskRequest* taskrequest) {
  delete taskrequest_;
  taskrequest_ = taskrequest;
  if (taskrequest) {
    set_has_taskrequest();
  } else {
    clear_has_taskrequest();
  }
}

// optional .vmsg.CSRankRequest RankRequest = 9;
inline bool VCli2LogicSvrMsg::has_rankrequest() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_rankrequest() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VCli2LogicSvrMsg::clear_has_rankrequest() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VCli2LogicSvrMsg::clear_rankrequest() {
  if (rankrequest_ != NULL) rankrequest_->::vmsg::CSRankRequest::Clear();
  clear_has_rankrequest();
}
inline const ::vmsg::CSRankRequest& VCli2LogicSvrMsg::rankrequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return rankrequest_ != NULL ? *rankrequest_ : *default_instance().rankrequest_;
#else
  return rankrequest_ != NULL ? *rankrequest_ : *default_instance_->rankrequest_;
#endif
}
inline ::vmsg::CSRankRequest* VCli2LogicSvrMsg::mutable_rankrequest() {
  set_has_rankrequest();
  if (rankrequest_ == NULL) rankrequest_ = new ::vmsg::CSRankRequest;
  return rankrequest_;
}
inline ::vmsg::CSRankRequest* VCli2LogicSvrMsg::release_rankrequest() {
  clear_has_rankrequest();
  ::vmsg::CSRankRequest* temp = rankrequest_;
  rankrequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_rankrequest(::vmsg::CSRankRequest* rankrequest) {
  delete rankrequest_;
  rankrequest_ = rankrequest;
  if (rankrequest) {
    set_has_rankrequest();
  } else {
    clear_has_rankrequest();
  }
}

// optional .vmsg.CSWeaponRequest WeaponRequest = 10;
inline bool VCli2LogicSvrMsg::has_weaponrequest() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_weaponrequest() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VCli2LogicSvrMsg::clear_has_weaponrequest() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VCli2LogicSvrMsg::clear_weaponrequest() {
  if (weaponrequest_ != NULL) weaponrequest_->::vmsg::CSWeaponRequest::Clear();
  clear_has_weaponrequest();
}
inline const ::vmsg::CSWeaponRequest& VCli2LogicSvrMsg::weaponrequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return weaponrequest_ != NULL ? *weaponrequest_ : *default_instance().weaponrequest_;
#else
  return weaponrequest_ != NULL ? *weaponrequest_ : *default_instance_->weaponrequest_;
#endif
}
inline ::vmsg::CSWeaponRequest* VCli2LogicSvrMsg::mutable_weaponrequest() {
  set_has_weaponrequest();
  if (weaponrequest_ == NULL) weaponrequest_ = new ::vmsg::CSWeaponRequest;
  return weaponrequest_;
}
inline ::vmsg::CSWeaponRequest* VCli2LogicSvrMsg::release_weaponrequest() {
  clear_has_weaponrequest();
  ::vmsg::CSWeaponRequest* temp = weaponrequest_;
  weaponrequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_weaponrequest(::vmsg::CSWeaponRequest* weaponrequest) {
  delete weaponrequest_;
  weaponrequest_ = weaponrequest;
  if (weaponrequest) {
    set_has_weaponrequest();
  } else {
    clear_has_weaponrequest();
  }
}

// optional .vmsg.CSGoldRequest GoldRequest = 11;
inline bool VCli2LogicSvrMsg::has_goldrequest() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_goldrequest() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VCli2LogicSvrMsg::clear_has_goldrequest() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VCli2LogicSvrMsg::clear_goldrequest() {
  if (goldrequest_ != NULL) goldrequest_->::vmsg::CSGoldRequest::Clear();
  clear_has_goldrequest();
}
inline const ::vmsg::CSGoldRequest& VCli2LogicSvrMsg::goldrequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return goldrequest_ != NULL ? *goldrequest_ : *default_instance().goldrequest_;
#else
  return goldrequest_ != NULL ? *goldrequest_ : *default_instance_->goldrequest_;
#endif
}
inline ::vmsg::CSGoldRequest* VCli2LogicSvrMsg::mutable_goldrequest() {
  set_has_goldrequest();
  if (goldrequest_ == NULL) goldrequest_ = new ::vmsg::CSGoldRequest;
  return goldrequest_;
}
inline ::vmsg::CSGoldRequest* VCli2LogicSvrMsg::release_goldrequest() {
  clear_has_goldrequest();
  ::vmsg::CSGoldRequest* temp = goldrequest_;
  goldrequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_goldrequest(::vmsg::CSGoldRequest* goldrequest) {
  delete goldrequest_;
  goldrequest_ = goldrequest;
  if (goldrequest) {
    set_has_goldrequest();
  } else {
    clear_has_goldrequest();
  }
}

// optional .vmsg.CSItemRequest ItemRequest = 12;
inline bool VCli2LogicSvrMsg::has_itemrequest() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_itemrequest() {
  _has_bits_[0] |= 0x00000200u;
}
inline void VCli2LogicSvrMsg::clear_has_itemrequest() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void VCli2LogicSvrMsg::clear_itemrequest() {
  if (itemrequest_ != NULL) itemrequest_->::vmsg::CSItemRequest::Clear();
  clear_has_itemrequest();
}
inline const ::vmsg::CSItemRequest& VCli2LogicSvrMsg::itemrequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return itemrequest_ != NULL ? *itemrequest_ : *default_instance().itemrequest_;
#else
  return itemrequest_ != NULL ? *itemrequest_ : *default_instance_->itemrequest_;
#endif
}
inline ::vmsg::CSItemRequest* VCli2LogicSvrMsg::mutable_itemrequest() {
  set_has_itemrequest();
  if (itemrequest_ == NULL) itemrequest_ = new ::vmsg::CSItemRequest;
  return itemrequest_;
}
inline ::vmsg::CSItemRequest* VCli2LogicSvrMsg::release_itemrequest() {
  clear_has_itemrequest();
  ::vmsg::CSItemRequest* temp = itemrequest_;
  itemrequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_itemrequest(::vmsg::CSItemRequest* itemrequest) {
  delete itemrequest_;
  itemrequest_ = itemrequest;
  if (itemrequest) {
    set_has_itemrequest();
  } else {
    clear_has_itemrequest();
  }
}

// optional .vmsg.CSWarMapRequest WarMapRequest = 13;
inline bool VCli2LogicSvrMsg::has_warmaprequest() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_warmaprequest() {
  _has_bits_[0] |= 0x00000400u;
}
inline void VCli2LogicSvrMsg::clear_has_warmaprequest() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void VCli2LogicSvrMsg::clear_warmaprequest() {
  if (warmaprequest_ != NULL) warmaprequest_->::vmsg::CSWarMapRequest::Clear();
  clear_has_warmaprequest();
}
inline const ::vmsg::CSWarMapRequest& VCli2LogicSvrMsg::warmaprequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return warmaprequest_ != NULL ? *warmaprequest_ : *default_instance().warmaprequest_;
#else
  return warmaprequest_ != NULL ? *warmaprequest_ : *default_instance_->warmaprequest_;
#endif
}
inline ::vmsg::CSWarMapRequest* VCli2LogicSvrMsg::mutable_warmaprequest() {
  set_has_warmaprequest();
  if (warmaprequest_ == NULL) warmaprequest_ = new ::vmsg::CSWarMapRequest;
  return warmaprequest_;
}
inline ::vmsg::CSWarMapRequest* VCli2LogicSvrMsg::release_warmaprequest() {
  clear_has_warmaprequest();
  ::vmsg::CSWarMapRequest* temp = warmaprequest_;
  warmaprequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_warmaprequest(::vmsg::CSWarMapRequest* warmaprequest) {
  delete warmaprequest_;
  warmaprequest_ = warmaprequest;
  if (warmaprequest) {
    set_has_warmaprequest();
  } else {
    clear_has_warmaprequest();
  }
}

// optional .vmsg.CSFriendRequest FriendRequest = 14;
inline bool VCli2LogicSvrMsg::has_friendrequest() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_friendrequest() {
  _has_bits_[0] |= 0x00000800u;
}
inline void VCli2LogicSvrMsg::clear_has_friendrequest() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void VCli2LogicSvrMsg::clear_friendrequest() {
  if (friendrequest_ != NULL) friendrequest_->::vmsg::CSFriendRequest::Clear();
  clear_has_friendrequest();
}
inline const ::vmsg::CSFriendRequest& VCli2LogicSvrMsg::friendrequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return friendrequest_ != NULL ? *friendrequest_ : *default_instance().friendrequest_;
#else
  return friendrequest_ != NULL ? *friendrequest_ : *default_instance_->friendrequest_;
#endif
}
inline ::vmsg::CSFriendRequest* VCli2LogicSvrMsg::mutable_friendrequest() {
  set_has_friendrequest();
  if (friendrequest_ == NULL) friendrequest_ = new ::vmsg::CSFriendRequest;
  return friendrequest_;
}
inline ::vmsg::CSFriendRequest* VCli2LogicSvrMsg::release_friendrequest() {
  clear_has_friendrequest();
  ::vmsg::CSFriendRequest* temp = friendrequest_;
  friendrequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_friendrequest(::vmsg::CSFriendRequest* friendrequest) {
  delete friendrequest_;
  friendrequest_ = friendrequest;
  if (friendrequest) {
    set_has_friendrequest();
  } else {
    clear_has_friendrequest();
  }
}

// optional .vmsg.CSGuildRequest GuildRequest = 15;
inline bool VCli2LogicSvrMsg::has_guildrequest() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_guildrequest() {
  _has_bits_[0] |= 0x00001000u;
}
inline void VCli2LogicSvrMsg::clear_has_guildrequest() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void VCli2LogicSvrMsg::clear_guildrequest() {
  if (guildrequest_ != NULL) guildrequest_->::vmsg::CSGuildRequest::Clear();
  clear_has_guildrequest();
}
inline const ::vmsg::CSGuildRequest& VCli2LogicSvrMsg::guildrequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return guildrequest_ != NULL ? *guildrequest_ : *default_instance().guildrequest_;
#else
  return guildrequest_ != NULL ? *guildrequest_ : *default_instance_->guildrequest_;
#endif
}
inline ::vmsg::CSGuildRequest* VCli2LogicSvrMsg::mutable_guildrequest() {
  set_has_guildrequest();
  if (guildrequest_ == NULL) guildrequest_ = new ::vmsg::CSGuildRequest;
  return guildrequest_;
}
inline ::vmsg::CSGuildRequest* VCli2LogicSvrMsg::release_guildrequest() {
  clear_has_guildrequest();
  ::vmsg::CSGuildRequest* temp = guildrequest_;
  guildrequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_guildrequest(::vmsg::CSGuildRequest* guildrequest) {
  delete guildrequest_;
  guildrequest_ = guildrequest;
  if (guildrequest) {
    set_has_guildrequest();
  } else {
    clear_has_guildrequest();
  }
}

// optional .vmsg.CSMailRequest MailRequest = 16;
inline bool VCli2LogicSvrMsg::has_mailrequest() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_mailrequest() {
  _has_bits_[0] |= 0x00002000u;
}
inline void VCli2LogicSvrMsg::clear_has_mailrequest() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void VCli2LogicSvrMsg::clear_mailrequest() {
  if (mailrequest_ != NULL) mailrequest_->::vmsg::CSMailRequest::Clear();
  clear_has_mailrequest();
}
inline const ::vmsg::CSMailRequest& VCli2LogicSvrMsg::mailrequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return mailrequest_ != NULL ? *mailrequest_ : *default_instance().mailrequest_;
#else
  return mailrequest_ != NULL ? *mailrequest_ : *default_instance_->mailrequest_;
#endif
}
inline ::vmsg::CSMailRequest* VCli2LogicSvrMsg::mutable_mailrequest() {
  set_has_mailrequest();
  if (mailrequest_ == NULL) mailrequest_ = new ::vmsg::CSMailRequest;
  return mailrequest_;
}
inline ::vmsg::CSMailRequest* VCli2LogicSvrMsg::release_mailrequest() {
  clear_has_mailrequest();
  ::vmsg::CSMailRequest* temp = mailrequest_;
  mailrequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_mailrequest(::vmsg::CSMailRequest* mailrequest) {
  delete mailrequest_;
  mailrequest_ = mailrequest;
  if (mailrequest) {
    set_has_mailrequest();
  } else {
    clear_has_mailrequest();
  }
}

// optional .vmsg.CSInfiniteRequest InfiniteRequest = 17;
inline bool VCli2LogicSvrMsg::has_infiniterequest() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_infiniterequest() {
  _has_bits_[0] |= 0x00004000u;
}
inline void VCli2LogicSvrMsg::clear_has_infiniterequest() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void VCli2LogicSvrMsg::clear_infiniterequest() {
  if (infiniterequest_ != NULL) infiniterequest_->::vmsg::CSInfiniteRequest::Clear();
  clear_has_infiniterequest();
}
inline const ::vmsg::CSInfiniteRequest& VCli2LogicSvrMsg::infiniterequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return infiniterequest_ != NULL ? *infiniterequest_ : *default_instance().infiniterequest_;
#else
  return infiniterequest_ != NULL ? *infiniterequest_ : *default_instance_->infiniterequest_;
#endif
}
inline ::vmsg::CSInfiniteRequest* VCli2LogicSvrMsg::mutable_infiniterequest() {
  set_has_infiniterequest();
  if (infiniterequest_ == NULL) infiniterequest_ = new ::vmsg::CSInfiniteRequest;
  return infiniterequest_;
}
inline ::vmsg::CSInfiniteRequest* VCli2LogicSvrMsg::release_infiniterequest() {
  clear_has_infiniterequest();
  ::vmsg::CSInfiniteRequest* temp = infiniterequest_;
  infiniterequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_infiniterequest(::vmsg::CSInfiniteRequest* infiniterequest) {
  delete infiniterequest_;
  infiniterequest_ = infiniterequest;
  if (infiniterequest) {
    set_has_infiniterequest();
  } else {
    clear_has_infiniterequest();
  }
}

// optional .vmsg.CSChatRequest ChatRequest = 18;
inline bool VCli2LogicSvrMsg::has_chatrequest() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_chatrequest() {
  _has_bits_[0] |= 0x00008000u;
}
inline void VCli2LogicSvrMsg::clear_has_chatrequest() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void VCli2LogicSvrMsg::clear_chatrequest() {
  if (chatrequest_ != NULL) chatrequest_->::vmsg::CSChatRequest::Clear();
  clear_has_chatrequest();
}
inline const ::vmsg::CSChatRequest& VCli2LogicSvrMsg::chatrequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return chatrequest_ != NULL ? *chatrequest_ : *default_instance().chatrequest_;
#else
  return chatrequest_ != NULL ? *chatrequest_ : *default_instance_->chatrequest_;
#endif
}
inline ::vmsg::CSChatRequest* VCli2LogicSvrMsg::mutable_chatrequest() {
  set_has_chatrequest();
  if (chatrequest_ == NULL) chatrequest_ = new ::vmsg::CSChatRequest;
  return chatrequest_;
}
inline ::vmsg::CSChatRequest* VCli2LogicSvrMsg::release_chatrequest() {
  clear_has_chatrequest();
  ::vmsg::CSChatRequest* temp = chatrequest_;
  chatrequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_chatrequest(::vmsg::CSChatRequest* chatrequest) {
  delete chatrequest_;
  chatrequest_ = chatrequest;
  if (chatrequest) {
    set_has_chatrequest();
  } else {
    clear_has_chatrequest();
  }
}

// optional .vmsg.CSCVZRequest CVZRequest = 19;
inline bool VCli2LogicSvrMsg::has_cvzrequest() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_cvzrequest() {
  _has_bits_[0] |= 0x00010000u;
}
inline void VCli2LogicSvrMsg::clear_has_cvzrequest() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void VCli2LogicSvrMsg::clear_cvzrequest() {
  if (cvzrequest_ != NULL) cvzrequest_->::vmsg::CSCVZRequest::Clear();
  clear_has_cvzrequest();
}
inline const ::vmsg::CSCVZRequest& VCli2LogicSvrMsg::cvzrequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cvzrequest_ != NULL ? *cvzrequest_ : *default_instance().cvzrequest_;
#else
  return cvzrequest_ != NULL ? *cvzrequest_ : *default_instance_->cvzrequest_;
#endif
}
inline ::vmsg::CSCVZRequest* VCli2LogicSvrMsg::mutable_cvzrequest() {
  set_has_cvzrequest();
  if (cvzrequest_ == NULL) cvzrequest_ = new ::vmsg::CSCVZRequest;
  return cvzrequest_;
}
inline ::vmsg::CSCVZRequest* VCli2LogicSvrMsg::release_cvzrequest() {
  clear_has_cvzrequest();
  ::vmsg::CSCVZRequest* temp = cvzrequest_;
  cvzrequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_cvzrequest(::vmsg::CSCVZRequest* cvzrequest) {
  delete cvzrequest_;
  cvzrequest_ = cvzrequest;
  if (cvzrequest) {
    set_has_cvzrequest();
  } else {
    clear_has_cvzrequest();
  }
}

// optional .vmsg.CSServerNotifyRequest ServerNotifyRequest = 20;
inline bool VCli2LogicSvrMsg::has_servernotifyrequest() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_servernotifyrequest() {
  _has_bits_[0] |= 0x00020000u;
}
inline void VCli2LogicSvrMsg::clear_has_servernotifyrequest() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void VCli2LogicSvrMsg::clear_servernotifyrequest() {
  if (servernotifyrequest_ != NULL) servernotifyrequest_->::vmsg::CSServerNotifyRequest::Clear();
  clear_has_servernotifyrequest();
}
inline const ::vmsg::CSServerNotifyRequest& VCli2LogicSvrMsg::servernotifyrequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return servernotifyrequest_ != NULL ? *servernotifyrequest_ : *default_instance().servernotifyrequest_;
#else
  return servernotifyrequest_ != NULL ? *servernotifyrequest_ : *default_instance_->servernotifyrequest_;
#endif
}
inline ::vmsg::CSServerNotifyRequest* VCli2LogicSvrMsg::mutable_servernotifyrequest() {
  set_has_servernotifyrequest();
  if (servernotifyrequest_ == NULL) servernotifyrequest_ = new ::vmsg::CSServerNotifyRequest;
  return servernotifyrequest_;
}
inline ::vmsg::CSServerNotifyRequest* VCli2LogicSvrMsg::release_servernotifyrequest() {
  clear_has_servernotifyrequest();
  ::vmsg::CSServerNotifyRequest* temp = servernotifyrequest_;
  servernotifyrequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_servernotifyrequest(::vmsg::CSServerNotifyRequest* servernotifyrequest) {
  delete servernotifyrequest_;
  servernotifyrequest_ = servernotifyrequest;
  if (servernotifyrequest) {
    set_has_servernotifyrequest();
  } else {
    clear_has_servernotifyrequest();
  }
}

// optional .vmsg.CSDailyGiftRequest DailyGiftRequest = 21;
inline bool VCli2LogicSvrMsg::has_dailygiftrequest() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_dailygiftrequest() {
  _has_bits_[0] |= 0x00040000u;
}
inline void VCli2LogicSvrMsg::clear_has_dailygiftrequest() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void VCli2LogicSvrMsg::clear_dailygiftrequest() {
  if (dailygiftrequest_ != NULL) dailygiftrequest_->::vmsg::CSDailyGiftRequest::Clear();
  clear_has_dailygiftrequest();
}
inline const ::vmsg::CSDailyGiftRequest& VCli2LogicSvrMsg::dailygiftrequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dailygiftrequest_ != NULL ? *dailygiftrequest_ : *default_instance().dailygiftrequest_;
#else
  return dailygiftrequest_ != NULL ? *dailygiftrequest_ : *default_instance_->dailygiftrequest_;
#endif
}
inline ::vmsg::CSDailyGiftRequest* VCli2LogicSvrMsg::mutable_dailygiftrequest() {
  set_has_dailygiftrequest();
  if (dailygiftrequest_ == NULL) dailygiftrequest_ = new ::vmsg::CSDailyGiftRequest;
  return dailygiftrequest_;
}
inline ::vmsg::CSDailyGiftRequest* VCli2LogicSvrMsg::release_dailygiftrequest() {
  clear_has_dailygiftrequest();
  ::vmsg::CSDailyGiftRequest* temp = dailygiftrequest_;
  dailygiftrequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_dailygiftrequest(::vmsg::CSDailyGiftRequest* dailygiftrequest) {
  delete dailygiftrequest_;
  dailygiftrequest_ = dailygiftrequest;
  if (dailygiftrequest) {
    set_has_dailygiftrequest();
  } else {
    clear_has_dailygiftrequest();
  }
}

// optional .vmsg.CSArenaRequest ArenaRequest = 22;
inline bool VCli2LogicSvrMsg::has_arenarequest() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_arenarequest() {
  _has_bits_[0] |= 0x00080000u;
}
inline void VCli2LogicSvrMsg::clear_has_arenarequest() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void VCli2LogicSvrMsg::clear_arenarequest() {
  if (arenarequest_ != NULL) arenarequest_->::vmsg::CSArenaRequest::Clear();
  clear_has_arenarequest();
}
inline const ::vmsg::CSArenaRequest& VCli2LogicSvrMsg::arenarequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return arenarequest_ != NULL ? *arenarequest_ : *default_instance().arenarequest_;
#else
  return arenarequest_ != NULL ? *arenarequest_ : *default_instance_->arenarequest_;
#endif
}
inline ::vmsg::CSArenaRequest* VCli2LogicSvrMsg::mutable_arenarequest() {
  set_has_arenarequest();
  if (arenarequest_ == NULL) arenarequest_ = new ::vmsg::CSArenaRequest;
  return arenarequest_;
}
inline ::vmsg::CSArenaRequest* VCli2LogicSvrMsg::release_arenarequest() {
  clear_has_arenarequest();
  ::vmsg::CSArenaRequest* temp = arenarequest_;
  arenarequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_arenarequest(::vmsg::CSArenaRequest* arenarequest) {
  delete arenarequest_;
  arenarequest_ = arenarequest;
  if (arenarequest) {
    set_has_arenarequest();
  } else {
    clear_has_arenarequest();
  }
}

// optional .vmsg.CSStoreRequest StoreRequest = 23;
inline bool VCli2LogicSvrMsg::has_storerequest() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_storerequest() {
  _has_bits_[0] |= 0x00100000u;
}
inline void VCli2LogicSvrMsg::clear_has_storerequest() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void VCli2LogicSvrMsg::clear_storerequest() {
  if (storerequest_ != NULL) storerequest_->::vmsg::CSStoreRequest::Clear();
  clear_has_storerequest();
}
inline const ::vmsg::CSStoreRequest& VCli2LogicSvrMsg::storerequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return storerequest_ != NULL ? *storerequest_ : *default_instance().storerequest_;
#else
  return storerequest_ != NULL ? *storerequest_ : *default_instance_->storerequest_;
#endif
}
inline ::vmsg::CSStoreRequest* VCli2LogicSvrMsg::mutable_storerequest() {
  set_has_storerequest();
  if (storerequest_ == NULL) storerequest_ = new ::vmsg::CSStoreRequest;
  return storerequest_;
}
inline ::vmsg::CSStoreRequest* VCli2LogicSvrMsg::release_storerequest() {
  clear_has_storerequest();
  ::vmsg::CSStoreRequest* temp = storerequest_;
  storerequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_storerequest(::vmsg::CSStoreRequest* storerequest) {
  delete storerequest_;
  storerequest_ = storerequest;
  if (storerequest) {
    set_has_storerequest();
  } else {
    clear_has_storerequest();
  }
}

// optional .vmsg.CSQiangHunRequest QiangHunRequest = 24;
inline bool VCli2LogicSvrMsg::has_qianghunrequest() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_qianghunrequest() {
  _has_bits_[0] |= 0x00200000u;
}
inline void VCli2LogicSvrMsg::clear_has_qianghunrequest() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void VCli2LogicSvrMsg::clear_qianghunrequest() {
  if (qianghunrequest_ != NULL) qianghunrequest_->::vmsg::CSQiangHunRequest::Clear();
  clear_has_qianghunrequest();
}
inline const ::vmsg::CSQiangHunRequest& VCli2LogicSvrMsg::qianghunrequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return qianghunrequest_ != NULL ? *qianghunrequest_ : *default_instance().qianghunrequest_;
#else
  return qianghunrequest_ != NULL ? *qianghunrequest_ : *default_instance_->qianghunrequest_;
#endif
}
inline ::vmsg::CSQiangHunRequest* VCli2LogicSvrMsg::mutable_qianghunrequest() {
  set_has_qianghunrequest();
  if (qianghunrequest_ == NULL) qianghunrequest_ = new ::vmsg::CSQiangHunRequest;
  return qianghunrequest_;
}
inline ::vmsg::CSQiangHunRequest* VCli2LogicSvrMsg::release_qianghunrequest() {
  clear_has_qianghunrequest();
  ::vmsg::CSQiangHunRequest* temp = qianghunrequest_;
  qianghunrequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_qianghunrequest(::vmsg::CSQiangHunRequest* qianghunrequest) {
  delete qianghunrequest_;
  qianghunrequest_ = qianghunrequest;
  if (qianghunrequest) {
    set_has_qianghunrequest();
  } else {
    clear_has_qianghunrequest();
  }
}

// optional .vmsg.CSDebrisRequest DebrisRequest = 25;
inline bool VCli2LogicSvrMsg::has_debrisrequest() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_debrisrequest() {
  _has_bits_[0] |= 0x00400000u;
}
inline void VCli2LogicSvrMsg::clear_has_debrisrequest() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void VCli2LogicSvrMsg::clear_debrisrequest() {
  if (debrisrequest_ != NULL) debrisrequest_->::vmsg::CSDebrisRequest::Clear();
  clear_has_debrisrequest();
}
inline const ::vmsg::CSDebrisRequest& VCli2LogicSvrMsg::debrisrequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return debrisrequest_ != NULL ? *debrisrequest_ : *default_instance().debrisrequest_;
#else
  return debrisrequest_ != NULL ? *debrisrequest_ : *default_instance_->debrisrequest_;
#endif
}
inline ::vmsg::CSDebrisRequest* VCli2LogicSvrMsg::mutable_debrisrequest() {
  set_has_debrisrequest();
  if (debrisrequest_ == NULL) debrisrequest_ = new ::vmsg::CSDebrisRequest;
  return debrisrequest_;
}
inline ::vmsg::CSDebrisRequest* VCli2LogicSvrMsg::release_debrisrequest() {
  clear_has_debrisrequest();
  ::vmsg::CSDebrisRequest* temp = debrisrequest_;
  debrisrequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_debrisrequest(::vmsg::CSDebrisRequest* debrisrequest) {
  delete debrisrequest_;
  debrisrequest_ = debrisrequest;
  if (debrisrequest) {
    set_has_debrisrequest();
  } else {
    clear_has_debrisrequest();
  }
}

// optional .vmsg.CSActRequest ActRequest = 26;
inline bool VCli2LogicSvrMsg::has_actrequest() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_actrequest() {
  _has_bits_[0] |= 0x00800000u;
}
inline void VCli2LogicSvrMsg::clear_has_actrequest() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void VCli2LogicSvrMsg::clear_actrequest() {
  if (actrequest_ != NULL) actrequest_->::vmsg::CSActRequest::Clear();
  clear_has_actrequest();
}
inline const ::vmsg::CSActRequest& VCli2LogicSvrMsg::actrequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return actrequest_ != NULL ? *actrequest_ : *default_instance().actrequest_;
#else
  return actrequest_ != NULL ? *actrequest_ : *default_instance_->actrequest_;
#endif
}
inline ::vmsg::CSActRequest* VCli2LogicSvrMsg::mutable_actrequest() {
  set_has_actrequest();
  if (actrequest_ == NULL) actrequest_ = new ::vmsg::CSActRequest;
  return actrequest_;
}
inline ::vmsg::CSActRequest* VCli2LogicSvrMsg::release_actrequest() {
  clear_has_actrequest();
  ::vmsg::CSActRequest* temp = actrequest_;
  actrequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_actrequest(::vmsg::CSActRequest* actrequest) {
  delete actrequest_;
  actrequest_ = actrequest;
  if (actrequest) {
    set_has_actrequest();
  } else {
    clear_has_actrequest();
  }
}

// optional .vmsg.CSDotaItemRequest DotaItemRequest = 27;
inline bool VCli2LogicSvrMsg::has_dotaitemrequest() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_dotaitemrequest() {
  _has_bits_[0] |= 0x01000000u;
}
inline void VCli2LogicSvrMsg::clear_has_dotaitemrequest() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void VCli2LogicSvrMsg::clear_dotaitemrequest() {
  if (dotaitemrequest_ != NULL) dotaitemrequest_->::vmsg::CSDotaItemRequest::Clear();
  clear_has_dotaitemrequest();
}
inline const ::vmsg::CSDotaItemRequest& VCli2LogicSvrMsg::dotaitemrequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dotaitemrequest_ != NULL ? *dotaitemrequest_ : *default_instance().dotaitemrequest_;
#else
  return dotaitemrequest_ != NULL ? *dotaitemrequest_ : *default_instance_->dotaitemrequest_;
#endif
}
inline ::vmsg::CSDotaItemRequest* VCli2LogicSvrMsg::mutable_dotaitemrequest() {
  set_has_dotaitemrequest();
  if (dotaitemrequest_ == NULL) dotaitemrequest_ = new ::vmsg::CSDotaItemRequest;
  return dotaitemrequest_;
}
inline ::vmsg::CSDotaItemRequest* VCli2LogicSvrMsg::release_dotaitemrequest() {
  clear_has_dotaitemrequest();
  ::vmsg::CSDotaItemRequest* temp = dotaitemrequest_;
  dotaitemrequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_dotaitemrequest(::vmsg::CSDotaItemRequest* dotaitemrequest) {
  delete dotaitemrequest_;
  dotaitemrequest_ = dotaitemrequest;
  if (dotaitemrequest) {
    set_has_dotaitemrequest();
  } else {
    clear_has_dotaitemrequest();
  }
}

// optional .vmsg.CSCouponRequest CouponRequest = 28;
inline bool VCli2LogicSvrMsg::has_couponrequest() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_couponrequest() {
  _has_bits_[0] |= 0x02000000u;
}
inline void VCli2LogicSvrMsg::clear_has_couponrequest() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void VCli2LogicSvrMsg::clear_couponrequest() {
  if (couponrequest_ != NULL) couponrequest_->::vmsg::CSCouponRequest::Clear();
  clear_has_couponrequest();
}
inline const ::vmsg::CSCouponRequest& VCli2LogicSvrMsg::couponrequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return couponrequest_ != NULL ? *couponrequest_ : *default_instance().couponrequest_;
#else
  return couponrequest_ != NULL ? *couponrequest_ : *default_instance_->couponrequest_;
#endif
}
inline ::vmsg::CSCouponRequest* VCli2LogicSvrMsg::mutable_couponrequest() {
  set_has_couponrequest();
  if (couponrequest_ == NULL) couponrequest_ = new ::vmsg::CSCouponRequest;
  return couponrequest_;
}
inline ::vmsg::CSCouponRequest* VCli2LogicSvrMsg::release_couponrequest() {
  clear_has_couponrequest();
  ::vmsg::CSCouponRequest* temp = couponrequest_;
  couponrequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_couponrequest(::vmsg::CSCouponRequest* couponrequest) {
  delete couponrequest_;
  couponrequest_ = couponrequest;
  if (couponrequest) {
    set_has_couponrequest();
  } else {
    clear_has_couponrequest();
  }
}

// optional .vmsg.CSPanicBuyingStoreRequest PanicBuyingRequst = 29;
inline bool VCli2LogicSvrMsg::has_panicbuyingrequst() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_panicbuyingrequst() {
  _has_bits_[0] |= 0x04000000u;
}
inline void VCli2LogicSvrMsg::clear_has_panicbuyingrequst() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void VCli2LogicSvrMsg::clear_panicbuyingrequst() {
  if (panicbuyingrequst_ != NULL) panicbuyingrequst_->::vmsg::CSPanicBuyingStoreRequest::Clear();
  clear_has_panicbuyingrequst();
}
inline const ::vmsg::CSPanicBuyingStoreRequest& VCli2LogicSvrMsg::panicbuyingrequst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return panicbuyingrequst_ != NULL ? *panicbuyingrequst_ : *default_instance().panicbuyingrequst_;
#else
  return panicbuyingrequst_ != NULL ? *panicbuyingrequst_ : *default_instance_->panicbuyingrequst_;
#endif
}
inline ::vmsg::CSPanicBuyingStoreRequest* VCli2LogicSvrMsg::mutable_panicbuyingrequst() {
  set_has_panicbuyingrequst();
  if (panicbuyingrequst_ == NULL) panicbuyingrequst_ = new ::vmsg::CSPanicBuyingStoreRequest;
  return panicbuyingrequst_;
}
inline ::vmsg::CSPanicBuyingStoreRequest* VCli2LogicSvrMsg::release_panicbuyingrequst() {
  clear_has_panicbuyingrequst();
  ::vmsg::CSPanicBuyingStoreRequest* temp = panicbuyingrequst_;
  panicbuyingrequst_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_panicbuyingrequst(::vmsg::CSPanicBuyingStoreRequest* panicbuyingrequst) {
  delete panicbuyingrequst_;
  panicbuyingrequst_ = panicbuyingrequst;
  if (panicbuyingrequst) {
    set_has_panicbuyingrequst();
  } else {
    clear_has_panicbuyingrequst();
  }
}

// optional .vmsg.CSUMemDeviceTokenReport DeviceTokenReport = 30;
inline bool VCli2LogicSvrMsg::has_devicetokenreport() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_devicetokenreport() {
  _has_bits_[0] |= 0x08000000u;
}
inline void VCli2LogicSvrMsg::clear_has_devicetokenreport() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void VCli2LogicSvrMsg::clear_devicetokenreport() {
  if (devicetokenreport_ != NULL) devicetokenreport_->::vmsg::CSUMemDeviceTokenReport::Clear();
  clear_has_devicetokenreport();
}
inline const ::vmsg::CSUMemDeviceTokenReport& VCli2LogicSvrMsg::devicetokenreport() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return devicetokenreport_ != NULL ? *devicetokenreport_ : *default_instance().devicetokenreport_;
#else
  return devicetokenreport_ != NULL ? *devicetokenreport_ : *default_instance_->devicetokenreport_;
#endif
}
inline ::vmsg::CSUMemDeviceTokenReport* VCli2LogicSvrMsg::mutable_devicetokenreport() {
  set_has_devicetokenreport();
  if (devicetokenreport_ == NULL) devicetokenreport_ = new ::vmsg::CSUMemDeviceTokenReport;
  return devicetokenreport_;
}
inline ::vmsg::CSUMemDeviceTokenReport* VCli2LogicSvrMsg::release_devicetokenreport() {
  clear_has_devicetokenreport();
  ::vmsg::CSUMemDeviceTokenReport* temp = devicetokenreport_;
  devicetokenreport_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_devicetokenreport(::vmsg::CSUMemDeviceTokenReport* devicetokenreport) {
  delete devicetokenreport_;
  devicetokenreport_ = devicetokenreport;
  if (devicetokenreport) {
    set_has_devicetokenreport();
  } else {
    clear_has_devicetokenreport();
  }
}

// optional .vmsg.CSBossChallengeRqst BossChallengeRqst = 31;
inline bool VCli2LogicSvrMsg::has_bosschallengerqst() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_bosschallengerqst() {
  _has_bits_[0] |= 0x10000000u;
}
inline void VCli2LogicSvrMsg::clear_has_bosschallengerqst() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void VCli2LogicSvrMsg::clear_bosschallengerqst() {
  if (bosschallengerqst_ != NULL) bosschallengerqst_->::vmsg::CSBossChallengeRqst::Clear();
  clear_has_bosschallengerqst();
}
inline const ::vmsg::CSBossChallengeRqst& VCli2LogicSvrMsg::bosschallengerqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bosschallengerqst_ != NULL ? *bosschallengerqst_ : *default_instance().bosschallengerqst_;
#else
  return bosschallengerqst_ != NULL ? *bosschallengerqst_ : *default_instance_->bosschallengerqst_;
#endif
}
inline ::vmsg::CSBossChallengeRqst* VCli2LogicSvrMsg::mutable_bosschallengerqst() {
  set_has_bosschallengerqst();
  if (bosschallengerqst_ == NULL) bosschallengerqst_ = new ::vmsg::CSBossChallengeRqst;
  return bosschallengerqst_;
}
inline ::vmsg::CSBossChallengeRqst* VCli2LogicSvrMsg::release_bosschallengerqst() {
  clear_has_bosschallengerqst();
  ::vmsg::CSBossChallengeRqst* temp = bosschallengerqst_;
  bosschallengerqst_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_bosschallengerqst(::vmsg::CSBossChallengeRqst* bosschallengerqst) {
  delete bosschallengerqst_;
  bosschallengerqst_ = bosschallengerqst;
  if (bosschallengerqst) {
    set_has_bosschallengerqst();
  } else {
    clear_has_bosschallengerqst();
  }
}

// optional .vmsg.CSHeartBeatRqst HeartBeat_Rqst = 100;
inline bool VCli2LogicSvrMsg::has_heartbeat_rqst() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_heartbeat_rqst() {
  _has_bits_[0] |= 0x20000000u;
}
inline void VCli2LogicSvrMsg::clear_has_heartbeat_rqst() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void VCli2LogicSvrMsg::clear_heartbeat_rqst() {
  if (heartbeat_rqst_ != NULL) heartbeat_rqst_->::vmsg::CSHeartBeatRqst::Clear();
  clear_has_heartbeat_rqst();
}
inline const ::vmsg::CSHeartBeatRqst& VCli2LogicSvrMsg::heartbeat_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return heartbeat_rqst_ != NULL ? *heartbeat_rqst_ : *default_instance().heartbeat_rqst_;
#else
  return heartbeat_rqst_ != NULL ? *heartbeat_rqst_ : *default_instance_->heartbeat_rqst_;
#endif
}
inline ::vmsg::CSHeartBeatRqst* VCli2LogicSvrMsg::mutable_heartbeat_rqst() {
  set_has_heartbeat_rqst();
  if (heartbeat_rqst_ == NULL) heartbeat_rqst_ = new ::vmsg::CSHeartBeatRqst;
  return heartbeat_rqst_;
}
inline ::vmsg::CSHeartBeatRqst* VCli2LogicSvrMsg::release_heartbeat_rqst() {
  clear_has_heartbeat_rqst();
  ::vmsg::CSHeartBeatRqst* temp = heartbeat_rqst_;
  heartbeat_rqst_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_heartbeat_rqst(::vmsg::CSHeartBeatRqst* heartbeat_rqst) {
  delete heartbeat_rqst_;
  heartbeat_rqst_ = heartbeat_rqst;
  if (heartbeat_rqst) {
    set_has_heartbeat_rqst();
  } else {
    clear_has_heartbeat_rqst();
  }
}

// optional .vmsg.CSAdminRequest AdminRequest = 101;
inline bool VCli2LogicSvrMsg::has_adminrequest() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_adminrequest() {
  _has_bits_[0] |= 0x40000000u;
}
inline void VCli2LogicSvrMsg::clear_has_adminrequest() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void VCli2LogicSvrMsg::clear_adminrequest() {
  if (adminrequest_ != NULL) adminrequest_->::vmsg::CSAdminRequest::Clear();
  clear_has_adminrequest();
}
inline const ::vmsg::CSAdminRequest& VCli2LogicSvrMsg::adminrequest() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return adminrequest_ != NULL ? *adminrequest_ : *default_instance().adminrequest_;
#else
  return adminrequest_ != NULL ? *adminrequest_ : *default_instance_->adminrequest_;
#endif
}
inline ::vmsg::CSAdminRequest* VCli2LogicSvrMsg::mutable_adminrequest() {
  set_has_adminrequest();
  if (adminrequest_ == NULL) adminrequest_ = new ::vmsg::CSAdminRequest;
  return adminrequest_;
}
inline ::vmsg::CSAdminRequest* VCli2LogicSvrMsg::release_adminrequest() {
  clear_has_adminrequest();
  ::vmsg::CSAdminRequest* temp = adminrequest_;
  adminrequest_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_adminrequest(::vmsg::CSAdminRequest* adminrequest) {
  delete adminrequest_;
  adminrequest_ = adminrequest;
  if (adminrequest) {
    set_has_adminrequest();
  } else {
    clear_has_adminrequest();
  }
}

// optional .vmsg.CSAccountRquest Account_Rqst = 102;
inline bool VCli2LogicSvrMsg::has_account_rqst() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void VCli2LogicSvrMsg::set_has_account_rqst() {
  _has_bits_[0] |= 0x80000000u;
}
inline void VCli2LogicSvrMsg::clear_has_account_rqst() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void VCli2LogicSvrMsg::clear_account_rqst() {
  if (account_rqst_ != NULL) account_rqst_->::vmsg::CSAccountRquest::Clear();
  clear_has_account_rqst();
}
inline const ::vmsg::CSAccountRquest& VCli2LogicSvrMsg::account_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return account_rqst_ != NULL ? *account_rqst_ : *default_instance().account_rqst_;
#else
  return account_rqst_ != NULL ? *account_rqst_ : *default_instance_->account_rqst_;
#endif
}
inline ::vmsg::CSAccountRquest* VCli2LogicSvrMsg::mutable_account_rqst() {
  set_has_account_rqst();
  if (account_rqst_ == NULL) account_rqst_ = new ::vmsg::CSAccountRquest;
  return account_rqst_;
}
inline ::vmsg::CSAccountRquest* VCli2LogicSvrMsg::release_account_rqst() {
  clear_has_account_rqst();
  ::vmsg::CSAccountRquest* temp = account_rqst_;
  account_rqst_ = NULL;
  return temp;
}
inline void VCli2LogicSvrMsg::set_allocated_account_rqst(::vmsg::CSAccountRquest* account_rqst) {
  delete account_rqst_;
  account_rqst_ = account_rqst;
  if (account_rqst) {
    set_has_account_rqst();
  } else {
    clear_has_account_rqst();
  }
}

// -------------------------------------------------------------------

// VLogicSvr2CliMsg

// required .vmsg.MsgHead Msg_Head = 1;
inline bool VLogicSvr2CliMsg::has_msg_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_msg_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VLogicSvr2CliMsg::clear_has_msg_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VLogicSvr2CliMsg::clear_msg_head() {
  if (msg_head_ != NULL) msg_head_->::vmsg::MsgHead::Clear();
  clear_has_msg_head();
}
inline const ::vmsg::MsgHead& VLogicSvr2CliMsg::msg_head() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return msg_head_ != NULL ? *msg_head_ : *default_instance().msg_head_;
#else
  return msg_head_ != NULL ? *msg_head_ : *default_instance_->msg_head_;
#endif
}
inline ::vmsg::MsgHead* VLogicSvr2CliMsg::mutable_msg_head() {
  set_has_msg_head();
  if (msg_head_ == NULL) msg_head_ = new ::vmsg::MsgHead;
  return msg_head_;
}
inline ::vmsg::MsgHead* VLogicSvr2CliMsg::release_msg_head() {
  clear_has_msg_head();
  ::vmsg::MsgHead* temp = msg_head_;
  msg_head_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_msg_head(::vmsg::MsgHead* msg_head) {
  delete msg_head_;
  msg_head_ = msg_head;
  if (msg_head) {
    set_has_msg_head();
  } else {
    clear_has_msg_head();
  }
}

// optional .vmsg.CSCommonErrMsg ErrMsg = 2;
inline bool VLogicSvr2CliMsg::has_errmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_errmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VLogicSvr2CliMsg::clear_has_errmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VLogicSvr2CliMsg::clear_errmsg() {
  if (errmsg_ != NULL) errmsg_->::vmsg::CSCommonErrMsg::Clear();
  clear_has_errmsg();
}
inline const ::vmsg::CSCommonErrMsg& VLogicSvr2CliMsg::errmsg() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return errmsg_ != NULL ? *errmsg_ : *default_instance().errmsg_;
#else
  return errmsg_ != NULL ? *errmsg_ : *default_instance_->errmsg_;
#endif
}
inline ::vmsg::CSCommonErrMsg* VLogicSvr2CliMsg::mutable_errmsg() {
  set_has_errmsg();
  if (errmsg_ == NULL) errmsg_ = new ::vmsg::CSCommonErrMsg;
  return errmsg_;
}
inline ::vmsg::CSCommonErrMsg* VLogicSvr2CliMsg::release_errmsg() {
  clear_has_errmsg();
  ::vmsg::CSCommonErrMsg* temp = errmsg_;
  errmsg_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_errmsg(::vmsg::CSCommonErrMsg* errmsg) {
  delete errmsg_;
  errmsg_ = errmsg;
  if (errmsg) {
    set_has_errmsg();
  } else {
    clear_has_errmsg();
  }
}

// optional .vmsg.CSBagRespond BagRespond = 3;
inline bool VLogicSvr2CliMsg::has_bagrespond() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_bagrespond() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VLogicSvr2CliMsg::clear_has_bagrespond() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VLogicSvr2CliMsg::clear_bagrespond() {
  if (bagrespond_ != NULL) bagrespond_->::vmsg::CSBagRespond::Clear();
  clear_has_bagrespond();
}
inline const ::vmsg::CSBagRespond& VLogicSvr2CliMsg::bagrespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bagrespond_ != NULL ? *bagrespond_ : *default_instance().bagrespond_;
#else
  return bagrespond_ != NULL ? *bagrespond_ : *default_instance_->bagrespond_;
#endif
}
inline ::vmsg::CSBagRespond* VLogicSvr2CliMsg::mutable_bagrespond() {
  set_has_bagrespond();
  if (bagrespond_ == NULL) bagrespond_ = new ::vmsg::CSBagRespond;
  return bagrespond_;
}
inline ::vmsg::CSBagRespond* VLogicSvr2CliMsg::release_bagrespond() {
  clear_has_bagrespond();
  ::vmsg::CSBagRespond* temp = bagrespond_;
  bagrespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_bagrespond(::vmsg::CSBagRespond* bagrespond) {
  delete bagrespond_;
  bagrespond_ = bagrespond;
  if (bagrespond) {
    set_has_bagrespond();
  } else {
    clear_has_bagrespond();
  }
}

// optional .vmsg.CSPlayerRespond PlayerRespond = 5;
inline bool VLogicSvr2CliMsg::has_playerrespond() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_playerrespond() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VLogicSvr2CliMsg::clear_has_playerrespond() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VLogicSvr2CliMsg::clear_playerrespond() {
  if (playerrespond_ != NULL) playerrespond_->::vmsg::CSPlayerRespond::Clear();
  clear_has_playerrespond();
}
inline const ::vmsg::CSPlayerRespond& VLogicSvr2CliMsg::playerrespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerrespond_ != NULL ? *playerrespond_ : *default_instance().playerrespond_;
#else
  return playerrespond_ != NULL ? *playerrespond_ : *default_instance_->playerrespond_;
#endif
}
inline ::vmsg::CSPlayerRespond* VLogicSvr2CliMsg::mutable_playerrespond() {
  set_has_playerrespond();
  if (playerrespond_ == NULL) playerrespond_ = new ::vmsg::CSPlayerRespond;
  return playerrespond_;
}
inline ::vmsg::CSPlayerRespond* VLogicSvr2CliMsg::release_playerrespond() {
  clear_has_playerrespond();
  ::vmsg::CSPlayerRespond* temp = playerrespond_;
  playerrespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_playerrespond(::vmsg::CSPlayerRespond* playerrespond) {
  delete playerrespond_;
  playerrespond_ = playerrespond;
  if (playerrespond) {
    set_has_playerrespond();
  } else {
    clear_has_playerrespond();
  }
}

// optional .vmsg.CSSceneOSDRespond SceneOSDRespond = 6;
inline bool VLogicSvr2CliMsg::has_sceneosdrespond() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_sceneosdrespond() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VLogicSvr2CliMsg::clear_has_sceneosdrespond() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VLogicSvr2CliMsg::clear_sceneosdrespond() {
  if (sceneosdrespond_ != NULL) sceneosdrespond_->::vmsg::CSSceneOSDRespond::Clear();
  clear_has_sceneosdrespond();
}
inline const ::vmsg::CSSceneOSDRespond& VLogicSvr2CliMsg::sceneosdrespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sceneosdrespond_ != NULL ? *sceneosdrespond_ : *default_instance().sceneosdrespond_;
#else
  return sceneosdrespond_ != NULL ? *sceneosdrespond_ : *default_instance_->sceneosdrespond_;
#endif
}
inline ::vmsg::CSSceneOSDRespond* VLogicSvr2CliMsg::mutable_sceneosdrespond() {
  set_has_sceneosdrespond();
  if (sceneosdrespond_ == NULL) sceneosdrespond_ = new ::vmsg::CSSceneOSDRespond;
  return sceneosdrespond_;
}
inline ::vmsg::CSSceneOSDRespond* VLogicSvr2CliMsg::release_sceneosdrespond() {
  clear_has_sceneosdrespond();
  ::vmsg::CSSceneOSDRespond* temp = sceneosdrespond_;
  sceneosdrespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_sceneosdrespond(::vmsg::CSSceneOSDRespond* sceneosdrespond) {
  delete sceneosdrespond_;
  sceneosdrespond_ = sceneosdrespond;
  if (sceneosdrespond) {
    set_has_sceneosdrespond();
  } else {
    clear_has_sceneosdrespond();
  }
}

// optional .vmsg.CSEquipRespond EquipRespond = 7;
inline bool VLogicSvr2CliMsg::has_equiprespond() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_equiprespond() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VLogicSvr2CliMsg::clear_has_equiprespond() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VLogicSvr2CliMsg::clear_equiprespond() {
  if (equiprespond_ != NULL) equiprespond_->::vmsg::CSEquipRespond::Clear();
  clear_has_equiprespond();
}
inline const ::vmsg::CSEquipRespond& VLogicSvr2CliMsg::equiprespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equiprespond_ != NULL ? *equiprespond_ : *default_instance().equiprespond_;
#else
  return equiprespond_ != NULL ? *equiprespond_ : *default_instance_->equiprespond_;
#endif
}
inline ::vmsg::CSEquipRespond* VLogicSvr2CliMsg::mutable_equiprespond() {
  set_has_equiprespond();
  if (equiprespond_ == NULL) equiprespond_ = new ::vmsg::CSEquipRespond;
  return equiprespond_;
}
inline ::vmsg::CSEquipRespond* VLogicSvr2CliMsg::release_equiprespond() {
  clear_has_equiprespond();
  ::vmsg::CSEquipRespond* temp = equiprespond_;
  equiprespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_equiprespond(::vmsg::CSEquipRespond* equiprespond) {
  delete equiprespond_;
  equiprespond_ = equiprespond;
  if (equiprespond) {
    set_has_equiprespond();
  } else {
    clear_has_equiprespond();
  }
}

// optional .vmsg.CSTaskRespond TaskRespond = 8;
inline bool VLogicSvr2CliMsg::has_taskrespond() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_taskrespond() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VLogicSvr2CliMsg::clear_has_taskrespond() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VLogicSvr2CliMsg::clear_taskrespond() {
  if (taskrespond_ != NULL) taskrespond_->::vmsg::CSTaskRespond::Clear();
  clear_has_taskrespond();
}
inline const ::vmsg::CSTaskRespond& VLogicSvr2CliMsg::taskrespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return taskrespond_ != NULL ? *taskrespond_ : *default_instance().taskrespond_;
#else
  return taskrespond_ != NULL ? *taskrespond_ : *default_instance_->taskrespond_;
#endif
}
inline ::vmsg::CSTaskRespond* VLogicSvr2CliMsg::mutable_taskrespond() {
  set_has_taskrespond();
  if (taskrespond_ == NULL) taskrespond_ = new ::vmsg::CSTaskRespond;
  return taskrespond_;
}
inline ::vmsg::CSTaskRespond* VLogicSvr2CliMsg::release_taskrespond() {
  clear_has_taskrespond();
  ::vmsg::CSTaskRespond* temp = taskrespond_;
  taskrespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_taskrespond(::vmsg::CSTaskRespond* taskrespond) {
  delete taskrespond_;
  taskrespond_ = taskrespond;
  if (taskrespond) {
    set_has_taskrespond();
  } else {
    clear_has_taskrespond();
  }
}

// optional .vmsg.CSRankRespond RankRespond = 9;
inline bool VLogicSvr2CliMsg::has_rankrespond() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_rankrespond() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VLogicSvr2CliMsg::clear_has_rankrespond() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VLogicSvr2CliMsg::clear_rankrespond() {
  if (rankrespond_ != NULL) rankrespond_->::vmsg::CSRankRespond::Clear();
  clear_has_rankrespond();
}
inline const ::vmsg::CSRankRespond& VLogicSvr2CliMsg::rankrespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return rankrespond_ != NULL ? *rankrespond_ : *default_instance().rankrespond_;
#else
  return rankrespond_ != NULL ? *rankrespond_ : *default_instance_->rankrespond_;
#endif
}
inline ::vmsg::CSRankRespond* VLogicSvr2CliMsg::mutable_rankrespond() {
  set_has_rankrespond();
  if (rankrespond_ == NULL) rankrespond_ = new ::vmsg::CSRankRespond;
  return rankrespond_;
}
inline ::vmsg::CSRankRespond* VLogicSvr2CliMsg::release_rankrespond() {
  clear_has_rankrespond();
  ::vmsg::CSRankRespond* temp = rankrespond_;
  rankrespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_rankrespond(::vmsg::CSRankRespond* rankrespond) {
  delete rankrespond_;
  rankrespond_ = rankrespond;
  if (rankrespond) {
    set_has_rankrespond();
  } else {
    clear_has_rankrespond();
  }
}

// optional .vmsg.CSWeaponRespond WeaponRespond = 10;
inline bool VLogicSvr2CliMsg::has_weaponrespond() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_weaponrespond() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VLogicSvr2CliMsg::clear_has_weaponrespond() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VLogicSvr2CliMsg::clear_weaponrespond() {
  if (weaponrespond_ != NULL) weaponrespond_->::vmsg::CSWeaponRespond::Clear();
  clear_has_weaponrespond();
}
inline const ::vmsg::CSWeaponRespond& VLogicSvr2CliMsg::weaponrespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return weaponrespond_ != NULL ? *weaponrespond_ : *default_instance().weaponrespond_;
#else
  return weaponrespond_ != NULL ? *weaponrespond_ : *default_instance_->weaponrespond_;
#endif
}
inline ::vmsg::CSWeaponRespond* VLogicSvr2CliMsg::mutable_weaponrespond() {
  set_has_weaponrespond();
  if (weaponrespond_ == NULL) weaponrespond_ = new ::vmsg::CSWeaponRespond;
  return weaponrespond_;
}
inline ::vmsg::CSWeaponRespond* VLogicSvr2CliMsg::release_weaponrespond() {
  clear_has_weaponrespond();
  ::vmsg::CSWeaponRespond* temp = weaponrespond_;
  weaponrespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_weaponrespond(::vmsg::CSWeaponRespond* weaponrespond) {
  delete weaponrespond_;
  weaponrespond_ = weaponrespond;
  if (weaponrespond) {
    set_has_weaponrespond();
  } else {
    clear_has_weaponrespond();
  }
}

// optional .vmsg.CSGoldRespond GoldRespond = 11;
inline bool VLogicSvr2CliMsg::has_goldrespond() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_goldrespond() {
  _has_bits_[0] |= 0x00000200u;
}
inline void VLogicSvr2CliMsg::clear_has_goldrespond() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void VLogicSvr2CliMsg::clear_goldrespond() {
  if (goldrespond_ != NULL) goldrespond_->::vmsg::CSGoldRespond::Clear();
  clear_has_goldrespond();
}
inline const ::vmsg::CSGoldRespond& VLogicSvr2CliMsg::goldrespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return goldrespond_ != NULL ? *goldrespond_ : *default_instance().goldrespond_;
#else
  return goldrespond_ != NULL ? *goldrespond_ : *default_instance_->goldrespond_;
#endif
}
inline ::vmsg::CSGoldRespond* VLogicSvr2CliMsg::mutable_goldrespond() {
  set_has_goldrespond();
  if (goldrespond_ == NULL) goldrespond_ = new ::vmsg::CSGoldRespond;
  return goldrespond_;
}
inline ::vmsg::CSGoldRespond* VLogicSvr2CliMsg::release_goldrespond() {
  clear_has_goldrespond();
  ::vmsg::CSGoldRespond* temp = goldrespond_;
  goldrespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_goldrespond(::vmsg::CSGoldRespond* goldrespond) {
  delete goldrespond_;
  goldrespond_ = goldrespond;
  if (goldrespond) {
    set_has_goldrespond();
  } else {
    clear_has_goldrespond();
  }
}

// optional .vmsg.CSItemRespond ItemRespond = 12;
inline bool VLogicSvr2CliMsg::has_itemrespond() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_itemrespond() {
  _has_bits_[0] |= 0x00000400u;
}
inline void VLogicSvr2CliMsg::clear_has_itemrespond() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void VLogicSvr2CliMsg::clear_itemrespond() {
  if (itemrespond_ != NULL) itemrespond_->::vmsg::CSItemRespond::Clear();
  clear_has_itemrespond();
}
inline const ::vmsg::CSItemRespond& VLogicSvr2CliMsg::itemrespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return itemrespond_ != NULL ? *itemrespond_ : *default_instance().itemrespond_;
#else
  return itemrespond_ != NULL ? *itemrespond_ : *default_instance_->itemrespond_;
#endif
}
inline ::vmsg::CSItemRespond* VLogicSvr2CliMsg::mutable_itemrespond() {
  set_has_itemrespond();
  if (itemrespond_ == NULL) itemrespond_ = new ::vmsg::CSItemRespond;
  return itemrespond_;
}
inline ::vmsg::CSItemRespond* VLogicSvr2CliMsg::release_itemrespond() {
  clear_has_itemrespond();
  ::vmsg::CSItemRespond* temp = itemrespond_;
  itemrespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_itemrespond(::vmsg::CSItemRespond* itemrespond) {
  delete itemrespond_;
  itemrespond_ = itemrespond;
  if (itemrespond) {
    set_has_itemrespond();
  } else {
    clear_has_itemrespond();
  }
}

// optional .vmsg.CSWarMapRespond WarMapRespond = 13;
inline bool VLogicSvr2CliMsg::has_warmaprespond() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_warmaprespond() {
  _has_bits_[0] |= 0x00000800u;
}
inline void VLogicSvr2CliMsg::clear_has_warmaprespond() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void VLogicSvr2CliMsg::clear_warmaprespond() {
  if (warmaprespond_ != NULL) warmaprespond_->::vmsg::CSWarMapRespond::Clear();
  clear_has_warmaprespond();
}
inline const ::vmsg::CSWarMapRespond& VLogicSvr2CliMsg::warmaprespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return warmaprespond_ != NULL ? *warmaprespond_ : *default_instance().warmaprespond_;
#else
  return warmaprespond_ != NULL ? *warmaprespond_ : *default_instance_->warmaprespond_;
#endif
}
inline ::vmsg::CSWarMapRespond* VLogicSvr2CliMsg::mutable_warmaprespond() {
  set_has_warmaprespond();
  if (warmaprespond_ == NULL) warmaprespond_ = new ::vmsg::CSWarMapRespond;
  return warmaprespond_;
}
inline ::vmsg::CSWarMapRespond* VLogicSvr2CliMsg::release_warmaprespond() {
  clear_has_warmaprespond();
  ::vmsg::CSWarMapRespond* temp = warmaprespond_;
  warmaprespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_warmaprespond(::vmsg::CSWarMapRespond* warmaprespond) {
  delete warmaprespond_;
  warmaprespond_ = warmaprespond;
  if (warmaprespond) {
    set_has_warmaprespond();
  } else {
    clear_has_warmaprespond();
  }
}

// optional .vmsg.CSFriendRespond FriendRespond = 14;
inline bool VLogicSvr2CliMsg::has_friendrespond() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_friendrespond() {
  _has_bits_[0] |= 0x00001000u;
}
inline void VLogicSvr2CliMsg::clear_has_friendrespond() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void VLogicSvr2CliMsg::clear_friendrespond() {
  if (friendrespond_ != NULL) friendrespond_->::vmsg::CSFriendRespond::Clear();
  clear_has_friendrespond();
}
inline const ::vmsg::CSFriendRespond& VLogicSvr2CliMsg::friendrespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return friendrespond_ != NULL ? *friendrespond_ : *default_instance().friendrespond_;
#else
  return friendrespond_ != NULL ? *friendrespond_ : *default_instance_->friendrespond_;
#endif
}
inline ::vmsg::CSFriendRespond* VLogicSvr2CliMsg::mutable_friendrespond() {
  set_has_friendrespond();
  if (friendrespond_ == NULL) friendrespond_ = new ::vmsg::CSFriendRespond;
  return friendrespond_;
}
inline ::vmsg::CSFriendRespond* VLogicSvr2CliMsg::release_friendrespond() {
  clear_has_friendrespond();
  ::vmsg::CSFriendRespond* temp = friendrespond_;
  friendrespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_friendrespond(::vmsg::CSFriendRespond* friendrespond) {
  delete friendrespond_;
  friendrespond_ = friendrespond;
  if (friendrespond) {
    set_has_friendrespond();
  } else {
    clear_has_friendrespond();
  }
}

// optional .vmsg.CSGuildRespond GuildRespond = 15;
inline bool VLogicSvr2CliMsg::has_guildrespond() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_guildrespond() {
  _has_bits_[0] |= 0x00002000u;
}
inline void VLogicSvr2CliMsg::clear_has_guildrespond() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void VLogicSvr2CliMsg::clear_guildrespond() {
  if (guildrespond_ != NULL) guildrespond_->::vmsg::CSGuildRespond::Clear();
  clear_has_guildrespond();
}
inline const ::vmsg::CSGuildRespond& VLogicSvr2CliMsg::guildrespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return guildrespond_ != NULL ? *guildrespond_ : *default_instance().guildrespond_;
#else
  return guildrespond_ != NULL ? *guildrespond_ : *default_instance_->guildrespond_;
#endif
}
inline ::vmsg::CSGuildRespond* VLogicSvr2CliMsg::mutable_guildrespond() {
  set_has_guildrespond();
  if (guildrespond_ == NULL) guildrespond_ = new ::vmsg::CSGuildRespond;
  return guildrespond_;
}
inline ::vmsg::CSGuildRespond* VLogicSvr2CliMsg::release_guildrespond() {
  clear_has_guildrespond();
  ::vmsg::CSGuildRespond* temp = guildrespond_;
  guildrespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_guildrespond(::vmsg::CSGuildRespond* guildrespond) {
  delete guildrespond_;
  guildrespond_ = guildrespond;
  if (guildrespond) {
    set_has_guildrespond();
  } else {
    clear_has_guildrespond();
  }
}

// optional .vmsg.CSMailRespond MailRespond = 16;
inline bool VLogicSvr2CliMsg::has_mailrespond() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_mailrespond() {
  _has_bits_[0] |= 0x00004000u;
}
inline void VLogicSvr2CliMsg::clear_has_mailrespond() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void VLogicSvr2CliMsg::clear_mailrespond() {
  if (mailrespond_ != NULL) mailrespond_->::vmsg::CSMailRespond::Clear();
  clear_has_mailrespond();
}
inline const ::vmsg::CSMailRespond& VLogicSvr2CliMsg::mailrespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return mailrespond_ != NULL ? *mailrespond_ : *default_instance().mailrespond_;
#else
  return mailrespond_ != NULL ? *mailrespond_ : *default_instance_->mailrespond_;
#endif
}
inline ::vmsg::CSMailRespond* VLogicSvr2CliMsg::mutable_mailrespond() {
  set_has_mailrespond();
  if (mailrespond_ == NULL) mailrespond_ = new ::vmsg::CSMailRespond;
  return mailrespond_;
}
inline ::vmsg::CSMailRespond* VLogicSvr2CliMsg::release_mailrespond() {
  clear_has_mailrespond();
  ::vmsg::CSMailRespond* temp = mailrespond_;
  mailrespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_mailrespond(::vmsg::CSMailRespond* mailrespond) {
  delete mailrespond_;
  mailrespond_ = mailrespond;
  if (mailrespond) {
    set_has_mailrespond();
  } else {
    clear_has_mailrespond();
  }
}

// optional .vmsg.CSInfiniteRespond InfiniteRespond = 17;
inline bool VLogicSvr2CliMsg::has_infiniterespond() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_infiniterespond() {
  _has_bits_[0] |= 0x00008000u;
}
inline void VLogicSvr2CliMsg::clear_has_infiniterespond() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void VLogicSvr2CliMsg::clear_infiniterespond() {
  if (infiniterespond_ != NULL) infiniterespond_->::vmsg::CSInfiniteRespond::Clear();
  clear_has_infiniterespond();
}
inline const ::vmsg::CSInfiniteRespond& VLogicSvr2CliMsg::infiniterespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return infiniterespond_ != NULL ? *infiniterespond_ : *default_instance().infiniterespond_;
#else
  return infiniterespond_ != NULL ? *infiniterespond_ : *default_instance_->infiniterespond_;
#endif
}
inline ::vmsg::CSInfiniteRespond* VLogicSvr2CliMsg::mutable_infiniterespond() {
  set_has_infiniterespond();
  if (infiniterespond_ == NULL) infiniterespond_ = new ::vmsg::CSInfiniteRespond;
  return infiniterespond_;
}
inline ::vmsg::CSInfiniteRespond* VLogicSvr2CliMsg::release_infiniterespond() {
  clear_has_infiniterespond();
  ::vmsg::CSInfiniteRespond* temp = infiniterespond_;
  infiniterespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_infiniterespond(::vmsg::CSInfiniteRespond* infiniterespond) {
  delete infiniterespond_;
  infiniterespond_ = infiniterespond;
  if (infiniterespond) {
    set_has_infiniterespond();
  } else {
    clear_has_infiniterespond();
  }
}

// optional .vmsg.CSChatRespond ChatRespond = 18;
inline bool VLogicSvr2CliMsg::has_chatrespond() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_chatrespond() {
  _has_bits_[0] |= 0x00010000u;
}
inline void VLogicSvr2CliMsg::clear_has_chatrespond() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void VLogicSvr2CliMsg::clear_chatrespond() {
  if (chatrespond_ != NULL) chatrespond_->::vmsg::CSChatRespond::Clear();
  clear_has_chatrespond();
}
inline const ::vmsg::CSChatRespond& VLogicSvr2CliMsg::chatrespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return chatrespond_ != NULL ? *chatrespond_ : *default_instance().chatrespond_;
#else
  return chatrespond_ != NULL ? *chatrespond_ : *default_instance_->chatrespond_;
#endif
}
inline ::vmsg::CSChatRespond* VLogicSvr2CliMsg::mutable_chatrespond() {
  set_has_chatrespond();
  if (chatrespond_ == NULL) chatrespond_ = new ::vmsg::CSChatRespond;
  return chatrespond_;
}
inline ::vmsg::CSChatRespond* VLogicSvr2CliMsg::release_chatrespond() {
  clear_has_chatrespond();
  ::vmsg::CSChatRespond* temp = chatrespond_;
  chatrespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_chatrespond(::vmsg::CSChatRespond* chatrespond) {
  delete chatrespond_;
  chatrespond_ = chatrespond;
  if (chatrespond) {
    set_has_chatrespond();
  } else {
    clear_has_chatrespond();
  }
}

// optional .vmsg.CSCVZRespond CVZRespond = 19;
inline bool VLogicSvr2CliMsg::has_cvzrespond() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_cvzrespond() {
  _has_bits_[0] |= 0x00020000u;
}
inline void VLogicSvr2CliMsg::clear_has_cvzrespond() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void VLogicSvr2CliMsg::clear_cvzrespond() {
  if (cvzrespond_ != NULL) cvzrespond_->::vmsg::CSCVZRespond::Clear();
  clear_has_cvzrespond();
}
inline const ::vmsg::CSCVZRespond& VLogicSvr2CliMsg::cvzrespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cvzrespond_ != NULL ? *cvzrespond_ : *default_instance().cvzrespond_;
#else
  return cvzrespond_ != NULL ? *cvzrespond_ : *default_instance_->cvzrespond_;
#endif
}
inline ::vmsg::CSCVZRespond* VLogicSvr2CliMsg::mutable_cvzrespond() {
  set_has_cvzrespond();
  if (cvzrespond_ == NULL) cvzrespond_ = new ::vmsg::CSCVZRespond;
  return cvzrespond_;
}
inline ::vmsg::CSCVZRespond* VLogicSvr2CliMsg::release_cvzrespond() {
  clear_has_cvzrespond();
  ::vmsg::CSCVZRespond* temp = cvzrespond_;
  cvzrespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_cvzrespond(::vmsg::CSCVZRespond* cvzrespond) {
  delete cvzrespond_;
  cvzrespond_ = cvzrespond;
  if (cvzrespond) {
    set_has_cvzrespond();
  } else {
    clear_has_cvzrespond();
  }
}

// optional .vmsg.CSServerNotifyRespond ServerNotifyRespond = 20;
inline bool VLogicSvr2CliMsg::has_servernotifyrespond() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_servernotifyrespond() {
  _has_bits_[0] |= 0x00040000u;
}
inline void VLogicSvr2CliMsg::clear_has_servernotifyrespond() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void VLogicSvr2CliMsg::clear_servernotifyrespond() {
  if (servernotifyrespond_ != NULL) servernotifyrespond_->::vmsg::CSServerNotifyRespond::Clear();
  clear_has_servernotifyrespond();
}
inline const ::vmsg::CSServerNotifyRespond& VLogicSvr2CliMsg::servernotifyrespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return servernotifyrespond_ != NULL ? *servernotifyrespond_ : *default_instance().servernotifyrespond_;
#else
  return servernotifyrespond_ != NULL ? *servernotifyrespond_ : *default_instance_->servernotifyrespond_;
#endif
}
inline ::vmsg::CSServerNotifyRespond* VLogicSvr2CliMsg::mutable_servernotifyrespond() {
  set_has_servernotifyrespond();
  if (servernotifyrespond_ == NULL) servernotifyrespond_ = new ::vmsg::CSServerNotifyRespond;
  return servernotifyrespond_;
}
inline ::vmsg::CSServerNotifyRespond* VLogicSvr2CliMsg::release_servernotifyrespond() {
  clear_has_servernotifyrespond();
  ::vmsg::CSServerNotifyRespond* temp = servernotifyrespond_;
  servernotifyrespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_servernotifyrespond(::vmsg::CSServerNotifyRespond* servernotifyrespond) {
  delete servernotifyrespond_;
  servernotifyrespond_ = servernotifyrespond;
  if (servernotifyrespond) {
    set_has_servernotifyrespond();
  } else {
    clear_has_servernotifyrespond();
  }
}

// optional .vmsg.CSDailyGiftRespond DailyGiftRespond = 21;
inline bool VLogicSvr2CliMsg::has_dailygiftrespond() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_dailygiftrespond() {
  _has_bits_[0] |= 0x00080000u;
}
inline void VLogicSvr2CliMsg::clear_has_dailygiftrespond() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void VLogicSvr2CliMsg::clear_dailygiftrespond() {
  if (dailygiftrespond_ != NULL) dailygiftrespond_->::vmsg::CSDailyGiftRespond::Clear();
  clear_has_dailygiftrespond();
}
inline const ::vmsg::CSDailyGiftRespond& VLogicSvr2CliMsg::dailygiftrespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dailygiftrespond_ != NULL ? *dailygiftrespond_ : *default_instance().dailygiftrespond_;
#else
  return dailygiftrespond_ != NULL ? *dailygiftrespond_ : *default_instance_->dailygiftrespond_;
#endif
}
inline ::vmsg::CSDailyGiftRespond* VLogicSvr2CliMsg::mutable_dailygiftrespond() {
  set_has_dailygiftrespond();
  if (dailygiftrespond_ == NULL) dailygiftrespond_ = new ::vmsg::CSDailyGiftRespond;
  return dailygiftrespond_;
}
inline ::vmsg::CSDailyGiftRespond* VLogicSvr2CliMsg::release_dailygiftrespond() {
  clear_has_dailygiftrespond();
  ::vmsg::CSDailyGiftRespond* temp = dailygiftrespond_;
  dailygiftrespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_dailygiftrespond(::vmsg::CSDailyGiftRespond* dailygiftrespond) {
  delete dailygiftrespond_;
  dailygiftrespond_ = dailygiftrespond;
  if (dailygiftrespond) {
    set_has_dailygiftrespond();
  } else {
    clear_has_dailygiftrespond();
  }
}

// optional .vmsg.CSArenaRespond ArenaRespond = 22;
inline bool VLogicSvr2CliMsg::has_arenarespond() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_arenarespond() {
  _has_bits_[0] |= 0x00100000u;
}
inline void VLogicSvr2CliMsg::clear_has_arenarespond() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void VLogicSvr2CliMsg::clear_arenarespond() {
  if (arenarespond_ != NULL) arenarespond_->::vmsg::CSArenaRespond::Clear();
  clear_has_arenarespond();
}
inline const ::vmsg::CSArenaRespond& VLogicSvr2CliMsg::arenarespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return arenarespond_ != NULL ? *arenarespond_ : *default_instance().arenarespond_;
#else
  return arenarespond_ != NULL ? *arenarespond_ : *default_instance_->arenarespond_;
#endif
}
inline ::vmsg::CSArenaRespond* VLogicSvr2CliMsg::mutable_arenarespond() {
  set_has_arenarespond();
  if (arenarespond_ == NULL) arenarespond_ = new ::vmsg::CSArenaRespond;
  return arenarespond_;
}
inline ::vmsg::CSArenaRespond* VLogicSvr2CliMsg::release_arenarespond() {
  clear_has_arenarespond();
  ::vmsg::CSArenaRespond* temp = arenarespond_;
  arenarespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_arenarespond(::vmsg::CSArenaRespond* arenarespond) {
  delete arenarespond_;
  arenarespond_ = arenarespond;
  if (arenarespond) {
    set_has_arenarespond();
  } else {
    clear_has_arenarespond();
  }
}

// optional .vmsg.CSStoreRespond StoreRespond = 23;
inline bool VLogicSvr2CliMsg::has_storerespond() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_storerespond() {
  _has_bits_[0] |= 0x00200000u;
}
inline void VLogicSvr2CliMsg::clear_has_storerespond() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void VLogicSvr2CliMsg::clear_storerespond() {
  if (storerespond_ != NULL) storerespond_->::vmsg::CSStoreRespond::Clear();
  clear_has_storerespond();
}
inline const ::vmsg::CSStoreRespond& VLogicSvr2CliMsg::storerespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return storerespond_ != NULL ? *storerespond_ : *default_instance().storerespond_;
#else
  return storerespond_ != NULL ? *storerespond_ : *default_instance_->storerespond_;
#endif
}
inline ::vmsg::CSStoreRespond* VLogicSvr2CliMsg::mutable_storerespond() {
  set_has_storerespond();
  if (storerespond_ == NULL) storerespond_ = new ::vmsg::CSStoreRespond;
  return storerespond_;
}
inline ::vmsg::CSStoreRespond* VLogicSvr2CliMsg::release_storerespond() {
  clear_has_storerespond();
  ::vmsg::CSStoreRespond* temp = storerespond_;
  storerespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_storerespond(::vmsg::CSStoreRespond* storerespond) {
  delete storerespond_;
  storerespond_ = storerespond;
  if (storerespond) {
    set_has_storerespond();
  } else {
    clear_has_storerespond();
  }
}

// optional .vmsg.CSQiangHunRespond QiangHunRespond = 24;
inline bool VLogicSvr2CliMsg::has_qianghunrespond() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_qianghunrespond() {
  _has_bits_[0] |= 0x00400000u;
}
inline void VLogicSvr2CliMsg::clear_has_qianghunrespond() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void VLogicSvr2CliMsg::clear_qianghunrespond() {
  if (qianghunrespond_ != NULL) qianghunrespond_->::vmsg::CSQiangHunRespond::Clear();
  clear_has_qianghunrespond();
}
inline const ::vmsg::CSQiangHunRespond& VLogicSvr2CliMsg::qianghunrespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return qianghunrespond_ != NULL ? *qianghunrespond_ : *default_instance().qianghunrespond_;
#else
  return qianghunrespond_ != NULL ? *qianghunrespond_ : *default_instance_->qianghunrespond_;
#endif
}
inline ::vmsg::CSQiangHunRespond* VLogicSvr2CliMsg::mutable_qianghunrespond() {
  set_has_qianghunrespond();
  if (qianghunrespond_ == NULL) qianghunrespond_ = new ::vmsg::CSQiangHunRespond;
  return qianghunrespond_;
}
inline ::vmsg::CSQiangHunRespond* VLogicSvr2CliMsg::release_qianghunrespond() {
  clear_has_qianghunrespond();
  ::vmsg::CSQiangHunRespond* temp = qianghunrespond_;
  qianghunrespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_qianghunrespond(::vmsg::CSQiangHunRespond* qianghunrespond) {
  delete qianghunrespond_;
  qianghunrespond_ = qianghunrespond;
  if (qianghunrespond) {
    set_has_qianghunrespond();
  } else {
    clear_has_qianghunrespond();
  }
}

// optional .vmsg.CSDebrisRespond DebrisRespond = 25;
inline bool VLogicSvr2CliMsg::has_debrisrespond() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_debrisrespond() {
  _has_bits_[0] |= 0x00800000u;
}
inline void VLogicSvr2CliMsg::clear_has_debrisrespond() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void VLogicSvr2CliMsg::clear_debrisrespond() {
  if (debrisrespond_ != NULL) debrisrespond_->::vmsg::CSDebrisRespond::Clear();
  clear_has_debrisrespond();
}
inline const ::vmsg::CSDebrisRespond& VLogicSvr2CliMsg::debrisrespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return debrisrespond_ != NULL ? *debrisrespond_ : *default_instance().debrisrespond_;
#else
  return debrisrespond_ != NULL ? *debrisrespond_ : *default_instance_->debrisrespond_;
#endif
}
inline ::vmsg::CSDebrisRespond* VLogicSvr2CliMsg::mutable_debrisrespond() {
  set_has_debrisrespond();
  if (debrisrespond_ == NULL) debrisrespond_ = new ::vmsg::CSDebrisRespond;
  return debrisrespond_;
}
inline ::vmsg::CSDebrisRespond* VLogicSvr2CliMsg::release_debrisrespond() {
  clear_has_debrisrespond();
  ::vmsg::CSDebrisRespond* temp = debrisrespond_;
  debrisrespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_debrisrespond(::vmsg::CSDebrisRespond* debrisrespond) {
  delete debrisrespond_;
  debrisrespond_ = debrisrespond;
  if (debrisrespond) {
    set_has_debrisrespond();
  } else {
    clear_has_debrisrespond();
  }
}

// optional .vmsg.CSActRespond ActRespond = 26;
inline bool VLogicSvr2CliMsg::has_actrespond() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_actrespond() {
  _has_bits_[0] |= 0x01000000u;
}
inline void VLogicSvr2CliMsg::clear_has_actrespond() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void VLogicSvr2CliMsg::clear_actrespond() {
  if (actrespond_ != NULL) actrespond_->::vmsg::CSActRespond::Clear();
  clear_has_actrespond();
}
inline const ::vmsg::CSActRespond& VLogicSvr2CliMsg::actrespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return actrespond_ != NULL ? *actrespond_ : *default_instance().actrespond_;
#else
  return actrespond_ != NULL ? *actrespond_ : *default_instance_->actrespond_;
#endif
}
inline ::vmsg::CSActRespond* VLogicSvr2CliMsg::mutable_actrespond() {
  set_has_actrespond();
  if (actrespond_ == NULL) actrespond_ = new ::vmsg::CSActRespond;
  return actrespond_;
}
inline ::vmsg::CSActRespond* VLogicSvr2CliMsg::release_actrespond() {
  clear_has_actrespond();
  ::vmsg::CSActRespond* temp = actrespond_;
  actrespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_actrespond(::vmsg::CSActRespond* actrespond) {
  delete actrespond_;
  actrespond_ = actrespond;
  if (actrespond) {
    set_has_actrespond();
  } else {
    clear_has_actrespond();
  }
}

// optional .vmsg.CSDotaItemRespond DotaItemRespond = 27;
inline bool VLogicSvr2CliMsg::has_dotaitemrespond() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_dotaitemrespond() {
  _has_bits_[0] |= 0x02000000u;
}
inline void VLogicSvr2CliMsg::clear_has_dotaitemrespond() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void VLogicSvr2CliMsg::clear_dotaitemrespond() {
  if (dotaitemrespond_ != NULL) dotaitemrespond_->::vmsg::CSDotaItemRespond::Clear();
  clear_has_dotaitemrespond();
}
inline const ::vmsg::CSDotaItemRespond& VLogicSvr2CliMsg::dotaitemrespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dotaitemrespond_ != NULL ? *dotaitemrespond_ : *default_instance().dotaitemrespond_;
#else
  return dotaitemrespond_ != NULL ? *dotaitemrespond_ : *default_instance_->dotaitemrespond_;
#endif
}
inline ::vmsg::CSDotaItemRespond* VLogicSvr2CliMsg::mutable_dotaitemrespond() {
  set_has_dotaitemrespond();
  if (dotaitemrespond_ == NULL) dotaitemrespond_ = new ::vmsg::CSDotaItemRespond;
  return dotaitemrespond_;
}
inline ::vmsg::CSDotaItemRespond* VLogicSvr2CliMsg::release_dotaitemrespond() {
  clear_has_dotaitemrespond();
  ::vmsg::CSDotaItemRespond* temp = dotaitemrespond_;
  dotaitemrespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_dotaitemrespond(::vmsg::CSDotaItemRespond* dotaitemrespond) {
  delete dotaitemrespond_;
  dotaitemrespond_ = dotaitemrespond;
  if (dotaitemrespond) {
    set_has_dotaitemrespond();
  } else {
    clear_has_dotaitemrespond();
  }
}

// optional .vmsg.CSCouponRespond CouponRespond = 28;
inline bool VLogicSvr2CliMsg::has_couponrespond() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_couponrespond() {
  _has_bits_[0] |= 0x04000000u;
}
inline void VLogicSvr2CliMsg::clear_has_couponrespond() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void VLogicSvr2CliMsg::clear_couponrespond() {
  if (couponrespond_ != NULL) couponrespond_->::vmsg::CSCouponRespond::Clear();
  clear_has_couponrespond();
}
inline const ::vmsg::CSCouponRespond& VLogicSvr2CliMsg::couponrespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return couponrespond_ != NULL ? *couponrespond_ : *default_instance().couponrespond_;
#else
  return couponrespond_ != NULL ? *couponrespond_ : *default_instance_->couponrespond_;
#endif
}
inline ::vmsg::CSCouponRespond* VLogicSvr2CliMsg::mutable_couponrespond() {
  set_has_couponrespond();
  if (couponrespond_ == NULL) couponrespond_ = new ::vmsg::CSCouponRespond;
  return couponrespond_;
}
inline ::vmsg::CSCouponRespond* VLogicSvr2CliMsg::release_couponrespond() {
  clear_has_couponrespond();
  ::vmsg::CSCouponRespond* temp = couponrespond_;
  couponrespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_couponrespond(::vmsg::CSCouponRespond* couponrespond) {
  delete couponrespond_;
  couponrespond_ = couponrespond;
  if (couponrespond) {
    set_has_couponrespond();
  } else {
    clear_has_couponrespond();
  }
}

// optional .vmsg.CSPanicBuyingStoreResponse PanicBuyingRespond = 29;
inline bool VLogicSvr2CliMsg::has_panicbuyingrespond() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_panicbuyingrespond() {
  _has_bits_[0] |= 0x08000000u;
}
inline void VLogicSvr2CliMsg::clear_has_panicbuyingrespond() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void VLogicSvr2CliMsg::clear_panicbuyingrespond() {
  if (panicbuyingrespond_ != NULL) panicbuyingrespond_->::vmsg::CSPanicBuyingStoreResponse::Clear();
  clear_has_panicbuyingrespond();
}
inline const ::vmsg::CSPanicBuyingStoreResponse& VLogicSvr2CliMsg::panicbuyingrespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return panicbuyingrespond_ != NULL ? *panicbuyingrespond_ : *default_instance().panicbuyingrespond_;
#else
  return panicbuyingrespond_ != NULL ? *panicbuyingrespond_ : *default_instance_->panicbuyingrespond_;
#endif
}
inline ::vmsg::CSPanicBuyingStoreResponse* VLogicSvr2CliMsg::mutable_panicbuyingrespond() {
  set_has_panicbuyingrespond();
  if (panicbuyingrespond_ == NULL) panicbuyingrespond_ = new ::vmsg::CSPanicBuyingStoreResponse;
  return panicbuyingrespond_;
}
inline ::vmsg::CSPanicBuyingStoreResponse* VLogicSvr2CliMsg::release_panicbuyingrespond() {
  clear_has_panicbuyingrespond();
  ::vmsg::CSPanicBuyingStoreResponse* temp = panicbuyingrespond_;
  panicbuyingrespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_panicbuyingrespond(::vmsg::CSPanicBuyingStoreResponse* panicbuyingrespond) {
  delete panicbuyingrespond_;
  panicbuyingrespond_ = panicbuyingrespond;
  if (panicbuyingrespond) {
    set_has_panicbuyingrespond();
  } else {
    clear_has_panicbuyingrespond();
  }
}

// optional .vmsg.CSBossChallengeRsp BossChallengeRsp = 30;
inline bool VLogicSvr2CliMsg::has_bosschallengersp() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_bosschallengersp() {
  _has_bits_[0] |= 0x10000000u;
}
inline void VLogicSvr2CliMsg::clear_has_bosschallengersp() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void VLogicSvr2CliMsg::clear_bosschallengersp() {
  if (bosschallengersp_ != NULL) bosschallengersp_->::vmsg::CSBossChallengeRsp::Clear();
  clear_has_bosschallengersp();
}
inline const ::vmsg::CSBossChallengeRsp& VLogicSvr2CliMsg::bosschallengersp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bosschallengersp_ != NULL ? *bosschallengersp_ : *default_instance().bosschallengersp_;
#else
  return bosschallengersp_ != NULL ? *bosschallengersp_ : *default_instance_->bosschallengersp_;
#endif
}
inline ::vmsg::CSBossChallengeRsp* VLogicSvr2CliMsg::mutable_bosschallengersp() {
  set_has_bosschallengersp();
  if (bosschallengersp_ == NULL) bosschallengersp_ = new ::vmsg::CSBossChallengeRsp;
  return bosschallengersp_;
}
inline ::vmsg::CSBossChallengeRsp* VLogicSvr2CliMsg::release_bosschallengersp() {
  clear_has_bosschallengersp();
  ::vmsg::CSBossChallengeRsp* temp = bosschallengersp_;
  bosschallengersp_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_bosschallengersp(::vmsg::CSBossChallengeRsp* bosschallengersp) {
  delete bosschallengersp_;
  bosschallengersp_ = bosschallengersp;
  if (bosschallengersp) {
    set_has_bosschallengersp();
  } else {
    clear_has_bosschallengersp();
  }
}

// optional int32 CheckNick_Rsp = 99;
inline bool VLogicSvr2CliMsg::has_checknick_rsp() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_checknick_rsp() {
  _has_bits_[0] |= 0x20000000u;
}
inline void VLogicSvr2CliMsg::clear_has_checknick_rsp() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void VLogicSvr2CliMsg::clear_checknick_rsp() {
  checknick_rsp_ = 0;
  clear_has_checknick_rsp();
}
inline ::google::protobuf::int32 VLogicSvr2CliMsg::checknick_rsp() const {
  return checknick_rsp_;
}
inline void VLogicSvr2CliMsg::set_checknick_rsp(::google::protobuf::int32 value) {
  set_has_checknick_rsp();
  checknick_rsp_ = value;
}

// optional .vmsg.CSHeartBeatRsp HeartBeat_Rsp = 100;
inline bool VLogicSvr2CliMsg::has_heartbeat_rsp() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_heartbeat_rsp() {
  _has_bits_[0] |= 0x40000000u;
}
inline void VLogicSvr2CliMsg::clear_has_heartbeat_rsp() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void VLogicSvr2CliMsg::clear_heartbeat_rsp() {
  if (heartbeat_rsp_ != NULL) heartbeat_rsp_->::vmsg::CSHeartBeatRsp::Clear();
  clear_has_heartbeat_rsp();
}
inline const ::vmsg::CSHeartBeatRsp& VLogicSvr2CliMsg::heartbeat_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return heartbeat_rsp_ != NULL ? *heartbeat_rsp_ : *default_instance().heartbeat_rsp_;
#else
  return heartbeat_rsp_ != NULL ? *heartbeat_rsp_ : *default_instance_->heartbeat_rsp_;
#endif
}
inline ::vmsg::CSHeartBeatRsp* VLogicSvr2CliMsg::mutable_heartbeat_rsp() {
  set_has_heartbeat_rsp();
  if (heartbeat_rsp_ == NULL) heartbeat_rsp_ = new ::vmsg::CSHeartBeatRsp;
  return heartbeat_rsp_;
}
inline ::vmsg::CSHeartBeatRsp* VLogicSvr2CliMsg::release_heartbeat_rsp() {
  clear_has_heartbeat_rsp();
  ::vmsg::CSHeartBeatRsp* temp = heartbeat_rsp_;
  heartbeat_rsp_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_heartbeat_rsp(::vmsg::CSHeartBeatRsp* heartbeat_rsp) {
  delete heartbeat_rsp_;
  heartbeat_rsp_ = heartbeat_rsp;
  if (heartbeat_rsp) {
    set_has_heartbeat_rsp();
  } else {
    clear_has_heartbeat_rsp();
  }
}

// optional .vmsg.CSAdminRespond AdminRespond = 101;
inline bool VLogicSvr2CliMsg::has_adminrespond() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_adminrespond() {
  _has_bits_[0] |= 0x80000000u;
}
inline void VLogicSvr2CliMsg::clear_has_adminrespond() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void VLogicSvr2CliMsg::clear_adminrespond() {
  if (adminrespond_ != NULL) adminrespond_->::vmsg::CSAdminRespond::Clear();
  clear_has_adminrespond();
}
inline const ::vmsg::CSAdminRespond& VLogicSvr2CliMsg::adminrespond() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return adminrespond_ != NULL ? *adminrespond_ : *default_instance().adminrespond_;
#else
  return adminrespond_ != NULL ? *adminrespond_ : *default_instance_->adminrespond_;
#endif
}
inline ::vmsg::CSAdminRespond* VLogicSvr2CliMsg::mutable_adminrespond() {
  set_has_adminrespond();
  if (adminrespond_ == NULL) adminrespond_ = new ::vmsg::CSAdminRespond;
  return adminrespond_;
}
inline ::vmsg::CSAdminRespond* VLogicSvr2CliMsg::release_adminrespond() {
  clear_has_adminrespond();
  ::vmsg::CSAdminRespond* temp = adminrespond_;
  adminrespond_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_adminrespond(::vmsg::CSAdminRespond* adminrespond) {
  delete adminrespond_;
  adminrespond_ = adminrespond;
  if (adminrespond) {
    set_has_adminrespond();
  } else {
    clear_has_adminrespond();
  }
}

// optional .vmsg.CSAccountRespond Account_Rsp = 102;
inline bool VLogicSvr2CliMsg::has_account_rsp() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void VLogicSvr2CliMsg::set_has_account_rsp() {
  _has_bits_[1] |= 0x00000001u;
}
inline void VLogicSvr2CliMsg::clear_has_account_rsp() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void VLogicSvr2CliMsg::clear_account_rsp() {
  if (account_rsp_ != NULL) account_rsp_->::vmsg::CSAccountRespond::Clear();
  clear_has_account_rsp();
}
inline const ::vmsg::CSAccountRespond& VLogicSvr2CliMsg::account_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return account_rsp_ != NULL ? *account_rsp_ : *default_instance().account_rsp_;
#else
  return account_rsp_ != NULL ? *account_rsp_ : *default_instance_->account_rsp_;
#endif
}
inline ::vmsg::CSAccountRespond* VLogicSvr2CliMsg::mutable_account_rsp() {
  set_has_account_rsp();
  if (account_rsp_ == NULL) account_rsp_ = new ::vmsg::CSAccountRespond;
  return account_rsp_;
}
inline ::vmsg::CSAccountRespond* VLogicSvr2CliMsg::release_account_rsp() {
  clear_has_account_rsp();
  ::vmsg::CSAccountRespond* temp = account_rsp_;
  account_rsp_ = NULL;
  return temp;
}
inline void VLogicSvr2CliMsg::set_allocated_account_rsp(::vmsg::CSAccountRespond* account_rsp) {
  delete account_rsp_;
  account_rsp_ = account_rsp;
  if (account_rsp) {
    set_has_account_rsp();
  } else {
    clear_has_account_rsp();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ClientSvrMsg_2eproto__INCLUDED
