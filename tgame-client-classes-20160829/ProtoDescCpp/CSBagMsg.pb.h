// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSBagMsg.proto

#ifndef PROTOBUF_CSBagMsg_2eproto__INCLUDED
#define PROTOBUF_CSBagMsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MsgBase.pb.h"
#include "ShareByClient.pb.h"
#include "CSPlayerMsg.pb.h"
#include "CSEquipItemMsg.pb.h"
// @@protoc_insertion_point(includes)

namespace vmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CSBagMsg_2eproto();
void protobuf_AssignDesc_CSBagMsg_2eproto();
void protobuf_ShutdownFile_CSBagMsg_2eproto();

class CSBagCellInfo;
class CSBagInfo;
class CSQueryBagInfoRqst;
class CSQueryBagInfoRsp;
class CSBagInfoNotify;
class CSWearEquipRqst;
class CSWearEquipRsp;
class CSEnlargeRqst;
class CSEnlargeRsp;
class CSTakeOffEquipRqst;
class CSTakeOffEquipRsp;
class CSBagSellRqst;
class CSBagSellRsp;
class CSBagStatNotify;
class CSBuyItemRqst;
class CSBuyItemRsp;
class CSConsumeItemRqst;
class CSConsumeItemRsp;
class CSBagRequest;
class CSBagRespond;

// ===================================================================

class CSBagCellInfo : public ::google::protobuf::MessageLite {
 public:
  CSBagCellInfo();
  virtual ~CSBagCellInfo();

  CSBagCellInfo(const CSBagCellInfo& from);

  inline CSBagCellInfo& operator=(const CSBagCellInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBagCellInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBagCellInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBagCellInfo* other);

  // implements Message ----------------------------------------------

  CSBagCellInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBagCellInfo& from);
  void MergeFrom(const CSBagCellInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // required uint32 Type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional .vmsg.CSEquipInfo EquipInfo = 3;
  inline bool has_equipinfo() const;
  inline void clear_equipinfo();
  static const int kEquipInfoFieldNumber = 3;
  inline const ::vmsg::CSEquipInfo& equipinfo() const;
  inline ::vmsg::CSEquipInfo* mutable_equipinfo();
  inline ::vmsg::CSEquipInfo* release_equipinfo();
  inline void set_allocated_equipinfo(::vmsg::CSEquipInfo* equipinfo);

  // optional .vmsg.CSItemInfo ItemInfo = 4;
  inline bool has_iteminfo() const;
  inline void clear_iteminfo();
  static const int kItemInfoFieldNumber = 4;
  inline const ::vmsg::CSItemInfo& iteminfo() const;
  inline ::vmsg::CSItemInfo* mutable_iteminfo();
  inline ::vmsg::CSItemInfo* release_iteminfo();
  inline void set_allocated_iteminfo(::vmsg::CSItemInfo* iteminfo);

  // @@protoc_insertion_point(class_scope:vmsg.CSBagCellInfo)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_equipinfo();
  inline void clear_has_equipinfo();
  inline void set_has_iteminfo();
  inline void clear_has_iteminfo();

  ::google::protobuf::int32 index_;
  ::google::protobuf::uint32 type_;
  ::vmsg::CSEquipInfo* equipinfo_;
  ::vmsg::CSItemInfo* iteminfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBagMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBagMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBagMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBagMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBagCellInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSBagInfo : public ::google::protobuf::MessageLite {
 public:
  CSBagInfo();
  virtual ~CSBagInfo();

  CSBagInfo(const CSBagInfo& from);

  inline CSBagInfo& operator=(const CSBagInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBagInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBagInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBagInfo* other);

  // implements Message ----------------------------------------------

  CSBagInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBagInfo& from);
  void MergeFrom(const CSBagInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Capacity = 1;
  inline bool has_capacity() const;
  inline void clear_capacity();
  static const int kCapacityFieldNumber = 1;
  inline ::google::protobuf::uint32 capacity() const;
  inline void set_capacity(::google::protobuf::uint32 value);

  // repeated .vmsg.CSBagCellInfo CellLst = 2;
  inline int celllst_size() const;
  inline void clear_celllst();
  static const int kCellLstFieldNumber = 2;
  inline const ::vmsg::CSBagCellInfo& celllst(int index) const;
  inline ::vmsg::CSBagCellInfo* mutable_celllst(int index);
  inline ::vmsg::CSBagCellInfo* add_celllst();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSBagCellInfo >&
      celllst() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSBagCellInfo >*
      mutable_celllst();

  // @@protoc_insertion_point(class_scope:vmsg.CSBagInfo)
 private:
  inline void set_has_capacity();
  inline void clear_has_capacity();

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSBagCellInfo > celllst_;
  ::google::protobuf::uint32 capacity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBagMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBagMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBagMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBagMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBagInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSQueryBagInfoRqst : public ::google::protobuf::MessageLite {
 public:
  CSQueryBagInfoRqst();
  virtual ~CSQueryBagInfoRqst();

  CSQueryBagInfoRqst(const CSQueryBagInfoRqst& from);

  inline CSQueryBagInfoRqst& operator=(const CSQueryBagInfoRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSQueryBagInfoRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQueryBagInfoRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQueryBagInfoRqst* other);

  // implements Message ----------------------------------------------

  CSQueryBagInfoRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQueryBagInfoRqst& from);
  void MergeFrom(const CSQueryBagInfoRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vmsg.CSQueryBagInfoRqst)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBagMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBagMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBagMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBagMsg_2eproto();

  void InitAsDefaultInstance();
  static CSQueryBagInfoRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSQueryBagInfoRsp : public ::google::protobuf::MessageLite {
 public:
  CSQueryBagInfoRsp();
  virtual ~CSQueryBagInfoRsp();

  CSQueryBagInfoRsp(const CSQueryBagInfoRsp& from);

  inline CSQueryBagInfoRsp& operator=(const CSQueryBagInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSQueryBagInfoRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQueryBagInfoRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQueryBagInfoRsp* other);

  // implements Message ----------------------------------------------

  CSQueryBagInfoRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQueryBagInfoRsp& from);
  void MergeFrom(const CSQueryBagInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSBagInfo BagInfo = 1;
  inline bool has_baginfo() const;
  inline void clear_baginfo();
  static const int kBagInfoFieldNumber = 1;
  inline const ::vmsg::CSBagInfo& baginfo() const;
  inline ::vmsg::CSBagInfo* mutable_baginfo();
  inline ::vmsg::CSBagInfo* release_baginfo();
  inline void set_allocated_baginfo(::vmsg::CSBagInfo* baginfo);

  // @@protoc_insertion_point(class_scope:vmsg.CSQueryBagInfoRsp)
 private:
  inline void set_has_baginfo();
  inline void clear_has_baginfo();

  ::vmsg::CSBagInfo* baginfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBagMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBagMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBagMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBagMsg_2eproto();

  void InitAsDefaultInstance();
  static CSQueryBagInfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSBagInfoNotify : public ::google::protobuf::MessageLite {
 public:
  CSBagInfoNotify();
  virtual ~CSBagInfoNotify();

  CSBagInfoNotify(const CSBagInfoNotify& from);

  inline CSBagInfoNotify& operator=(const CSBagInfoNotify& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBagInfoNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBagInfoNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBagInfoNotify* other);

  // implements Message ----------------------------------------------

  CSBagInfoNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBagInfoNotify& from);
  void MergeFrom(const CSBagInfoNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 PkgID = 1;
  inline bool has_pkgid() const;
  inline void clear_pkgid();
  static const int kPkgIDFieldNumber = 1;
  inline ::google::protobuf::uint32 pkgid() const;
  inline void set_pkgid(::google::protobuf::uint32 value);

  // required .vmsg.CSBagInfo BagInfo = 2;
  inline bool has_baginfo() const;
  inline void clear_baginfo();
  static const int kBagInfoFieldNumber = 2;
  inline const ::vmsg::CSBagInfo& baginfo() const;
  inline ::vmsg::CSBagInfo* mutable_baginfo();
  inline ::vmsg::CSBagInfo* release_baginfo();
  inline void set_allocated_baginfo(::vmsg::CSBagInfo* baginfo);

  // @@protoc_insertion_point(class_scope:vmsg.CSBagInfoNotify)
 private:
  inline void set_has_pkgid();
  inline void clear_has_pkgid();
  inline void set_has_baginfo();
  inline void clear_has_baginfo();

  ::vmsg::CSBagInfo* baginfo_;
  ::google::protobuf::uint32 pkgid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBagMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBagMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBagMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBagMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBagInfoNotify* default_instance_;
};
// -------------------------------------------------------------------

class CSWearEquipRqst : public ::google::protobuf::MessageLite {
 public:
  CSWearEquipRqst();
  virtual ~CSWearEquipRqst();

  CSWearEquipRqst(const CSWearEquipRqst& from);

  inline CSWearEquipRqst& operator=(const CSWearEquipRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWearEquipRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWearEquipRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWearEquipRqst* other);

  // implements Message ----------------------------------------------

  CSWearEquipRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWearEquipRqst& from);
  void MergeFrom(const CSWearEquipRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 CellIdx = 1;
  inline bool has_cellidx() const;
  inline void clear_cellidx();
  static const int kCellIdxFieldNumber = 1;
  inline ::google::protobuf::int32 cellidx() const;
  inline void set_cellidx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSWearEquipRqst)
 private:
  inline void set_has_cellidx();
  inline void clear_has_cellidx();

  ::google::protobuf::int32 cellidx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBagMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBagMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBagMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBagMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWearEquipRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSWearEquipRsp : public ::google::protobuf::MessageLite {
 public:
  CSWearEquipRsp();
  virtual ~CSWearEquipRsp();

  CSWearEquipRsp(const CSWearEquipRsp& from);

  inline CSWearEquipRsp& operator=(const CSWearEquipRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWearEquipRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWearEquipRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWearEquipRsp* other);

  // implements Message ----------------------------------------------

  CSWearEquipRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWearEquipRsp& from);
  void MergeFrom(const CSWearEquipRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSBagInfo BagInfo = 1;
  inline bool has_baginfo() const;
  inline void clear_baginfo();
  static const int kBagInfoFieldNumber = 1;
  inline const ::vmsg::CSBagInfo& baginfo() const;
  inline ::vmsg::CSBagInfo* mutable_baginfo();
  inline ::vmsg::CSBagInfo* release_baginfo();
  inline void set_allocated_baginfo(::vmsg::CSBagInfo* baginfo);

  // required .vmsg.CSPlayerDetailInfo PlayerDetailInfo = 2;
  inline bool has_playerdetailinfo() const;
  inline void clear_playerdetailinfo();
  static const int kPlayerDetailInfoFieldNumber = 2;
  inline const ::vmsg::CSPlayerDetailInfo& playerdetailinfo() const;
  inline ::vmsg::CSPlayerDetailInfo* mutable_playerdetailinfo();
  inline ::vmsg::CSPlayerDetailInfo* release_playerdetailinfo();
  inline void set_allocated_playerdetailinfo(::vmsg::CSPlayerDetailInfo* playerdetailinfo);

  // @@protoc_insertion_point(class_scope:vmsg.CSWearEquipRsp)
 private:
  inline void set_has_baginfo();
  inline void clear_has_baginfo();
  inline void set_has_playerdetailinfo();
  inline void clear_has_playerdetailinfo();

  ::vmsg::CSBagInfo* baginfo_;
  ::vmsg::CSPlayerDetailInfo* playerdetailinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBagMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBagMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBagMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBagMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWearEquipRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSEnlargeRqst : public ::google::protobuf::MessageLite {
 public:
  CSEnlargeRqst();
  virtual ~CSEnlargeRqst();

  CSEnlargeRqst(const CSEnlargeRqst& from);

  inline CSEnlargeRqst& operator=(const CSEnlargeRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEnlargeRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEnlargeRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEnlargeRqst* other);

  // implements Message ----------------------------------------------

  CSEnlargeRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEnlargeRqst& from);
  void MergeFrom(const CSEnlargeRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 EnlargeCnt = 1;
  inline bool has_enlargecnt() const;
  inline void clear_enlargecnt();
  static const int kEnlargeCntFieldNumber = 1;
  inline ::google::protobuf::int32 enlargecnt() const;
  inline void set_enlargecnt(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSEnlargeRqst)
 private:
  inline void set_has_enlargecnt();
  inline void clear_has_enlargecnt();

  ::google::protobuf::int32 enlargecnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBagMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBagMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBagMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBagMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEnlargeRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSEnlargeRsp : public ::google::protobuf::MessageLite {
 public:
  CSEnlargeRsp();
  virtual ~CSEnlargeRsp();

  CSEnlargeRsp(const CSEnlargeRsp& from);

  inline CSEnlargeRsp& operator=(const CSEnlargeRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEnlargeRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEnlargeRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEnlargeRsp* other);

  // implements Message ----------------------------------------------

  CSEnlargeRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEnlargeRsp& from);
  void MergeFrom(const CSEnlargeRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 EnlargeCnt = 1;
  inline bool has_enlargecnt() const;
  inline void clear_enlargecnt();
  static const int kEnlargeCntFieldNumber = 1;
  inline ::google::protobuf::int32 enlargecnt() const;
  inline void set_enlargecnt(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSEnlargeRsp)
 private:
  inline void set_has_enlargecnt();
  inline void clear_has_enlargecnt();

  ::google::protobuf::int32 enlargecnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBagMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBagMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBagMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBagMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEnlargeRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSTakeOffEquipRqst : public ::google::protobuf::MessageLite {
 public:
  CSTakeOffEquipRqst();
  virtual ~CSTakeOffEquipRqst();

  CSTakeOffEquipRqst(const CSTakeOffEquipRqst& from);

  inline CSTakeOffEquipRqst& operator=(const CSTakeOffEquipRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSTakeOffEquipRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSTakeOffEquipRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSTakeOffEquipRqst* other);

  // implements Message ----------------------------------------------

  CSTakeOffEquipRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSTakeOffEquipRqst& from);
  void MergeFrom(const CSTakeOffEquipRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 EquipGUID = 1;
  inline bool has_equipguid() const;
  inline void clear_equipguid();
  static const int kEquipGUIDFieldNumber = 1;
  inline ::google::protobuf::uint64 equipguid() const;
  inline void set_equipguid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSTakeOffEquipRqst)
 private:
  inline void set_has_equipguid();
  inline void clear_has_equipguid();

  ::google::protobuf::uint64 equipguid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBagMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBagMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBagMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBagMsg_2eproto();

  void InitAsDefaultInstance();
  static CSTakeOffEquipRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSTakeOffEquipRsp : public ::google::protobuf::MessageLite {
 public:
  CSTakeOffEquipRsp();
  virtual ~CSTakeOffEquipRsp();

  CSTakeOffEquipRsp(const CSTakeOffEquipRsp& from);

  inline CSTakeOffEquipRsp& operator=(const CSTakeOffEquipRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSTakeOffEquipRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSTakeOffEquipRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSTakeOffEquipRsp* other);

  // implements Message ----------------------------------------------

  CSTakeOffEquipRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSTakeOffEquipRsp& from);
  void MergeFrom(const CSTakeOffEquipRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSBagInfo BagInfo = 1;
  inline bool has_baginfo() const;
  inline void clear_baginfo();
  static const int kBagInfoFieldNumber = 1;
  inline const ::vmsg::CSBagInfo& baginfo() const;
  inline ::vmsg::CSBagInfo* mutable_baginfo();
  inline ::vmsg::CSBagInfo* release_baginfo();
  inline void set_allocated_baginfo(::vmsg::CSBagInfo* baginfo);

  // required .vmsg.CSPlayerDetailInfo PlayerDetailInfo = 2;
  inline bool has_playerdetailinfo() const;
  inline void clear_playerdetailinfo();
  static const int kPlayerDetailInfoFieldNumber = 2;
  inline const ::vmsg::CSPlayerDetailInfo& playerdetailinfo() const;
  inline ::vmsg::CSPlayerDetailInfo* mutable_playerdetailinfo();
  inline ::vmsg::CSPlayerDetailInfo* release_playerdetailinfo();
  inline void set_allocated_playerdetailinfo(::vmsg::CSPlayerDetailInfo* playerdetailinfo);

  // @@protoc_insertion_point(class_scope:vmsg.CSTakeOffEquipRsp)
 private:
  inline void set_has_baginfo();
  inline void clear_has_baginfo();
  inline void set_has_playerdetailinfo();
  inline void clear_has_playerdetailinfo();

  ::vmsg::CSBagInfo* baginfo_;
  ::vmsg::CSPlayerDetailInfo* playerdetailinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBagMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBagMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBagMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBagMsg_2eproto();

  void InitAsDefaultInstance();
  static CSTakeOffEquipRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSBagSellRqst : public ::google::protobuf::MessageLite {
 public:
  CSBagSellRqst();
  virtual ~CSBagSellRqst();

  CSBagSellRqst(const CSBagSellRqst& from);

  inline CSBagSellRqst& operator=(const CSBagSellRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBagSellRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBagSellRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBagSellRqst* other);

  // implements Message ----------------------------------------------

  CSBagSellRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBagSellRqst& from);
  void MergeFrom(const CSBagSellRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 BagIdx = 1;
  inline bool has_bagidx() const;
  inline void clear_bagidx();
  static const int kBagIdxFieldNumber = 1;
  inline ::google::protobuf::int32 bagidx() const;
  inline void set_bagidx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSBagSellRqst)
 private:
  inline void set_has_bagidx();
  inline void clear_has_bagidx();

  ::google::protobuf::int32 bagidx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBagMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBagMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBagMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBagMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBagSellRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSBagSellRsp : public ::google::protobuf::MessageLite {
 public:
  CSBagSellRsp();
  virtual ~CSBagSellRsp();

  CSBagSellRsp(const CSBagSellRsp& from);

  inline CSBagSellRsp& operator=(const CSBagSellRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBagSellRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBagSellRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBagSellRsp* other);

  // implements Message ----------------------------------------------

  CSBagSellRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBagSellRsp& from);
  void MergeFrom(const CSBagSellRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 BagIdx = 1;
  inline bool has_bagidx() const;
  inline void clear_bagidx();
  static const int kBagIdxFieldNumber = 1;
  inline ::google::protobuf::int32 bagidx() const;
  inline void set_bagidx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSBagSellRsp)
 private:
  inline void set_has_bagidx();
  inline void clear_has_bagidx();

  ::google::protobuf::int32 bagidx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBagMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBagMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBagMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBagMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBagSellRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSBagStatNotify : public ::google::protobuf::MessageLite {
 public:
  CSBagStatNotify();
  virtual ~CSBagStatNotify();

  CSBagStatNotify(const CSBagStatNotify& from);

  inline CSBagStatNotify& operator=(const CSBagStatNotify& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBagStatNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBagStatNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBagStatNotify* other);

  // implements Message ----------------------------------------------

  CSBagStatNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBagStatNotify& from);
  void MergeFrom(const CSBagStatNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 IsFull = 1;
  inline bool has_isfull() const;
  inline void clear_isfull();
  static const int kIsFullFieldNumber = 1;
  inline ::google::protobuf::uint32 isfull() const;
  inline void set_isfull(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSBagStatNotify)
 private:
  inline void set_has_isfull();
  inline void clear_has_isfull();

  ::google::protobuf::uint32 isfull_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBagMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBagMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBagMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBagMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBagStatNotify* default_instance_;
};
// -------------------------------------------------------------------

class CSBuyItemRqst : public ::google::protobuf::MessageLite {
 public:
  CSBuyItemRqst();
  virtual ~CSBuyItemRqst();

  CSBuyItemRqst(const CSBuyItemRqst& from);

  inline CSBuyItemRqst& operator=(const CSBuyItemRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBuyItemRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBuyItemRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBuyItemRqst* other);

  // implements Message ----------------------------------------------

  CSBuyItemRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBuyItemRqst& from);
  void MergeFrom(const CSBuyItemRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ItemType = 1;
  inline bool has_itemtype() const;
  inline void clear_itemtype();
  static const int kItemTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 itemtype() const;
  inline void set_itemtype(::google::protobuf::uint32 value);

  // required uint32 ItemCfgID = 2;
  inline bool has_itemcfgid() const;
  inline void clear_itemcfgid();
  static const int kItemCfgIDFieldNumber = 2;
  inline ::google::protobuf::uint32 itemcfgid() const;
  inline void set_itemcfgid(::google::protobuf::uint32 value);

  // required uint32 Cnt = 3;
  inline bool has_cnt() const;
  inline void clear_cnt();
  static const int kCntFieldNumber = 3;
  inline ::google::protobuf::uint32 cnt() const;
  inline void set_cnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSBuyItemRqst)
 private:
  inline void set_has_itemtype();
  inline void clear_has_itemtype();
  inline void set_has_itemcfgid();
  inline void clear_has_itemcfgid();
  inline void set_has_cnt();
  inline void clear_has_cnt();

  ::google::protobuf::uint32 itemtype_;
  ::google::protobuf::uint32 itemcfgid_;
  ::google::protobuf::uint32 cnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBagMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBagMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBagMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBagMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBuyItemRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSBuyItemRsp : public ::google::protobuf::MessageLite {
 public:
  CSBuyItemRsp();
  virtual ~CSBuyItemRsp();

  CSBuyItemRsp(const CSBuyItemRsp& from);

  inline CSBuyItemRsp& operator=(const CSBuyItemRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBuyItemRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBuyItemRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBuyItemRsp* other);

  // implements Message ----------------------------------------------

  CSBuyItemRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBuyItemRsp& from);
  void MergeFrom(const CSBuyItemRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ItemType = 1;
  inline bool has_itemtype() const;
  inline void clear_itemtype();
  static const int kItemTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 itemtype() const;
  inline void set_itemtype(::google::protobuf::uint32 value);

  // required uint32 ItemCfgID = 2;
  inline bool has_itemcfgid() const;
  inline void clear_itemcfgid();
  static const int kItemCfgIDFieldNumber = 2;
  inline ::google::protobuf::uint32 itemcfgid() const;
  inline void set_itemcfgid(::google::protobuf::uint32 value);

  // required uint32 Cnt = 3;
  inline bool has_cnt() const;
  inline void clear_cnt();
  static const int kCntFieldNumber = 3;
  inline ::google::protobuf::uint32 cnt() const;
  inline void set_cnt(::google::protobuf::uint32 value);

  // required .vmsg.CSBagInfo BagInfo = 4;
  inline bool has_baginfo() const;
  inline void clear_baginfo();
  static const int kBagInfoFieldNumber = 4;
  inline const ::vmsg::CSBagInfo& baginfo() const;
  inline ::vmsg::CSBagInfo* mutable_baginfo();
  inline ::vmsg::CSBagInfo* release_baginfo();
  inline void set_allocated_baginfo(::vmsg::CSBagInfo* baginfo);

  // @@protoc_insertion_point(class_scope:vmsg.CSBuyItemRsp)
 private:
  inline void set_has_itemtype();
  inline void clear_has_itemtype();
  inline void set_has_itemcfgid();
  inline void clear_has_itemcfgid();
  inline void set_has_cnt();
  inline void clear_has_cnt();
  inline void set_has_baginfo();
  inline void clear_has_baginfo();

  ::google::protobuf::uint32 itemtype_;
  ::google::protobuf::uint32 itemcfgid_;
  ::vmsg::CSBagInfo* baginfo_;
  ::google::protobuf::uint32 cnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBagMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBagMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBagMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBagMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBuyItemRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSConsumeItemRqst : public ::google::protobuf::MessageLite {
 public:
  CSConsumeItemRqst();
  virtual ~CSConsumeItemRqst();

  CSConsumeItemRqst(const CSConsumeItemRqst& from);

  inline CSConsumeItemRqst& operator=(const CSConsumeItemRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSConsumeItemRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSConsumeItemRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSConsumeItemRqst* other);

  // implements Message ----------------------------------------------

  CSConsumeItemRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSConsumeItemRqst& from);
  void MergeFrom(const CSConsumeItemRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 BagIdx = 1;
  inline bool has_bagidx() const;
  inline void clear_bagidx();
  static const int kBagIdxFieldNumber = 1;
  inline ::google::protobuf::int32 bagidx() const;
  inline void set_bagidx(::google::protobuf::int32 value);

  // required uint32 CfgID = 2;
  inline bool has_cfgid() const;
  inline void clear_cfgid();
  static const int kCfgIDFieldNumber = 2;
  inline ::google::protobuf::uint32 cfgid() const;
  inline void set_cfgid(::google::protobuf::uint32 value);

  // required uint32 Type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 Cnt = 4;
  inline bool has_cnt() const;
  inline void clear_cnt();
  static const int kCntFieldNumber = 4;
  inline ::google::protobuf::uint32 cnt() const;
  inline void set_cnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSConsumeItemRqst)
 private:
  inline void set_has_bagidx();
  inline void clear_has_bagidx();
  inline void set_has_cfgid();
  inline void clear_has_cfgid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_cnt();
  inline void clear_has_cnt();

  ::google::protobuf::int32 bagidx_;
  ::google::protobuf::uint32 cfgid_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 cnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBagMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBagMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBagMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBagMsg_2eproto();

  void InitAsDefaultInstance();
  static CSConsumeItemRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSConsumeItemRsp : public ::google::protobuf::MessageLite {
 public:
  CSConsumeItemRsp();
  virtual ~CSConsumeItemRsp();

  CSConsumeItemRsp(const CSConsumeItemRsp& from);

  inline CSConsumeItemRsp& operator=(const CSConsumeItemRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSConsumeItemRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSConsumeItemRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSConsumeItemRsp* other);

  // implements Message ----------------------------------------------

  CSConsumeItemRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSConsumeItemRsp& from);
  void MergeFrom(const CSConsumeItemRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSBagInfo BagInfo = 1;
  inline bool has_baginfo() const;
  inline void clear_baginfo();
  static const int kBagInfoFieldNumber = 1;
  inline const ::vmsg::CSBagInfo& baginfo() const;
  inline ::vmsg::CSBagInfo* mutable_baginfo();
  inline ::vmsg::CSBagInfo* release_baginfo();
  inline void set_allocated_baginfo(::vmsg::CSBagInfo* baginfo);

  // required uint32 CfgID = 2;
  inline bool has_cfgid() const;
  inline void clear_cfgid();
  static const int kCfgIDFieldNumber = 2;
  inline ::google::protobuf::uint32 cfgid() const;
  inline void set_cfgid(::google::protobuf::uint32 value);

  // required uint32 Type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 Cnt = 4;
  inline bool has_cnt() const;
  inline void clear_cnt();
  static const int kCntFieldNumber = 4;
  inline ::google::protobuf::uint32 cnt() const;
  inline void set_cnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSConsumeItemRsp)
 private:
  inline void set_has_baginfo();
  inline void clear_has_baginfo();
  inline void set_has_cfgid();
  inline void clear_has_cfgid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_cnt();
  inline void clear_has_cnt();

  ::vmsg::CSBagInfo* baginfo_;
  ::google::protobuf::uint32 cfgid_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 cnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBagMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBagMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBagMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBagMsg_2eproto();

  void InitAsDefaultInstance();
  static CSConsumeItemRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSBagRequest : public ::google::protobuf::MessageLite {
 public:
  CSBagRequest();
  virtual ~CSBagRequest();

  CSBagRequest(const CSBagRequest& from);

  inline CSBagRequest& operator=(const CSBagRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBagRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBagRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBagRequest* other);

  // implements Message ----------------------------------------------

  CSBagRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBagRequest& from);
  void MergeFrom(const CSBagRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSQueryBagInfoRqst QueryBagInfo_Rqst = 1;
  inline bool has_querybaginfo_rqst() const;
  inline void clear_querybaginfo_rqst();
  static const int kQueryBagInfoRqstFieldNumber = 1;
  inline const ::vmsg::CSQueryBagInfoRqst& querybaginfo_rqst() const;
  inline ::vmsg::CSQueryBagInfoRqst* mutable_querybaginfo_rqst();
  inline ::vmsg::CSQueryBagInfoRqst* release_querybaginfo_rqst();
  inline void set_allocated_querybaginfo_rqst(::vmsg::CSQueryBagInfoRqst* querybaginfo_rqst);

  // optional .vmsg.CSWearEquipRqst WearEquip_Rqst = 4;
  inline bool has_wearequip_rqst() const;
  inline void clear_wearequip_rqst();
  static const int kWearEquipRqstFieldNumber = 4;
  inline const ::vmsg::CSWearEquipRqst& wearequip_rqst() const;
  inline ::vmsg::CSWearEquipRqst* mutable_wearequip_rqst();
  inline ::vmsg::CSWearEquipRqst* release_wearequip_rqst();
  inline void set_allocated_wearequip_rqst(::vmsg::CSWearEquipRqst* wearequip_rqst);

  // optional .vmsg.CSEnlargeRqst Enlarge_Rqst = 5;
  inline bool has_enlarge_rqst() const;
  inline void clear_enlarge_rqst();
  static const int kEnlargeRqstFieldNumber = 5;
  inline const ::vmsg::CSEnlargeRqst& enlarge_rqst() const;
  inline ::vmsg::CSEnlargeRqst* mutable_enlarge_rqst();
  inline ::vmsg::CSEnlargeRqst* release_enlarge_rqst();
  inline void set_allocated_enlarge_rqst(::vmsg::CSEnlargeRqst* enlarge_rqst);

  // optional .vmsg.CSTakeOffEquipRqst TakeOffEquip_Rqst = 6;
  inline bool has_takeoffequip_rqst() const;
  inline void clear_takeoffequip_rqst();
  static const int kTakeOffEquipRqstFieldNumber = 6;
  inline const ::vmsg::CSTakeOffEquipRqst& takeoffequip_rqst() const;
  inline ::vmsg::CSTakeOffEquipRqst* mutable_takeoffequip_rqst();
  inline ::vmsg::CSTakeOffEquipRqst* release_takeoffequip_rqst();
  inline void set_allocated_takeoffequip_rqst(::vmsg::CSTakeOffEquipRqst* takeoffequip_rqst);

  // optional .vmsg.CSBagSellRqst BagSell_Rqst = 7;
  inline bool has_bagsell_rqst() const;
  inline void clear_bagsell_rqst();
  static const int kBagSellRqstFieldNumber = 7;
  inline const ::vmsg::CSBagSellRqst& bagsell_rqst() const;
  inline ::vmsg::CSBagSellRqst* mutable_bagsell_rqst();
  inline ::vmsg::CSBagSellRqst* release_bagsell_rqst();
  inline void set_allocated_bagsell_rqst(::vmsg::CSBagSellRqst* bagsell_rqst);

  // optional .vmsg.CSBuyItemRqst BuyItem_Rqst = 8;
  inline bool has_buyitem_rqst() const;
  inline void clear_buyitem_rqst();
  static const int kBuyItemRqstFieldNumber = 8;
  inline const ::vmsg::CSBuyItemRqst& buyitem_rqst() const;
  inline ::vmsg::CSBuyItemRqst* mutable_buyitem_rqst();
  inline ::vmsg::CSBuyItemRqst* release_buyitem_rqst();
  inline void set_allocated_buyitem_rqst(::vmsg::CSBuyItemRqst* buyitem_rqst);

  // optional .vmsg.CSConsumeItemRqst ConsumeItem_Rqst = 9;
  inline bool has_consumeitem_rqst() const;
  inline void clear_consumeitem_rqst();
  static const int kConsumeItemRqstFieldNumber = 9;
  inline const ::vmsg::CSConsumeItemRqst& consumeitem_rqst() const;
  inline ::vmsg::CSConsumeItemRqst* mutable_consumeitem_rqst();
  inline ::vmsg::CSConsumeItemRqst* release_consumeitem_rqst();
  inline void set_allocated_consumeitem_rqst(::vmsg::CSConsumeItemRqst* consumeitem_rqst);

  // @@protoc_insertion_point(class_scope:vmsg.CSBagRequest)
 private:
  inline void set_has_querybaginfo_rqst();
  inline void clear_has_querybaginfo_rqst();
  inline void set_has_wearequip_rqst();
  inline void clear_has_wearequip_rqst();
  inline void set_has_enlarge_rqst();
  inline void clear_has_enlarge_rqst();
  inline void set_has_takeoffequip_rqst();
  inline void clear_has_takeoffequip_rqst();
  inline void set_has_bagsell_rqst();
  inline void clear_has_bagsell_rqst();
  inline void set_has_buyitem_rqst();
  inline void clear_has_buyitem_rqst();
  inline void set_has_consumeitem_rqst();
  inline void clear_has_consumeitem_rqst();

  ::vmsg::CSQueryBagInfoRqst* querybaginfo_rqst_;
  ::vmsg::CSWearEquipRqst* wearequip_rqst_;
  ::vmsg::CSEnlargeRqst* enlarge_rqst_;
  ::vmsg::CSTakeOffEquipRqst* takeoffequip_rqst_;
  ::vmsg::CSBagSellRqst* bagsell_rqst_;
  ::vmsg::CSBuyItemRqst* buyitem_rqst_;
  ::vmsg::CSConsumeItemRqst* consumeitem_rqst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBagMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBagMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBagMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBagMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBagRequest* default_instance_;
};
// -------------------------------------------------------------------

class CSBagRespond : public ::google::protobuf::MessageLite {
 public:
  CSBagRespond();
  virtual ~CSBagRespond();

  CSBagRespond(const CSBagRespond& from);

  inline CSBagRespond& operator=(const CSBagRespond& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBagRespond& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBagRespond* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBagRespond* other);

  // implements Message ----------------------------------------------

  CSBagRespond* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBagRespond& from);
  void MergeFrom(const CSBagRespond& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSQueryBagInfoRsp QueryBagInfo_Rsp = 1;
  inline bool has_querybaginfo_rsp() const;
  inline void clear_querybaginfo_rsp();
  static const int kQueryBagInfoRspFieldNumber = 1;
  inline const ::vmsg::CSQueryBagInfoRsp& querybaginfo_rsp() const;
  inline ::vmsg::CSQueryBagInfoRsp* mutable_querybaginfo_rsp();
  inline ::vmsg::CSQueryBagInfoRsp* release_querybaginfo_rsp();
  inline void set_allocated_querybaginfo_rsp(::vmsg::CSQueryBagInfoRsp* querybaginfo_rsp);

  // optional .vmsg.CSWearEquipRsp WearEquip_Rsp = 4;
  inline bool has_wearequip_rsp() const;
  inline void clear_wearequip_rsp();
  static const int kWearEquipRspFieldNumber = 4;
  inline const ::vmsg::CSWearEquipRsp& wearequip_rsp() const;
  inline ::vmsg::CSWearEquipRsp* mutable_wearequip_rsp();
  inline ::vmsg::CSWearEquipRsp* release_wearequip_rsp();
  inline void set_allocated_wearequip_rsp(::vmsg::CSWearEquipRsp* wearequip_rsp);

  // optional .vmsg.CSEnlargeRsp Enlarge_Rsp = 5;
  inline bool has_enlarge_rsp() const;
  inline void clear_enlarge_rsp();
  static const int kEnlargeRspFieldNumber = 5;
  inline const ::vmsg::CSEnlargeRsp& enlarge_rsp() const;
  inline ::vmsg::CSEnlargeRsp* mutable_enlarge_rsp();
  inline ::vmsg::CSEnlargeRsp* release_enlarge_rsp();
  inline void set_allocated_enlarge_rsp(::vmsg::CSEnlargeRsp* enlarge_rsp);

  // optional .vmsg.CSTakeOffEquipRsp TakeOffEquip_Rsp = 6;
  inline bool has_takeoffequip_rsp() const;
  inline void clear_takeoffequip_rsp();
  static const int kTakeOffEquipRspFieldNumber = 6;
  inline const ::vmsg::CSTakeOffEquipRsp& takeoffequip_rsp() const;
  inline ::vmsg::CSTakeOffEquipRsp* mutable_takeoffequip_rsp();
  inline ::vmsg::CSTakeOffEquipRsp* release_takeoffequip_rsp();
  inline void set_allocated_takeoffequip_rsp(::vmsg::CSTakeOffEquipRsp* takeoffequip_rsp);

  // optional .vmsg.CSBagSellRsp BagSell_Rsp = 7;
  inline bool has_bagsell_rsp() const;
  inline void clear_bagsell_rsp();
  static const int kBagSellRspFieldNumber = 7;
  inline const ::vmsg::CSBagSellRsp& bagsell_rsp() const;
  inline ::vmsg::CSBagSellRsp* mutable_bagsell_rsp();
  inline ::vmsg::CSBagSellRsp* release_bagsell_rsp();
  inline void set_allocated_bagsell_rsp(::vmsg::CSBagSellRsp* bagsell_rsp);

  // optional .vmsg.CSBagStatNotify BagStat_Notify = 8;
  inline bool has_bagstat_notify() const;
  inline void clear_bagstat_notify();
  static const int kBagStatNotifyFieldNumber = 8;
  inline const ::vmsg::CSBagStatNotify& bagstat_notify() const;
  inline ::vmsg::CSBagStatNotify* mutable_bagstat_notify();
  inline ::vmsg::CSBagStatNotify* release_bagstat_notify();
  inline void set_allocated_bagstat_notify(::vmsg::CSBagStatNotify* bagstat_notify);

  // optional .vmsg.CSBagInfoNotify BagInfo_Notify = 9;
  inline bool has_baginfo_notify() const;
  inline void clear_baginfo_notify();
  static const int kBagInfoNotifyFieldNumber = 9;
  inline const ::vmsg::CSBagInfoNotify& baginfo_notify() const;
  inline ::vmsg::CSBagInfoNotify* mutable_baginfo_notify();
  inline ::vmsg::CSBagInfoNotify* release_baginfo_notify();
  inline void set_allocated_baginfo_notify(::vmsg::CSBagInfoNotify* baginfo_notify);

  // optional .vmsg.CSConsumeItemRsp ConsumeItem_Rsp = 10;
  inline bool has_consumeitem_rsp() const;
  inline void clear_consumeitem_rsp();
  static const int kConsumeItemRspFieldNumber = 10;
  inline const ::vmsg::CSConsumeItemRsp& consumeitem_rsp() const;
  inline ::vmsg::CSConsumeItemRsp* mutable_consumeitem_rsp();
  inline ::vmsg::CSConsumeItemRsp* release_consumeitem_rsp();
  inline void set_allocated_consumeitem_rsp(::vmsg::CSConsumeItemRsp* consumeitem_rsp);

  // optional .vmsg.CSBuyItemRsp BuyItem_Rsp = 11;
  inline bool has_buyitem_rsp() const;
  inline void clear_buyitem_rsp();
  static const int kBuyItemRspFieldNumber = 11;
  inline const ::vmsg::CSBuyItemRsp& buyitem_rsp() const;
  inline ::vmsg::CSBuyItemRsp* mutable_buyitem_rsp();
  inline ::vmsg::CSBuyItemRsp* release_buyitem_rsp();
  inline void set_allocated_buyitem_rsp(::vmsg::CSBuyItemRsp* buyitem_rsp);

  // @@protoc_insertion_point(class_scope:vmsg.CSBagRespond)
 private:
  inline void set_has_querybaginfo_rsp();
  inline void clear_has_querybaginfo_rsp();
  inline void set_has_wearequip_rsp();
  inline void clear_has_wearequip_rsp();
  inline void set_has_enlarge_rsp();
  inline void clear_has_enlarge_rsp();
  inline void set_has_takeoffequip_rsp();
  inline void clear_has_takeoffequip_rsp();
  inline void set_has_bagsell_rsp();
  inline void clear_has_bagsell_rsp();
  inline void set_has_bagstat_notify();
  inline void clear_has_bagstat_notify();
  inline void set_has_baginfo_notify();
  inline void clear_has_baginfo_notify();
  inline void set_has_consumeitem_rsp();
  inline void clear_has_consumeitem_rsp();
  inline void set_has_buyitem_rsp();
  inline void clear_has_buyitem_rsp();

  ::vmsg::CSQueryBagInfoRsp* querybaginfo_rsp_;
  ::vmsg::CSWearEquipRsp* wearequip_rsp_;
  ::vmsg::CSEnlargeRsp* enlarge_rsp_;
  ::vmsg::CSTakeOffEquipRsp* takeoffequip_rsp_;
  ::vmsg::CSBagSellRsp* bagsell_rsp_;
  ::vmsg::CSBagStatNotify* bagstat_notify_;
  ::vmsg::CSBagInfoNotify* baginfo_notify_;
  ::vmsg::CSConsumeItemRsp* consumeitem_rsp_;
  ::vmsg::CSBuyItemRsp* buyitem_rsp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSBagMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSBagMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSBagMsg_2eproto();
  friend void protobuf_ShutdownFile_CSBagMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBagRespond* default_instance_;
};
// ===================================================================


// ===================================================================

// CSBagCellInfo

// required int32 Index = 1;
inline bool CSBagCellInfo::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBagCellInfo::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBagCellInfo::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBagCellInfo::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 CSBagCellInfo::index() const {
  return index_;
}
inline void CSBagCellInfo::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// required uint32 Type = 2;
inline bool CSBagCellInfo::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBagCellInfo::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBagCellInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBagCellInfo::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSBagCellInfo::type() const {
  return type_;
}
inline void CSBagCellInfo::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional .vmsg.CSEquipInfo EquipInfo = 3;
inline bool CSBagCellInfo::has_equipinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBagCellInfo::set_has_equipinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBagCellInfo::clear_has_equipinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBagCellInfo::clear_equipinfo() {
  if (equipinfo_ != NULL) equipinfo_->::vmsg::CSEquipInfo::Clear();
  clear_has_equipinfo();
}
inline const ::vmsg::CSEquipInfo& CSBagCellInfo::equipinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equipinfo_ != NULL ? *equipinfo_ : *default_instance().equipinfo_;
#else
  return equipinfo_ != NULL ? *equipinfo_ : *default_instance_->equipinfo_;
#endif
}
inline ::vmsg::CSEquipInfo* CSBagCellInfo::mutable_equipinfo() {
  set_has_equipinfo();
  if (equipinfo_ == NULL) equipinfo_ = new ::vmsg::CSEquipInfo;
  return equipinfo_;
}
inline ::vmsg::CSEquipInfo* CSBagCellInfo::release_equipinfo() {
  clear_has_equipinfo();
  ::vmsg::CSEquipInfo* temp = equipinfo_;
  equipinfo_ = NULL;
  return temp;
}
inline void CSBagCellInfo::set_allocated_equipinfo(::vmsg::CSEquipInfo* equipinfo) {
  delete equipinfo_;
  equipinfo_ = equipinfo;
  if (equipinfo) {
    set_has_equipinfo();
  } else {
    clear_has_equipinfo();
  }
}

// optional .vmsg.CSItemInfo ItemInfo = 4;
inline bool CSBagCellInfo::has_iteminfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSBagCellInfo::set_has_iteminfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSBagCellInfo::clear_has_iteminfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSBagCellInfo::clear_iteminfo() {
  if (iteminfo_ != NULL) iteminfo_->::vmsg::CSItemInfo::Clear();
  clear_has_iteminfo();
}
inline const ::vmsg::CSItemInfo& CSBagCellInfo::iteminfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return iteminfo_ != NULL ? *iteminfo_ : *default_instance().iteminfo_;
#else
  return iteminfo_ != NULL ? *iteminfo_ : *default_instance_->iteminfo_;
#endif
}
inline ::vmsg::CSItemInfo* CSBagCellInfo::mutable_iteminfo() {
  set_has_iteminfo();
  if (iteminfo_ == NULL) iteminfo_ = new ::vmsg::CSItemInfo;
  return iteminfo_;
}
inline ::vmsg::CSItemInfo* CSBagCellInfo::release_iteminfo() {
  clear_has_iteminfo();
  ::vmsg::CSItemInfo* temp = iteminfo_;
  iteminfo_ = NULL;
  return temp;
}
inline void CSBagCellInfo::set_allocated_iteminfo(::vmsg::CSItemInfo* iteminfo) {
  delete iteminfo_;
  iteminfo_ = iteminfo;
  if (iteminfo) {
    set_has_iteminfo();
  } else {
    clear_has_iteminfo();
  }
}

// -------------------------------------------------------------------

// CSBagInfo

// required uint32 Capacity = 1;
inline bool CSBagInfo::has_capacity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBagInfo::set_has_capacity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBagInfo::clear_has_capacity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBagInfo::clear_capacity() {
  capacity_ = 0u;
  clear_has_capacity();
}
inline ::google::protobuf::uint32 CSBagInfo::capacity() const {
  return capacity_;
}
inline void CSBagInfo::set_capacity(::google::protobuf::uint32 value) {
  set_has_capacity();
  capacity_ = value;
}

// repeated .vmsg.CSBagCellInfo CellLst = 2;
inline int CSBagInfo::celllst_size() const {
  return celllst_.size();
}
inline void CSBagInfo::clear_celllst() {
  celllst_.Clear();
}
inline const ::vmsg::CSBagCellInfo& CSBagInfo::celllst(int index) const {
  return celllst_.Get(index);
}
inline ::vmsg::CSBagCellInfo* CSBagInfo::mutable_celllst(int index) {
  return celllst_.Mutable(index);
}
inline ::vmsg::CSBagCellInfo* CSBagInfo::add_celllst() {
  return celllst_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSBagCellInfo >&
CSBagInfo::celllst() const {
  return celllst_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSBagCellInfo >*
CSBagInfo::mutable_celllst() {
  return &celllst_;
}

// -------------------------------------------------------------------

// CSQueryBagInfoRqst

// -------------------------------------------------------------------

// CSQueryBagInfoRsp

// required .vmsg.CSBagInfo BagInfo = 1;
inline bool CSQueryBagInfoRsp::has_baginfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSQueryBagInfoRsp::set_has_baginfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSQueryBagInfoRsp::clear_has_baginfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSQueryBagInfoRsp::clear_baginfo() {
  if (baginfo_ != NULL) baginfo_->::vmsg::CSBagInfo::Clear();
  clear_has_baginfo();
}
inline const ::vmsg::CSBagInfo& CSQueryBagInfoRsp::baginfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return baginfo_ != NULL ? *baginfo_ : *default_instance().baginfo_;
#else
  return baginfo_ != NULL ? *baginfo_ : *default_instance_->baginfo_;
#endif
}
inline ::vmsg::CSBagInfo* CSQueryBagInfoRsp::mutable_baginfo() {
  set_has_baginfo();
  if (baginfo_ == NULL) baginfo_ = new ::vmsg::CSBagInfo;
  return baginfo_;
}
inline ::vmsg::CSBagInfo* CSQueryBagInfoRsp::release_baginfo() {
  clear_has_baginfo();
  ::vmsg::CSBagInfo* temp = baginfo_;
  baginfo_ = NULL;
  return temp;
}
inline void CSQueryBagInfoRsp::set_allocated_baginfo(::vmsg::CSBagInfo* baginfo) {
  delete baginfo_;
  baginfo_ = baginfo;
  if (baginfo) {
    set_has_baginfo();
  } else {
    clear_has_baginfo();
  }
}

// -------------------------------------------------------------------

// CSBagInfoNotify

// optional uint32 PkgID = 1;
inline bool CSBagInfoNotify::has_pkgid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBagInfoNotify::set_has_pkgid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBagInfoNotify::clear_has_pkgid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBagInfoNotify::clear_pkgid() {
  pkgid_ = 0u;
  clear_has_pkgid();
}
inline ::google::protobuf::uint32 CSBagInfoNotify::pkgid() const {
  return pkgid_;
}
inline void CSBagInfoNotify::set_pkgid(::google::protobuf::uint32 value) {
  set_has_pkgid();
  pkgid_ = value;
}

// required .vmsg.CSBagInfo BagInfo = 2;
inline bool CSBagInfoNotify::has_baginfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBagInfoNotify::set_has_baginfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBagInfoNotify::clear_has_baginfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBagInfoNotify::clear_baginfo() {
  if (baginfo_ != NULL) baginfo_->::vmsg::CSBagInfo::Clear();
  clear_has_baginfo();
}
inline const ::vmsg::CSBagInfo& CSBagInfoNotify::baginfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return baginfo_ != NULL ? *baginfo_ : *default_instance().baginfo_;
#else
  return baginfo_ != NULL ? *baginfo_ : *default_instance_->baginfo_;
#endif
}
inline ::vmsg::CSBagInfo* CSBagInfoNotify::mutable_baginfo() {
  set_has_baginfo();
  if (baginfo_ == NULL) baginfo_ = new ::vmsg::CSBagInfo;
  return baginfo_;
}
inline ::vmsg::CSBagInfo* CSBagInfoNotify::release_baginfo() {
  clear_has_baginfo();
  ::vmsg::CSBagInfo* temp = baginfo_;
  baginfo_ = NULL;
  return temp;
}
inline void CSBagInfoNotify::set_allocated_baginfo(::vmsg::CSBagInfo* baginfo) {
  delete baginfo_;
  baginfo_ = baginfo;
  if (baginfo) {
    set_has_baginfo();
  } else {
    clear_has_baginfo();
  }
}

// -------------------------------------------------------------------

// CSWearEquipRqst

// required int32 CellIdx = 1;
inline bool CSWearEquipRqst::has_cellidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWearEquipRqst::set_has_cellidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWearEquipRqst::clear_has_cellidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWearEquipRqst::clear_cellidx() {
  cellidx_ = 0;
  clear_has_cellidx();
}
inline ::google::protobuf::int32 CSWearEquipRqst::cellidx() const {
  return cellidx_;
}
inline void CSWearEquipRqst::set_cellidx(::google::protobuf::int32 value) {
  set_has_cellidx();
  cellidx_ = value;
}

// -------------------------------------------------------------------

// CSWearEquipRsp

// required .vmsg.CSBagInfo BagInfo = 1;
inline bool CSWearEquipRsp::has_baginfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWearEquipRsp::set_has_baginfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWearEquipRsp::clear_has_baginfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWearEquipRsp::clear_baginfo() {
  if (baginfo_ != NULL) baginfo_->::vmsg::CSBagInfo::Clear();
  clear_has_baginfo();
}
inline const ::vmsg::CSBagInfo& CSWearEquipRsp::baginfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return baginfo_ != NULL ? *baginfo_ : *default_instance().baginfo_;
#else
  return baginfo_ != NULL ? *baginfo_ : *default_instance_->baginfo_;
#endif
}
inline ::vmsg::CSBagInfo* CSWearEquipRsp::mutable_baginfo() {
  set_has_baginfo();
  if (baginfo_ == NULL) baginfo_ = new ::vmsg::CSBagInfo;
  return baginfo_;
}
inline ::vmsg::CSBagInfo* CSWearEquipRsp::release_baginfo() {
  clear_has_baginfo();
  ::vmsg::CSBagInfo* temp = baginfo_;
  baginfo_ = NULL;
  return temp;
}
inline void CSWearEquipRsp::set_allocated_baginfo(::vmsg::CSBagInfo* baginfo) {
  delete baginfo_;
  baginfo_ = baginfo;
  if (baginfo) {
    set_has_baginfo();
  } else {
    clear_has_baginfo();
  }
}

// required .vmsg.CSPlayerDetailInfo PlayerDetailInfo = 2;
inline bool CSWearEquipRsp::has_playerdetailinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWearEquipRsp::set_has_playerdetailinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWearEquipRsp::clear_has_playerdetailinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWearEquipRsp::clear_playerdetailinfo() {
  if (playerdetailinfo_ != NULL) playerdetailinfo_->::vmsg::CSPlayerDetailInfo::Clear();
  clear_has_playerdetailinfo();
}
inline const ::vmsg::CSPlayerDetailInfo& CSWearEquipRsp::playerdetailinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerdetailinfo_ != NULL ? *playerdetailinfo_ : *default_instance().playerdetailinfo_;
#else
  return playerdetailinfo_ != NULL ? *playerdetailinfo_ : *default_instance_->playerdetailinfo_;
#endif
}
inline ::vmsg::CSPlayerDetailInfo* CSWearEquipRsp::mutable_playerdetailinfo() {
  set_has_playerdetailinfo();
  if (playerdetailinfo_ == NULL) playerdetailinfo_ = new ::vmsg::CSPlayerDetailInfo;
  return playerdetailinfo_;
}
inline ::vmsg::CSPlayerDetailInfo* CSWearEquipRsp::release_playerdetailinfo() {
  clear_has_playerdetailinfo();
  ::vmsg::CSPlayerDetailInfo* temp = playerdetailinfo_;
  playerdetailinfo_ = NULL;
  return temp;
}
inline void CSWearEquipRsp::set_allocated_playerdetailinfo(::vmsg::CSPlayerDetailInfo* playerdetailinfo) {
  delete playerdetailinfo_;
  playerdetailinfo_ = playerdetailinfo;
  if (playerdetailinfo) {
    set_has_playerdetailinfo();
  } else {
    clear_has_playerdetailinfo();
  }
}

// -------------------------------------------------------------------

// CSEnlargeRqst

// required int32 EnlargeCnt = 1;
inline bool CSEnlargeRqst::has_enlargecnt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEnlargeRqst::set_has_enlargecnt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEnlargeRqst::clear_has_enlargecnt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEnlargeRqst::clear_enlargecnt() {
  enlargecnt_ = 0;
  clear_has_enlargecnt();
}
inline ::google::protobuf::int32 CSEnlargeRqst::enlargecnt() const {
  return enlargecnt_;
}
inline void CSEnlargeRqst::set_enlargecnt(::google::protobuf::int32 value) {
  set_has_enlargecnt();
  enlargecnt_ = value;
}

// -------------------------------------------------------------------

// CSEnlargeRsp

// required int32 EnlargeCnt = 1;
inline bool CSEnlargeRsp::has_enlargecnt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEnlargeRsp::set_has_enlargecnt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEnlargeRsp::clear_has_enlargecnt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEnlargeRsp::clear_enlargecnt() {
  enlargecnt_ = 0;
  clear_has_enlargecnt();
}
inline ::google::protobuf::int32 CSEnlargeRsp::enlargecnt() const {
  return enlargecnt_;
}
inline void CSEnlargeRsp::set_enlargecnt(::google::protobuf::int32 value) {
  set_has_enlargecnt();
  enlargecnt_ = value;
}

// -------------------------------------------------------------------

// CSTakeOffEquipRqst

// required uint64 EquipGUID = 1;
inline bool CSTakeOffEquipRqst::has_equipguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSTakeOffEquipRqst::set_has_equipguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSTakeOffEquipRqst::clear_has_equipguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSTakeOffEquipRqst::clear_equipguid() {
  equipguid_ = GOOGLE_ULONGLONG(0);
  clear_has_equipguid();
}
inline ::google::protobuf::uint64 CSTakeOffEquipRqst::equipguid() const {
  return equipguid_;
}
inline void CSTakeOffEquipRqst::set_equipguid(::google::protobuf::uint64 value) {
  set_has_equipguid();
  equipguid_ = value;
}

// -------------------------------------------------------------------

// CSTakeOffEquipRsp

// required .vmsg.CSBagInfo BagInfo = 1;
inline bool CSTakeOffEquipRsp::has_baginfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSTakeOffEquipRsp::set_has_baginfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSTakeOffEquipRsp::clear_has_baginfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSTakeOffEquipRsp::clear_baginfo() {
  if (baginfo_ != NULL) baginfo_->::vmsg::CSBagInfo::Clear();
  clear_has_baginfo();
}
inline const ::vmsg::CSBagInfo& CSTakeOffEquipRsp::baginfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return baginfo_ != NULL ? *baginfo_ : *default_instance().baginfo_;
#else
  return baginfo_ != NULL ? *baginfo_ : *default_instance_->baginfo_;
#endif
}
inline ::vmsg::CSBagInfo* CSTakeOffEquipRsp::mutable_baginfo() {
  set_has_baginfo();
  if (baginfo_ == NULL) baginfo_ = new ::vmsg::CSBagInfo;
  return baginfo_;
}
inline ::vmsg::CSBagInfo* CSTakeOffEquipRsp::release_baginfo() {
  clear_has_baginfo();
  ::vmsg::CSBagInfo* temp = baginfo_;
  baginfo_ = NULL;
  return temp;
}
inline void CSTakeOffEquipRsp::set_allocated_baginfo(::vmsg::CSBagInfo* baginfo) {
  delete baginfo_;
  baginfo_ = baginfo;
  if (baginfo) {
    set_has_baginfo();
  } else {
    clear_has_baginfo();
  }
}

// required .vmsg.CSPlayerDetailInfo PlayerDetailInfo = 2;
inline bool CSTakeOffEquipRsp::has_playerdetailinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSTakeOffEquipRsp::set_has_playerdetailinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSTakeOffEquipRsp::clear_has_playerdetailinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSTakeOffEquipRsp::clear_playerdetailinfo() {
  if (playerdetailinfo_ != NULL) playerdetailinfo_->::vmsg::CSPlayerDetailInfo::Clear();
  clear_has_playerdetailinfo();
}
inline const ::vmsg::CSPlayerDetailInfo& CSTakeOffEquipRsp::playerdetailinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerdetailinfo_ != NULL ? *playerdetailinfo_ : *default_instance().playerdetailinfo_;
#else
  return playerdetailinfo_ != NULL ? *playerdetailinfo_ : *default_instance_->playerdetailinfo_;
#endif
}
inline ::vmsg::CSPlayerDetailInfo* CSTakeOffEquipRsp::mutable_playerdetailinfo() {
  set_has_playerdetailinfo();
  if (playerdetailinfo_ == NULL) playerdetailinfo_ = new ::vmsg::CSPlayerDetailInfo;
  return playerdetailinfo_;
}
inline ::vmsg::CSPlayerDetailInfo* CSTakeOffEquipRsp::release_playerdetailinfo() {
  clear_has_playerdetailinfo();
  ::vmsg::CSPlayerDetailInfo* temp = playerdetailinfo_;
  playerdetailinfo_ = NULL;
  return temp;
}
inline void CSTakeOffEquipRsp::set_allocated_playerdetailinfo(::vmsg::CSPlayerDetailInfo* playerdetailinfo) {
  delete playerdetailinfo_;
  playerdetailinfo_ = playerdetailinfo;
  if (playerdetailinfo) {
    set_has_playerdetailinfo();
  } else {
    clear_has_playerdetailinfo();
  }
}

// -------------------------------------------------------------------

// CSBagSellRqst

// required int32 BagIdx = 1;
inline bool CSBagSellRqst::has_bagidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBagSellRqst::set_has_bagidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBagSellRqst::clear_has_bagidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBagSellRqst::clear_bagidx() {
  bagidx_ = 0;
  clear_has_bagidx();
}
inline ::google::protobuf::int32 CSBagSellRqst::bagidx() const {
  return bagidx_;
}
inline void CSBagSellRqst::set_bagidx(::google::protobuf::int32 value) {
  set_has_bagidx();
  bagidx_ = value;
}

// -------------------------------------------------------------------

// CSBagSellRsp

// required int32 BagIdx = 1;
inline bool CSBagSellRsp::has_bagidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBagSellRsp::set_has_bagidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBagSellRsp::clear_has_bagidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBagSellRsp::clear_bagidx() {
  bagidx_ = 0;
  clear_has_bagidx();
}
inline ::google::protobuf::int32 CSBagSellRsp::bagidx() const {
  return bagidx_;
}
inline void CSBagSellRsp::set_bagidx(::google::protobuf::int32 value) {
  set_has_bagidx();
  bagidx_ = value;
}

// -------------------------------------------------------------------

// CSBagStatNotify

// required uint32 IsFull = 1;
inline bool CSBagStatNotify::has_isfull() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBagStatNotify::set_has_isfull() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBagStatNotify::clear_has_isfull() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBagStatNotify::clear_isfull() {
  isfull_ = 0u;
  clear_has_isfull();
}
inline ::google::protobuf::uint32 CSBagStatNotify::isfull() const {
  return isfull_;
}
inline void CSBagStatNotify::set_isfull(::google::protobuf::uint32 value) {
  set_has_isfull();
  isfull_ = value;
}

// -------------------------------------------------------------------

// CSBuyItemRqst

// required uint32 ItemType = 1;
inline bool CSBuyItemRqst::has_itemtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBuyItemRqst::set_has_itemtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBuyItemRqst::clear_has_itemtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBuyItemRqst::clear_itemtype() {
  itemtype_ = 0u;
  clear_has_itemtype();
}
inline ::google::protobuf::uint32 CSBuyItemRqst::itemtype() const {
  return itemtype_;
}
inline void CSBuyItemRqst::set_itemtype(::google::protobuf::uint32 value) {
  set_has_itemtype();
  itemtype_ = value;
}

// required uint32 ItemCfgID = 2;
inline bool CSBuyItemRqst::has_itemcfgid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBuyItemRqst::set_has_itemcfgid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBuyItemRqst::clear_has_itemcfgid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBuyItemRqst::clear_itemcfgid() {
  itemcfgid_ = 0u;
  clear_has_itemcfgid();
}
inline ::google::protobuf::uint32 CSBuyItemRqst::itemcfgid() const {
  return itemcfgid_;
}
inline void CSBuyItemRqst::set_itemcfgid(::google::protobuf::uint32 value) {
  set_has_itemcfgid();
  itemcfgid_ = value;
}

// required uint32 Cnt = 3;
inline bool CSBuyItemRqst::has_cnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBuyItemRqst::set_has_cnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBuyItemRqst::clear_has_cnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBuyItemRqst::clear_cnt() {
  cnt_ = 0u;
  clear_has_cnt();
}
inline ::google::protobuf::uint32 CSBuyItemRqst::cnt() const {
  return cnt_;
}
inline void CSBuyItemRqst::set_cnt(::google::protobuf::uint32 value) {
  set_has_cnt();
  cnt_ = value;
}

// -------------------------------------------------------------------

// CSBuyItemRsp

// required uint32 ItemType = 1;
inline bool CSBuyItemRsp::has_itemtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBuyItemRsp::set_has_itemtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBuyItemRsp::clear_has_itemtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBuyItemRsp::clear_itemtype() {
  itemtype_ = 0u;
  clear_has_itemtype();
}
inline ::google::protobuf::uint32 CSBuyItemRsp::itemtype() const {
  return itemtype_;
}
inline void CSBuyItemRsp::set_itemtype(::google::protobuf::uint32 value) {
  set_has_itemtype();
  itemtype_ = value;
}

// required uint32 ItemCfgID = 2;
inline bool CSBuyItemRsp::has_itemcfgid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBuyItemRsp::set_has_itemcfgid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBuyItemRsp::clear_has_itemcfgid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBuyItemRsp::clear_itemcfgid() {
  itemcfgid_ = 0u;
  clear_has_itemcfgid();
}
inline ::google::protobuf::uint32 CSBuyItemRsp::itemcfgid() const {
  return itemcfgid_;
}
inline void CSBuyItemRsp::set_itemcfgid(::google::protobuf::uint32 value) {
  set_has_itemcfgid();
  itemcfgid_ = value;
}

// required uint32 Cnt = 3;
inline bool CSBuyItemRsp::has_cnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBuyItemRsp::set_has_cnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBuyItemRsp::clear_has_cnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBuyItemRsp::clear_cnt() {
  cnt_ = 0u;
  clear_has_cnt();
}
inline ::google::protobuf::uint32 CSBuyItemRsp::cnt() const {
  return cnt_;
}
inline void CSBuyItemRsp::set_cnt(::google::protobuf::uint32 value) {
  set_has_cnt();
  cnt_ = value;
}

// required .vmsg.CSBagInfo BagInfo = 4;
inline bool CSBuyItemRsp::has_baginfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSBuyItemRsp::set_has_baginfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSBuyItemRsp::clear_has_baginfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSBuyItemRsp::clear_baginfo() {
  if (baginfo_ != NULL) baginfo_->::vmsg::CSBagInfo::Clear();
  clear_has_baginfo();
}
inline const ::vmsg::CSBagInfo& CSBuyItemRsp::baginfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return baginfo_ != NULL ? *baginfo_ : *default_instance().baginfo_;
#else
  return baginfo_ != NULL ? *baginfo_ : *default_instance_->baginfo_;
#endif
}
inline ::vmsg::CSBagInfo* CSBuyItemRsp::mutable_baginfo() {
  set_has_baginfo();
  if (baginfo_ == NULL) baginfo_ = new ::vmsg::CSBagInfo;
  return baginfo_;
}
inline ::vmsg::CSBagInfo* CSBuyItemRsp::release_baginfo() {
  clear_has_baginfo();
  ::vmsg::CSBagInfo* temp = baginfo_;
  baginfo_ = NULL;
  return temp;
}
inline void CSBuyItemRsp::set_allocated_baginfo(::vmsg::CSBagInfo* baginfo) {
  delete baginfo_;
  baginfo_ = baginfo;
  if (baginfo) {
    set_has_baginfo();
  } else {
    clear_has_baginfo();
  }
}

// -------------------------------------------------------------------

// CSConsumeItemRqst

// required int32 BagIdx = 1;
inline bool CSConsumeItemRqst::has_bagidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSConsumeItemRqst::set_has_bagidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSConsumeItemRqst::clear_has_bagidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSConsumeItemRqst::clear_bagidx() {
  bagidx_ = 0;
  clear_has_bagidx();
}
inline ::google::protobuf::int32 CSConsumeItemRqst::bagidx() const {
  return bagidx_;
}
inline void CSConsumeItemRqst::set_bagidx(::google::protobuf::int32 value) {
  set_has_bagidx();
  bagidx_ = value;
}

// required uint32 CfgID = 2;
inline bool CSConsumeItemRqst::has_cfgid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSConsumeItemRqst::set_has_cfgid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSConsumeItemRqst::clear_has_cfgid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSConsumeItemRqst::clear_cfgid() {
  cfgid_ = 0u;
  clear_has_cfgid();
}
inline ::google::protobuf::uint32 CSConsumeItemRqst::cfgid() const {
  return cfgid_;
}
inline void CSConsumeItemRqst::set_cfgid(::google::protobuf::uint32 value) {
  set_has_cfgid();
  cfgid_ = value;
}

// required uint32 Type = 3;
inline bool CSConsumeItemRqst::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSConsumeItemRqst::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSConsumeItemRqst::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSConsumeItemRqst::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSConsumeItemRqst::type() const {
  return type_;
}
inline void CSConsumeItemRqst::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required uint32 Cnt = 4;
inline bool CSConsumeItemRqst::has_cnt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSConsumeItemRqst::set_has_cnt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSConsumeItemRqst::clear_has_cnt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSConsumeItemRqst::clear_cnt() {
  cnt_ = 0u;
  clear_has_cnt();
}
inline ::google::protobuf::uint32 CSConsumeItemRqst::cnt() const {
  return cnt_;
}
inline void CSConsumeItemRqst::set_cnt(::google::protobuf::uint32 value) {
  set_has_cnt();
  cnt_ = value;
}

// -------------------------------------------------------------------

// CSConsumeItemRsp

// required .vmsg.CSBagInfo BagInfo = 1;
inline bool CSConsumeItemRsp::has_baginfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSConsumeItemRsp::set_has_baginfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSConsumeItemRsp::clear_has_baginfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSConsumeItemRsp::clear_baginfo() {
  if (baginfo_ != NULL) baginfo_->::vmsg::CSBagInfo::Clear();
  clear_has_baginfo();
}
inline const ::vmsg::CSBagInfo& CSConsumeItemRsp::baginfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return baginfo_ != NULL ? *baginfo_ : *default_instance().baginfo_;
#else
  return baginfo_ != NULL ? *baginfo_ : *default_instance_->baginfo_;
#endif
}
inline ::vmsg::CSBagInfo* CSConsumeItemRsp::mutable_baginfo() {
  set_has_baginfo();
  if (baginfo_ == NULL) baginfo_ = new ::vmsg::CSBagInfo;
  return baginfo_;
}
inline ::vmsg::CSBagInfo* CSConsumeItemRsp::release_baginfo() {
  clear_has_baginfo();
  ::vmsg::CSBagInfo* temp = baginfo_;
  baginfo_ = NULL;
  return temp;
}
inline void CSConsumeItemRsp::set_allocated_baginfo(::vmsg::CSBagInfo* baginfo) {
  delete baginfo_;
  baginfo_ = baginfo;
  if (baginfo) {
    set_has_baginfo();
  } else {
    clear_has_baginfo();
  }
}

// required uint32 CfgID = 2;
inline bool CSConsumeItemRsp::has_cfgid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSConsumeItemRsp::set_has_cfgid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSConsumeItemRsp::clear_has_cfgid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSConsumeItemRsp::clear_cfgid() {
  cfgid_ = 0u;
  clear_has_cfgid();
}
inline ::google::protobuf::uint32 CSConsumeItemRsp::cfgid() const {
  return cfgid_;
}
inline void CSConsumeItemRsp::set_cfgid(::google::protobuf::uint32 value) {
  set_has_cfgid();
  cfgid_ = value;
}

// required uint32 Type = 3;
inline bool CSConsumeItemRsp::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSConsumeItemRsp::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSConsumeItemRsp::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSConsumeItemRsp::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSConsumeItemRsp::type() const {
  return type_;
}
inline void CSConsumeItemRsp::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required uint32 Cnt = 4;
inline bool CSConsumeItemRsp::has_cnt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSConsumeItemRsp::set_has_cnt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSConsumeItemRsp::clear_has_cnt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSConsumeItemRsp::clear_cnt() {
  cnt_ = 0u;
  clear_has_cnt();
}
inline ::google::protobuf::uint32 CSConsumeItemRsp::cnt() const {
  return cnt_;
}
inline void CSConsumeItemRsp::set_cnt(::google::protobuf::uint32 value) {
  set_has_cnt();
  cnt_ = value;
}

// -------------------------------------------------------------------

// CSBagRequest

// optional .vmsg.CSQueryBagInfoRqst QueryBagInfo_Rqst = 1;
inline bool CSBagRequest::has_querybaginfo_rqst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBagRequest::set_has_querybaginfo_rqst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBagRequest::clear_has_querybaginfo_rqst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBagRequest::clear_querybaginfo_rqst() {
  if (querybaginfo_rqst_ != NULL) querybaginfo_rqst_->::vmsg::CSQueryBagInfoRqst::Clear();
  clear_has_querybaginfo_rqst();
}
inline const ::vmsg::CSQueryBagInfoRqst& CSBagRequest::querybaginfo_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return querybaginfo_rqst_ != NULL ? *querybaginfo_rqst_ : *default_instance().querybaginfo_rqst_;
#else
  return querybaginfo_rqst_ != NULL ? *querybaginfo_rqst_ : *default_instance_->querybaginfo_rqst_;
#endif
}
inline ::vmsg::CSQueryBagInfoRqst* CSBagRequest::mutable_querybaginfo_rqst() {
  set_has_querybaginfo_rqst();
  if (querybaginfo_rqst_ == NULL) querybaginfo_rqst_ = new ::vmsg::CSQueryBagInfoRqst;
  return querybaginfo_rqst_;
}
inline ::vmsg::CSQueryBagInfoRqst* CSBagRequest::release_querybaginfo_rqst() {
  clear_has_querybaginfo_rqst();
  ::vmsg::CSQueryBagInfoRqst* temp = querybaginfo_rqst_;
  querybaginfo_rqst_ = NULL;
  return temp;
}
inline void CSBagRequest::set_allocated_querybaginfo_rqst(::vmsg::CSQueryBagInfoRqst* querybaginfo_rqst) {
  delete querybaginfo_rqst_;
  querybaginfo_rqst_ = querybaginfo_rqst;
  if (querybaginfo_rqst) {
    set_has_querybaginfo_rqst();
  } else {
    clear_has_querybaginfo_rqst();
  }
}

// optional .vmsg.CSWearEquipRqst WearEquip_Rqst = 4;
inline bool CSBagRequest::has_wearequip_rqst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBagRequest::set_has_wearequip_rqst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBagRequest::clear_has_wearequip_rqst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBagRequest::clear_wearequip_rqst() {
  if (wearequip_rqst_ != NULL) wearequip_rqst_->::vmsg::CSWearEquipRqst::Clear();
  clear_has_wearequip_rqst();
}
inline const ::vmsg::CSWearEquipRqst& CSBagRequest::wearequip_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return wearequip_rqst_ != NULL ? *wearequip_rqst_ : *default_instance().wearequip_rqst_;
#else
  return wearequip_rqst_ != NULL ? *wearequip_rqst_ : *default_instance_->wearequip_rqst_;
#endif
}
inline ::vmsg::CSWearEquipRqst* CSBagRequest::mutable_wearequip_rqst() {
  set_has_wearequip_rqst();
  if (wearequip_rqst_ == NULL) wearequip_rqst_ = new ::vmsg::CSWearEquipRqst;
  return wearequip_rqst_;
}
inline ::vmsg::CSWearEquipRqst* CSBagRequest::release_wearequip_rqst() {
  clear_has_wearequip_rqst();
  ::vmsg::CSWearEquipRqst* temp = wearequip_rqst_;
  wearequip_rqst_ = NULL;
  return temp;
}
inline void CSBagRequest::set_allocated_wearequip_rqst(::vmsg::CSWearEquipRqst* wearequip_rqst) {
  delete wearequip_rqst_;
  wearequip_rqst_ = wearequip_rqst;
  if (wearequip_rqst) {
    set_has_wearequip_rqst();
  } else {
    clear_has_wearequip_rqst();
  }
}

// optional .vmsg.CSEnlargeRqst Enlarge_Rqst = 5;
inline bool CSBagRequest::has_enlarge_rqst() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBagRequest::set_has_enlarge_rqst() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBagRequest::clear_has_enlarge_rqst() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBagRequest::clear_enlarge_rqst() {
  if (enlarge_rqst_ != NULL) enlarge_rqst_->::vmsg::CSEnlargeRqst::Clear();
  clear_has_enlarge_rqst();
}
inline const ::vmsg::CSEnlargeRqst& CSBagRequest::enlarge_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return enlarge_rqst_ != NULL ? *enlarge_rqst_ : *default_instance().enlarge_rqst_;
#else
  return enlarge_rqst_ != NULL ? *enlarge_rqst_ : *default_instance_->enlarge_rqst_;
#endif
}
inline ::vmsg::CSEnlargeRqst* CSBagRequest::mutable_enlarge_rqst() {
  set_has_enlarge_rqst();
  if (enlarge_rqst_ == NULL) enlarge_rqst_ = new ::vmsg::CSEnlargeRqst;
  return enlarge_rqst_;
}
inline ::vmsg::CSEnlargeRqst* CSBagRequest::release_enlarge_rqst() {
  clear_has_enlarge_rqst();
  ::vmsg::CSEnlargeRqst* temp = enlarge_rqst_;
  enlarge_rqst_ = NULL;
  return temp;
}
inline void CSBagRequest::set_allocated_enlarge_rqst(::vmsg::CSEnlargeRqst* enlarge_rqst) {
  delete enlarge_rqst_;
  enlarge_rqst_ = enlarge_rqst;
  if (enlarge_rqst) {
    set_has_enlarge_rqst();
  } else {
    clear_has_enlarge_rqst();
  }
}

// optional .vmsg.CSTakeOffEquipRqst TakeOffEquip_Rqst = 6;
inline bool CSBagRequest::has_takeoffequip_rqst() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSBagRequest::set_has_takeoffequip_rqst() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSBagRequest::clear_has_takeoffequip_rqst() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSBagRequest::clear_takeoffequip_rqst() {
  if (takeoffequip_rqst_ != NULL) takeoffequip_rqst_->::vmsg::CSTakeOffEquipRqst::Clear();
  clear_has_takeoffequip_rqst();
}
inline const ::vmsg::CSTakeOffEquipRqst& CSBagRequest::takeoffequip_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return takeoffequip_rqst_ != NULL ? *takeoffequip_rqst_ : *default_instance().takeoffequip_rqst_;
#else
  return takeoffequip_rqst_ != NULL ? *takeoffequip_rqst_ : *default_instance_->takeoffequip_rqst_;
#endif
}
inline ::vmsg::CSTakeOffEquipRqst* CSBagRequest::mutable_takeoffequip_rqst() {
  set_has_takeoffequip_rqst();
  if (takeoffequip_rqst_ == NULL) takeoffequip_rqst_ = new ::vmsg::CSTakeOffEquipRqst;
  return takeoffequip_rqst_;
}
inline ::vmsg::CSTakeOffEquipRqst* CSBagRequest::release_takeoffequip_rqst() {
  clear_has_takeoffequip_rqst();
  ::vmsg::CSTakeOffEquipRqst* temp = takeoffequip_rqst_;
  takeoffequip_rqst_ = NULL;
  return temp;
}
inline void CSBagRequest::set_allocated_takeoffequip_rqst(::vmsg::CSTakeOffEquipRqst* takeoffequip_rqst) {
  delete takeoffequip_rqst_;
  takeoffequip_rqst_ = takeoffequip_rqst;
  if (takeoffequip_rqst) {
    set_has_takeoffequip_rqst();
  } else {
    clear_has_takeoffequip_rqst();
  }
}

// optional .vmsg.CSBagSellRqst BagSell_Rqst = 7;
inline bool CSBagRequest::has_bagsell_rqst() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSBagRequest::set_has_bagsell_rqst() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSBagRequest::clear_has_bagsell_rqst() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSBagRequest::clear_bagsell_rqst() {
  if (bagsell_rqst_ != NULL) bagsell_rqst_->::vmsg::CSBagSellRqst::Clear();
  clear_has_bagsell_rqst();
}
inline const ::vmsg::CSBagSellRqst& CSBagRequest::bagsell_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bagsell_rqst_ != NULL ? *bagsell_rqst_ : *default_instance().bagsell_rqst_;
#else
  return bagsell_rqst_ != NULL ? *bagsell_rqst_ : *default_instance_->bagsell_rqst_;
#endif
}
inline ::vmsg::CSBagSellRqst* CSBagRequest::mutable_bagsell_rqst() {
  set_has_bagsell_rqst();
  if (bagsell_rqst_ == NULL) bagsell_rqst_ = new ::vmsg::CSBagSellRqst;
  return bagsell_rqst_;
}
inline ::vmsg::CSBagSellRqst* CSBagRequest::release_bagsell_rqst() {
  clear_has_bagsell_rqst();
  ::vmsg::CSBagSellRqst* temp = bagsell_rqst_;
  bagsell_rqst_ = NULL;
  return temp;
}
inline void CSBagRequest::set_allocated_bagsell_rqst(::vmsg::CSBagSellRqst* bagsell_rqst) {
  delete bagsell_rqst_;
  bagsell_rqst_ = bagsell_rqst;
  if (bagsell_rqst) {
    set_has_bagsell_rqst();
  } else {
    clear_has_bagsell_rqst();
  }
}

// optional .vmsg.CSBuyItemRqst BuyItem_Rqst = 8;
inline bool CSBagRequest::has_buyitem_rqst() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSBagRequest::set_has_buyitem_rqst() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSBagRequest::clear_has_buyitem_rqst() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSBagRequest::clear_buyitem_rqst() {
  if (buyitem_rqst_ != NULL) buyitem_rqst_->::vmsg::CSBuyItemRqst::Clear();
  clear_has_buyitem_rqst();
}
inline const ::vmsg::CSBuyItemRqst& CSBagRequest::buyitem_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return buyitem_rqst_ != NULL ? *buyitem_rqst_ : *default_instance().buyitem_rqst_;
#else
  return buyitem_rqst_ != NULL ? *buyitem_rqst_ : *default_instance_->buyitem_rqst_;
#endif
}
inline ::vmsg::CSBuyItemRqst* CSBagRequest::mutable_buyitem_rqst() {
  set_has_buyitem_rqst();
  if (buyitem_rqst_ == NULL) buyitem_rqst_ = new ::vmsg::CSBuyItemRqst;
  return buyitem_rqst_;
}
inline ::vmsg::CSBuyItemRqst* CSBagRequest::release_buyitem_rqst() {
  clear_has_buyitem_rqst();
  ::vmsg::CSBuyItemRqst* temp = buyitem_rqst_;
  buyitem_rqst_ = NULL;
  return temp;
}
inline void CSBagRequest::set_allocated_buyitem_rqst(::vmsg::CSBuyItemRqst* buyitem_rqst) {
  delete buyitem_rqst_;
  buyitem_rqst_ = buyitem_rqst;
  if (buyitem_rqst) {
    set_has_buyitem_rqst();
  } else {
    clear_has_buyitem_rqst();
  }
}

// optional .vmsg.CSConsumeItemRqst ConsumeItem_Rqst = 9;
inline bool CSBagRequest::has_consumeitem_rqst() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSBagRequest::set_has_consumeitem_rqst() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSBagRequest::clear_has_consumeitem_rqst() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSBagRequest::clear_consumeitem_rqst() {
  if (consumeitem_rqst_ != NULL) consumeitem_rqst_->::vmsg::CSConsumeItemRqst::Clear();
  clear_has_consumeitem_rqst();
}
inline const ::vmsg::CSConsumeItemRqst& CSBagRequest::consumeitem_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return consumeitem_rqst_ != NULL ? *consumeitem_rqst_ : *default_instance().consumeitem_rqst_;
#else
  return consumeitem_rqst_ != NULL ? *consumeitem_rqst_ : *default_instance_->consumeitem_rqst_;
#endif
}
inline ::vmsg::CSConsumeItemRqst* CSBagRequest::mutable_consumeitem_rqst() {
  set_has_consumeitem_rqst();
  if (consumeitem_rqst_ == NULL) consumeitem_rqst_ = new ::vmsg::CSConsumeItemRqst;
  return consumeitem_rqst_;
}
inline ::vmsg::CSConsumeItemRqst* CSBagRequest::release_consumeitem_rqst() {
  clear_has_consumeitem_rqst();
  ::vmsg::CSConsumeItemRqst* temp = consumeitem_rqst_;
  consumeitem_rqst_ = NULL;
  return temp;
}
inline void CSBagRequest::set_allocated_consumeitem_rqst(::vmsg::CSConsumeItemRqst* consumeitem_rqst) {
  delete consumeitem_rqst_;
  consumeitem_rqst_ = consumeitem_rqst;
  if (consumeitem_rqst) {
    set_has_consumeitem_rqst();
  } else {
    clear_has_consumeitem_rqst();
  }
}

// -------------------------------------------------------------------

// CSBagRespond

// optional .vmsg.CSQueryBagInfoRsp QueryBagInfo_Rsp = 1;
inline bool CSBagRespond::has_querybaginfo_rsp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBagRespond::set_has_querybaginfo_rsp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBagRespond::clear_has_querybaginfo_rsp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBagRespond::clear_querybaginfo_rsp() {
  if (querybaginfo_rsp_ != NULL) querybaginfo_rsp_->::vmsg::CSQueryBagInfoRsp::Clear();
  clear_has_querybaginfo_rsp();
}
inline const ::vmsg::CSQueryBagInfoRsp& CSBagRespond::querybaginfo_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return querybaginfo_rsp_ != NULL ? *querybaginfo_rsp_ : *default_instance().querybaginfo_rsp_;
#else
  return querybaginfo_rsp_ != NULL ? *querybaginfo_rsp_ : *default_instance_->querybaginfo_rsp_;
#endif
}
inline ::vmsg::CSQueryBagInfoRsp* CSBagRespond::mutable_querybaginfo_rsp() {
  set_has_querybaginfo_rsp();
  if (querybaginfo_rsp_ == NULL) querybaginfo_rsp_ = new ::vmsg::CSQueryBagInfoRsp;
  return querybaginfo_rsp_;
}
inline ::vmsg::CSQueryBagInfoRsp* CSBagRespond::release_querybaginfo_rsp() {
  clear_has_querybaginfo_rsp();
  ::vmsg::CSQueryBagInfoRsp* temp = querybaginfo_rsp_;
  querybaginfo_rsp_ = NULL;
  return temp;
}
inline void CSBagRespond::set_allocated_querybaginfo_rsp(::vmsg::CSQueryBagInfoRsp* querybaginfo_rsp) {
  delete querybaginfo_rsp_;
  querybaginfo_rsp_ = querybaginfo_rsp;
  if (querybaginfo_rsp) {
    set_has_querybaginfo_rsp();
  } else {
    clear_has_querybaginfo_rsp();
  }
}

// optional .vmsg.CSWearEquipRsp WearEquip_Rsp = 4;
inline bool CSBagRespond::has_wearequip_rsp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBagRespond::set_has_wearequip_rsp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBagRespond::clear_has_wearequip_rsp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBagRespond::clear_wearequip_rsp() {
  if (wearequip_rsp_ != NULL) wearequip_rsp_->::vmsg::CSWearEquipRsp::Clear();
  clear_has_wearequip_rsp();
}
inline const ::vmsg::CSWearEquipRsp& CSBagRespond::wearequip_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return wearequip_rsp_ != NULL ? *wearequip_rsp_ : *default_instance().wearequip_rsp_;
#else
  return wearequip_rsp_ != NULL ? *wearequip_rsp_ : *default_instance_->wearequip_rsp_;
#endif
}
inline ::vmsg::CSWearEquipRsp* CSBagRespond::mutable_wearequip_rsp() {
  set_has_wearequip_rsp();
  if (wearequip_rsp_ == NULL) wearequip_rsp_ = new ::vmsg::CSWearEquipRsp;
  return wearequip_rsp_;
}
inline ::vmsg::CSWearEquipRsp* CSBagRespond::release_wearequip_rsp() {
  clear_has_wearequip_rsp();
  ::vmsg::CSWearEquipRsp* temp = wearequip_rsp_;
  wearequip_rsp_ = NULL;
  return temp;
}
inline void CSBagRespond::set_allocated_wearequip_rsp(::vmsg::CSWearEquipRsp* wearequip_rsp) {
  delete wearequip_rsp_;
  wearequip_rsp_ = wearequip_rsp;
  if (wearequip_rsp) {
    set_has_wearequip_rsp();
  } else {
    clear_has_wearequip_rsp();
  }
}

// optional .vmsg.CSEnlargeRsp Enlarge_Rsp = 5;
inline bool CSBagRespond::has_enlarge_rsp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBagRespond::set_has_enlarge_rsp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBagRespond::clear_has_enlarge_rsp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBagRespond::clear_enlarge_rsp() {
  if (enlarge_rsp_ != NULL) enlarge_rsp_->::vmsg::CSEnlargeRsp::Clear();
  clear_has_enlarge_rsp();
}
inline const ::vmsg::CSEnlargeRsp& CSBagRespond::enlarge_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return enlarge_rsp_ != NULL ? *enlarge_rsp_ : *default_instance().enlarge_rsp_;
#else
  return enlarge_rsp_ != NULL ? *enlarge_rsp_ : *default_instance_->enlarge_rsp_;
#endif
}
inline ::vmsg::CSEnlargeRsp* CSBagRespond::mutable_enlarge_rsp() {
  set_has_enlarge_rsp();
  if (enlarge_rsp_ == NULL) enlarge_rsp_ = new ::vmsg::CSEnlargeRsp;
  return enlarge_rsp_;
}
inline ::vmsg::CSEnlargeRsp* CSBagRespond::release_enlarge_rsp() {
  clear_has_enlarge_rsp();
  ::vmsg::CSEnlargeRsp* temp = enlarge_rsp_;
  enlarge_rsp_ = NULL;
  return temp;
}
inline void CSBagRespond::set_allocated_enlarge_rsp(::vmsg::CSEnlargeRsp* enlarge_rsp) {
  delete enlarge_rsp_;
  enlarge_rsp_ = enlarge_rsp;
  if (enlarge_rsp) {
    set_has_enlarge_rsp();
  } else {
    clear_has_enlarge_rsp();
  }
}

// optional .vmsg.CSTakeOffEquipRsp TakeOffEquip_Rsp = 6;
inline bool CSBagRespond::has_takeoffequip_rsp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSBagRespond::set_has_takeoffequip_rsp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSBagRespond::clear_has_takeoffequip_rsp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSBagRespond::clear_takeoffequip_rsp() {
  if (takeoffequip_rsp_ != NULL) takeoffequip_rsp_->::vmsg::CSTakeOffEquipRsp::Clear();
  clear_has_takeoffequip_rsp();
}
inline const ::vmsg::CSTakeOffEquipRsp& CSBagRespond::takeoffequip_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return takeoffequip_rsp_ != NULL ? *takeoffequip_rsp_ : *default_instance().takeoffequip_rsp_;
#else
  return takeoffequip_rsp_ != NULL ? *takeoffequip_rsp_ : *default_instance_->takeoffequip_rsp_;
#endif
}
inline ::vmsg::CSTakeOffEquipRsp* CSBagRespond::mutable_takeoffequip_rsp() {
  set_has_takeoffequip_rsp();
  if (takeoffequip_rsp_ == NULL) takeoffequip_rsp_ = new ::vmsg::CSTakeOffEquipRsp;
  return takeoffequip_rsp_;
}
inline ::vmsg::CSTakeOffEquipRsp* CSBagRespond::release_takeoffequip_rsp() {
  clear_has_takeoffequip_rsp();
  ::vmsg::CSTakeOffEquipRsp* temp = takeoffequip_rsp_;
  takeoffequip_rsp_ = NULL;
  return temp;
}
inline void CSBagRespond::set_allocated_takeoffequip_rsp(::vmsg::CSTakeOffEquipRsp* takeoffequip_rsp) {
  delete takeoffequip_rsp_;
  takeoffequip_rsp_ = takeoffequip_rsp;
  if (takeoffequip_rsp) {
    set_has_takeoffequip_rsp();
  } else {
    clear_has_takeoffequip_rsp();
  }
}

// optional .vmsg.CSBagSellRsp BagSell_Rsp = 7;
inline bool CSBagRespond::has_bagsell_rsp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSBagRespond::set_has_bagsell_rsp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSBagRespond::clear_has_bagsell_rsp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSBagRespond::clear_bagsell_rsp() {
  if (bagsell_rsp_ != NULL) bagsell_rsp_->::vmsg::CSBagSellRsp::Clear();
  clear_has_bagsell_rsp();
}
inline const ::vmsg::CSBagSellRsp& CSBagRespond::bagsell_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bagsell_rsp_ != NULL ? *bagsell_rsp_ : *default_instance().bagsell_rsp_;
#else
  return bagsell_rsp_ != NULL ? *bagsell_rsp_ : *default_instance_->bagsell_rsp_;
#endif
}
inline ::vmsg::CSBagSellRsp* CSBagRespond::mutable_bagsell_rsp() {
  set_has_bagsell_rsp();
  if (bagsell_rsp_ == NULL) bagsell_rsp_ = new ::vmsg::CSBagSellRsp;
  return bagsell_rsp_;
}
inline ::vmsg::CSBagSellRsp* CSBagRespond::release_bagsell_rsp() {
  clear_has_bagsell_rsp();
  ::vmsg::CSBagSellRsp* temp = bagsell_rsp_;
  bagsell_rsp_ = NULL;
  return temp;
}
inline void CSBagRespond::set_allocated_bagsell_rsp(::vmsg::CSBagSellRsp* bagsell_rsp) {
  delete bagsell_rsp_;
  bagsell_rsp_ = bagsell_rsp;
  if (bagsell_rsp) {
    set_has_bagsell_rsp();
  } else {
    clear_has_bagsell_rsp();
  }
}

// optional .vmsg.CSBagStatNotify BagStat_Notify = 8;
inline bool CSBagRespond::has_bagstat_notify() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSBagRespond::set_has_bagstat_notify() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSBagRespond::clear_has_bagstat_notify() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSBagRespond::clear_bagstat_notify() {
  if (bagstat_notify_ != NULL) bagstat_notify_->::vmsg::CSBagStatNotify::Clear();
  clear_has_bagstat_notify();
}
inline const ::vmsg::CSBagStatNotify& CSBagRespond::bagstat_notify() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bagstat_notify_ != NULL ? *bagstat_notify_ : *default_instance().bagstat_notify_;
#else
  return bagstat_notify_ != NULL ? *bagstat_notify_ : *default_instance_->bagstat_notify_;
#endif
}
inline ::vmsg::CSBagStatNotify* CSBagRespond::mutable_bagstat_notify() {
  set_has_bagstat_notify();
  if (bagstat_notify_ == NULL) bagstat_notify_ = new ::vmsg::CSBagStatNotify;
  return bagstat_notify_;
}
inline ::vmsg::CSBagStatNotify* CSBagRespond::release_bagstat_notify() {
  clear_has_bagstat_notify();
  ::vmsg::CSBagStatNotify* temp = bagstat_notify_;
  bagstat_notify_ = NULL;
  return temp;
}
inline void CSBagRespond::set_allocated_bagstat_notify(::vmsg::CSBagStatNotify* bagstat_notify) {
  delete bagstat_notify_;
  bagstat_notify_ = bagstat_notify;
  if (bagstat_notify) {
    set_has_bagstat_notify();
  } else {
    clear_has_bagstat_notify();
  }
}

// optional .vmsg.CSBagInfoNotify BagInfo_Notify = 9;
inline bool CSBagRespond::has_baginfo_notify() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSBagRespond::set_has_baginfo_notify() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSBagRespond::clear_has_baginfo_notify() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSBagRespond::clear_baginfo_notify() {
  if (baginfo_notify_ != NULL) baginfo_notify_->::vmsg::CSBagInfoNotify::Clear();
  clear_has_baginfo_notify();
}
inline const ::vmsg::CSBagInfoNotify& CSBagRespond::baginfo_notify() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return baginfo_notify_ != NULL ? *baginfo_notify_ : *default_instance().baginfo_notify_;
#else
  return baginfo_notify_ != NULL ? *baginfo_notify_ : *default_instance_->baginfo_notify_;
#endif
}
inline ::vmsg::CSBagInfoNotify* CSBagRespond::mutable_baginfo_notify() {
  set_has_baginfo_notify();
  if (baginfo_notify_ == NULL) baginfo_notify_ = new ::vmsg::CSBagInfoNotify;
  return baginfo_notify_;
}
inline ::vmsg::CSBagInfoNotify* CSBagRespond::release_baginfo_notify() {
  clear_has_baginfo_notify();
  ::vmsg::CSBagInfoNotify* temp = baginfo_notify_;
  baginfo_notify_ = NULL;
  return temp;
}
inline void CSBagRespond::set_allocated_baginfo_notify(::vmsg::CSBagInfoNotify* baginfo_notify) {
  delete baginfo_notify_;
  baginfo_notify_ = baginfo_notify;
  if (baginfo_notify) {
    set_has_baginfo_notify();
  } else {
    clear_has_baginfo_notify();
  }
}

// optional .vmsg.CSConsumeItemRsp ConsumeItem_Rsp = 10;
inline bool CSBagRespond::has_consumeitem_rsp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSBagRespond::set_has_consumeitem_rsp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSBagRespond::clear_has_consumeitem_rsp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSBagRespond::clear_consumeitem_rsp() {
  if (consumeitem_rsp_ != NULL) consumeitem_rsp_->::vmsg::CSConsumeItemRsp::Clear();
  clear_has_consumeitem_rsp();
}
inline const ::vmsg::CSConsumeItemRsp& CSBagRespond::consumeitem_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return consumeitem_rsp_ != NULL ? *consumeitem_rsp_ : *default_instance().consumeitem_rsp_;
#else
  return consumeitem_rsp_ != NULL ? *consumeitem_rsp_ : *default_instance_->consumeitem_rsp_;
#endif
}
inline ::vmsg::CSConsumeItemRsp* CSBagRespond::mutable_consumeitem_rsp() {
  set_has_consumeitem_rsp();
  if (consumeitem_rsp_ == NULL) consumeitem_rsp_ = new ::vmsg::CSConsumeItemRsp;
  return consumeitem_rsp_;
}
inline ::vmsg::CSConsumeItemRsp* CSBagRespond::release_consumeitem_rsp() {
  clear_has_consumeitem_rsp();
  ::vmsg::CSConsumeItemRsp* temp = consumeitem_rsp_;
  consumeitem_rsp_ = NULL;
  return temp;
}
inline void CSBagRespond::set_allocated_consumeitem_rsp(::vmsg::CSConsumeItemRsp* consumeitem_rsp) {
  delete consumeitem_rsp_;
  consumeitem_rsp_ = consumeitem_rsp;
  if (consumeitem_rsp) {
    set_has_consumeitem_rsp();
  } else {
    clear_has_consumeitem_rsp();
  }
}

// optional .vmsg.CSBuyItemRsp BuyItem_Rsp = 11;
inline bool CSBagRespond::has_buyitem_rsp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSBagRespond::set_has_buyitem_rsp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSBagRespond::clear_has_buyitem_rsp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSBagRespond::clear_buyitem_rsp() {
  if (buyitem_rsp_ != NULL) buyitem_rsp_->::vmsg::CSBuyItemRsp::Clear();
  clear_has_buyitem_rsp();
}
inline const ::vmsg::CSBuyItemRsp& CSBagRespond::buyitem_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return buyitem_rsp_ != NULL ? *buyitem_rsp_ : *default_instance().buyitem_rsp_;
#else
  return buyitem_rsp_ != NULL ? *buyitem_rsp_ : *default_instance_->buyitem_rsp_;
#endif
}
inline ::vmsg::CSBuyItemRsp* CSBagRespond::mutable_buyitem_rsp() {
  set_has_buyitem_rsp();
  if (buyitem_rsp_ == NULL) buyitem_rsp_ = new ::vmsg::CSBuyItemRsp;
  return buyitem_rsp_;
}
inline ::vmsg::CSBuyItemRsp* CSBagRespond::release_buyitem_rsp() {
  clear_has_buyitem_rsp();
  ::vmsg::CSBuyItemRsp* temp = buyitem_rsp_;
  buyitem_rsp_ = NULL;
  return temp;
}
inline void CSBagRespond::set_allocated_buyitem_rsp(::vmsg::CSBuyItemRsp* buyitem_rsp) {
  delete buyitem_rsp_;
  buyitem_rsp_ = buyitem_rsp;
  if (buyitem_rsp) {
    set_has_buyitem_rsp();
  } else {
    clear_has_buyitem_rsp();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CSBagMsg_2eproto__INCLUDED
