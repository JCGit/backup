// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSDotaItemMsg.proto

#ifndef PROTOBUF_CSDotaItemMsg_2eproto__INCLUDED
#define PROTOBUF_CSDotaItemMsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MsgBase.pb.h"
#include "ShareByClient.pb.h"
// @@protoc_insertion_point(includes)

namespace vmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CSDotaItemMsg_2eproto();
void protobuf_AssignDesc_CSDotaItemMsg_2eproto();
void protobuf_ShutdownFile_CSDotaItemMsg_2eproto();

class CSDotaItem;
class CSDotaPart;
class CSDotaPartInfo;
class CSDotaItemBag;
class CSDotaInfo;
class CSDotaItemComposeRqst;
class CSDotaItemMosaicRqst;
class CSDotaItemLvUpRqst;
class CSDotaItemRequest;
class CSDotaItemRespond;

// ===================================================================

class CSDotaItem : public ::google::protobuf::MessageLite {
 public:
  CSDotaItem();
  virtual ~CSDotaItem();

  CSDotaItem(const CSDotaItem& from);

  inline CSDotaItem& operator=(const CSDotaItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSDotaItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDotaItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDotaItem* other);

  // implements Message ----------------------------------------------

  CSDotaItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDotaItem& from);
  void MergeFrom(const CSDotaItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 DotaItemID = 1;
  inline bool has_dotaitemid() const;
  inline void clear_dotaitemid();
  static const int kDotaItemIDFieldNumber = 1;
  inline ::google::protobuf::uint32 dotaitemid() const;
  inline void set_dotaitemid(::google::protobuf::uint32 value);

  // required uint32 DotaItemCnt = 2;
  inline bool has_dotaitemcnt() const;
  inline void clear_dotaitemcnt();
  static const int kDotaItemCntFieldNumber = 2;
  inline ::google::protobuf::uint32 dotaitemcnt() const;
  inline void set_dotaitemcnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSDotaItem)
 private:
  inline void set_has_dotaitemid();
  inline void clear_has_dotaitemid();
  inline void set_has_dotaitemcnt();
  inline void clear_has_dotaitemcnt();

  ::google::protobuf::uint32 dotaitemid_;
  ::google::protobuf::uint32 dotaitemcnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSDotaItemMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSDotaItemMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSDotaItemMsg_2eproto();
  friend void protobuf_ShutdownFile_CSDotaItemMsg_2eproto();

  void InitAsDefaultInstance();
  static CSDotaItem* default_instance_;
};
// -------------------------------------------------------------------

class CSDotaPart : public ::google::protobuf::MessageLite {
 public:
  CSDotaPart();
  virtual ~CSDotaPart();

  CSDotaPart(const CSDotaPart& from);

  inline CSDotaPart& operator=(const CSDotaPart& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSDotaPart& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDotaPart* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDotaPart* other);

  // implements Message ----------------------------------------------

  CSDotaPart* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDotaPart& from);
  void MergeFrom(const CSDotaPart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ATK = 1;
  inline bool has_atk() const;
  inline void clear_atk();
  static const int kATKFieldNumber = 1;
  inline ::google::protobuf::uint32 atk() const;
  inline void set_atk(::google::protobuf::uint32 value);

  // required uint32 DEF = 2;
  inline bool has_def() const;
  inline void clear_def();
  static const int kDEFFieldNumber = 2;
  inline ::google::protobuf::uint32 def() const;
  inline void set_def(::google::protobuf::uint32 value);

  // required uint32 HP = 3;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHPFieldNumber = 3;
  inline ::google::protobuf::uint32 hp() const;
  inline void set_hp(::google::protobuf::uint32 value);

  // required uint32 HIT = 4;
  inline bool has_hit() const;
  inline void clear_hit();
  static const int kHITFieldNumber = 4;
  inline ::google::protobuf::uint32 hit() const;
  inline void set_hit(::google::protobuf::uint32 value);

  // required uint32 Lv = 5;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 5;
  inline ::google::protobuf::uint32 lv() const;
  inline void set_lv(::google::protobuf::uint32 value);

  // repeated uint32 Items = 6;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 6;
  inline ::google::protobuf::uint32 items(int index) const;
  inline void set_items(int index, ::google::protobuf::uint32 value);
  inline void add_items(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      items() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:vmsg.CSDotaPart)
 private:
  inline void set_has_atk();
  inline void clear_has_atk();
  inline void set_has_def();
  inline void clear_has_def();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_hit();
  inline void clear_has_hit();
  inline void set_has_lv();
  inline void clear_has_lv();

  ::google::protobuf::uint32 atk_;
  ::google::protobuf::uint32 def_;
  ::google::protobuf::uint32 hp_;
  ::google::protobuf::uint32 hit_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > items_;
  ::google::protobuf::uint32 lv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSDotaItemMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSDotaItemMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSDotaItemMsg_2eproto();
  friend void protobuf_ShutdownFile_CSDotaItemMsg_2eproto();

  void InitAsDefaultInstance();
  static CSDotaPart* default_instance_;
};
// -------------------------------------------------------------------

class CSDotaPartInfo : public ::google::protobuf::MessageLite {
 public:
  CSDotaPartInfo();
  virtual ~CSDotaPartInfo();

  CSDotaPartInfo(const CSDotaPartInfo& from);

  inline CSDotaPartInfo& operator=(const CSDotaPartInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSDotaPartInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDotaPartInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDotaPartInfo* other);

  // implements Message ----------------------------------------------

  CSDotaPartInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDotaPartInfo& from);
  void MergeFrom(const CSDotaPartInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSDotaPart Parts = 1;
  inline int parts_size() const;
  inline void clear_parts();
  static const int kPartsFieldNumber = 1;
  inline const ::vmsg::CSDotaPart& parts(int index) const;
  inline ::vmsg::CSDotaPart* mutable_parts(int index);
  inline ::vmsg::CSDotaPart* add_parts();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSDotaPart >&
      parts() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSDotaPart >*
      mutable_parts();

  // @@protoc_insertion_point(class_scope:vmsg.CSDotaPartInfo)
 private:

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSDotaPart > parts_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSDotaItemMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSDotaItemMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSDotaItemMsg_2eproto();
  friend void protobuf_ShutdownFile_CSDotaItemMsg_2eproto();

  void InitAsDefaultInstance();
  static CSDotaPartInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSDotaItemBag : public ::google::protobuf::MessageLite {
 public:
  CSDotaItemBag();
  virtual ~CSDotaItemBag();

  CSDotaItemBag(const CSDotaItemBag& from);

  inline CSDotaItemBag& operator=(const CSDotaItemBag& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSDotaItemBag& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDotaItemBag* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDotaItemBag* other);

  // implements Message ----------------------------------------------

  CSDotaItemBag* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDotaItemBag& from);
  void MergeFrom(const CSDotaItemBag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSDotaItem Items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::vmsg::CSDotaItem& items(int index) const;
  inline ::vmsg::CSDotaItem* mutable_items(int index);
  inline ::vmsg::CSDotaItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSDotaItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSDotaItem >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:vmsg.CSDotaItemBag)
 private:

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSDotaItem > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSDotaItemMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSDotaItemMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSDotaItemMsg_2eproto();
  friend void protobuf_ShutdownFile_CSDotaItemMsg_2eproto();

  void InitAsDefaultInstance();
  static CSDotaItemBag* default_instance_;
};
// -------------------------------------------------------------------

class CSDotaInfo : public ::google::protobuf::MessageLite {
 public:
  CSDotaInfo();
  virtual ~CSDotaInfo();

  CSDotaInfo(const CSDotaInfo& from);

  inline CSDotaInfo& operator=(const CSDotaInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSDotaInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDotaInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDotaInfo* other);

  // implements Message ----------------------------------------------

  CSDotaInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDotaInfo& from);
  void MergeFrom(const CSDotaInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSDotaItemBag BagInfo = 1;
  inline bool has_baginfo() const;
  inline void clear_baginfo();
  static const int kBagInfoFieldNumber = 1;
  inline const ::vmsg::CSDotaItemBag& baginfo() const;
  inline ::vmsg::CSDotaItemBag* mutable_baginfo();
  inline ::vmsg::CSDotaItemBag* release_baginfo();
  inline void set_allocated_baginfo(::vmsg::CSDotaItemBag* baginfo);

  // required .vmsg.CSDotaPartInfo PartInfo = 2;
  inline bool has_partinfo() const;
  inline void clear_partinfo();
  static const int kPartInfoFieldNumber = 2;
  inline const ::vmsg::CSDotaPartInfo& partinfo() const;
  inline ::vmsg::CSDotaPartInfo* mutable_partinfo();
  inline ::vmsg::CSDotaPartInfo* release_partinfo();
  inline void set_allocated_partinfo(::vmsg::CSDotaPartInfo* partinfo);

  // @@protoc_insertion_point(class_scope:vmsg.CSDotaInfo)
 private:
  inline void set_has_baginfo();
  inline void clear_has_baginfo();
  inline void set_has_partinfo();
  inline void clear_has_partinfo();

  ::vmsg::CSDotaItemBag* baginfo_;
  ::vmsg::CSDotaPartInfo* partinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSDotaItemMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSDotaItemMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSDotaItemMsg_2eproto();
  friend void protobuf_ShutdownFile_CSDotaItemMsg_2eproto();

  void InitAsDefaultInstance();
  static CSDotaInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSDotaItemComposeRqst : public ::google::protobuf::MessageLite {
 public:
  CSDotaItemComposeRqst();
  virtual ~CSDotaItemComposeRqst();

  CSDotaItemComposeRqst(const CSDotaItemComposeRqst& from);

  inline CSDotaItemComposeRqst& operator=(const CSDotaItemComposeRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSDotaItemComposeRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDotaItemComposeRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDotaItemComposeRqst* other);

  // implements Message ----------------------------------------------

  CSDotaItemComposeRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDotaItemComposeRqst& from);
  void MergeFrom(const CSDotaItemComposeRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 DotaItemID = 1;
  inline bool has_dotaitemid() const;
  inline void clear_dotaitemid();
  static const int kDotaItemIDFieldNumber = 1;
  inline ::google::protobuf::uint32 dotaitemid() const;
  inline void set_dotaitemid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSDotaItemComposeRqst)
 private:
  inline void set_has_dotaitemid();
  inline void clear_has_dotaitemid();

  ::google::protobuf::uint32 dotaitemid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSDotaItemMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSDotaItemMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSDotaItemMsg_2eproto();
  friend void protobuf_ShutdownFile_CSDotaItemMsg_2eproto();

  void InitAsDefaultInstance();
  static CSDotaItemComposeRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSDotaItemMosaicRqst : public ::google::protobuf::MessageLite {
 public:
  CSDotaItemMosaicRqst();
  virtual ~CSDotaItemMosaicRqst();

  CSDotaItemMosaicRqst(const CSDotaItemMosaicRqst& from);

  inline CSDotaItemMosaicRqst& operator=(const CSDotaItemMosaicRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSDotaItemMosaicRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDotaItemMosaicRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDotaItemMosaicRqst* other);

  // implements Message ----------------------------------------------

  CSDotaItemMosaicRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDotaItemMosaicRqst& from);
  void MergeFrom(const CSDotaItemMosaicRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Part = 1;
  inline bool has_part() const;
  inline void clear_part();
  static const int kPartFieldNumber = 1;
  inline ::google::protobuf::uint32 part() const;
  inline void set_part(::google::protobuf::uint32 value);

  // required uint32 DotaItemID = 2;
  inline bool has_dotaitemid() const;
  inline void clear_dotaitemid();
  static const int kDotaItemIDFieldNumber = 2;
  inline ::google::protobuf::uint32 dotaitemid() const;
  inline void set_dotaitemid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSDotaItemMosaicRqst)
 private:
  inline void set_has_part();
  inline void clear_has_part();
  inline void set_has_dotaitemid();
  inline void clear_has_dotaitemid();

  ::google::protobuf::uint32 part_;
  ::google::protobuf::uint32 dotaitemid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSDotaItemMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSDotaItemMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSDotaItemMsg_2eproto();
  friend void protobuf_ShutdownFile_CSDotaItemMsg_2eproto();

  void InitAsDefaultInstance();
  static CSDotaItemMosaicRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSDotaItemLvUpRqst : public ::google::protobuf::MessageLite {
 public:
  CSDotaItemLvUpRqst();
  virtual ~CSDotaItemLvUpRqst();

  CSDotaItemLvUpRqst(const CSDotaItemLvUpRqst& from);

  inline CSDotaItemLvUpRqst& operator=(const CSDotaItemLvUpRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSDotaItemLvUpRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDotaItemLvUpRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDotaItemLvUpRqst* other);

  // implements Message ----------------------------------------------

  CSDotaItemLvUpRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDotaItemLvUpRqst& from);
  void MergeFrom(const CSDotaItemLvUpRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Part = 1;
  inline bool has_part() const;
  inline void clear_part();
  static const int kPartFieldNumber = 1;
  inline ::google::protobuf::uint32 part() const;
  inline void set_part(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSDotaItemLvUpRqst)
 private:
  inline void set_has_part();
  inline void clear_has_part();

  ::google::protobuf::uint32 part_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSDotaItemMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSDotaItemMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSDotaItemMsg_2eproto();
  friend void protobuf_ShutdownFile_CSDotaItemMsg_2eproto();

  void InitAsDefaultInstance();
  static CSDotaItemLvUpRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSDotaItemRequest : public ::google::protobuf::MessageLite {
 public:
  CSDotaItemRequest();
  virtual ~CSDotaItemRequest();

  CSDotaItemRequest(const CSDotaItemRequest& from);

  inline CSDotaItemRequest& operator=(const CSDotaItemRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSDotaItemRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDotaItemRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDotaItemRequest* other);

  // implements Message ----------------------------------------------

  CSDotaItemRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDotaItemRequest& from);
  void MergeFrom(const CSDotaItemRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSDotaItemComposeRqst DotaItemCompose_Rqst = 1;
  inline bool has_dotaitemcompose_rqst() const;
  inline void clear_dotaitemcompose_rqst();
  static const int kDotaItemComposeRqstFieldNumber = 1;
  inline const ::vmsg::CSDotaItemComposeRqst& dotaitemcompose_rqst() const;
  inline ::vmsg::CSDotaItemComposeRqst* mutable_dotaitemcompose_rqst();
  inline ::vmsg::CSDotaItemComposeRqst* release_dotaitemcompose_rqst();
  inline void set_allocated_dotaitemcompose_rqst(::vmsg::CSDotaItemComposeRqst* dotaitemcompose_rqst);

  // optional .vmsg.CSDotaItemMosaicRqst DotaItemMosaic_Rqst = 2;
  inline bool has_dotaitemmosaic_rqst() const;
  inline void clear_dotaitemmosaic_rqst();
  static const int kDotaItemMosaicRqstFieldNumber = 2;
  inline const ::vmsg::CSDotaItemMosaicRqst& dotaitemmosaic_rqst() const;
  inline ::vmsg::CSDotaItemMosaicRqst* mutable_dotaitemmosaic_rqst();
  inline ::vmsg::CSDotaItemMosaicRqst* release_dotaitemmosaic_rqst();
  inline void set_allocated_dotaitemmosaic_rqst(::vmsg::CSDotaItemMosaicRqst* dotaitemmosaic_rqst);

  // optional .vmsg.CSDotaItemLvUpRqst DotaItemLvUp_Rqst = 3;
  inline bool has_dotaitemlvup_rqst() const;
  inline void clear_dotaitemlvup_rqst();
  static const int kDotaItemLvUpRqstFieldNumber = 3;
  inline const ::vmsg::CSDotaItemLvUpRqst& dotaitemlvup_rqst() const;
  inline ::vmsg::CSDotaItemLvUpRqst* mutable_dotaitemlvup_rqst();
  inline ::vmsg::CSDotaItemLvUpRqst* release_dotaitemlvup_rqst();
  inline void set_allocated_dotaitemlvup_rqst(::vmsg::CSDotaItemLvUpRqst* dotaitemlvup_rqst);

  // @@protoc_insertion_point(class_scope:vmsg.CSDotaItemRequest)
 private:
  inline void set_has_dotaitemcompose_rqst();
  inline void clear_has_dotaitemcompose_rqst();
  inline void set_has_dotaitemmosaic_rqst();
  inline void clear_has_dotaitemmosaic_rqst();
  inline void set_has_dotaitemlvup_rqst();
  inline void clear_has_dotaitemlvup_rqst();

  ::vmsg::CSDotaItemComposeRqst* dotaitemcompose_rqst_;
  ::vmsg::CSDotaItemMosaicRqst* dotaitemmosaic_rqst_;
  ::vmsg::CSDotaItemLvUpRqst* dotaitemlvup_rqst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSDotaItemMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSDotaItemMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSDotaItemMsg_2eproto();
  friend void protobuf_ShutdownFile_CSDotaItemMsg_2eproto();

  void InitAsDefaultInstance();
  static CSDotaItemRequest* default_instance_;
};
// -------------------------------------------------------------------

class CSDotaItemRespond : public ::google::protobuf::MessageLite {
 public:
  CSDotaItemRespond();
  virtual ~CSDotaItemRespond();

  CSDotaItemRespond(const CSDotaItemRespond& from);

  inline CSDotaItemRespond& operator=(const CSDotaItemRespond& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSDotaItemRespond& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDotaItemRespond* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDotaItemRespond* other);

  // implements Message ----------------------------------------------

  CSDotaItemRespond* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDotaItemRespond& from);
  void MergeFrom(const CSDotaItemRespond& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSDotaInfo DotaItemBagQuery_Rsp = 1;
  inline bool has_dotaitembagquery_rsp() const;
  inline void clear_dotaitembagquery_rsp();
  static const int kDotaItemBagQueryRspFieldNumber = 1;
  inline const ::vmsg::CSDotaInfo& dotaitembagquery_rsp() const;
  inline ::vmsg::CSDotaInfo* mutable_dotaitembagquery_rsp();
  inline ::vmsg::CSDotaInfo* release_dotaitembagquery_rsp();
  inline void set_allocated_dotaitembagquery_rsp(::vmsg::CSDotaInfo* dotaitembagquery_rsp);

  // optional .vmsg.CSDotaItemBag DotaItemCompose_Rsp = 2;
  inline bool has_dotaitemcompose_rsp() const;
  inline void clear_dotaitemcompose_rsp();
  static const int kDotaItemComposeRspFieldNumber = 2;
  inline const ::vmsg::CSDotaItemBag& dotaitemcompose_rsp() const;
  inline ::vmsg::CSDotaItemBag* mutable_dotaitemcompose_rsp();
  inline ::vmsg::CSDotaItemBag* release_dotaitemcompose_rsp();
  inline void set_allocated_dotaitemcompose_rsp(::vmsg::CSDotaItemBag* dotaitemcompose_rsp);

  // optional .vmsg.CSDotaInfo DotaItemMosaic_Rsp = 3;
  inline bool has_dotaitemmosaic_rsp() const;
  inline void clear_dotaitemmosaic_rsp();
  static const int kDotaItemMosaicRspFieldNumber = 3;
  inline const ::vmsg::CSDotaInfo& dotaitemmosaic_rsp() const;
  inline ::vmsg::CSDotaInfo* mutable_dotaitemmosaic_rsp();
  inline ::vmsg::CSDotaInfo* release_dotaitemmosaic_rsp();
  inline void set_allocated_dotaitemmosaic_rsp(::vmsg::CSDotaInfo* dotaitemmosaic_rsp);

  // optional .vmsg.CSDotaPartInfo DotaItemLvUp_Rsp = 4;
  inline bool has_dotaitemlvup_rsp() const;
  inline void clear_dotaitemlvup_rsp();
  static const int kDotaItemLvUpRspFieldNumber = 4;
  inline const ::vmsg::CSDotaPartInfo& dotaitemlvup_rsp() const;
  inline ::vmsg::CSDotaPartInfo* mutable_dotaitemlvup_rsp();
  inline ::vmsg::CSDotaPartInfo* release_dotaitemlvup_rsp();
  inline void set_allocated_dotaitemlvup_rsp(::vmsg::CSDotaPartInfo* dotaitemlvup_rsp);

  // @@protoc_insertion_point(class_scope:vmsg.CSDotaItemRespond)
 private:
  inline void set_has_dotaitembagquery_rsp();
  inline void clear_has_dotaitembagquery_rsp();
  inline void set_has_dotaitemcompose_rsp();
  inline void clear_has_dotaitemcompose_rsp();
  inline void set_has_dotaitemmosaic_rsp();
  inline void clear_has_dotaitemmosaic_rsp();
  inline void set_has_dotaitemlvup_rsp();
  inline void clear_has_dotaitemlvup_rsp();

  ::vmsg::CSDotaInfo* dotaitembagquery_rsp_;
  ::vmsg::CSDotaItemBag* dotaitemcompose_rsp_;
  ::vmsg::CSDotaInfo* dotaitemmosaic_rsp_;
  ::vmsg::CSDotaPartInfo* dotaitemlvup_rsp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSDotaItemMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSDotaItemMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSDotaItemMsg_2eproto();
  friend void protobuf_ShutdownFile_CSDotaItemMsg_2eproto();

  void InitAsDefaultInstance();
  static CSDotaItemRespond* default_instance_;
};
// ===================================================================


// ===================================================================

// CSDotaItem

// required uint32 DotaItemID = 1;
inline bool CSDotaItem::has_dotaitemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDotaItem::set_has_dotaitemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDotaItem::clear_has_dotaitemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDotaItem::clear_dotaitemid() {
  dotaitemid_ = 0u;
  clear_has_dotaitemid();
}
inline ::google::protobuf::uint32 CSDotaItem::dotaitemid() const {
  return dotaitemid_;
}
inline void CSDotaItem::set_dotaitemid(::google::protobuf::uint32 value) {
  set_has_dotaitemid();
  dotaitemid_ = value;
}

// required uint32 DotaItemCnt = 2;
inline bool CSDotaItem::has_dotaitemcnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSDotaItem::set_has_dotaitemcnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSDotaItem::clear_has_dotaitemcnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSDotaItem::clear_dotaitemcnt() {
  dotaitemcnt_ = 0u;
  clear_has_dotaitemcnt();
}
inline ::google::protobuf::uint32 CSDotaItem::dotaitemcnt() const {
  return dotaitemcnt_;
}
inline void CSDotaItem::set_dotaitemcnt(::google::protobuf::uint32 value) {
  set_has_dotaitemcnt();
  dotaitemcnt_ = value;
}

// -------------------------------------------------------------------

// CSDotaPart

// required uint32 ATK = 1;
inline bool CSDotaPart::has_atk() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDotaPart::set_has_atk() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDotaPart::clear_has_atk() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDotaPart::clear_atk() {
  atk_ = 0u;
  clear_has_atk();
}
inline ::google::protobuf::uint32 CSDotaPart::atk() const {
  return atk_;
}
inline void CSDotaPart::set_atk(::google::protobuf::uint32 value) {
  set_has_atk();
  atk_ = value;
}

// required uint32 DEF = 2;
inline bool CSDotaPart::has_def() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSDotaPart::set_has_def() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSDotaPart::clear_has_def() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSDotaPart::clear_def() {
  def_ = 0u;
  clear_has_def();
}
inline ::google::protobuf::uint32 CSDotaPart::def() const {
  return def_;
}
inline void CSDotaPart::set_def(::google::protobuf::uint32 value) {
  set_has_def();
  def_ = value;
}

// required uint32 HP = 3;
inline bool CSDotaPart::has_hp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSDotaPart::set_has_hp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSDotaPart::clear_has_hp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSDotaPart::clear_hp() {
  hp_ = 0u;
  clear_has_hp();
}
inline ::google::protobuf::uint32 CSDotaPart::hp() const {
  return hp_;
}
inline void CSDotaPart::set_hp(::google::protobuf::uint32 value) {
  set_has_hp();
  hp_ = value;
}

// required uint32 HIT = 4;
inline bool CSDotaPart::has_hit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSDotaPart::set_has_hit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSDotaPart::clear_has_hit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSDotaPart::clear_hit() {
  hit_ = 0u;
  clear_has_hit();
}
inline ::google::protobuf::uint32 CSDotaPart::hit() const {
  return hit_;
}
inline void CSDotaPart::set_hit(::google::protobuf::uint32 value) {
  set_has_hit();
  hit_ = value;
}

// required uint32 Lv = 5;
inline bool CSDotaPart::has_lv() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSDotaPart::set_has_lv() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSDotaPart::clear_has_lv() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSDotaPart::clear_lv() {
  lv_ = 0u;
  clear_has_lv();
}
inline ::google::protobuf::uint32 CSDotaPart::lv() const {
  return lv_;
}
inline void CSDotaPart::set_lv(::google::protobuf::uint32 value) {
  set_has_lv();
  lv_ = value;
}

// repeated uint32 Items = 6;
inline int CSDotaPart::items_size() const {
  return items_.size();
}
inline void CSDotaPart::clear_items() {
  items_.Clear();
}
inline ::google::protobuf::uint32 CSDotaPart::items(int index) const {
  return items_.Get(index);
}
inline void CSDotaPart::set_items(int index, ::google::protobuf::uint32 value) {
  items_.Set(index, value);
}
inline void CSDotaPart::add_items(::google::protobuf::uint32 value) {
  items_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSDotaPart::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSDotaPart::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// CSDotaPartInfo

// repeated .vmsg.CSDotaPart Parts = 1;
inline int CSDotaPartInfo::parts_size() const {
  return parts_.size();
}
inline void CSDotaPartInfo::clear_parts() {
  parts_.Clear();
}
inline const ::vmsg::CSDotaPart& CSDotaPartInfo::parts(int index) const {
  return parts_.Get(index);
}
inline ::vmsg::CSDotaPart* CSDotaPartInfo::mutable_parts(int index) {
  return parts_.Mutable(index);
}
inline ::vmsg::CSDotaPart* CSDotaPartInfo::add_parts() {
  return parts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSDotaPart >&
CSDotaPartInfo::parts() const {
  return parts_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSDotaPart >*
CSDotaPartInfo::mutable_parts() {
  return &parts_;
}

// -------------------------------------------------------------------

// CSDotaItemBag

// repeated .vmsg.CSDotaItem Items = 1;
inline int CSDotaItemBag::items_size() const {
  return items_.size();
}
inline void CSDotaItemBag::clear_items() {
  items_.Clear();
}
inline const ::vmsg::CSDotaItem& CSDotaItemBag::items(int index) const {
  return items_.Get(index);
}
inline ::vmsg::CSDotaItem* CSDotaItemBag::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::vmsg::CSDotaItem* CSDotaItemBag::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSDotaItem >&
CSDotaItemBag::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSDotaItem >*
CSDotaItemBag::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// CSDotaInfo

// required .vmsg.CSDotaItemBag BagInfo = 1;
inline bool CSDotaInfo::has_baginfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDotaInfo::set_has_baginfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDotaInfo::clear_has_baginfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDotaInfo::clear_baginfo() {
  if (baginfo_ != NULL) baginfo_->::vmsg::CSDotaItemBag::Clear();
  clear_has_baginfo();
}
inline const ::vmsg::CSDotaItemBag& CSDotaInfo::baginfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return baginfo_ != NULL ? *baginfo_ : *default_instance().baginfo_;
#else
  return baginfo_ != NULL ? *baginfo_ : *default_instance_->baginfo_;
#endif
}
inline ::vmsg::CSDotaItemBag* CSDotaInfo::mutable_baginfo() {
  set_has_baginfo();
  if (baginfo_ == NULL) baginfo_ = new ::vmsg::CSDotaItemBag;
  return baginfo_;
}
inline ::vmsg::CSDotaItemBag* CSDotaInfo::release_baginfo() {
  clear_has_baginfo();
  ::vmsg::CSDotaItemBag* temp = baginfo_;
  baginfo_ = NULL;
  return temp;
}
inline void CSDotaInfo::set_allocated_baginfo(::vmsg::CSDotaItemBag* baginfo) {
  delete baginfo_;
  baginfo_ = baginfo;
  if (baginfo) {
    set_has_baginfo();
  } else {
    clear_has_baginfo();
  }
}

// required .vmsg.CSDotaPartInfo PartInfo = 2;
inline bool CSDotaInfo::has_partinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSDotaInfo::set_has_partinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSDotaInfo::clear_has_partinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSDotaInfo::clear_partinfo() {
  if (partinfo_ != NULL) partinfo_->::vmsg::CSDotaPartInfo::Clear();
  clear_has_partinfo();
}
inline const ::vmsg::CSDotaPartInfo& CSDotaInfo::partinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return partinfo_ != NULL ? *partinfo_ : *default_instance().partinfo_;
#else
  return partinfo_ != NULL ? *partinfo_ : *default_instance_->partinfo_;
#endif
}
inline ::vmsg::CSDotaPartInfo* CSDotaInfo::mutable_partinfo() {
  set_has_partinfo();
  if (partinfo_ == NULL) partinfo_ = new ::vmsg::CSDotaPartInfo;
  return partinfo_;
}
inline ::vmsg::CSDotaPartInfo* CSDotaInfo::release_partinfo() {
  clear_has_partinfo();
  ::vmsg::CSDotaPartInfo* temp = partinfo_;
  partinfo_ = NULL;
  return temp;
}
inline void CSDotaInfo::set_allocated_partinfo(::vmsg::CSDotaPartInfo* partinfo) {
  delete partinfo_;
  partinfo_ = partinfo;
  if (partinfo) {
    set_has_partinfo();
  } else {
    clear_has_partinfo();
  }
}

// -------------------------------------------------------------------

// CSDotaItemComposeRqst

// required uint32 DotaItemID = 1;
inline bool CSDotaItemComposeRqst::has_dotaitemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDotaItemComposeRqst::set_has_dotaitemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDotaItemComposeRqst::clear_has_dotaitemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDotaItemComposeRqst::clear_dotaitemid() {
  dotaitemid_ = 0u;
  clear_has_dotaitemid();
}
inline ::google::protobuf::uint32 CSDotaItemComposeRqst::dotaitemid() const {
  return dotaitemid_;
}
inline void CSDotaItemComposeRqst::set_dotaitemid(::google::protobuf::uint32 value) {
  set_has_dotaitemid();
  dotaitemid_ = value;
}

// -------------------------------------------------------------------

// CSDotaItemMosaicRqst

// required uint32 Part = 1;
inline bool CSDotaItemMosaicRqst::has_part() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDotaItemMosaicRqst::set_has_part() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDotaItemMosaicRqst::clear_has_part() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDotaItemMosaicRqst::clear_part() {
  part_ = 0u;
  clear_has_part();
}
inline ::google::protobuf::uint32 CSDotaItemMosaicRqst::part() const {
  return part_;
}
inline void CSDotaItemMosaicRqst::set_part(::google::protobuf::uint32 value) {
  set_has_part();
  part_ = value;
}

// required uint32 DotaItemID = 2;
inline bool CSDotaItemMosaicRqst::has_dotaitemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSDotaItemMosaicRqst::set_has_dotaitemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSDotaItemMosaicRqst::clear_has_dotaitemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSDotaItemMosaicRqst::clear_dotaitemid() {
  dotaitemid_ = 0u;
  clear_has_dotaitemid();
}
inline ::google::protobuf::uint32 CSDotaItemMosaicRqst::dotaitemid() const {
  return dotaitemid_;
}
inline void CSDotaItemMosaicRqst::set_dotaitemid(::google::protobuf::uint32 value) {
  set_has_dotaitemid();
  dotaitemid_ = value;
}

// -------------------------------------------------------------------

// CSDotaItemLvUpRqst

// required uint32 Part = 1;
inline bool CSDotaItemLvUpRqst::has_part() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDotaItemLvUpRqst::set_has_part() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDotaItemLvUpRqst::clear_has_part() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDotaItemLvUpRqst::clear_part() {
  part_ = 0u;
  clear_has_part();
}
inline ::google::protobuf::uint32 CSDotaItemLvUpRqst::part() const {
  return part_;
}
inline void CSDotaItemLvUpRqst::set_part(::google::protobuf::uint32 value) {
  set_has_part();
  part_ = value;
}

// -------------------------------------------------------------------

// CSDotaItemRequest

// optional .vmsg.CSDotaItemComposeRqst DotaItemCompose_Rqst = 1;
inline bool CSDotaItemRequest::has_dotaitemcompose_rqst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDotaItemRequest::set_has_dotaitemcompose_rqst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDotaItemRequest::clear_has_dotaitemcompose_rqst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDotaItemRequest::clear_dotaitemcompose_rqst() {
  if (dotaitemcompose_rqst_ != NULL) dotaitemcompose_rqst_->::vmsg::CSDotaItemComposeRqst::Clear();
  clear_has_dotaitemcompose_rqst();
}
inline const ::vmsg::CSDotaItemComposeRqst& CSDotaItemRequest::dotaitemcompose_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dotaitemcompose_rqst_ != NULL ? *dotaitemcompose_rqst_ : *default_instance().dotaitemcompose_rqst_;
#else
  return dotaitemcompose_rqst_ != NULL ? *dotaitemcompose_rqst_ : *default_instance_->dotaitemcompose_rqst_;
#endif
}
inline ::vmsg::CSDotaItemComposeRqst* CSDotaItemRequest::mutable_dotaitemcompose_rqst() {
  set_has_dotaitemcompose_rqst();
  if (dotaitemcompose_rqst_ == NULL) dotaitemcompose_rqst_ = new ::vmsg::CSDotaItemComposeRqst;
  return dotaitemcompose_rqst_;
}
inline ::vmsg::CSDotaItemComposeRqst* CSDotaItemRequest::release_dotaitemcompose_rqst() {
  clear_has_dotaitemcompose_rqst();
  ::vmsg::CSDotaItemComposeRqst* temp = dotaitemcompose_rqst_;
  dotaitemcompose_rqst_ = NULL;
  return temp;
}
inline void CSDotaItemRequest::set_allocated_dotaitemcompose_rqst(::vmsg::CSDotaItemComposeRqst* dotaitemcompose_rqst) {
  delete dotaitemcompose_rqst_;
  dotaitemcompose_rqst_ = dotaitemcompose_rqst;
  if (dotaitemcompose_rqst) {
    set_has_dotaitemcompose_rqst();
  } else {
    clear_has_dotaitemcompose_rqst();
  }
}

// optional .vmsg.CSDotaItemMosaicRqst DotaItemMosaic_Rqst = 2;
inline bool CSDotaItemRequest::has_dotaitemmosaic_rqst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSDotaItemRequest::set_has_dotaitemmosaic_rqst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSDotaItemRequest::clear_has_dotaitemmosaic_rqst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSDotaItemRequest::clear_dotaitemmosaic_rqst() {
  if (dotaitemmosaic_rqst_ != NULL) dotaitemmosaic_rqst_->::vmsg::CSDotaItemMosaicRqst::Clear();
  clear_has_dotaitemmosaic_rqst();
}
inline const ::vmsg::CSDotaItemMosaicRqst& CSDotaItemRequest::dotaitemmosaic_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dotaitemmosaic_rqst_ != NULL ? *dotaitemmosaic_rqst_ : *default_instance().dotaitemmosaic_rqst_;
#else
  return dotaitemmosaic_rqst_ != NULL ? *dotaitemmosaic_rqst_ : *default_instance_->dotaitemmosaic_rqst_;
#endif
}
inline ::vmsg::CSDotaItemMosaicRqst* CSDotaItemRequest::mutable_dotaitemmosaic_rqst() {
  set_has_dotaitemmosaic_rqst();
  if (dotaitemmosaic_rqst_ == NULL) dotaitemmosaic_rqst_ = new ::vmsg::CSDotaItemMosaicRqst;
  return dotaitemmosaic_rqst_;
}
inline ::vmsg::CSDotaItemMosaicRqst* CSDotaItemRequest::release_dotaitemmosaic_rqst() {
  clear_has_dotaitemmosaic_rqst();
  ::vmsg::CSDotaItemMosaicRqst* temp = dotaitemmosaic_rqst_;
  dotaitemmosaic_rqst_ = NULL;
  return temp;
}
inline void CSDotaItemRequest::set_allocated_dotaitemmosaic_rqst(::vmsg::CSDotaItemMosaicRqst* dotaitemmosaic_rqst) {
  delete dotaitemmosaic_rqst_;
  dotaitemmosaic_rqst_ = dotaitemmosaic_rqst;
  if (dotaitemmosaic_rqst) {
    set_has_dotaitemmosaic_rqst();
  } else {
    clear_has_dotaitemmosaic_rqst();
  }
}

// optional .vmsg.CSDotaItemLvUpRqst DotaItemLvUp_Rqst = 3;
inline bool CSDotaItemRequest::has_dotaitemlvup_rqst() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSDotaItemRequest::set_has_dotaitemlvup_rqst() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSDotaItemRequest::clear_has_dotaitemlvup_rqst() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSDotaItemRequest::clear_dotaitemlvup_rqst() {
  if (dotaitemlvup_rqst_ != NULL) dotaitemlvup_rqst_->::vmsg::CSDotaItemLvUpRqst::Clear();
  clear_has_dotaitemlvup_rqst();
}
inline const ::vmsg::CSDotaItemLvUpRqst& CSDotaItemRequest::dotaitemlvup_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dotaitemlvup_rqst_ != NULL ? *dotaitemlvup_rqst_ : *default_instance().dotaitemlvup_rqst_;
#else
  return dotaitemlvup_rqst_ != NULL ? *dotaitemlvup_rqst_ : *default_instance_->dotaitemlvup_rqst_;
#endif
}
inline ::vmsg::CSDotaItemLvUpRqst* CSDotaItemRequest::mutable_dotaitemlvup_rqst() {
  set_has_dotaitemlvup_rqst();
  if (dotaitemlvup_rqst_ == NULL) dotaitemlvup_rqst_ = new ::vmsg::CSDotaItemLvUpRqst;
  return dotaitemlvup_rqst_;
}
inline ::vmsg::CSDotaItemLvUpRqst* CSDotaItemRequest::release_dotaitemlvup_rqst() {
  clear_has_dotaitemlvup_rqst();
  ::vmsg::CSDotaItemLvUpRqst* temp = dotaitemlvup_rqst_;
  dotaitemlvup_rqst_ = NULL;
  return temp;
}
inline void CSDotaItemRequest::set_allocated_dotaitemlvup_rqst(::vmsg::CSDotaItemLvUpRqst* dotaitemlvup_rqst) {
  delete dotaitemlvup_rqst_;
  dotaitemlvup_rqst_ = dotaitemlvup_rqst;
  if (dotaitemlvup_rqst) {
    set_has_dotaitemlvup_rqst();
  } else {
    clear_has_dotaitemlvup_rqst();
  }
}

// -------------------------------------------------------------------

// CSDotaItemRespond

// optional .vmsg.CSDotaInfo DotaItemBagQuery_Rsp = 1;
inline bool CSDotaItemRespond::has_dotaitembagquery_rsp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDotaItemRespond::set_has_dotaitembagquery_rsp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDotaItemRespond::clear_has_dotaitembagquery_rsp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDotaItemRespond::clear_dotaitembagquery_rsp() {
  if (dotaitembagquery_rsp_ != NULL) dotaitembagquery_rsp_->::vmsg::CSDotaInfo::Clear();
  clear_has_dotaitembagquery_rsp();
}
inline const ::vmsg::CSDotaInfo& CSDotaItemRespond::dotaitembagquery_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dotaitembagquery_rsp_ != NULL ? *dotaitembagquery_rsp_ : *default_instance().dotaitembagquery_rsp_;
#else
  return dotaitembagquery_rsp_ != NULL ? *dotaitembagquery_rsp_ : *default_instance_->dotaitembagquery_rsp_;
#endif
}
inline ::vmsg::CSDotaInfo* CSDotaItemRespond::mutable_dotaitembagquery_rsp() {
  set_has_dotaitembagquery_rsp();
  if (dotaitembagquery_rsp_ == NULL) dotaitembagquery_rsp_ = new ::vmsg::CSDotaInfo;
  return dotaitembagquery_rsp_;
}
inline ::vmsg::CSDotaInfo* CSDotaItemRespond::release_dotaitembagquery_rsp() {
  clear_has_dotaitembagquery_rsp();
  ::vmsg::CSDotaInfo* temp = dotaitembagquery_rsp_;
  dotaitembagquery_rsp_ = NULL;
  return temp;
}
inline void CSDotaItemRespond::set_allocated_dotaitembagquery_rsp(::vmsg::CSDotaInfo* dotaitembagquery_rsp) {
  delete dotaitembagquery_rsp_;
  dotaitembagquery_rsp_ = dotaitembagquery_rsp;
  if (dotaitembagquery_rsp) {
    set_has_dotaitembagquery_rsp();
  } else {
    clear_has_dotaitembagquery_rsp();
  }
}

// optional .vmsg.CSDotaItemBag DotaItemCompose_Rsp = 2;
inline bool CSDotaItemRespond::has_dotaitemcompose_rsp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSDotaItemRespond::set_has_dotaitemcompose_rsp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSDotaItemRespond::clear_has_dotaitemcompose_rsp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSDotaItemRespond::clear_dotaitemcompose_rsp() {
  if (dotaitemcompose_rsp_ != NULL) dotaitemcompose_rsp_->::vmsg::CSDotaItemBag::Clear();
  clear_has_dotaitemcompose_rsp();
}
inline const ::vmsg::CSDotaItemBag& CSDotaItemRespond::dotaitemcompose_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dotaitemcompose_rsp_ != NULL ? *dotaitemcompose_rsp_ : *default_instance().dotaitemcompose_rsp_;
#else
  return dotaitemcompose_rsp_ != NULL ? *dotaitemcompose_rsp_ : *default_instance_->dotaitemcompose_rsp_;
#endif
}
inline ::vmsg::CSDotaItemBag* CSDotaItemRespond::mutable_dotaitemcompose_rsp() {
  set_has_dotaitemcompose_rsp();
  if (dotaitemcompose_rsp_ == NULL) dotaitemcompose_rsp_ = new ::vmsg::CSDotaItemBag;
  return dotaitemcompose_rsp_;
}
inline ::vmsg::CSDotaItemBag* CSDotaItemRespond::release_dotaitemcompose_rsp() {
  clear_has_dotaitemcompose_rsp();
  ::vmsg::CSDotaItemBag* temp = dotaitemcompose_rsp_;
  dotaitemcompose_rsp_ = NULL;
  return temp;
}
inline void CSDotaItemRespond::set_allocated_dotaitemcompose_rsp(::vmsg::CSDotaItemBag* dotaitemcompose_rsp) {
  delete dotaitemcompose_rsp_;
  dotaitemcompose_rsp_ = dotaitemcompose_rsp;
  if (dotaitemcompose_rsp) {
    set_has_dotaitemcompose_rsp();
  } else {
    clear_has_dotaitemcompose_rsp();
  }
}

// optional .vmsg.CSDotaInfo DotaItemMosaic_Rsp = 3;
inline bool CSDotaItemRespond::has_dotaitemmosaic_rsp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSDotaItemRespond::set_has_dotaitemmosaic_rsp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSDotaItemRespond::clear_has_dotaitemmosaic_rsp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSDotaItemRespond::clear_dotaitemmosaic_rsp() {
  if (dotaitemmosaic_rsp_ != NULL) dotaitemmosaic_rsp_->::vmsg::CSDotaInfo::Clear();
  clear_has_dotaitemmosaic_rsp();
}
inline const ::vmsg::CSDotaInfo& CSDotaItemRespond::dotaitemmosaic_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dotaitemmosaic_rsp_ != NULL ? *dotaitemmosaic_rsp_ : *default_instance().dotaitemmosaic_rsp_;
#else
  return dotaitemmosaic_rsp_ != NULL ? *dotaitemmosaic_rsp_ : *default_instance_->dotaitemmosaic_rsp_;
#endif
}
inline ::vmsg::CSDotaInfo* CSDotaItemRespond::mutable_dotaitemmosaic_rsp() {
  set_has_dotaitemmosaic_rsp();
  if (dotaitemmosaic_rsp_ == NULL) dotaitemmosaic_rsp_ = new ::vmsg::CSDotaInfo;
  return dotaitemmosaic_rsp_;
}
inline ::vmsg::CSDotaInfo* CSDotaItemRespond::release_dotaitemmosaic_rsp() {
  clear_has_dotaitemmosaic_rsp();
  ::vmsg::CSDotaInfo* temp = dotaitemmosaic_rsp_;
  dotaitemmosaic_rsp_ = NULL;
  return temp;
}
inline void CSDotaItemRespond::set_allocated_dotaitemmosaic_rsp(::vmsg::CSDotaInfo* dotaitemmosaic_rsp) {
  delete dotaitemmosaic_rsp_;
  dotaitemmosaic_rsp_ = dotaitemmosaic_rsp;
  if (dotaitemmosaic_rsp) {
    set_has_dotaitemmosaic_rsp();
  } else {
    clear_has_dotaitemmosaic_rsp();
  }
}

// optional .vmsg.CSDotaPartInfo DotaItemLvUp_Rsp = 4;
inline bool CSDotaItemRespond::has_dotaitemlvup_rsp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSDotaItemRespond::set_has_dotaitemlvup_rsp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSDotaItemRespond::clear_has_dotaitemlvup_rsp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSDotaItemRespond::clear_dotaitemlvup_rsp() {
  if (dotaitemlvup_rsp_ != NULL) dotaitemlvup_rsp_->::vmsg::CSDotaPartInfo::Clear();
  clear_has_dotaitemlvup_rsp();
}
inline const ::vmsg::CSDotaPartInfo& CSDotaItemRespond::dotaitemlvup_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dotaitemlvup_rsp_ != NULL ? *dotaitemlvup_rsp_ : *default_instance().dotaitemlvup_rsp_;
#else
  return dotaitemlvup_rsp_ != NULL ? *dotaitemlvup_rsp_ : *default_instance_->dotaitemlvup_rsp_;
#endif
}
inline ::vmsg::CSDotaPartInfo* CSDotaItemRespond::mutable_dotaitemlvup_rsp() {
  set_has_dotaitemlvup_rsp();
  if (dotaitemlvup_rsp_ == NULL) dotaitemlvup_rsp_ = new ::vmsg::CSDotaPartInfo;
  return dotaitemlvup_rsp_;
}
inline ::vmsg::CSDotaPartInfo* CSDotaItemRespond::release_dotaitemlvup_rsp() {
  clear_has_dotaitemlvup_rsp();
  ::vmsg::CSDotaPartInfo* temp = dotaitemlvup_rsp_;
  dotaitemlvup_rsp_ = NULL;
  return temp;
}
inline void CSDotaItemRespond::set_allocated_dotaitemlvup_rsp(::vmsg::CSDotaPartInfo* dotaitemlvup_rsp) {
  delete dotaitemlvup_rsp_;
  dotaitemlvup_rsp_ = dotaitemlvup_rsp;
  if (dotaitemlvup_rsp) {
    set_has_dotaitemlvup_rsp();
  } else {
    clear_has_dotaitemlvup_rsp();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CSDotaItemMsg_2eproto__INCLUDED
