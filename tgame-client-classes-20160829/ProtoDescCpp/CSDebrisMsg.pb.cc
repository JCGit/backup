// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSDebrisMsg.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "CSDebrisMsg.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace vmsg {

void protobuf_ShutdownFile_CSDebrisMsg_2eproto() {
  delete CSDebrisInfo::default_instance_;
  delete CSDebrisBagInfo::default_instance_;
  delete CSDebrisComposeRqst::default_instance_;
  delete CSDebrisComposeRsp::default_instance_;
  delete CSDebrisRequest::default_instance_;
  delete CSDebrisRespond::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_CSDebrisMsg_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_CSDebrisMsg_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::vmsg::protobuf_AddDesc_MsgBase_2eproto();
  ::vmsg::protobuf_AddDesc_ShareByClient_2eproto();
  CSDebrisInfo::default_instance_ = new CSDebrisInfo();
  CSDebrisBagInfo::default_instance_ = new CSDebrisBagInfo();
  CSDebrisComposeRqst::default_instance_ = new CSDebrisComposeRqst();
  CSDebrisComposeRsp::default_instance_ = new CSDebrisComposeRsp();
  CSDebrisRequest::default_instance_ = new CSDebrisRequest();
  CSDebrisRespond::default_instance_ = new CSDebrisRespond();
  CSDebrisInfo::default_instance_->InitAsDefaultInstance();
  CSDebrisBagInfo::default_instance_->InitAsDefaultInstance();
  CSDebrisComposeRqst::default_instance_->InitAsDefaultInstance();
  CSDebrisComposeRsp::default_instance_->InitAsDefaultInstance();
  CSDebrisRequest::default_instance_->InitAsDefaultInstance();
  CSDebrisRespond::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_CSDebrisMsg_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_CSDebrisMsg_2eproto_once_);
void protobuf_AddDesc_CSDebrisMsg_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_CSDebrisMsg_2eproto_once_,
                 &protobuf_AddDesc_CSDebrisMsg_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_CSDebrisMsg_2eproto {
  StaticDescriptorInitializer_CSDebrisMsg_2eproto() {
    protobuf_AddDesc_CSDebrisMsg_2eproto();
  }
} static_descriptor_initializer_CSDebrisMsg_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int CSDebrisInfo::kDebrisCfgIDFieldNumber;
const int CSDebrisInfo::kDebrisCntFieldNumber;
#endif  // !_MSC_VER

CSDebrisInfo::CSDebrisInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSDebrisInfo::InitAsDefaultInstance() {
}

CSDebrisInfo::CSDebrisInfo(const CSDebrisInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSDebrisInfo::SharedCtor() {
  _cached_size_ = 0;
  debriscfgid_ = 0u;
  debriscnt_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSDebrisInfo::~CSDebrisInfo() {
  SharedDtor();
}

void CSDebrisInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSDebrisInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSDebrisInfo& CSDebrisInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSDebrisMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSDebrisMsg_2eproto();
#endif
  return *default_instance_;
}

CSDebrisInfo* CSDebrisInfo::default_instance_ = NULL;

CSDebrisInfo* CSDebrisInfo::New() const {
  return new CSDebrisInfo;
}

void CSDebrisInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    debriscfgid_ = 0u;
    debriscnt_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSDebrisInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 DebrisCfgID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &debriscfgid_)));
          set_has_debriscfgid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_DebrisCnt;
        break;
      }

      // required uint32 DebrisCnt = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_DebrisCnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &debriscnt_)));
          set_has_debriscnt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSDebrisInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 DebrisCfgID = 1;
  if (has_debriscfgid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->debriscfgid(), output);
  }

  // required uint32 DebrisCnt = 2;
  if (has_debriscnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->debriscnt(), output);
  }

}

int CSDebrisInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 DebrisCfgID = 1;
    if (has_debriscfgid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->debriscfgid());
    }

    // required uint32 DebrisCnt = 2;
    if (has_debriscnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->debriscnt());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSDebrisInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSDebrisInfo*>(&from));
}

void CSDebrisInfo::MergeFrom(const CSDebrisInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_debriscfgid()) {
      set_debriscfgid(from.debriscfgid());
    }
    if (from.has_debriscnt()) {
      set_debriscnt(from.debriscnt());
    }
  }
}

void CSDebrisInfo::CopyFrom(const CSDebrisInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSDebrisInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSDebrisInfo::Swap(CSDebrisInfo* other) {
  if (other != this) {
    std::swap(debriscfgid_, other->debriscfgid_);
    std::swap(debriscnt_, other->debriscnt_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSDebrisInfo::GetTypeName() const {
  return "vmsg.CSDebrisInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CSDebrisBagInfo::kDebrisInfosFieldNumber;
#endif  // !_MSC_VER

CSDebrisBagInfo::CSDebrisBagInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSDebrisBagInfo::InitAsDefaultInstance() {
}

CSDebrisBagInfo::CSDebrisBagInfo(const CSDebrisBagInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSDebrisBagInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSDebrisBagInfo::~CSDebrisBagInfo() {
  SharedDtor();
}

void CSDebrisBagInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSDebrisBagInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSDebrisBagInfo& CSDebrisBagInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSDebrisMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSDebrisMsg_2eproto();
#endif
  return *default_instance_;
}

CSDebrisBagInfo* CSDebrisBagInfo::default_instance_ = NULL;

CSDebrisBagInfo* CSDebrisBagInfo::New() const {
  return new CSDebrisBagInfo;
}

void CSDebrisBagInfo::Clear() {
  debrisinfos_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSDebrisBagInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .vmsg.CSDebrisInfo DebrisInfos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_DebrisInfos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_debrisinfos()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_DebrisInfos;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSDebrisBagInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .vmsg.CSDebrisInfo DebrisInfos = 1;
  for (int i = 0; i < this->debrisinfos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->debrisinfos(i), output);
  }

}

int CSDebrisBagInfo::ByteSize() const {
  int total_size = 0;

  // repeated .vmsg.CSDebrisInfo DebrisInfos = 1;
  total_size += 1 * this->debrisinfos_size();
  for (int i = 0; i < this->debrisinfos_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->debrisinfos(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSDebrisBagInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSDebrisBagInfo*>(&from));
}

void CSDebrisBagInfo::MergeFrom(const CSDebrisBagInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  debrisinfos_.MergeFrom(from.debrisinfos_);
}

void CSDebrisBagInfo::CopyFrom(const CSDebrisBagInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSDebrisBagInfo::IsInitialized() const {

  for (int i = 0; i < debrisinfos_size(); i++) {
    if (!this->debrisinfos(i).IsInitialized()) return false;
  }
  return true;
}

void CSDebrisBagInfo::Swap(CSDebrisBagInfo* other) {
  if (other != this) {
    debrisinfos_.Swap(&other->debrisinfos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSDebrisBagInfo::GetTypeName() const {
  return "vmsg.CSDebrisBagInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CSDebrisComposeRqst::kDebrisCfgIDFieldNumber;
#endif  // !_MSC_VER

CSDebrisComposeRqst::CSDebrisComposeRqst()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSDebrisComposeRqst::InitAsDefaultInstance() {
}

CSDebrisComposeRqst::CSDebrisComposeRqst(const CSDebrisComposeRqst& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSDebrisComposeRqst::SharedCtor() {
  _cached_size_ = 0;
  debriscfgid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSDebrisComposeRqst::~CSDebrisComposeRqst() {
  SharedDtor();
}

void CSDebrisComposeRqst::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSDebrisComposeRqst::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSDebrisComposeRqst& CSDebrisComposeRqst::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSDebrisMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSDebrisMsg_2eproto();
#endif
  return *default_instance_;
}

CSDebrisComposeRqst* CSDebrisComposeRqst::default_instance_ = NULL;

CSDebrisComposeRqst* CSDebrisComposeRqst::New() const {
  return new CSDebrisComposeRqst;
}

void CSDebrisComposeRqst::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    debriscfgid_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSDebrisComposeRqst::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 DebrisCfgID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &debriscfgid_)));
          set_has_debriscfgid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSDebrisComposeRqst::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 DebrisCfgID = 1;
  if (has_debriscfgid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->debriscfgid(), output);
  }

}

int CSDebrisComposeRqst::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 DebrisCfgID = 1;
    if (has_debriscfgid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->debriscfgid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSDebrisComposeRqst::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSDebrisComposeRqst*>(&from));
}

void CSDebrisComposeRqst::MergeFrom(const CSDebrisComposeRqst& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_debriscfgid()) {
      set_debriscfgid(from.debriscfgid());
    }
  }
}

void CSDebrisComposeRqst::CopyFrom(const CSDebrisComposeRqst& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSDebrisComposeRqst::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSDebrisComposeRqst::Swap(CSDebrisComposeRqst* other) {
  if (other != this) {
    std::swap(debriscfgid_, other->debriscfgid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSDebrisComposeRqst::GetTypeName() const {
  return "vmsg.CSDebrisComposeRqst";
}


// ===================================================================

#ifndef _MSC_VER
const int CSDebrisComposeRsp::kDebrisBagInfoFieldNumber;
#endif  // !_MSC_VER

CSDebrisComposeRsp::CSDebrisComposeRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSDebrisComposeRsp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  debrisbaginfo_ = const_cast< ::vmsg::CSDebrisBagInfo*>(
      ::vmsg::CSDebrisBagInfo::internal_default_instance());
#else
  debrisbaginfo_ = const_cast< ::vmsg::CSDebrisBagInfo*>(&::vmsg::CSDebrisBagInfo::default_instance());
#endif
}

CSDebrisComposeRsp::CSDebrisComposeRsp(const CSDebrisComposeRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSDebrisComposeRsp::SharedCtor() {
  _cached_size_ = 0;
  debrisbaginfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSDebrisComposeRsp::~CSDebrisComposeRsp() {
  SharedDtor();
}

void CSDebrisComposeRsp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete debrisbaginfo_;
  }
}

void CSDebrisComposeRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSDebrisComposeRsp& CSDebrisComposeRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSDebrisMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSDebrisMsg_2eproto();
#endif
  return *default_instance_;
}

CSDebrisComposeRsp* CSDebrisComposeRsp::default_instance_ = NULL;

CSDebrisComposeRsp* CSDebrisComposeRsp::New() const {
  return new CSDebrisComposeRsp;
}

void CSDebrisComposeRsp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_debrisbaginfo()) {
      if (debrisbaginfo_ != NULL) debrisbaginfo_->::vmsg::CSDebrisBagInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSDebrisComposeRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vmsg.CSDebrisBagInfo DebrisBagInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_debrisbaginfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSDebrisComposeRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .vmsg.CSDebrisBagInfo DebrisBagInfo = 1;
  if (has_debrisbaginfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->debrisbaginfo(), output);
  }

}

int CSDebrisComposeRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .vmsg.CSDebrisBagInfo DebrisBagInfo = 1;
    if (has_debrisbaginfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->debrisbaginfo());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSDebrisComposeRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSDebrisComposeRsp*>(&from));
}

void CSDebrisComposeRsp::MergeFrom(const CSDebrisComposeRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_debrisbaginfo()) {
      mutable_debrisbaginfo()->::vmsg::CSDebrisBagInfo::MergeFrom(from.debrisbaginfo());
    }
  }
}

void CSDebrisComposeRsp::CopyFrom(const CSDebrisComposeRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSDebrisComposeRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_debrisbaginfo()) {
    if (!this->debrisbaginfo().IsInitialized()) return false;
  }
  return true;
}

void CSDebrisComposeRsp::Swap(CSDebrisComposeRsp* other) {
  if (other != this) {
    std::swap(debrisbaginfo_, other->debrisbaginfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSDebrisComposeRsp::GetTypeName() const {
  return "vmsg.CSDebrisComposeRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSDebrisRequest::kDebrisComposeRqstFieldNumber;
#endif  // !_MSC_VER

CSDebrisRequest::CSDebrisRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSDebrisRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  debriscompose_rqst_ = const_cast< ::vmsg::CSDebrisComposeRqst*>(
      ::vmsg::CSDebrisComposeRqst::internal_default_instance());
#else
  debriscompose_rqst_ = const_cast< ::vmsg::CSDebrisComposeRqst*>(&::vmsg::CSDebrisComposeRqst::default_instance());
#endif
}

CSDebrisRequest::CSDebrisRequest(const CSDebrisRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSDebrisRequest::SharedCtor() {
  _cached_size_ = 0;
  debriscompose_rqst_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSDebrisRequest::~CSDebrisRequest() {
  SharedDtor();
}

void CSDebrisRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete debriscompose_rqst_;
  }
}

void CSDebrisRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSDebrisRequest& CSDebrisRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSDebrisMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSDebrisMsg_2eproto();
#endif
  return *default_instance_;
}

CSDebrisRequest* CSDebrisRequest::default_instance_ = NULL;

CSDebrisRequest* CSDebrisRequest::New() const {
  return new CSDebrisRequest;
}

void CSDebrisRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_debriscompose_rqst()) {
      if (debriscompose_rqst_ != NULL) debriscompose_rqst_->::vmsg::CSDebrisComposeRqst::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSDebrisRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .vmsg.CSDebrisComposeRqst DebrisCompose_Rqst = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_debriscompose_rqst()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSDebrisRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .vmsg.CSDebrisComposeRqst DebrisCompose_Rqst = 1;
  if (has_debriscompose_rqst()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->debriscompose_rqst(), output);
  }

}

int CSDebrisRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .vmsg.CSDebrisComposeRqst DebrisCompose_Rqst = 1;
    if (has_debriscompose_rqst()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->debriscompose_rqst());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSDebrisRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSDebrisRequest*>(&from));
}

void CSDebrisRequest::MergeFrom(const CSDebrisRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_debriscompose_rqst()) {
      mutable_debriscompose_rqst()->::vmsg::CSDebrisComposeRqst::MergeFrom(from.debriscompose_rqst());
    }
  }
}

void CSDebrisRequest::CopyFrom(const CSDebrisRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSDebrisRequest::IsInitialized() const {

  if (has_debriscompose_rqst()) {
    if (!this->debriscompose_rqst().IsInitialized()) return false;
  }
  return true;
}

void CSDebrisRequest::Swap(CSDebrisRequest* other) {
  if (other != this) {
    std::swap(debriscompose_rqst_, other->debriscompose_rqst_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSDebrisRequest::GetTypeName() const {
  return "vmsg.CSDebrisRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int CSDebrisRespond::kDebrisComposeRspFieldNumber;
const int CSDebrisRespond::kDebrisBagQueryRspFieldNumber;
#endif  // !_MSC_VER

CSDebrisRespond::CSDebrisRespond()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSDebrisRespond::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  debriscompose_rsp_ = const_cast< ::vmsg::CSDebrisComposeRsp*>(
      ::vmsg::CSDebrisComposeRsp::internal_default_instance());
#else
  debriscompose_rsp_ = const_cast< ::vmsg::CSDebrisComposeRsp*>(&::vmsg::CSDebrisComposeRsp::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  debrisbagquery_rsp_ = const_cast< ::vmsg::CSDebrisBagInfo*>(
      ::vmsg::CSDebrisBagInfo::internal_default_instance());
#else
  debrisbagquery_rsp_ = const_cast< ::vmsg::CSDebrisBagInfo*>(&::vmsg::CSDebrisBagInfo::default_instance());
#endif
}

CSDebrisRespond::CSDebrisRespond(const CSDebrisRespond& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSDebrisRespond::SharedCtor() {
  _cached_size_ = 0;
  debriscompose_rsp_ = NULL;
  debrisbagquery_rsp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSDebrisRespond::~CSDebrisRespond() {
  SharedDtor();
}

void CSDebrisRespond::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete debriscompose_rsp_;
    delete debrisbagquery_rsp_;
  }
}

void CSDebrisRespond::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSDebrisRespond& CSDebrisRespond::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSDebrisMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSDebrisMsg_2eproto();
#endif
  return *default_instance_;
}

CSDebrisRespond* CSDebrisRespond::default_instance_ = NULL;

CSDebrisRespond* CSDebrisRespond::New() const {
  return new CSDebrisRespond;
}

void CSDebrisRespond::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_debriscompose_rsp()) {
      if (debriscompose_rsp_ != NULL) debriscompose_rsp_->::vmsg::CSDebrisComposeRsp::Clear();
    }
    if (has_debrisbagquery_rsp()) {
      if (debrisbagquery_rsp_ != NULL) debrisbagquery_rsp_->::vmsg::CSDebrisBagInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSDebrisRespond::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .vmsg.CSDebrisComposeRsp DebrisCompose_Rsp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_debriscompose_rsp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_DebrisBagQuery_Rsp;
        break;
      }

      // optional .vmsg.CSDebrisBagInfo DebrisBagQuery_Rsp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_DebrisBagQuery_Rsp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_debrisbagquery_rsp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSDebrisRespond::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .vmsg.CSDebrisComposeRsp DebrisCompose_Rsp = 1;
  if (has_debriscompose_rsp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->debriscompose_rsp(), output);
  }

  // optional .vmsg.CSDebrisBagInfo DebrisBagQuery_Rsp = 2;
  if (has_debrisbagquery_rsp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->debrisbagquery_rsp(), output);
  }

}

int CSDebrisRespond::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .vmsg.CSDebrisComposeRsp DebrisCompose_Rsp = 1;
    if (has_debriscompose_rsp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->debriscompose_rsp());
    }

    // optional .vmsg.CSDebrisBagInfo DebrisBagQuery_Rsp = 2;
    if (has_debrisbagquery_rsp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->debrisbagquery_rsp());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSDebrisRespond::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSDebrisRespond*>(&from));
}

void CSDebrisRespond::MergeFrom(const CSDebrisRespond& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_debriscompose_rsp()) {
      mutable_debriscompose_rsp()->::vmsg::CSDebrisComposeRsp::MergeFrom(from.debriscompose_rsp());
    }
    if (from.has_debrisbagquery_rsp()) {
      mutable_debrisbagquery_rsp()->::vmsg::CSDebrisBagInfo::MergeFrom(from.debrisbagquery_rsp());
    }
  }
}

void CSDebrisRespond::CopyFrom(const CSDebrisRespond& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSDebrisRespond::IsInitialized() const {

  if (has_debriscompose_rsp()) {
    if (!this->debriscompose_rsp().IsInitialized()) return false;
  }
  if (has_debrisbagquery_rsp()) {
    if (!this->debrisbagquery_rsp().IsInitialized()) return false;
  }
  return true;
}

void CSDebrisRespond::Swap(CSDebrisRespond* other) {
  if (other != this) {
    std::swap(debriscompose_rsp_, other->debriscompose_rsp_);
    std::swap(debrisbagquery_rsp_, other->debrisbagquery_rsp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSDebrisRespond::GetTypeName() const {
  return "vmsg.CSDebrisRespond";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)
