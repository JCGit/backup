// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSPlayerMsg.proto

#ifndef PROTOBUF_CSPlayerMsg_2eproto__INCLUDED
#define PROTOBUF_CSPlayerMsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "MsgBase.pb.h"
#include "CSEquipItemMsg.pb.h"
// @@protoc_insertion_point(includes)

namespace vmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CSPlayerMsg_2eproto();
void protobuf_AssignDesc_CSPlayerMsg_2eproto();
void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

class CSPlayerAttr;
class CSPlayerDetailInfo;
class CSNothinglandInfo;
class CSDailyRegInfo;
class CSMonthCardInfo;
class CSPlayerInfo;
class CSQueryPlayerInfoRsp;
class CSSetSettingParamRqst;
class CSRegPlayerInfoRqst;
class CSRegPlayerInfoRsp;
class CSChangeArmorRsp;
class CSPlayerRoleInfo;
class CSQueryRoleLstRsp;
class CSRoleLoginRqst;
class CSRoleLoginRsp;
class CSRoleLogoutRqst;
class CSRoleLogoutRsp;
class CSPlayerManualNotify;
class CSBuyManualInfo;
class CSQueryPlayerManualRsp;
class CSPlayerEvolutionInfo;
class CSEvolutionSkill;
class CSPlayerEvolutionSkillInfo;
class CSChangePlayerEvolutionSkillRqst;
class CSChangePlayerEvolutionSkillRsp;
class CSAttrStrengthenRqst;
class CSAttrStrengthenInfo;
class CSWeaponLotQueryRsp;
class CSWeaponLotRqst;
class CSWeaponLotRsp;
class CSAwardRankInfo;
class CSAwardRankRsp;
class CSFetchRankAwardRqst;
class CSPlayerLvUpRsp;
class CSVIPNotify;
class CSVIPInfos;
class CSFightPowerNotify;
class CSOtherPlayerInfoRsp;
class CSBlackProductInfo;
class CSBlackMarketInfo;
class CSQuickLoginRqst;
class CSQuickLoginRsp;
class CSBuyCoinInfo;
class CSBuyCoinRsp;
class CSGuestRegisterRsp;
class CSGuestBindRqst;
class CSPlayerEnforceMyselfRqst;
class CSPlayerEnforceMyselfRsp;
class CSPlayerEnforceMyselfConfirmRqst;
class CSPlayerEnforceMyselfConfirmRsp;
class CSPlayerEnforceMyselfQueryRsp;
class CSPlayerRequest;
class CSPlayerRespond;

enum CS_LOTTERY_TYPE {
  CS_LOTTERY_TYPE_NORMAL = 1,
  CS_LOTTERY_TYPE_ADVANCE = 2,
  CS_LOTTERY_TYPE_BAT_NORMAL = 3,
  CS_LOTTERY_TYPE_BAT_ADVANCE = 4,
  CS_LOTTERY_TYPE_VIP = 5
};
bool CS_LOTTERY_TYPE_IsValid(int value);
const CS_LOTTERY_TYPE CS_LOTTERY_TYPE_MIN = CS_LOTTERY_TYPE_NORMAL;
const CS_LOTTERY_TYPE CS_LOTTERY_TYPE_MAX = CS_LOTTERY_TYPE_VIP;
const int CS_LOTTERY_TYPE_ARRAYSIZE = CS_LOTTERY_TYPE_MAX + 1;

// ===================================================================

class CSPlayerAttr : public ::google::protobuf::MessageLite {
 public:
  CSPlayerAttr();
  virtual ~CSPlayerAttr();

  CSPlayerAttr(const CSPlayerAttr& from);

  inline CSPlayerAttr& operator=(const CSPlayerAttr& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerAttr& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerAttr* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerAttr* other);

  // implements Message ----------------------------------------------

  CSPlayerAttr* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerAttr& from);
  void MergeFrom(const CSPlayerAttr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 AttrType = 1;
  inline bool has_attrtype() const;
  inline void clear_attrtype();
  static const int kAttrTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 attrtype() const;
  inline void set_attrtype(::google::protobuf::uint32 value);

  // required uint32 AttrVal = 2;
  inline bool has_attrval() const;
  inline void clear_attrval();
  static const int kAttrValFieldNumber = 2;
  inline ::google::protobuf::uint32 attrval() const;
  inline void set_attrval(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerAttr)
 private:
  inline void set_has_attrtype();
  inline void clear_has_attrtype();
  inline void set_has_attrval();
  inline void clear_has_attrval();

  ::google::protobuf::uint32 attrtype_;
  ::google::protobuf::uint32 attrval_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerAttr* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerDetailInfo : public ::google::protobuf::MessageLite {
 public:
  CSPlayerDetailInfo();
  virtual ~CSPlayerDetailInfo();

  CSPlayerDetailInfo(const CSPlayerDetailInfo& from);

  inline CSPlayerDetailInfo& operator=(const CSPlayerDetailInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerDetailInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerDetailInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerDetailInfo* other);

  // implements Message ----------------------------------------------

  CSPlayerDetailInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerDetailInfo& from);
  void MergeFrom(const CSPlayerDetailInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 HP = 1;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHPFieldNumber = 1;
  inline ::google::protobuf::uint32 hp() const;
  inline void set_hp(::google::protobuf::uint32 value);

  // required uint32 MP = 2;
  inline bool has_mp() const;
  inline void clear_mp();
  static const int kMPFieldNumber = 2;
  inline ::google::protobuf::uint32 mp() const;
  inline void set_mp(::google::protobuf::uint32 value);

  // required uint32 DEF = 3;
  inline bool has_def() const;
  inline void clear_def();
  static const int kDEFFieldNumber = 3;
  inline ::google::protobuf::uint32 def() const;
  inline void set_def(::google::protobuf::uint32 value);

  // required uint32 ATK = 4;
  inline bool has_atk() const;
  inline void clear_atk();
  static const int kATKFieldNumber = 4;
  inline ::google::protobuf::uint32 atk() const;
  inline void set_atk(::google::protobuf::uint32 value);

  // required uint32 DEFType = 5;
  inline bool has_deftype() const;
  inline void clear_deftype();
  static const int kDEFTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 deftype() const;
  inline void set_deftype(::google::protobuf::uint32 value);

  // required uint32 ATKType = 6;
  inline bool has_atktype() const;
  inline void clear_atktype();
  static const int kATKTypeFieldNumber = 6;
  inline ::google::protobuf::uint32 atktype() const;
  inline void set_atktype(::google::protobuf::uint32 value);

  // repeated .vmsg.CSPlayerAttr ATKAttrs = 7;
  inline int atkattrs_size() const;
  inline void clear_atkattrs();
  static const int kATKAttrsFieldNumber = 7;
  inline const ::vmsg::CSPlayerAttr& atkattrs(int index) const;
  inline ::vmsg::CSPlayerAttr* mutable_atkattrs(int index);
  inline ::vmsg::CSPlayerAttr* add_atkattrs();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerAttr >&
      atkattrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerAttr >*
      mutable_atkattrs();

  // repeated .vmsg.CSPlayerAttr DEFAttrs = 8;
  inline int defattrs_size() const;
  inline void clear_defattrs();
  static const int kDEFAttrsFieldNumber = 8;
  inline const ::vmsg::CSPlayerAttr& defattrs(int index) const;
  inline ::vmsg::CSPlayerAttr* mutable_defattrs(int index);
  inline ::vmsg::CSPlayerAttr* add_defattrs();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerAttr >&
      defattrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerAttr >*
      mutable_defattrs();

  // required uint32 MoveSpeed = 9;
  inline bool has_movespeed() const;
  inline void clear_movespeed();
  static const int kMoveSpeedFieldNumber = 9;
  inline ::google::protobuf::uint32 movespeed() const;
  inline void set_movespeed(::google::protobuf::uint32 value);

  // required uint32 RunSpeed = 10;
  inline bool has_runspeed() const;
  inline void clear_runspeed();
  static const int kRunSpeedFieldNumber = 10;
  inline ::google::protobuf::uint32 runspeed() const;
  inline void set_runspeed(::google::protobuf::uint32 value);

  // required uint32 BackSpeed = 11;
  inline bool has_backspeed() const;
  inline void clear_backspeed();
  static const int kBackSpeedFieldNumber = 11;
  inline ::google::protobuf::uint32 backspeed() const;
  inline void set_backspeed(::google::protobuf::uint32 value);

  // required uint64 FightPower = 12;
  inline bool has_fightpower() const;
  inline void clear_fightpower();
  static const int kFightPowerFieldNumber = 12;
  inline ::google::protobuf::uint64 fightpower() const;
  inline void set_fightpower(::google::protobuf::uint64 value);

  // repeated .vmsg.CSEquipInfo EquipLst = 13;
  inline int equiplst_size() const;
  inline void clear_equiplst();
  static const int kEquipLstFieldNumber = 13;
  inline const ::vmsg::CSEquipInfo& equiplst(int index) const;
  inline ::vmsg::CSEquipInfo* mutable_equiplst(int index);
  inline ::vmsg::CSEquipInfo* add_equiplst();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSEquipInfo >&
      equiplst() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSEquipInfo >*
      mutable_equiplst();

  // required .vmsg.CSEquipInfo SpareEquip = 14;
  inline bool has_spareequip() const;
  inline void clear_spareequip();
  static const int kSpareEquipFieldNumber = 14;
  inline const ::vmsg::CSEquipInfo& spareequip() const;
  inline ::vmsg::CSEquipInfo* mutable_spareequip();
  inline ::vmsg::CSEquipInfo* release_spareequip();
  inline void set_allocated_spareequip(::vmsg::CSEquipInfo* spareequip);

  // required .vmsg.CSWeapon Weapon = 15;
  inline bool has_weapon() const;
  inline void clear_weapon();
  static const int kWeaponFieldNumber = 15;
  inline const ::vmsg::CSWeapon& weapon() const;
  inline ::vmsg::CSWeapon* mutable_weapon();
  inline ::vmsg::CSWeapon* release_weapon();
  inline void set_allocated_weapon(::vmsg::CSWeapon* weapon);

  // required uint32 ShowID = 16;
  inline bool has_showid() const;
  inline void clear_showid();
  static const int kShowIDFieldNumber = 16;
  inline ::google::protobuf::uint32 showid() const;
  inline void set_showid(::google::protobuf::uint32 value);

  // required uint32 DodgeDist = 17;
  inline bool has_dodgedist() const;
  inline void clear_dodgedist();
  static const int kDodgeDistFieldNumber = 17;
  inline ::google::protobuf::uint32 dodgedist() const;
  inline void set_dodgedist(::google::protobuf::uint32 value);

  // required uint32 DodgeCD = 18;
  inline bool has_dodgecd() const;
  inline void clear_dodgecd();
  static const int kDodgeCDFieldNumber = 18;
  inline ::google::protobuf::uint32 dodgecd() const;
  inline void set_dodgecd(::google::protobuf::uint32 value);

  // required uint32 AtkSpeed = 19;
  inline bool has_atkspeed() const;
  inline void clear_atkspeed();
  static const int kAtkSpeedFieldNumber = 19;
  inline ::google::protobuf::uint32 atkspeed() const;
  inline void set_atkspeed(::google::protobuf::uint32 value);

  // required uint32 EvolutionSkillID = 20;
  inline bool has_evolutionskillid() const;
  inline void clear_evolutionskillid();
  static const int kEvolutionSkillIDFieldNumber = 20;
  inline ::google::protobuf::uint32 evolutionskillid() const;
  inline void set_evolutionskillid(::google::protobuf::uint32 value);

  // required uint32 Level = 21;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 21;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint32 Hit = 22;
  inline bool has_hit() const;
  inline void clear_hit();
  static const int kHitFieldNumber = 22;
  inline ::google::protobuf::uint32 hit() const;
  inline void set_hit(::google::protobuf::uint32 value);

  // required uint32 HitWithoutInitVal = 23;
  inline bool has_hitwithoutinitval() const;
  inline void clear_hitwithoutinitval();
  static const int kHitWithoutInitValFieldNumber = 23;
  inline ::google::protobuf::uint32 hitwithoutinitval() const;
  inline void set_hitwithoutinitval(::google::protobuf::uint32 value);

  // repeated .vmsg.CSInbattleWeaponElmt InBattleWeapons = 24;
  inline int inbattleweapons_size() const;
  inline void clear_inbattleweapons();
  static const int kInBattleWeaponsFieldNumber = 24;
  inline const ::vmsg::CSInbattleWeaponElmt& inbattleweapons(int index) const;
  inline ::vmsg::CSInbattleWeaponElmt* mutable_inbattleweapons(int index);
  inline ::vmsg::CSInbattleWeaponElmt* add_inbattleweapons();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSInbattleWeaponElmt >&
      inbattleweapons() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSInbattleWeaponElmt >*
      mutable_inbattleweapons();

  // required uint32 HPAddEff = 25;
  inline bool has_hpaddeff() const;
  inline void clear_hpaddeff();
  static const int kHPAddEffFieldNumber = 25;
  inline ::google::protobuf::uint32 hpaddeff() const;
  inline void set_hpaddeff(::google::protobuf::uint32 value);

  // required uint32 AtkAddEff = 26;
  inline bool has_atkaddeff() const;
  inline void clear_atkaddeff();
  static const int kAtkAddEffFieldNumber = 26;
  inline ::google::protobuf::uint32 atkaddeff() const;
  inline void set_atkaddeff(::google::protobuf::uint32 value);

  // required uint32 DefAddEff = 27;
  inline bool has_defaddeff() const;
  inline void clear_defaddeff();
  static const int kDefAddEffFieldNumber = 27;
  inline ::google::protobuf::uint32 defaddeff() const;
  inline void set_defaddeff(::google::protobuf::uint32 value);

  // required uint32 TotalHpEnforceAdd = 28;
  inline bool has_totalhpenforceadd() const;
  inline void clear_totalhpenforceadd();
  static const int kTotalHpEnforceAddFieldNumber = 28;
  inline ::google::protobuf::uint32 totalhpenforceadd() const;
  inline void set_totalhpenforceadd(::google::protobuf::uint32 value);

  // required uint32 TotalAtkEnforceAdd = 29;
  inline bool has_totalatkenforceadd() const;
  inline void clear_totalatkenforceadd();
  static const int kTotalAtkEnforceAddFieldNumber = 29;
  inline ::google::protobuf::uint32 totalatkenforceadd() const;
  inline void set_totalatkenforceadd(::google::protobuf::uint32 value);

  // required uint32 TotalDefEnforceAdd = 30;
  inline bool has_totaldefenforceadd() const;
  inline void clear_totaldefenforceadd();
  static const int kTotalDefEnforceAddFieldNumber = 30;
  inline ::google::protobuf::uint32 totaldefenforceadd() const;
  inline void set_totaldefenforceadd(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerDetailInfo)
 private:
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_mp();
  inline void clear_has_mp();
  inline void set_has_def();
  inline void clear_has_def();
  inline void set_has_atk();
  inline void clear_has_atk();
  inline void set_has_deftype();
  inline void clear_has_deftype();
  inline void set_has_atktype();
  inline void clear_has_atktype();
  inline void set_has_movespeed();
  inline void clear_has_movespeed();
  inline void set_has_runspeed();
  inline void clear_has_runspeed();
  inline void set_has_backspeed();
  inline void clear_has_backspeed();
  inline void set_has_fightpower();
  inline void clear_has_fightpower();
  inline void set_has_spareequip();
  inline void clear_has_spareequip();
  inline void set_has_weapon();
  inline void clear_has_weapon();
  inline void set_has_showid();
  inline void clear_has_showid();
  inline void set_has_dodgedist();
  inline void clear_has_dodgedist();
  inline void set_has_dodgecd();
  inline void clear_has_dodgecd();
  inline void set_has_atkspeed();
  inline void clear_has_atkspeed();
  inline void set_has_evolutionskillid();
  inline void clear_has_evolutionskillid();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_hit();
  inline void clear_has_hit();
  inline void set_has_hitwithoutinitval();
  inline void clear_has_hitwithoutinitval();
  inline void set_has_hpaddeff();
  inline void clear_has_hpaddeff();
  inline void set_has_atkaddeff();
  inline void clear_has_atkaddeff();
  inline void set_has_defaddeff();
  inline void clear_has_defaddeff();
  inline void set_has_totalhpenforceadd();
  inline void clear_has_totalhpenforceadd();
  inline void set_has_totalatkenforceadd();
  inline void clear_has_totalatkenforceadd();
  inline void set_has_totaldefenforceadd();
  inline void clear_has_totaldefenforceadd();

  ::google::protobuf::uint32 hp_;
  ::google::protobuf::uint32 mp_;
  ::google::protobuf::uint32 def_;
  ::google::protobuf::uint32 atk_;
  ::google::protobuf::uint32 deftype_;
  ::google::protobuf::uint32 atktype_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerAttr > atkattrs_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerAttr > defattrs_;
  ::google::protobuf::uint32 movespeed_;
  ::google::protobuf::uint32 runspeed_;
  ::google::protobuf::uint64 fightpower_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSEquipInfo > equiplst_;
  ::google::protobuf::uint32 backspeed_;
  ::google::protobuf::uint32 showid_;
  ::vmsg::CSEquipInfo* spareequip_;
  ::vmsg::CSWeapon* weapon_;
  ::google::protobuf::uint32 dodgedist_;
  ::google::protobuf::uint32 dodgecd_;
  ::google::protobuf::uint32 atkspeed_;
  ::google::protobuf::uint32 evolutionskillid_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 hit_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSInbattleWeaponElmt > inbattleweapons_;
  ::google::protobuf::uint32 hitwithoutinitval_;
  ::google::protobuf::uint32 hpaddeff_;
  ::google::protobuf::uint32 atkaddeff_;
  ::google::protobuf::uint32 defaddeff_;
  ::google::protobuf::uint32 totalhpenforceadd_;
  ::google::protobuf::uint32 totalatkenforceadd_;
  ::google::protobuf::uint32 totaldefenforceadd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(30 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerDetailInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSNothinglandInfo : public ::google::protobuf::MessageLite {
 public:
  CSNothinglandInfo();
  virtual ~CSNothinglandInfo();

  CSNothinglandInfo(const CSNothinglandInfo& from);

  inline CSNothinglandInfo& operator=(const CSNothinglandInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSNothinglandInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSNothinglandInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSNothinglandInfo* other);

  // implements Message ----------------------------------------------

  CSNothinglandInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSNothinglandInfo& from);
  void MergeFrom(const CSNothinglandInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Score = 2;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 2;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // required uint32 Floor = 3;
  inline bool has_floor() const;
  inline void clear_floor();
  static const int kFloorFieldNumber = 3;
  inline ::google::protobuf::uint32 floor() const;
  inline void set_floor(::google::protobuf::uint32 value);

  // required uint32 MaxFloorScore = 4;
  inline bool has_maxfloorscore() const;
  inline void clear_maxfloorscore();
  static const int kMaxFloorScoreFieldNumber = 4;
  inline ::google::protobuf::uint32 maxfloorscore() const;
  inline void set_maxfloorscore(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSNothinglandInfo)
 private:
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_floor();
  inline void clear_has_floor();
  inline void set_has_maxfloorscore();
  inline void clear_has_maxfloorscore();

  ::google::protobuf::uint32 score_;
  ::google::protobuf::uint32 floor_;
  ::google::protobuf::uint32 maxfloorscore_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSNothinglandInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSDailyRegInfo : public ::google::protobuf::MessageLite {
 public:
  CSDailyRegInfo();
  virtual ~CSDailyRegInfo();

  CSDailyRegInfo(const CSDailyRegInfo& from);

  inline CSDailyRegInfo& operator=(const CSDailyRegInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSDailyRegInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSDailyRegInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSDailyRegInfo* other);

  // implements Message ----------------------------------------------

  CSDailyRegInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSDailyRegInfo& from);
  void MergeFrom(const CSDailyRegInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 RegCnt = 1;
  inline bool has_regcnt() const;
  inline void clear_regcnt();
  static const int kRegCntFieldNumber = 1;
  inline ::google::protobuf::uint32 regcnt() const;
  inline void set_regcnt(::google::protobuf::uint32 value);

  // required uint32 CanReg = 2;
  inline bool has_canreg() const;
  inline void clear_canreg();
  static const int kCanRegFieldNumber = 2;
  inline ::google::protobuf::uint32 canreg() const;
  inline void set_canreg(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSDailyRegInfo)
 private:
  inline void set_has_regcnt();
  inline void clear_has_regcnt();
  inline void set_has_canreg();
  inline void clear_has_canreg();

  ::google::protobuf::uint32 regcnt_;
  ::google::protobuf::uint32 canreg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSDailyRegInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSMonthCardInfo : public ::google::protobuf::MessageLite {
 public:
  CSMonthCardInfo();
  virtual ~CSMonthCardInfo();

  CSMonthCardInfo(const CSMonthCardInfo& from);

  inline CSMonthCardInfo& operator=(const CSMonthCardInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSMonthCardInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSMonthCardInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSMonthCardInfo* other);

  // implements Message ----------------------------------------------

  CSMonthCardInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSMonthCardInfo& from);
  void MergeFrom(const CSMonthCardInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Gold = 1;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 1;
  inline ::google::protobuf::uint32 gold() const;
  inline void set_gold(::google::protobuf::uint32 value);

  // required int32 EndTime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 2;
  inline ::google::protobuf::int32 endtime() const;
  inline void set_endtime(::google::protobuf::int32 value);

  // required uint32 TotalDays = 3;
  inline bool has_totaldays() const;
  inline void clear_totaldays();
  static const int kTotalDaysFieldNumber = 3;
  inline ::google::protobuf::uint32 totaldays() const;
  inline void set_totaldays(::google::protobuf::uint32 value);

  // required int32 LastAwardTime = 4;
  inline bool has_lastawardtime() const;
  inline void clear_lastawardtime();
  static const int kLastAwardTimeFieldNumber = 4;
  inline ::google::protobuf::int32 lastawardtime() const;
  inline void set_lastawardtime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSMonthCardInfo)
 private:
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_totaldays();
  inline void clear_has_totaldays();
  inline void set_has_lastawardtime();
  inline void clear_has_lastawardtime();

  ::google::protobuf::uint32 gold_;
  ::google::protobuf::int32 endtime_;
  ::google::protobuf::uint32 totaldays_;
  ::google::protobuf::int32 lastawardtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSMonthCardInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerInfo : public ::google::protobuf::MessageLite {
 public:
  CSPlayerInfo();
  virtual ~CSPlayerInfo();

  CSPlayerInfo(const CSPlayerInfo& from);

  inline CSPlayerInfo& operator=(const CSPlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerInfo* other);

  // implements Message ----------------------------------------------

  CSPlayerInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerInfo& from);
  void MergeFrom(const CSPlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // required string Nick = 3;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 3;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // required uint32 Level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint64 Exp = 5;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 5;
  inline ::google::protobuf::uint64 exp() const;
  inline void set_exp(::google::protobuf::uint64 value);

  // required uint32 WeaponCfgID = 6;
  inline bool has_weaponcfgid() const;
  inline void clear_weaponcfgid();
  static const int kWeaponCfgIDFieldNumber = 6;
  inline ::google::protobuf::uint32 weaponcfgid() const;
  inline void set_weaponcfgid(::google::protobuf::uint32 value);

  // required uint64 Coin = 7;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 7;
  inline ::google::protobuf::uint64 coin() const;
  inline void set_coin(::google::protobuf::uint64 value);

  // required uint32 RemainManual = 8;
  inline bool has_remainmanual() const;
  inline void clear_remainmanual();
  static const int kRemainManualFieldNumber = 8;
  inline ::google::protobuf::uint32 remainmanual() const;
  inline void set_remainmanual(::google::protobuf::uint32 value);

  // required int32 UpdateRemainTime = 9;
  inline bool has_updateremaintime() const;
  inline void clear_updateremaintime();
  static const int kUpdateRemainTimeFieldNumber = 9;
  inline ::google::protobuf::int32 updateremaintime() const;
  inline void set_updateremaintime(::google::protobuf::int32 value);

  // required uint32 ShowID = 10;
  inline bool has_showid() const;
  inline void clear_showid();
  static const int kShowIDFieldNumber = 10;
  inline ::google::protobuf::uint32 showid() const;
  inline void set_showid(::google::protobuf::uint32 value);

  // required uint32 SceneID = 11;
  inline bool has_sceneid() const;
  inline void clear_sceneid();
  static const int kSceneIDFieldNumber = 11;
  inline ::google::protobuf::uint32 sceneid() const;
  inline void set_sceneid(::google::protobuf::uint32 value);

  // required uint32 NewestWarMapID = 12;
  inline bool has_newestwarmapid() const;
  inline void clear_newestwarmapid();
  static const int kNewestWarMapIDFieldNumber = 12;
  inline ::google::protobuf::uint32 newestwarmapid() const;
  inline void set_newestwarmapid(::google::protobuf::uint32 value);

  // required uint32 VIPLv = 13;
  inline bool has_viplv() const;
  inline void clear_viplv();
  static const int kVIPLvFieldNumber = 13;
  inline ::google::protobuf::uint32 viplv() const;
  inline void set_viplv(::google::protobuf::uint32 value);

  // required uint64 FightPower = 14;
  inline bool has_fightpower() const;
  inline void clear_fightpower();
  static const int kFightPowerFieldNumber = 14;
  inline ::google::protobuf::uint64 fightpower() const;
  inline void set_fightpower(::google::protobuf::uint64 value);

  // required uint64 GuildID = 15;
  inline bool has_guildid() const;
  inline void clear_guildid();
  static const int kGuildIDFieldNumber = 15;
  inline ::google::protobuf::uint64 guildid() const;
  inline void set_guildid(::google::protobuf::uint64 value);

  // required string SettingParam = 16;
  inline bool has_settingparam() const;
  inline void clear_settingparam();
  static const int kSettingParamFieldNumber = 16;
  inline const ::std::string& settingparam() const;
  inline void set_settingparam(const ::std::string& value);
  inline void set_settingparam(const char* value);
  inline void set_settingparam(const char* value, size_t size);
  inline ::std::string* mutable_settingparam();
  inline ::std::string* release_settingparam();
  inline void set_allocated_settingparam(::std::string* settingparam);

  // required .vmsg.CSNothinglandInfo NothinglandInfo = 17;
  inline bool has_nothinglandinfo() const;
  inline void clear_nothinglandinfo();
  static const int kNothinglandInfoFieldNumber = 17;
  inline const ::vmsg::CSNothinglandInfo& nothinglandinfo() const;
  inline ::vmsg::CSNothinglandInfo* mutable_nothinglandinfo();
  inline ::vmsg::CSNothinglandInfo* release_nothinglandinfo();
  inline void set_allocated_nothinglandinfo(::vmsg::CSNothinglandInfo* nothinglandinfo);

  // required uint64 QuickLoginKey = 18;
  inline bool has_quickloginkey() const;
  inline void clear_quickloginkey();
  static const int kQuickLoginKeyFieldNumber = 18;
  inline ::google::protobuf::uint64 quickloginkey() const;
  inline void set_quickloginkey(::google::protobuf::uint64 value);

  // required .vmsg.CSDailyRegInfo DailyRegInfo = 19;
  inline bool has_dailyreginfo() const;
  inline void clear_dailyreginfo();
  static const int kDailyRegInfoFieldNumber = 19;
  inline const ::vmsg::CSDailyRegInfo& dailyreginfo() const;
  inline ::vmsg::CSDailyRegInfo* mutable_dailyreginfo();
  inline ::vmsg::CSDailyRegInfo* release_dailyreginfo();
  inline void set_allocated_dailyreginfo(::vmsg::CSDailyRegInfo* dailyreginfo);

  // required .vmsg.CSMonthCardInfo MonthCardInfo = 20;
  inline bool has_monthcardinfo() const;
  inline void clear_monthcardinfo();
  static const int kMonthCardInfoFieldNumber = 20;
  inline const ::vmsg::CSMonthCardInfo& monthcardinfo() const;
  inline ::vmsg::CSMonthCardInfo* mutable_monthcardinfo();
  inline ::vmsg::CSMonthCardInfo* release_monthcardinfo();
  inline void set_allocated_monthcardinfo(::vmsg::CSMonthCardInfo* monthcardinfo);

  // required uint32 VIPDailyClaimed = 21;
  inline bool has_vipdailyclaimed() const;
  inline void clear_vipdailyclaimed();
  static const int kVIPDailyClaimedFieldNumber = 21;
  inline ::google::protobuf::uint32 vipdailyclaimed() const;
  inline void set_vipdailyclaimed(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerInfo)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_weaponcfgid();
  inline void clear_has_weaponcfgid();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_remainmanual();
  inline void clear_has_remainmanual();
  inline void set_has_updateremaintime();
  inline void clear_has_updateremaintime();
  inline void set_has_showid();
  inline void clear_has_showid();
  inline void set_has_sceneid();
  inline void clear_has_sceneid();
  inline void set_has_newestwarmapid();
  inline void clear_has_newestwarmapid();
  inline void set_has_viplv();
  inline void clear_has_viplv();
  inline void set_has_fightpower();
  inline void clear_has_fightpower();
  inline void set_has_guildid();
  inline void clear_has_guildid();
  inline void set_has_settingparam();
  inline void clear_has_settingparam();
  inline void set_has_nothinglandinfo();
  inline void clear_has_nothinglandinfo();
  inline void set_has_quickloginkey();
  inline void clear_has_quickloginkey();
  inline void set_has_dailyreginfo();
  inline void clear_has_dailyreginfo();
  inline void set_has_monthcardinfo();
  inline void clear_has_monthcardinfo();
  inline void set_has_vipdailyclaimed();
  inline void clear_has_vipdailyclaimed();

  ::google::protobuf::uint64 uin_;
  ::std::string* nick_;
  ::google::protobuf::uint64 exp_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 weaponcfgid_;
  ::google::protobuf::uint64 coin_;
  ::google::protobuf::uint32 remainmanual_;
  ::google::protobuf::int32 updateremaintime_;
  ::google::protobuf::uint32 showid_;
  ::google::protobuf::uint32 sceneid_;
  ::google::protobuf::uint32 newestwarmapid_;
  ::google::protobuf::uint32 viplv_;
  ::google::protobuf::uint64 fightpower_;
  ::google::protobuf::uint64 guildid_;
  ::std::string* settingparam_;
  ::vmsg::CSNothinglandInfo* nothinglandinfo_;
  ::google::protobuf::uint64 quickloginkey_;
  ::vmsg::CSDailyRegInfo* dailyreginfo_;
  ::vmsg::CSMonthCardInfo* monthcardinfo_;
  ::google::protobuf::uint32 vipdailyclaimed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSQueryPlayerInfoRsp : public ::google::protobuf::MessageLite {
 public:
  CSQueryPlayerInfoRsp();
  virtual ~CSQueryPlayerInfoRsp();

  CSQueryPlayerInfoRsp(const CSQueryPlayerInfoRsp& from);

  inline CSQueryPlayerInfoRsp& operator=(const CSQueryPlayerInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSQueryPlayerInfoRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQueryPlayerInfoRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQueryPlayerInfoRsp* other);

  // implements Message ----------------------------------------------

  CSQueryPlayerInfoRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQueryPlayerInfoRsp& from);
  void MergeFrom(const CSQueryPlayerInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSPlayerInfo PlayerInfo = 1;
  inline bool has_playerinfo() const;
  inline void clear_playerinfo();
  static const int kPlayerInfoFieldNumber = 1;
  inline const ::vmsg::CSPlayerInfo& playerinfo() const;
  inline ::vmsg::CSPlayerInfo* mutable_playerinfo();
  inline ::vmsg::CSPlayerInfo* release_playerinfo();
  inline void set_allocated_playerinfo(::vmsg::CSPlayerInfo* playerinfo);

  // optional uint32 ServerOpenTime = 2;
  inline bool has_serveropentime() const;
  inline void clear_serveropentime();
  static const int kServerOpenTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 serveropentime() const;
  inline void set_serveropentime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSQueryPlayerInfoRsp)
 private:
  inline void set_has_playerinfo();
  inline void clear_has_playerinfo();
  inline void set_has_serveropentime();
  inline void clear_has_serveropentime();

  ::vmsg::CSPlayerInfo* playerinfo_;
  ::google::protobuf::uint32 serveropentime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSQueryPlayerInfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSSetSettingParamRqst : public ::google::protobuf::MessageLite {
 public:
  CSSetSettingParamRqst();
  virtual ~CSSetSettingParamRqst();

  CSSetSettingParamRqst(const CSSetSettingParamRqst& from);

  inline CSSetSettingParamRqst& operator=(const CSSetSettingParamRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSSetSettingParamRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSSetSettingParamRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSSetSettingParamRqst* other);

  // implements Message ----------------------------------------------

  CSSetSettingParamRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSSetSettingParamRqst& from);
  void MergeFrom(const CSSetSettingParamRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string SettingParam = 1;
  inline bool has_settingparam() const;
  inline void clear_settingparam();
  static const int kSettingParamFieldNumber = 1;
  inline const ::std::string& settingparam() const;
  inline void set_settingparam(const ::std::string& value);
  inline void set_settingparam(const char* value);
  inline void set_settingparam(const char* value, size_t size);
  inline ::std::string* mutable_settingparam();
  inline ::std::string* release_settingparam();
  inline void set_allocated_settingparam(::std::string* settingparam);

  // @@protoc_insertion_point(class_scope:vmsg.CSSetSettingParamRqst)
 private:
  inline void set_has_settingparam();
  inline void clear_has_settingparam();

  ::std::string* settingparam_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSSetSettingParamRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSRegPlayerInfoRqst : public ::google::protobuf::MessageLite {
 public:
  CSRegPlayerInfoRqst();
  virtual ~CSRegPlayerInfoRqst();

  CSRegPlayerInfoRqst(const CSRegPlayerInfoRqst& from);

  inline CSRegPlayerInfoRqst& operator=(const CSRegPlayerInfoRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSRegPlayerInfoRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRegPlayerInfoRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRegPlayerInfoRqst* other);

  // implements Message ----------------------------------------------

  CSRegPlayerInfoRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRegPlayerInfoRqst& from);
  void MergeFrom(const CSRegPlayerInfoRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 PlayerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // required string Nick = 2;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 2;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // @@protoc_insertion_point(class_scope:vmsg.CSRegPlayerInfoRqst)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_nick();
  inline void clear_has_nick();

  ::std::string* nick_;
  ::google::protobuf::uint32 playerid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSRegPlayerInfoRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSRegPlayerInfoRsp : public ::google::protobuf::MessageLite {
 public:
  CSRegPlayerInfoRsp();
  virtual ~CSRegPlayerInfoRsp();

  CSRegPlayerInfoRsp(const CSRegPlayerInfoRsp& from);

  inline CSRegPlayerInfoRsp& operator=(const CSRegPlayerInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSRegPlayerInfoRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRegPlayerInfoRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRegPlayerInfoRsp* other);

  // implements Message ----------------------------------------------

  CSRegPlayerInfoRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRegPlayerInfoRsp& from);
  void MergeFrom(const CSRegPlayerInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSPlayerInfo PlayerInfo = 1;
  inline bool has_playerinfo() const;
  inline void clear_playerinfo();
  static const int kPlayerInfoFieldNumber = 1;
  inline const ::vmsg::CSPlayerInfo& playerinfo() const;
  inline ::vmsg::CSPlayerInfo* mutable_playerinfo();
  inline ::vmsg::CSPlayerInfo* release_playerinfo();
  inline void set_allocated_playerinfo(::vmsg::CSPlayerInfo* playerinfo);

  // @@protoc_insertion_point(class_scope:vmsg.CSRegPlayerInfoRsp)
 private:
  inline void set_has_playerinfo();
  inline void clear_has_playerinfo();

  ::vmsg::CSPlayerInfo* playerinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSRegPlayerInfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSChangeArmorRsp : public ::google::protobuf::MessageLite {
 public:
  CSChangeArmorRsp();
  virtual ~CSChangeArmorRsp();

  CSChangeArmorRsp(const CSChangeArmorRsp& from);

  inline CSChangeArmorRsp& operator=(const CSChangeArmorRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSChangeArmorRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChangeArmorRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChangeArmorRsp* other);

  // implements Message ----------------------------------------------

  CSChangeArmorRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChangeArmorRsp& from);
  void MergeFrom(const CSChangeArmorRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSPlayerDetailInfo PlayerDetailInfo = 1;
  inline bool has_playerdetailinfo() const;
  inline void clear_playerdetailinfo();
  static const int kPlayerDetailInfoFieldNumber = 1;
  inline const ::vmsg::CSPlayerDetailInfo& playerdetailinfo() const;
  inline ::vmsg::CSPlayerDetailInfo* mutable_playerdetailinfo();
  inline ::vmsg::CSPlayerDetailInfo* release_playerdetailinfo();
  inline void set_allocated_playerdetailinfo(::vmsg::CSPlayerDetailInfo* playerdetailinfo);

  // @@protoc_insertion_point(class_scope:vmsg.CSChangeArmorRsp)
 private:
  inline void set_has_playerdetailinfo();
  inline void clear_has_playerdetailinfo();

  ::vmsg::CSPlayerDetailInfo* playerdetailinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSChangeArmorRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerRoleInfo : public ::google::protobuf::MessageLite {
 public:
  CSPlayerRoleInfo();
  virtual ~CSPlayerRoleInfo();

  CSPlayerRoleInfo(const CSPlayerRoleInfo& from);

  inline CSPlayerRoleInfo& operator=(const CSPlayerRoleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerRoleInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerRoleInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerRoleInfo* other);

  // implements Message ----------------------------------------------

  CSPlayerRoleInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerRoleInfo& from);
  void MergeFrom(const CSPlayerRoleInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // required uint32 ShowID = 2;
  inline bool has_showid() const;
  inline void clear_showid();
  static const int kShowIDFieldNumber = 2;
  inline ::google::protobuf::uint32 showid() const;
  inline void set_showid(::google::protobuf::uint32 value);

  // required string Nick = 3;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 3;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // required uint32 Level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint64 Exp = 5;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 5;
  inline ::google::protobuf::uint64 exp() const;
  inline void set_exp(::google::protobuf::uint64 value);

  // required uint32 WeaponCfgID = 6;
  inline bool has_weaponcfgid() const;
  inline void clear_weaponcfgid();
  static const int kWeaponCfgIDFieldNumber = 6;
  inline ::google::protobuf::uint32 weaponcfgid() const;
  inline void set_weaponcfgid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerRoleInfo)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();
  inline void set_has_showid();
  inline void clear_has_showid();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_weaponcfgid();
  inline void clear_has_weaponcfgid();

  ::google::protobuf::uint64 uin_;
  ::std::string* nick_;
  ::google::protobuf::uint32 showid_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint64 exp_;
  ::google::protobuf::uint32 weaponcfgid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerRoleInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSQueryRoleLstRsp : public ::google::protobuf::MessageLite {
 public:
  CSQueryRoleLstRsp();
  virtual ~CSQueryRoleLstRsp();

  CSQueryRoleLstRsp(const CSQueryRoleLstRsp& from);

  inline CSQueryRoleLstRsp& operator=(const CSQueryRoleLstRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSQueryRoleLstRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQueryRoleLstRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQueryRoleLstRsp* other);

  // implements Message ----------------------------------------------

  CSQueryRoleLstRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQueryRoleLstRsp& from);
  void MergeFrom(const CSQueryRoleLstRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSPlayerRoleInfo RoleLst = 1;
  inline int rolelst_size() const;
  inline void clear_rolelst();
  static const int kRoleLstFieldNumber = 1;
  inline const ::vmsg::CSPlayerRoleInfo& rolelst(int index) const;
  inline ::vmsg::CSPlayerRoleInfo* mutable_rolelst(int index);
  inline ::vmsg::CSPlayerRoleInfo* add_rolelst();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerRoleInfo >&
      rolelst() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerRoleInfo >*
      mutable_rolelst();

  // @@protoc_insertion_point(class_scope:vmsg.CSQueryRoleLstRsp)
 private:

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerRoleInfo > rolelst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSQueryRoleLstRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSRoleLoginRqst : public ::google::protobuf::MessageLite {
 public:
  CSRoleLoginRqst();
  virtual ~CSRoleLoginRqst();

  CSRoleLoginRqst(const CSRoleLoginRqst& from);

  inline CSRoleLoginRqst& operator=(const CSRoleLoginRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSRoleLoginRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRoleLoginRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRoleLoginRqst* other);

  // implements Message ----------------------------------------------

  CSRoleLoginRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRoleLoginRqst& from);
  void MergeFrom(const CSRoleLoginRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSRoleLoginRqst)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();

  ::google::protobuf::uint64 uin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSRoleLoginRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSRoleLoginRsp : public ::google::protobuf::MessageLite {
 public:
  CSRoleLoginRsp();
  virtual ~CSRoleLoginRsp();

  CSRoleLoginRsp(const CSRoleLoginRsp& from);

  inline CSRoleLoginRsp& operator=(const CSRoleLoginRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSRoleLoginRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRoleLoginRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRoleLoginRsp* other);

  // implements Message ----------------------------------------------

  CSRoleLoginRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRoleLoginRsp& from);
  void MergeFrom(const CSRoleLoginRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 RetCode = 1;
  inline bool has_retcode() const;
  inline void clear_retcode();
  static const int kRetCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 retcode() const;
  inline void set_retcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSRoleLoginRsp)
 private:
  inline void set_has_retcode();
  inline void clear_has_retcode();

  ::google::protobuf::uint32 retcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSRoleLoginRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSRoleLogoutRqst : public ::google::protobuf::MessageLite {
 public:
  CSRoleLogoutRqst();
  virtual ~CSRoleLogoutRqst();

  CSRoleLogoutRqst(const CSRoleLogoutRqst& from);

  inline CSRoleLogoutRqst& operator=(const CSRoleLogoutRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSRoleLogoutRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRoleLogoutRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRoleLogoutRqst* other);

  // implements Message ----------------------------------------------

  CSRoleLogoutRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRoleLogoutRqst& from);
  void MergeFrom(const CSRoleLogoutRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 Uin = 1;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 1;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSRoleLogoutRqst)
 private:
  inline void set_has_uin();
  inline void clear_has_uin();

  ::google::protobuf::uint64 uin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSRoleLogoutRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSRoleLogoutRsp : public ::google::protobuf::MessageLite {
 public:
  CSRoleLogoutRsp();
  virtual ~CSRoleLogoutRsp();

  CSRoleLogoutRsp(const CSRoleLogoutRsp& from);

  inline CSRoleLogoutRsp& operator=(const CSRoleLogoutRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSRoleLogoutRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSRoleLogoutRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSRoleLogoutRsp* other);

  // implements Message ----------------------------------------------

  CSRoleLogoutRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSRoleLogoutRsp& from);
  void MergeFrom(const CSRoleLogoutRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 RetCode = 1;
  inline bool has_retcode() const;
  inline void clear_retcode();
  static const int kRetCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 retcode() const;
  inline void set_retcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSRoleLogoutRsp)
 private:
  inline void set_has_retcode();
  inline void clear_has_retcode();

  ::google::protobuf::uint32 retcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSRoleLogoutRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerManualNotify : public ::google::protobuf::MessageLite {
 public:
  CSPlayerManualNotify();
  virtual ~CSPlayerManualNotify();

  CSPlayerManualNotify(const CSPlayerManualNotify& from);

  inline CSPlayerManualNotify& operator=(const CSPlayerManualNotify& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerManualNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerManualNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerManualNotify* other);

  // implements Message ----------------------------------------------

  CSPlayerManualNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerManualNotify& from);
  void MergeFrom(const CSPlayerManualNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 RemainManual = 1;
  inline bool has_remainmanual() const;
  inline void clear_remainmanual();
  static const int kRemainManualFieldNumber = 1;
  inline ::google::protobuf::uint32 remainmanual() const;
  inline void set_remainmanual(::google::protobuf::uint32 value);

  // required int32 UpdateRemainTime = 2;
  inline bool has_updateremaintime() const;
  inline void clear_updateremaintime();
  static const int kUpdateRemainTimeFieldNumber = 2;
  inline ::google::protobuf::int32 updateremaintime() const;
  inline void set_updateremaintime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerManualNotify)
 private:
  inline void set_has_remainmanual();
  inline void clear_has_remainmanual();
  inline void set_has_updateremaintime();
  inline void clear_has_updateremaintime();

  ::google::protobuf::uint32 remainmanual_;
  ::google::protobuf::int32 updateremaintime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerManualNotify* default_instance_;
};
// -------------------------------------------------------------------

class CSBuyManualInfo : public ::google::protobuf::MessageLite {
 public:
  CSBuyManualInfo();
  virtual ~CSBuyManualInfo();

  CSBuyManualInfo(const CSBuyManualInfo& from);

  inline CSBuyManualInfo& operator=(const CSBuyManualInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBuyManualInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBuyManualInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBuyManualInfo* other);

  // implements Message ----------------------------------------------

  CSBuyManualInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBuyManualInfo& from);
  void MergeFrom(const CSBuyManualInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 BuyCnt = 1;
  inline bool has_buycnt() const;
  inline void clear_buycnt();
  static const int kBuyCntFieldNumber = 1;
  inline ::google::protobuf::uint32 buycnt() const;
  inline void set_buycnt(::google::protobuf::uint32 value);

  // required uint32 MaxCnt = 2;
  inline bool has_maxcnt() const;
  inline void clear_maxcnt();
  static const int kMaxCntFieldNumber = 2;
  inline ::google::protobuf::uint32 maxcnt() const;
  inline void set_maxcnt(::google::protobuf::uint32 value);

  // required uint32 GoldCost = 3;
  inline bool has_goldcost() const;
  inline void clear_goldcost();
  static const int kGoldCostFieldNumber = 3;
  inline ::google::protobuf::uint32 goldcost() const;
  inline void set_goldcost(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSBuyManualInfo)
 private:
  inline void set_has_buycnt();
  inline void clear_has_buycnt();
  inline void set_has_maxcnt();
  inline void clear_has_maxcnt();
  inline void set_has_goldcost();
  inline void clear_has_goldcost();

  ::google::protobuf::uint32 buycnt_;
  ::google::protobuf::uint32 maxcnt_;
  ::google::protobuf::uint32 goldcost_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBuyManualInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSQueryPlayerManualRsp : public ::google::protobuf::MessageLite {
 public:
  CSQueryPlayerManualRsp();
  virtual ~CSQueryPlayerManualRsp();

  CSQueryPlayerManualRsp(const CSQueryPlayerManualRsp& from);

  inline CSQueryPlayerManualRsp& operator=(const CSQueryPlayerManualRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSQueryPlayerManualRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQueryPlayerManualRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQueryPlayerManualRsp* other);

  // implements Message ----------------------------------------------

  CSQueryPlayerManualRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQueryPlayerManualRsp& from);
  void MergeFrom(const CSQueryPlayerManualRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 RemainManual = 1;
  inline bool has_remainmanual() const;
  inline void clear_remainmanual();
  static const int kRemainManualFieldNumber = 1;
  inline ::google::protobuf::uint32 remainmanual() const;
  inline void set_remainmanual(::google::protobuf::uint32 value);

  // required int32 UpdateRemainTime = 2;
  inline bool has_updateremaintime() const;
  inline void clear_updateremaintime();
  static const int kUpdateRemainTimeFieldNumber = 2;
  inline ::google::protobuf::int32 updateremaintime() const;
  inline void set_updateremaintime(::google::protobuf::int32 value);

  // required .vmsg.CSBuyManualInfo ManualInfo = 3;
  inline bool has_manualinfo() const;
  inline void clear_manualinfo();
  static const int kManualInfoFieldNumber = 3;
  inline const ::vmsg::CSBuyManualInfo& manualinfo() const;
  inline ::vmsg::CSBuyManualInfo* mutable_manualinfo();
  inline ::vmsg::CSBuyManualInfo* release_manualinfo();
  inline void set_allocated_manualinfo(::vmsg::CSBuyManualInfo* manualinfo);

  // @@protoc_insertion_point(class_scope:vmsg.CSQueryPlayerManualRsp)
 private:
  inline void set_has_remainmanual();
  inline void clear_has_remainmanual();
  inline void set_has_updateremaintime();
  inline void clear_has_updateremaintime();
  inline void set_has_manualinfo();
  inline void clear_has_manualinfo();

  ::google::protobuf::uint32 remainmanual_;
  ::google::protobuf::int32 updateremaintime_;
  ::vmsg::CSBuyManualInfo* manualinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSQueryPlayerManualRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerEvolutionInfo : public ::google::protobuf::MessageLite {
 public:
  CSPlayerEvolutionInfo();
  virtual ~CSPlayerEvolutionInfo();

  CSPlayerEvolutionInfo(const CSPlayerEvolutionInfo& from);

  inline CSPlayerEvolutionInfo& operator=(const CSPlayerEvolutionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerEvolutionInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerEvolutionInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerEvolutionInfo* other);

  // implements Message ----------------------------------------------

  CSPlayerEvolutionInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerEvolutionInfo& from);
  void MergeFrom(const CSPlayerEvolutionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 EvolutionID = 1;
  inline bool has_evolutionid() const;
  inline void clear_evolutionid();
  static const int kEvolutionIDFieldNumber = 1;
  inline ::google::protobuf::uint32 evolutionid() const;
  inline void set_evolutionid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerEvolutionInfo)
 private:
  inline void set_has_evolutionid();
  inline void clear_has_evolutionid();

  ::google::protobuf::uint32 evolutionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerEvolutionInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSEvolutionSkill : public ::google::protobuf::MessageLite {
 public:
  CSEvolutionSkill();
  virtual ~CSEvolutionSkill();

  CSEvolutionSkill(const CSEvolutionSkill& from);

  inline CSEvolutionSkill& operator=(const CSEvolutionSkill& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSEvolutionSkill& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSEvolutionSkill* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSEvolutionSkill* other);

  // implements Message ----------------------------------------------

  CSEvolutionSkill* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSEvolutionSkill& from);
  void MergeFrom(const CSEvolutionSkill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 StartSkillID = 1;
  inline bool has_startskillid() const;
  inline void clear_startskillid();
  static const int kStartSkillIDFieldNumber = 1;
  inline ::google::protobuf::uint32 startskillid() const;
  inline void set_startskillid(::google::protobuf::uint32 value);

  // required uint64 Exp = 2;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 2;
  inline ::google::protobuf::uint64 exp() const;
  inline void set_exp(::google::protobuf::uint64 value);

  // required uint32 Level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSEvolutionSkill)
 private:
  inline void set_has_startskillid();
  inline void clear_has_startskillid();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::uint64 exp_;
  ::google::protobuf::uint32 startskillid_;
  ::google::protobuf::uint32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSEvolutionSkill* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerEvolutionSkillInfo : public ::google::protobuf::MessageLite {
 public:
  CSPlayerEvolutionSkillInfo();
  virtual ~CSPlayerEvolutionSkillInfo();

  CSPlayerEvolutionSkillInfo(const CSPlayerEvolutionSkillInfo& from);

  inline CSPlayerEvolutionSkillInfo& operator=(const CSPlayerEvolutionSkillInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerEvolutionSkillInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerEvolutionSkillInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerEvolutionSkillInfo* other);

  // implements Message ----------------------------------------------

  CSPlayerEvolutionSkillInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerEvolutionSkillInfo& from);
  void MergeFrom(const CSPlayerEvolutionSkillInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSEvolutionSkill Skills = 1;
  inline int skills_size() const;
  inline void clear_skills();
  static const int kSkillsFieldNumber = 1;
  inline const ::vmsg::CSEvolutionSkill& skills(int index) const;
  inline ::vmsg::CSEvolutionSkill* mutable_skills(int index);
  inline ::vmsg::CSEvolutionSkill* add_skills();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSEvolutionSkill >&
      skills() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSEvolutionSkill >*
      mutable_skills();

  // required int32 UseSkillIdx = 2;
  inline bool has_useskillidx() const;
  inline void clear_useskillidx();
  static const int kUseSkillIdxFieldNumber = 2;
  inline ::google::protobuf::int32 useskillidx() const;
  inline void set_useskillidx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerEvolutionSkillInfo)
 private:
  inline void set_has_useskillidx();
  inline void clear_has_useskillidx();

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSEvolutionSkill > skills_;
  ::google::protobuf::int32 useskillidx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerEvolutionSkillInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSChangePlayerEvolutionSkillRqst : public ::google::protobuf::MessageLite {
 public:
  CSChangePlayerEvolutionSkillRqst();
  virtual ~CSChangePlayerEvolutionSkillRqst();

  CSChangePlayerEvolutionSkillRqst(const CSChangePlayerEvolutionSkillRqst& from);

  inline CSChangePlayerEvolutionSkillRqst& operator=(const CSChangePlayerEvolutionSkillRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSChangePlayerEvolutionSkillRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChangePlayerEvolutionSkillRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChangePlayerEvolutionSkillRqst* other);

  // implements Message ----------------------------------------------

  CSChangePlayerEvolutionSkillRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChangePlayerEvolutionSkillRqst& from);
  void MergeFrom(const CSChangePlayerEvolutionSkillRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 UseSkillIdx = 1;
  inline bool has_useskillidx() const;
  inline void clear_useskillidx();
  static const int kUseSkillIdxFieldNumber = 1;
  inline ::google::protobuf::int32 useskillidx() const;
  inline void set_useskillidx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSChangePlayerEvolutionSkillRqst)
 private:
  inline void set_has_useskillidx();
  inline void clear_has_useskillidx();

  ::google::protobuf::int32 useskillidx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSChangePlayerEvolutionSkillRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSChangePlayerEvolutionSkillRsp : public ::google::protobuf::MessageLite {
 public:
  CSChangePlayerEvolutionSkillRsp();
  virtual ~CSChangePlayerEvolutionSkillRsp();

  CSChangePlayerEvolutionSkillRsp(const CSChangePlayerEvolutionSkillRsp& from);

  inline CSChangePlayerEvolutionSkillRsp& operator=(const CSChangePlayerEvolutionSkillRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSChangePlayerEvolutionSkillRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSChangePlayerEvolutionSkillRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSChangePlayerEvolutionSkillRsp* other);

  // implements Message ----------------------------------------------

  CSChangePlayerEvolutionSkillRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSChangePlayerEvolutionSkillRsp& from);
  void MergeFrom(const CSChangePlayerEvolutionSkillRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 UseSkillIdx = 1;
  inline bool has_useskillidx() const;
  inline void clear_useskillidx();
  static const int kUseSkillIdxFieldNumber = 1;
  inline ::google::protobuf::uint32 useskillidx() const;
  inline void set_useskillidx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSChangePlayerEvolutionSkillRsp)
 private:
  inline void set_has_useskillidx();
  inline void clear_has_useskillidx();

  ::google::protobuf::uint32 useskillidx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSChangePlayerEvolutionSkillRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSAttrStrengthenRqst : public ::google::protobuf::MessageLite {
 public:
  CSAttrStrengthenRqst();
  virtual ~CSAttrStrengthenRqst();

  CSAttrStrengthenRqst(const CSAttrStrengthenRqst& from);

  inline CSAttrStrengthenRqst& operator=(const CSAttrStrengthenRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSAttrStrengthenRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAttrStrengthenRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAttrStrengthenRqst* other);

  // implements Message ----------------------------------------------

  CSAttrStrengthenRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAttrStrengthenRqst& from);
  void MergeFrom(const CSAttrStrengthenRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 MagicType = 2;
  inline bool has_magictype() const;
  inline void clear_magictype();
  static const int kMagicTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 magictype() const;
  inline void set_magictype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSAttrStrengthenRqst)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_magictype();
  inline void clear_has_magictype();

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 magictype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSAttrStrengthenRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSAttrStrengthenInfo : public ::google::protobuf::MessageLite {
 public:
  CSAttrStrengthenInfo();
  virtual ~CSAttrStrengthenInfo();

  CSAttrStrengthenInfo(const CSAttrStrengthenInfo& from);

  inline CSAttrStrengthenInfo& operator=(const CSAttrStrengthenInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSAttrStrengthenInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAttrStrengthenInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAttrStrengthenInfo* other);

  // implements Message ----------------------------------------------

  CSAttrStrengthenInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAttrStrengthenInfo& from);
  void MergeFrom(const CSAttrStrengthenInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 AtkMagics = 1;
  inline int atkmagics_size() const;
  inline void clear_atkmagics();
  static const int kAtkMagicsFieldNumber = 1;
  inline ::google::protobuf::uint32 atkmagics(int index) const;
  inline void set_atkmagics(int index, ::google::protobuf::uint32 value);
  inline void add_atkmagics(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      atkmagics() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_atkmagics();

  // repeated uint32 DefMagics = 2;
  inline int defmagics_size() const;
  inline void clear_defmagics();
  static const int kDefMagicsFieldNumber = 2;
  inline ::google::protobuf::uint32 defmagics(int index) const;
  inline void set_defmagics(int index, ::google::protobuf::uint32 value);
  inline void add_defmagics(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      defmagics() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_defmagics();

  // @@protoc_insertion_point(class_scope:vmsg.CSAttrStrengthenInfo)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > atkmagics_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > defmagics_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSAttrStrengthenInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSWeaponLotQueryRsp : public ::google::protobuf::MessageLite {
 public:
  CSWeaponLotQueryRsp();
  virtual ~CSWeaponLotQueryRsp();

  CSWeaponLotQueryRsp(const CSWeaponLotQueryRsp& from);

  inline CSWeaponLotQueryRsp& operator=(const CSWeaponLotQueryRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWeaponLotQueryRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWeaponLotQueryRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWeaponLotQueryRsp* other);

  // implements Message ----------------------------------------------

  CSWeaponLotQueryRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWeaponLotQueryRsp& from);
  void MergeFrom(const CSWeaponLotQueryRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 NormalLotRemainTime = 1;
  inline bool has_normallotremaintime() const;
  inline void clear_normallotremaintime();
  static const int kNormalLotRemainTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 normallotremaintime() const;
  inline void set_normallotremaintime(::google::protobuf::uint32 value);

  // required uint32 AdvanceLotRemainTime = 2;
  inline bool has_advancelotremaintime() const;
  inline void clear_advancelotremaintime();
  static const int kAdvanceLotRemainTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 advancelotremaintime() const;
  inline void set_advancelotremaintime(::google::protobuf::uint32 value);

  // required uint32 RemainGoldCardCnt = 3;
  inline bool has_remaingoldcardcnt() const;
  inline void clear_remaingoldcardcnt();
  static const int kRemainGoldCardCntFieldNumber = 3;
  inline ::google::protobuf::uint32 remaingoldcardcnt() const;
  inline void set_remaingoldcardcnt(::google::protobuf::uint32 value);

  // required uint32 RemainVipAwardCntToday = 4;
  inline bool has_remainvipawardcnttoday() const;
  inline void clear_remainvipawardcnttoday();
  static const int kRemainVipAwardCntTodayFieldNumber = 4;
  inline ::google::protobuf::uint32 remainvipawardcnttoday() const;
  inline void set_remainvipawardcnttoday(::google::protobuf::uint32 value);

  // required uint32 RemainVipAwardCntTotal = 5;
  inline bool has_remainvipawardcnttotal() const;
  inline void clear_remainvipawardcnttotal();
  static const int kRemainVipAwardCntTotalFieldNumber = 5;
  inline ::google::protobuf::uint32 remainvipawardcnttotal() const;
  inline void set_remainvipawardcnttotal(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSWeaponLotQueryRsp)
 private:
  inline void set_has_normallotremaintime();
  inline void clear_has_normallotremaintime();
  inline void set_has_advancelotremaintime();
  inline void clear_has_advancelotremaintime();
  inline void set_has_remaingoldcardcnt();
  inline void clear_has_remaingoldcardcnt();
  inline void set_has_remainvipawardcnttoday();
  inline void clear_has_remainvipawardcnttoday();
  inline void set_has_remainvipawardcnttotal();
  inline void clear_has_remainvipawardcnttotal();

  ::google::protobuf::uint32 normallotremaintime_;
  ::google::protobuf::uint32 advancelotremaintime_;
  ::google::protobuf::uint32 remaingoldcardcnt_;
  ::google::protobuf::uint32 remainvipawardcnttoday_;
  ::google::protobuf::uint32 remainvipawardcnttotal_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWeaponLotQueryRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSWeaponLotRqst : public ::google::protobuf::MessageLite {
 public:
  CSWeaponLotRqst();
  virtual ~CSWeaponLotRqst();

  CSWeaponLotRqst(const CSWeaponLotRqst& from);

  inline CSWeaponLotRqst& operator=(const CSWeaponLotRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWeaponLotRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWeaponLotRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWeaponLotRqst* other);

  // implements Message ----------------------------------------------

  CSWeaponLotRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWeaponLotRqst& from);
  void MergeFrom(const CSWeaponLotRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSWeaponLotRqst)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWeaponLotRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSWeaponLotRsp : public ::google::protobuf::MessageLite {
 public:
  CSWeaponLotRsp();
  virtual ~CSWeaponLotRsp();

  CSWeaponLotRsp(const CSWeaponLotRsp& from);

  inline CSWeaponLotRsp& operator=(const CSWeaponLotRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSWeaponLotRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSWeaponLotRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSWeaponLotRsp* other);

  // implements Message ----------------------------------------------

  CSWeaponLotRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSWeaponLotRsp& from);
  void MergeFrom(const CSWeaponLotRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required .vmsg.CSAwardElement FixedElmt = 2;
  inline bool has_fixedelmt() const;
  inline void clear_fixedelmt();
  static const int kFixedElmtFieldNumber = 2;
  inline const ::vmsg::CSAwardElement& fixedelmt() const;
  inline ::vmsg::CSAwardElement* mutable_fixedelmt();
  inline ::vmsg::CSAwardElement* release_fixedelmt();
  inline void set_allocated_fixedelmt(::vmsg::CSAwardElement* fixedelmt);

  // repeated .vmsg.CSAwardElement ElmtLst = 3;
  inline int elmtlst_size() const;
  inline void clear_elmtlst();
  static const int kElmtLstFieldNumber = 3;
  inline const ::vmsg::CSAwardElement& elmtlst(int index) const;
  inline ::vmsg::CSAwardElement* mutable_elmtlst(int index);
  inline ::vmsg::CSAwardElement* add_elmtlst();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >&
      elmtlst() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >*
      mutable_elmtlst();

  // @@protoc_insertion_point(class_scope:vmsg.CSWeaponLotRsp)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_fixedelmt();
  inline void clear_has_fixedelmt();

  ::vmsg::CSAwardElement* fixedelmt_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement > elmtlst_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSWeaponLotRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSAwardRankInfo : public ::google::protobuf::MessageLite {
 public:
  CSAwardRankInfo();
  virtual ~CSAwardRankInfo();

  CSAwardRankInfo(const CSAwardRankInfo& from);

  inline CSAwardRankInfo& operator=(const CSAwardRankInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSAwardRankInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAwardRankInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAwardRankInfo* other);

  // implements Message ----------------------------------------------

  CSAwardRankInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAwardRankInfo& from);
  void MergeFrom(const CSAwardRankInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 RankType = 1;
  inline bool has_ranktype() const;
  inline void clear_ranktype();
  static const int kRankTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 ranktype() const;
  inline void set_ranktype(::google::protobuf::uint32 value);

  // required uint32 HasLastAward = 2;
  inline bool has_haslastaward() const;
  inline void clear_haslastaward();
  static const int kHasLastAwardFieldNumber = 2;
  inline ::google::protobuf::uint32 haslastaward() const;
  inline void set_haslastaward(::google::protobuf::uint32 value);

  // required uint32 Coin = 3;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 3;
  inline ::google::protobuf::uint32 coin() const;
  inline void set_coin(::google::protobuf::uint32 value);

  // required uint32 ArenaMoney = 4;
  inline bool has_arenamoney() const;
  inline void clear_arenamoney();
  static const int kArenaMoneyFieldNumber = 4;
  inline ::google::protobuf::uint32 arenamoney() const;
  inline void set_arenamoney(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSAwardRankInfo)
 private:
  inline void set_has_ranktype();
  inline void clear_has_ranktype();
  inline void set_has_haslastaward();
  inline void clear_has_haslastaward();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_arenamoney();
  inline void clear_has_arenamoney();

  ::google::protobuf::uint32 ranktype_;
  ::google::protobuf::uint32 haslastaward_;
  ::google::protobuf::uint32 coin_;
  ::google::protobuf::uint32 arenamoney_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSAwardRankInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSAwardRankRsp : public ::google::protobuf::MessageLite {
 public:
  CSAwardRankRsp();
  virtual ~CSAwardRankRsp();

  CSAwardRankRsp(const CSAwardRankRsp& from);

  inline CSAwardRankRsp& operator=(const CSAwardRankRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSAwardRankRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSAwardRankRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSAwardRankRsp* other);

  // implements Message ----------------------------------------------

  CSAwardRankRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSAwardRankRsp& from);
  void MergeFrom(const CSAwardRankRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vmsg.CSAwardRankInfo Infos = 1;
  inline int infos_size() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 1;
  inline const ::vmsg::CSAwardRankInfo& infos(int index) const;
  inline ::vmsg::CSAwardRankInfo* mutable_infos(int index);
  inline ::vmsg::CSAwardRankInfo* add_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardRankInfo >&
      infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardRankInfo >*
      mutable_infos();

  // required int32 RemainTime = 2;
  inline bool has_remaintime() const;
  inline void clear_remaintime();
  static const int kRemainTimeFieldNumber = 2;
  inline ::google::protobuf::int32 remaintime() const;
  inline void set_remaintime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSAwardRankRsp)
 private:
  inline void set_has_remaintime();
  inline void clear_has_remaintime();

  ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardRankInfo > infos_;
  ::google::protobuf::int32 remaintime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSAwardRankRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSFetchRankAwardRqst : public ::google::protobuf::MessageLite {
 public:
  CSFetchRankAwardRqst();
  virtual ~CSFetchRankAwardRqst();

  CSFetchRankAwardRqst(const CSFetchRankAwardRqst& from);

  inline CSFetchRankAwardRqst& operator=(const CSFetchRankAwardRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSFetchRankAwardRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSFetchRankAwardRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSFetchRankAwardRqst* other);

  // implements Message ----------------------------------------------

  CSFetchRankAwardRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSFetchRankAwardRqst& from);
  void MergeFrom(const CSFetchRankAwardRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 RankType = 1;
  inline bool has_ranktype() const;
  inline void clear_ranktype();
  static const int kRankTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 ranktype() const;
  inline void set_ranktype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSFetchRankAwardRqst)
 private:
  inline void set_has_ranktype();
  inline void clear_has_ranktype();

  ::google::protobuf::uint32 ranktype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSFetchRankAwardRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerLvUpRsp : public ::google::protobuf::MessageLite {
 public:
  CSPlayerLvUpRsp();
  virtual ~CSPlayerLvUpRsp();

  CSPlayerLvUpRsp(const CSPlayerLvUpRsp& from);

  inline CSPlayerLvUpRsp& operator=(const CSPlayerLvUpRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerLvUpRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerLvUpRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerLvUpRsp* other);

  // implements Message ----------------------------------------------

  CSPlayerLvUpRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerLvUpRsp& from);
  void MergeFrom(const CSPlayerLvUpRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Lv = 1;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 1;
  inline ::google::protobuf::uint32 lv() const;
  inline void set_lv(::google::protobuf::uint32 value);

  // required uint64 Exp = 2;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 2;
  inline ::google::protobuf::uint64 exp() const;
  inline void set_exp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerLvUpRsp)
 private:
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_exp();
  inline void clear_has_exp();

  ::google::protobuf::uint64 exp_;
  ::google::protobuf::uint32 lv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerLvUpRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSVIPNotify : public ::google::protobuf::MessageLite {
 public:
  CSVIPNotify();
  virtual ~CSVIPNotify();

  CSVIPNotify(const CSVIPNotify& from);

  inline CSVIPNotify& operator=(const CSVIPNotify& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSVIPNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSVIPNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSVIPNotify* other);

  // implements Message ----------------------------------------------

  CSVIPNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSVIPNotify& from);
  void MergeFrom(const CSVIPNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 VIPLv = 1;
  inline bool has_viplv() const;
  inline void clear_viplv();
  static const int kVIPLvFieldNumber = 1;
  inline ::google::protobuf::uint32 viplv() const;
  inline void set_viplv(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSVIPNotify)
 private:
  inline void set_has_viplv();
  inline void clear_has_viplv();

  ::google::protobuf::uint32 viplv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSVIPNotify* default_instance_;
};
// -------------------------------------------------------------------

class CSVIPInfos : public ::google::protobuf::MessageLite {
 public:
  CSVIPInfos();
  virtual ~CSVIPInfos();

  CSVIPInfos(const CSVIPInfos& from);

  inline CSVIPInfos& operator=(const CSVIPInfos& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSVIPInfos& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSVIPInfos* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSVIPInfos* other);

  // implements Message ----------------------------------------------

  CSVIPInfos* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSVIPInfos& from);
  void MergeFrom(const CSVIPInfos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 VIPAward = 1;
  inline int vipaward_size() const;
  inline void clear_vipaward();
  static const int kVIPAwardFieldNumber = 1;
  inline ::google::protobuf::uint32 vipaward(int index) const;
  inline void set_vipaward(int index, ::google::protobuf::uint32 value);
  inline void add_vipaward(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      vipaward() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_vipaward();

  // @@protoc_insertion_point(class_scope:vmsg.CSVIPInfos)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > vipaward_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSVIPInfos* default_instance_;
};
// -------------------------------------------------------------------

class CSFightPowerNotify : public ::google::protobuf::MessageLite {
 public:
  CSFightPowerNotify();
  virtual ~CSFightPowerNotify();

  CSFightPowerNotify(const CSFightPowerNotify& from);

  inline CSFightPowerNotify& operator=(const CSFightPowerNotify& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSFightPowerNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSFightPowerNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSFightPowerNotify* other);

  // implements Message ----------------------------------------------

  CSFightPowerNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSFightPowerNotify& from);
  void MergeFrom(const CSFightPowerNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 FightPower = 1;
  inline bool has_fightpower() const;
  inline void clear_fightpower();
  static const int kFightPowerFieldNumber = 1;
  inline ::google::protobuf::uint64 fightpower() const;
  inline void set_fightpower(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSFightPowerNotify)
 private:
  inline void set_has_fightpower();
  inline void clear_has_fightpower();

  ::google::protobuf::uint64 fightpower_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSFightPowerNotify* default_instance_;
};
// -------------------------------------------------------------------

class CSOtherPlayerInfoRsp : public ::google::protobuf::MessageLite {
 public:
  CSOtherPlayerInfoRsp();
  virtual ~CSOtherPlayerInfoRsp();

  CSOtherPlayerInfoRsp(const CSOtherPlayerInfoRsp& from);

  inline CSOtherPlayerInfoRsp& operator=(const CSOtherPlayerInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSOtherPlayerInfoRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSOtherPlayerInfoRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSOtherPlayerInfoRsp* other);

  // implements Message ----------------------------------------------

  CSOtherPlayerInfoRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSOtherPlayerInfoRsp& from);
  void MergeFrom(const CSOtherPlayerInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSPlayerInfo PlayerInfo = 1;
  inline bool has_playerinfo() const;
  inline void clear_playerinfo();
  static const int kPlayerInfoFieldNumber = 1;
  inline const ::vmsg::CSPlayerInfo& playerinfo() const;
  inline ::vmsg::CSPlayerInfo* mutable_playerinfo();
  inline ::vmsg::CSPlayerInfo* release_playerinfo();
  inline void set_allocated_playerinfo(::vmsg::CSPlayerInfo* playerinfo);

  // required .vmsg.CSPlayerDetailInfo DetailInfo = 2;
  inline bool has_detailinfo() const;
  inline void clear_detailinfo();
  static const int kDetailInfoFieldNumber = 2;
  inline const ::vmsg::CSPlayerDetailInfo& detailinfo() const;
  inline ::vmsg::CSPlayerDetailInfo* mutable_detailinfo();
  inline ::vmsg::CSPlayerDetailInfo* release_detailinfo();
  inline void set_allocated_detailinfo(::vmsg::CSPlayerDetailInfo* detailinfo);

  // @@protoc_insertion_point(class_scope:vmsg.CSOtherPlayerInfoRsp)
 private:
  inline void set_has_playerinfo();
  inline void clear_has_playerinfo();
  inline void set_has_detailinfo();
  inline void clear_has_detailinfo();

  ::vmsg::CSPlayerInfo* playerinfo_;
  ::vmsg::CSPlayerDetailInfo* detailinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSOtherPlayerInfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSBlackProductInfo : public ::google::protobuf::MessageLite {
 public:
  CSBlackProductInfo();
  virtual ~CSBlackProductInfo();

  CSBlackProductInfo(const CSBlackProductInfo& from);

  inline CSBlackProductInfo& operator=(const CSBlackProductInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBlackProductInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBlackProductInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBlackProductInfo* other);

  // implements Message ----------------------------------------------

  CSBlackProductInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBlackProductInfo& from);
  void MergeFrom(const CSBlackProductInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ProductType = 1;
  inline bool has_producttype() const;
  inline void clear_producttype();
  static const int kProductTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 producttype() const;
  inline void set_producttype(::google::protobuf::uint32 value);

  // required uint32 ProductCfgID = 2;
  inline bool has_productcfgid() const;
  inline void clear_productcfgid();
  static const int kProductCfgIDFieldNumber = 2;
  inline ::google::protobuf::uint32 productcfgid() const;
  inline void set_productcfgid(::google::protobuf::uint32 value);

  // required uint32 ProductCnt = 3;
  inline bool has_productcnt() const;
  inline void clear_productcnt();
  static const int kProductCntFieldNumber = 3;
  inline ::google::protobuf::uint32 productcnt() const;
  inline void set_productcnt(::google::protobuf::uint32 value);

  // required uint32 CurrType = 4;
  inline bool has_currtype() const;
  inline void clear_currtype();
  static const int kCurrTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 currtype() const;
  inline void set_currtype(::google::protobuf::uint32 value);

  // required uint32 CurrCnt = 5;
  inline bool has_currcnt() const;
  inline void clear_currcnt();
  static const int kCurrCntFieldNumber = 5;
  inline ::google::protobuf::uint32 currcnt() const;
  inline void set_currcnt(::google::protobuf::uint32 value);

  // required uint32 HasBought = 6;
  inline bool has_hasbought() const;
  inline void clear_hasbought();
  static const int kHasBoughtFieldNumber = 6;
  inline ::google::protobuf::uint32 hasbought() const;
  inline void set_hasbought(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSBlackProductInfo)
 private:
  inline void set_has_producttype();
  inline void clear_has_producttype();
  inline void set_has_productcfgid();
  inline void clear_has_productcfgid();
  inline void set_has_productcnt();
  inline void clear_has_productcnt();
  inline void set_has_currtype();
  inline void clear_has_currtype();
  inline void set_has_currcnt();
  inline void clear_has_currcnt();
  inline void set_has_hasbought();
  inline void clear_has_hasbought();

  ::google::protobuf::uint32 producttype_;
  ::google::protobuf::uint32 productcfgid_;
  ::google::protobuf::uint32 productcnt_;
  ::google::protobuf::uint32 currtype_;
  ::google::protobuf::uint32 currcnt_;
  ::google::protobuf::uint32 hasbought_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBlackProductInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSBlackMarketInfo : public ::google::protobuf::MessageLite {
 public:
  CSBlackMarketInfo();
  virtual ~CSBlackMarketInfo();

  CSBlackMarketInfo(const CSBlackMarketInfo& from);

  inline CSBlackMarketInfo& operator=(const CSBlackMarketInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBlackMarketInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBlackMarketInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBlackMarketInfo* other);

  // implements Message ----------------------------------------------

  CSBlackMarketInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBlackMarketInfo& from);
  void MergeFrom(const CSBlackMarketInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 RemainTime = 1;
  inline bool has_remaintime() const;
  inline void clear_remaintime();
  static const int kRemainTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 remaintime() const;
  inline void set_remaintime(::google::protobuf::uint32 value);

  // required uint32 ResetCost = 2;
  inline bool has_resetcost() const;
  inline void clear_resetcost();
  static const int kResetCostFieldNumber = 2;
  inline ::google::protobuf::uint32 resetcost() const;
  inline void set_resetcost(::google::protobuf::uint32 value);

  // required uint32 RemainResetCnt = 3;
  inline bool has_remainresetcnt() const;
  inline void clear_remainresetcnt();
  static const int kRemainResetCntFieldNumber = 3;
  inline ::google::protobuf::uint32 remainresetcnt() const;
  inline void set_remainresetcnt(::google::protobuf::uint32 value);

  // repeated .vmsg.CSBlackProductInfo Products = 4;
  inline int products_size() const;
  inline void clear_products();
  static const int kProductsFieldNumber = 4;
  inline const ::vmsg::CSBlackProductInfo& products(int index) const;
  inline ::vmsg::CSBlackProductInfo* mutable_products(int index);
  inline ::vmsg::CSBlackProductInfo* add_products();
  inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSBlackProductInfo >&
      products() const;
  inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSBlackProductInfo >*
      mutable_products();

  // @@protoc_insertion_point(class_scope:vmsg.CSBlackMarketInfo)
 private:
  inline void set_has_remaintime();
  inline void clear_has_remaintime();
  inline void set_has_resetcost();
  inline void clear_has_resetcost();
  inline void set_has_remainresetcnt();
  inline void clear_has_remainresetcnt();

  ::google::protobuf::uint32 remaintime_;
  ::google::protobuf::uint32 resetcost_;
  ::google::protobuf::RepeatedPtrField< ::vmsg::CSBlackProductInfo > products_;
  ::google::protobuf::uint32 remainresetcnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBlackMarketInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSQuickLoginRqst : public ::google::protobuf::MessageLite {
 public:
  CSQuickLoginRqst();
  virtual ~CSQuickLoginRqst();

  CSQuickLoginRqst(const CSQuickLoginRqst& from);

  inline CSQuickLoginRqst& operator=(const CSQuickLoginRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSQuickLoginRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQuickLoginRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQuickLoginRqst* other);

  // implements Message ----------------------------------------------

  CSQuickLoginRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQuickLoginRqst& from);
  void MergeFrom(const CSQuickLoginRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 NeedOSDCast = 1;
  inline bool has_needosdcast() const;
  inline void clear_needosdcast();
  static const int kNeedOSDCastFieldNumber = 1;
  inline ::google::protobuf::uint32 needosdcast() const;
  inline void set_needosdcast(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSQuickLoginRqst)
 private:
  inline void set_has_needosdcast();
  inline void clear_has_needosdcast();

  ::google::protobuf::uint32 needosdcast_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSQuickLoginRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSQuickLoginRsp : public ::google::protobuf::MessageLite {
 public:
  CSQuickLoginRsp();
  virtual ~CSQuickLoginRsp();

  CSQuickLoginRsp(const CSQuickLoginRsp& from);

  inline CSQuickLoginRsp& operator=(const CSQuickLoginRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSQuickLoginRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSQuickLoginRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSQuickLoginRsp* other);

  // implements Message ----------------------------------------------

  CSQuickLoginRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSQuickLoginRsp& from);
  void MergeFrom(const CSQuickLoginRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 QuickKey = 1;
  inline bool has_quickkey() const;
  inline void clear_quickkey();
  static const int kQuickKeyFieldNumber = 1;
  inline ::google::protobuf::uint64 quickkey() const;
  inline void set_quickkey(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSQuickLoginRsp)
 private:
  inline void set_has_quickkey();
  inline void clear_has_quickkey();

  ::google::protobuf::uint64 quickkey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSQuickLoginRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSBuyCoinInfo : public ::google::protobuf::MessageLite {
 public:
  CSBuyCoinInfo();
  virtual ~CSBuyCoinInfo();

  CSBuyCoinInfo(const CSBuyCoinInfo& from);

  inline CSBuyCoinInfo& operator=(const CSBuyCoinInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBuyCoinInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBuyCoinInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBuyCoinInfo* other);

  // implements Message ----------------------------------------------

  CSBuyCoinInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBuyCoinInfo& from);
  void MergeFrom(const CSBuyCoinInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 RemainCnt = 1;
  inline bool has_remaincnt() const;
  inline void clear_remaincnt();
  static const int kRemainCntFieldNumber = 1;
  inline ::google::protobuf::uint32 remaincnt() const;
  inline void set_remaincnt(::google::protobuf::uint32 value);

  // required uint32 NextCostGold = 2;
  inline bool has_nextcostgold() const;
  inline void clear_nextcostgold();
  static const int kNextCostGoldFieldNumber = 2;
  inline ::google::protobuf::uint32 nextcostgold() const;
  inline void set_nextcostgold(::google::protobuf::uint32 value);

  // required uint32 NextCoin = 3;
  inline bool has_nextcoin() const;
  inline void clear_nextcoin();
  static const int kNextCoinFieldNumber = 3;
  inline ::google::protobuf::uint32 nextcoin() const;
  inline void set_nextcoin(::google::protobuf::uint32 value);

  // required uint32 MaxCnt = 4;
  inline bool has_maxcnt() const;
  inline void clear_maxcnt();
  static const int kMaxCntFieldNumber = 4;
  inline ::google::protobuf::uint32 maxcnt() const;
  inline void set_maxcnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSBuyCoinInfo)
 private:
  inline void set_has_remaincnt();
  inline void clear_has_remaincnt();
  inline void set_has_nextcostgold();
  inline void clear_has_nextcostgold();
  inline void set_has_nextcoin();
  inline void clear_has_nextcoin();
  inline void set_has_maxcnt();
  inline void clear_has_maxcnt();

  ::google::protobuf::uint32 remaincnt_;
  ::google::protobuf::uint32 nextcostgold_;
  ::google::protobuf::uint32 nextcoin_;
  ::google::protobuf::uint32 maxcnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBuyCoinInfo* default_instance_;
};
// -------------------------------------------------------------------

class CSBuyCoinRsp : public ::google::protobuf::MessageLite {
 public:
  CSBuyCoinRsp();
  virtual ~CSBuyCoinRsp();

  CSBuyCoinRsp(const CSBuyCoinRsp& from);

  inline CSBuyCoinRsp& operator=(const CSBuyCoinRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSBuyCoinRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSBuyCoinRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSBuyCoinRsp* other);

  // implements Message ----------------------------------------------

  CSBuyCoinRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSBuyCoinRsp& from);
  void MergeFrom(const CSBuyCoinRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .vmsg.CSBuyCoinInfo Info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::vmsg::CSBuyCoinInfo& info() const;
  inline ::vmsg::CSBuyCoinInfo* mutable_info();
  inline ::vmsg::CSBuyCoinInfo* release_info();
  inline void set_allocated_info(::vmsg::CSBuyCoinInfo* info);

  // required uint32 CritMulti = 2;
  inline bool has_critmulti() const;
  inline void clear_critmulti();
  static const int kCritMultiFieldNumber = 2;
  inline ::google::protobuf::uint32 critmulti() const;
  inline void set_critmulti(::google::protobuf::uint32 value);

  // required uint32 Coin = 3;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 3;
  inline ::google::protobuf::uint32 coin() const;
  inline void set_coin(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSBuyCoinRsp)
 private:
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_critmulti();
  inline void clear_has_critmulti();
  inline void set_has_coin();
  inline void clear_has_coin();

  ::vmsg::CSBuyCoinInfo* info_;
  ::google::protobuf::uint32 critmulti_;
  ::google::protobuf::uint32 coin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSBuyCoinRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSGuestRegisterRsp : public ::google::protobuf::MessageLite {
 public:
  CSGuestRegisterRsp();
  virtual ~CSGuestRegisterRsp();

  CSGuestRegisterRsp(const CSGuestRegisterRsp& from);

  inline CSGuestRegisterRsp& operator=(const CSGuestRegisterRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSGuestRegisterRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGuestRegisterRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGuestRegisterRsp* other);

  // implements Message ----------------------------------------------

  CSGuestRegisterRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGuestRegisterRsp& from);
  void MergeFrom(const CSGuestRegisterRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string GuestOpenID = 1;
  inline bool has_guestopenid() const;
  inline void clear_guestopenid();
  static const int kGuestOpenIDFieldNumber = 1;
  inline const ::std::string& guestopenid() const;
  inline void set_guestopenid(const ::std::string& value);
  inline void set_guestopenid(const char* value);
  inline void set_guestopenid(const char* value, size_t size);
  inline ::std::string* mutable_guestopenid();
  inline ::std::string* release_guestopenid();
  inline void set_allocated_guestopenid(::std::string* guestopenid);

  // required uint64 Uin = 2;
  inline bool has_uin() const;
  inline void clear_uin();
  static const int kUinFieldNumber = 2;
  inline ::google::protobuf::uint64 uin() const;
  inline void set_uin(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSGuestRegisterRsp)
 private:
  inline void set_has_guestopenid();
  inline void clear_has_guestopenid();
  inline void set_has_uin();
  inline void clear_has_uin();

  ::std::string* guestopenid_;
  ::google::protobuf::uint64 uin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSGuestRegisterRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSGuestBindRqst : public ::google::protobuf::MessageLite {
 public:
  CSGuestBindRqst();
  virtual ~CSGuestBindRqst();

  CSGuestBindRqst(const CSGuestBindRqst& from);

  inline CSGuestBindRqst& operator=(const CSGuestBindRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSGuestBindRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSGuestBindRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSGuestBindRqst* other);

  // implements Message ----------------------------------------------

  CSGuestBindRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSGuestBindRqst& from);
  void MergeFrom(const CSGuestBindRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string GuestOpenID = 1;
  inline bool has_guestopenid() const;
  inline void clear_guestopenid();
  static const int kGuestOpenIDFieldNumber = 1;
  inline const ::std::string& guestopenid() const;
  inline void set_guestopenid(const ::std::string& value);
  inline void set_guestopenid(const char* value);
  inline void set_guestopenid(const char* value, size_t size);
  inline ::std::string* mutable_guestopenid();
  inline ::std::string* release_guestopenid();
  inline void set_allocated_guestopenid(::std::string* guestopenid);

  // required string FormalOpenID = 2;
  inline bool has_formalopenid() const;
  inline void clear_formalopenid();
  static const int kFormalOpenIDFieldNumber = 2;
  inline const ::std::string& formalopenid() const;
  inline void set_formalopenid(const ::std::string& value);
  inline void set_formalopenid(const char* value);
  inline void set_formalopenid(const char* value, size_t size);
  inline ::std::string* mutable_formalopenid();
  inline ::std::string* release_formalopenid();
  inline void set_allocated_formalopenid(::std::string* formalopenid);

  // @@protoc_insertion_point(class_scope:vmsg.CSGuestBindRqst)
 private:
  inline void set_has_guestopenid();
  inline void clear_has_guestopenid();
  inline void set_has_formalopenid();
  inline void clear_has_formalopenid();

  ::std::string* guestopenid_;
  ::std::string* formalopenid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSGuestBindRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerEnforceMyselfRqst : public ::google::protobuf::MessageLite {
 public:
  CSPlayerEnforceMyselfRqst();
  virtual ~CSPlayerEnforceMyselfRqst();

  CSPlayerEnforceMyselfRqst(const CSPlayerEnforceMyselfRqst& from);

  inline CSPlayerEnforceMyselfRqst& operator=(const CSPlayerEnforceMyselfRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerEnforceMyselfRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerEnforceMyselfRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerEnforceMyselfRqst* other);

  // implements Message ----------------------------------------------

  CSPlayerEnforceMyselfRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerEnforceMyselfRqst& from);
  void MergeFrom(const CSPlayerEnforceMyselfRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 EnforceType = 1;
  inline bool has_enforcetype() const;
  inline void clear_enforcetype();
  static const int kEnforceTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 enforcetype() const;
  inline void set_enforcetype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerEnforceMyselfRqst)
 private:
  inline void set_has_enforcetype();
  inline void clear_has_enforcetype();

  ::google::protobuf::uint32 enforcetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerEnforceMyselfRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerEnforceMyselfRsp : public ::google::protobuf::MessageLite {
 public:
  CSPlayerEnforceMyselfRsp();
  virtual ~CSPlayerEnforceMyselfRsp();

  CSPlayerEnforceMyselfRsp(const CSPlayerEnforceMyselfRsp& from);

  inline CSPlayerEnforceMyselfRsp& operator=(const CSPlayerEnforceMyselfRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerEnforceMyselfRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerEnforceMyselfRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerEnforceMyselfRsp* other);

  // implements Message ----------------------------------------------

  CSPlayerEnforceMyselfRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerEnforceMyselfRsp& from);
  void MergeFrom(const CSPlayerEnforceMyselfRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 HPAdd = 1;
  inline bool has_hpadd() const;
  inline void clear_hpadd();
  static const int kHPAddFieldNumber = 1;
  inline ::google::protobuf::int32 hpadd() const;
  inline void set_hpadd(::google::protobuf::int32 value);

  // required int32 AtkAdd = 2;
  inline bool has_atkadd() const;
  inline void clear_atkadd();
  static const int kAtkAddFieldNumber = 2;
  inline ::google::protobuf::int32 atkadd() const;
  inline void set_atkadd(::google::protobuf::int32 value);

  // required int32 DefAdd = 3;
  inline bool has_defadd() const;
  inline void clear_defadd();
  static const int kDefAddFieldNumber = 3;
  inline ::google::protobuf::int32 defadd() const;
  inline void set_defadd(::google::protobuf::int32 value);

  // required uint32 TotalHPAdd = 4;
  inline bool has_totalhpadd() const;
  inline void clear_totalhpadd();
  static const int kTotalHPAddFieldNumber = 4;
  inline ::google::protobuf::uint32 totalhpadd() const;
  inline void set_totalhpadd(::google::protobuf::uint32 value);

  // required uint32 TotalAtkAdd = 5;
  inline bool has_totalatkadd() const;
  inline void clear_totalatkadd();
  static const int kTotalAtkAddFieldNumber = 5;
  inline ::google::protobuf::uint32 totalatkadd() const;
  inline void set_totalatkadd(::google::protobuf::uint32 value);

  // required uint32 TotalDefAdd = 6;
  inline bool has_totaldefadd() const;
  inline void clear_totaldefadd();
  static const int kTotalDefAddFieldNumber = 6;
  inline ::google::protobuf::uint32 totaldefadd() const;
  inline void set_totaldefadd(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerEnforceMyselfRsp)
 private:
  inline void set_has_hpadd();
  inline void clear_has_hpadd();
  inline void set_has_atkadd();
  inline void clear_has_atkadd();
  inline void set_has_defadd();
  inline void clear_has_defadd();
  inline void set_has_totalhpadd();
  inline void clear_has_totalhpadd();
  inline void set_has_totalatkadd();
  inline void clear_has_totalatkadd();
  inline void set_has_totaldefadd();
  inline void clear_has_totaldefadd();

  ::google::protobuf::int32 hpadd_;
  ::google::protobuf::int32 atkadd_;
  ::google::protobuf::int32 defadd_;
  ::google::protobuf::uint32 totalhpadd_;
  ::google::protobuf::uint32 totalatkadd_;
  ::google::protobuf::uint32 totaldefadd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerEnforceMyselfRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerEnforceMyselfConfirmRqst : public ::google::protobuf::MessageLite {
 public:
  CSPlayerEnforceMyselfConfirmRqst();
  virtual ~CSPlayerEnforceMyselfConfirmRqst();

  CSPlayerEnforceMyselfConfirmRqst(const CSPlayerEnforceMyselfConfirmRqst& from);

  inline CSPlayerEnforceMyselfConfirmRqst& operator=(const CSPlayerEnforceMyselfConfirmRqst& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerEnforceMyselfConfirmRqst& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerEnforceMyselfConfirmRqst* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerEnforceMyselfConfirmRqst* other);

  // implements Message ----------------------------------------------

  CSPlayerEnforceMyselfConfirmRqst* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerEnforceMyselfConfirmRqst& from);
  void MergeFrom(const CSPlayerEnforceMyselfConfirmRqst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 IsAccept = 1;
  inline bool has_isaccept() const;
  inline void clear_isaccept();
  static const int kIsAcceptFieldNumber = 1;
  inline ::google::protobuf::uint32 isaccept() const;
  inline void set_isaccept(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerEnforceMyselfConfirmRqst)
 private:
  inline void set_has_isaccept();
  inline void clear_has_isaccept();

  ::google::protobuf::uint32 isaccept_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerEnforceMyselfConfirmRqst* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerEnforceMyselfConfirmRsp : public ::google::protobuf::MessageLite {
 public:
  CSPlayerEnforceMyselfConfirmRsp();
  virtual ~CSPlayerEnforceMyselfConfirmRsp();

  CSPlayerEnforceMyselfConfirmRsp(const CSPlayerEnforceMyselfConfirmRsp& from);

  inline CSPlayerEnforceMyselfConfirmRsp& operator=(const CSPlayerEnforceMyselfConfirmRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerEnforceMyselfConfirmRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerEnforceMyselfConfirmRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerEnforceMyselfConfirmRsp* other);

  // implements Message ----------------------------------------------

  CSPlayerEnforceMyselfConfirmRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerEnforceMyselfConfirmRsp& from);
  void MergeFrom(const CSPlayerEnforceMyselfConfirmRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 TotalHPAdd = 1;
  inline bool has_totalhpadd() const;
  inline void clear_totalhpadd();
  static const int kTotalHPAddFieldNumber = 1;
  inline ::google::protobuf::uint32 totalhpadd() const;
  inline void set_totalhpadd(::google::protobuf::uint32 value);

  // required uint32 TotalAtkAdd = 2;
  inline bool has_totalatkadd() const;
  inline void clear_totalatkadd();
  static const int kTotalAtkAddFieldNumber = 2;
  inline ::google::protobuf::uint32 totalatkadd() const;
  inline void set_totalatkadd(::google::protobuf::uint32 value);

  // required uint32 TotalDefAdd = 3;
  inline bool has_totaldefadd() const;
  inline void clear_totaldefadd();
  static const int kTotalDefAddFieldNumber = 3;
  inline ::google::protobuf::uint32 totaldefadd() const;
  inline void set_totaldefadd(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerEnforceMyselfConfirmRsp)
 private:
  inline void set_has_totalhpadd();
  inline void clear_has_totalhpadd();
  inline void set_has_totalatkadd();
  inline void clear_has_totalatkadd();
  inline void set_has_totaldefadd();
  inline void clear_has_totaldefadd();

  ::google::protobuf::uint32 totalhpadd_;
  ::google::protobuf::uint32 totalatkadd_;
  ::google::protobuf::uint32 totaldefadd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerEnforceMyselfConfirmRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerEnforceMyselfQueryRsp : public ::google::protobuf::MessageLite {
 public:
  CSPlayerEnforceMyselfQueryRsp();
  virtual ~CSPlayerEnforceMyselfQueryRsp();

  CSPlayerEnforceMyselfQueryRsp(const CSPlayerEnforceMyselfQueryRsp& from);

  inline CSPlayerEnforceMyselfQueryRsp& operator=(const CSPlayerEnforceMyselfQueryRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerEnforceMyselfQueryRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerEnforceMyselfQueryRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerEnforceMyselfQueryRsp* other);

  // implements Message ----------------------------------------------

  CSPlayerEnforceMyselfQueryRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerEnforceMyselfQueryRsp& from);
  void MergeFrom(const CSPlayerEnforceMyselfQueryRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 TotalHPAdd = 1;
  inline bool has_totalhpadd() const;
  inline void clear_totalhpadd();
  static const int kTotalHPAddFieldNumber = 1;
  inline ::google::protobuf::uint32 totalhpadd() const;
  inline void set_totalhpadd(::google::protobuf::uint32 value);

  // required uint32 TotalAtkAdd = 2;
  inline bool has_totalatkadd() const;
  inline void clear_totalatkadd();
  static const int kTotalAtkAddFieldNumber = 2;
  inline ::google::protobuf::uint32 totalatkadd() const;
  inline void set_totalatkadd(::google::protobuf::uint32 value);

  // required uint32 TotalDefAdd = 3;
  inline bool has_totaldefadd() const;
  inline void clear_totaldefadd();
  static const int kTotalDefAddFieldNumber = 3;
  inline ::google::protobuf::uint32 totaldefadd() const;
  inline void set_totaldefadd(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerEnforceMyselfQueryRsp)
 private:
  inline void set_has_totalhpadd();
  inline void clear_has_totalhpadd();
  inline void set_has_totalatkadd();
  inline void clear_has_totalatkadd();
  inline void set_has_totaldefadd();
  inline void clear_has_totaldefadd();

  ::google::protobuf::uint32 totalhpadd_;
  ::google::protobuf::uint32 totalatkadd_;
  ::google::protobuf::uint32 totaldefadd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerEnforceMyselfQueryRsp* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerRequest : public ::google::protobuf::MessageLite {
 public:
  CSPlayerRequest();
  virtual ~CSPlayerRequest();

  CSPlayerRequest(const CSPlayerRequest& from);

  inline CSPlayerRequest& operator=(const CSPlayerRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerRequest* other);

  // implements Message ----------------------------------------------

  CSPlayerRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerRequest& from);
  void MergeFrom(const CSPlayerRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSRegPlayerInfoRqst RegPlayerInfo_Rqst = 1;
  inline bool has_regplayerinfo_rqst() const;
  inline void clear_regplayerinfo_rqst();
  static const int kRegPlayerInfoRqstFieldNumber = 1;
  inline const ::vmsg::CSRegPlayerInfoRqst& regplayerinfo_rqst() const;
  inline ::vmsg::CSRegPlayerInfoRqst* mutable_regplayerinfo_rqst();
  inline ::vmsg::CSRegPlayerInfoRqst* release_regplayerinfo_rqst();
  inline void set_allocated_regplayerinfo_rqst(::vmsg::CSRegPlayerInfoRqst* regplayerinfo_rqst);

  // optional .vmsg.CSRoleLoginRqst RoleLogin_Rqst = 2;
  inline bool has_rolelogin_rqst() const;
  inline void clear_rolelogin_rqst();
  static const int kRoleLoginRqstFieldNumber = 2;
  inline const ::vmsg::CSRoleLoginRqst& rolelogin_rqst() const;
  inline ::vmsg::CSRoleLoginRqst* mutable_rolelogin_rqst();
  inline ::vmsg::CSRoleLoginRqst* release_rolelogin_rqst();
  inline void set_allocated_rolelogin_rqst(::vmsg::CSRoleLoginRqst* rolelogin_rqst);

  // optional .vmsg.CSRoleLogoutRqst RoleLogout_Rqst = 3;
  inline bool has_rolelogout_rqst() const;
  inline void clear_rolelogout_rqst();
  static const int kRoleLogoutRqstFieldNumber = 3;
  inline const ::vmsg::CSRoleLogoutRqst& rolelogout_rqst() const;
  inline ::vmsg::CSRoleLogoutRqst* mutable_rolelogout_rqst();
  inline ::vmsg::CSRoleLogoutRqst* release_rolelogout_rqst();
  inline void set_allocated_rolelogout_rqst(::vmsg::CSRoleLogoutRqst* rolelogout_rqst);

  // optional .vmsg.CSChangePlayerEvolutionSkillRqst ChangeEvolutionSkill_Rqst = 4;
  inline bool has_changeevolutionskill_rqst() const;
  inline void clear_changeevolutionskill_rqst();
  static const int kChangeEvolutionSkillRqstFieldNumber = 4;
  inline const ::vmsg::CSChangePlayerEvolutionSkillRqst& changeevolutionskill_rqst() const;
  inline ::vmsg::CSChangePlayerEvolutionSkillRqst* mutable_changeevolutionskill_rqst();
  inline ::vmsg::CSChangePlayerEvolutionSkillRqst* release_changeevolutionskill_rqst();
  inline void set_allocated_changeevolutionskill_rqst(::vmsg::CSChangePlayerEvolutionSkillRqst* changeevolutionskill_rqst);

  // optional .vmsg.CSAttrStrengthenRqst AttrStrengthen_Rqst = 5;
  inline bool has_attrstrengthen_rqst() const;
  inline void clear_attrstrengthen_rqst();
  static const int kAttrStrengthenRqstFieldNumber = 5;
  inline const ::vmsg::CSAttrStrengthenRqst& attrstrengthen_rqst() const;
  inline ::vmsg::CSAttrStrengthenRqst* mutable_attrstrengthen_rqst();
  inline ::vmsg::CSAttrStrengthenRqst* release_attrstrengthen_rqst();
  inline void set_allocated_attrstrengthen_rqst(::vmsg::CSAttrStrengthenRqst* attrstrengthen_rqst);

  // optional .vmsg.CSWeaponLotRqst WeaponLot_Rqst = 6;
  inline bool has_weaponlot_rqst() const;
  inline void clear_weaponlot_rqst();
  static const int kWeaponLotRqstFieldNumber = 6;
  inline const ::vmsg::CSWeaponLotRqst& weaponlot_rqst() const;
  inline ::vmsg::CSWeaponLotRqst* mutable_weaponlot_rqst();
  inline ::vmsg::CSWeaponLotRqst* release_weaponlot_rqst();
  inline void set_allocated_weaponlot_rqst(::vmsg::CSWeaponLotRqst* weaponlot_rqst);

  // optional .vmsg.CSFetchRankAwardRqst FetchRankAward_Rqst = 7;
  inline bool has_fetchrankaward_rqst() const;
  inline void clear_fetchrankaward_rqst();
  static const int kFetchRankAwardRqstFieldNumber = 7;
  inline const ::vmsg::CSFetchRankAwardRqst& fetchrankaward_rqst() const;
  inline ::vmsg::CSFetchRankAwardRqst* mutable_fetchrankaward_rqst();
  inline ::vmsg::CSFetchRankAwardRqst* release_fetchrankaward_rqst();
  inline void set_allocated_fetchrankaward_rqst(::vmsg::CSFetchRankAwardRqst* fetchrankaward_rqst);

  // optional uint32 TalkWithNPC_Rqst = 8;
  inline bool has_talkwithnpc_rqst() const;
  inline void clear_talkwithnpc_rqst();
  static const int kTalkWithNPCRqstFieldNumber = 8;
  inline ::google::protobuf::uint32 talkwithnpc_rqst() const;
  inline void set_talkwithnpc_rqst(::google::protobuf::uint32 value);

  // optional uint32 GetVIPAward_Rqst = 9;
  inline bool has_getvipaward_rqst() const;
  inline void clear_getvipaward_rqst();
  static const int kGetVIPAwardRqstFieldNumber = 9;
  inline ::google::protobuf::uint32 getvipaward_rqst() const;
  inline void set_getvipaward_rqst(::google::protobuf::uint32 value);

  // optional uint64 QueryOtherPlayer_Rqst = 10;
  inline bool has_queryotherplayer_rqst() const;
  inline void clear_queryotherplayer_rqst();
  static const int kQueryOtherPlayerRqstFieldNumber = 10;
  inline ::google::protobuf::uint64 queryotherplayer_rqst() const;
  inline void set_queryotherplayer_rqst(::google::protobuf::uint64 value);

  // optional .vmsg.CSSetSettingParamRqst SetSettingParam_Rqst = 11;
  inline bool has_setsettingparam_rqst() const;
  inline void clear_setsettingparam_rqst();
  static const int kSetSettingParamRqstFieldNumber = 11;
  inline const ::vmsg::CSSetSettingParamRqst& setsettingparam_rqst() const;
  inline ::vmsg::CSSetSettingParamRqst* mutable_setsettingparam_rqst();
  inline ::vmsg::CSSetSettingParamRqst* release_setsettingparam_rqst();
  inline void set_allocated_setsettingparam_rqst(::vmsg::CSSetSettingParamRqst* setsettingparam_rqst);

  // optional uint32 BuyBlackMarket_Rqst = 12;
  inline bool has_buyblackmarket_rqst() const;
  inline void clear_buyblackmarket_rqst();
  static const int kBuyBlackMarketRqstFieldNumber = 12;
  inline ::google::protobuf::uint32 buyblackmarket_rqst() const;
  inline void set_buyblackmarket_rqst(::google::protobuf::uint32 value);

  // optional .vmsg.CSQuickLoginRqst QuickLogin_Rqst = 13;
  inline bool has_quicklogin_rqst() const;
  inline void clear_quicklogin_rqst();
  static const int kQuickLoginRqstFieldNumber = 13;
  inline const ::vmsg::CSQuickLoginRqst& quicklogin_rqst() const;
  inline ::vmsg::CSQuickLoginRqst* mutable_quicklogin_rqst();
  inline ::vmsg::CSQuickLoginRqst* release_quicklogin_rqst();
  inline void set_allocated_quicklogin_rqst(::vmsg::CSQuickLoginRqst* quicklogin_rqst);

  // optional .vmsg.CSGuestBindRqst GuestBind_Rqst = 14;
  inline bool has_guestbind_rqst() const;
  inline void clear_guestbind_rqst();
  static const int kGuestBindRqstFieldNumber = 14;
  inline const ::vmsg::CSGuestBindRqst& guestbind_rqst() const;
  inline ::vmsg::CSGuestBindRqst* mutable_guestbind_rqst();
  inline ::vmsg::CSGuestBindRqst* release_guestbind_rqst();
  inline void set_allocated_guestbind_rqst(::vmsg::CSGuestBindRqst* guestbind_rqst);

  // optional .vmsg.CSPlayerEnforceMyselfRqst PlayerEnforce_Rqst = 15;
  inline bool has_playerenforce_rqst() const;
  inline void clear_playerenforce_rqst();
  static const int kPlayerEnforceRqstFieldNumber = 15;
  inline const ::vmsg::CSPlayerEnforceMyselfRqst& playerenforce_rqst() const;
  inline ::vmsg::CSPlayerEnforceMyselfRqst* mutable_playerenforce_rqst();
  inline ::vmsg::CSPlayerEnforceMyselfRqst* release_playerenforce_rqst();
  inline void set_allocated_playerenforce_rqst(::vmsg::CSPlayerEnforceMyselfRqst* playerenforce_rqst);

  // optional .vmsg.CSPlayerEnforceMyselfConfirmRqst PlayerEnforceConfirm_Rqst = 16;
  inline bool has_playerenforceconfirm_rqst() const;
  inline void clear_playerenforceconfirm_rqst();
  static const int kPlayerEnforceConfirmRqstFieldNumber = 16;
  inline const ::vmsg::CSPlayerEnforceMyselfConfirmRqst& playerenforceconfirm_rqst() const;
  inline ::vmsg::CSPlayerEnforceMyselfConfirmRqst* mutable_playerenforceconfirm_rqst();
  inline ::vmsg::CSPlayerEnforceMyselfConfirmRqst* release_playerenforceconfirm_rqst();
  inline void set_allocated_playerenforceconfirm_rqst(::vmsg::CSPlayerEnforceMyselfConfirmRqst* playerenforceconfirm_rqst);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerRequest)
 private:
  inline void set_has_regplayerinfo_rqst();
  inline void clear_has_regplayerinfo_rqst();
  inline void set_has_rolelogin_rqst();
  inline void clear_has_rolelogin_rqst();
  inline void set_has_rolelogout_rqst();
  inline void clear_has_rolelogout_rqst();
  inline void set_has_changeevolutionskill_rqst();
  inline void clear_has_changeevolutionskill_rqst();
  inline void set_has_attrstrengthen_rqst();
  inline void clear_has_attrstrengthen_rqst();
  inline void set_has_weaponlot_rqst();
  inline void clear_has_weaponlot_rqst();
  inline void set_has_fetchrankaward_rqst();
  inline void clear_has_fetchrankaward_rqst();
  inline void set_has_talkwithnpc_rqst();
  inline void clear_has_talkwithnpc_rqst();
  inline void set_has_getvipaward_rqst();
  inline void clear_has_getvipaward_rqst();
  inline void set_has_queryotherplayer_rqst();
  inline void clear_has_queryotherplayer_rqst();
  inline void set_has_setsettingparam_rqst();
  inline void clear_has_setsettingparam_rqst();
  inline void set_has_buyblackmarket_rqst();
  inline void clear_has_buyblackmarket_rqst();
  inline void set_has_quicklogin_rqst();
  inline void clear_has_quicklogin_rqst();
  inline void set_has_guestbind_rqst();
  inline void clear_has_guestbind_rqst();
  inline void set_has_playerenforce_rqst();
  inline void clear_has_playerenforce_rqst();
  inline void set_has_playerenforceconfirm_rqst();
  inline void clear_has_playerenforceconfirm_rqst();

  ::vmsg::CSRegPlayerInfoRqst* regplayerinfo_rqst_;
  ::vmsg::CSRoleLoginRqst* rolelogin_rqst_;
  ::vmsg::CSRoleLogoutRqst* rolelogout_rqst_;
  ::vmsg::CSChangePlayerEvolutionSkillRqst* changeevolutionskill_rqst_;
  ::vmsg::CSAttrStrengthenRqst* attrstrengthen_rqst_;
  ::vmsg::CSWeaponLotRqst* weaponlot_rqst_;
  ::vmsg::CSFetchRankAwardRqst* fetchrankaward_rqst_;
  ::google::protobuf::uint32 talkwithnpc_rqst_;
  ::google::protobuf::uint32 getvipaward_rqst_;
  ::google::protobuf::uint64 queryotherplayer_rqst_;
  ::vmsg::CSSetSettingParamRqst* setsettingparam_rqst_;
  ::vmsg::CSQuickLoginRqst* quicklogin_rqst_;
  ::vmsg::CSGuestBindRqst* guestbind_rqst_;
  ::vmsg::CSPlayerEnforceMyselfRqst* playerenforce_rqst_;
  ::vmsg::CSPlayerEnforceMyselfConfirmRqst* playerenforceconfirm_rqst_;
  ::google::protobuf::uint32 buyblackmarket_rqst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerRequest* default_instance_;
};
// -------------------------------------------------------------------

class CSPlayerRespond : public ::google::protobuf::MessageLite {
 public:
  CSPlayerRespond();
  virtual ~CSPlayerRespond();

  CSPlayerRespond(const CSPlayerRespond& from);

  inline CSPlayerRespond& operator=(const CSPlayerRespond& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSPlayerRespond& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSPlayerRespond* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSPlayerRespond* other);

  // implements Message ----------------------------------------------

  CSPlayerRespond* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSPlayerRespond& from);
  void MergeFrom(const CSPlayerRespond& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vmsg.CSRegPlayerInfoRsp RegPlayerInfo_Rsp = 1;
  inline bool has_regplayerinfo_rsp() const;
  inline void clear_regplayerinfo_rsp();
  static const int kRegPlayerInfoRspFieldNumber = 1;
  inline const ::vmsg::CSRegPlayerInfoRsp& regplayerinfo_rsp() const;
  inline ::vmsg::CSRegPlayerInfoRsp* mutable_regplayerinfo_rsp();
  inline ::vmsg::CSRegPlayerInfoRsp* release_regplayerinfo_rsp();
  inline void set_allocated_regplayerinfo_rsp(::vmsg::CSRegPlayerInfoRsp* regplayerinfo_rsp);

  // optional .vmsg.CSQueryPlayerInfoRsp QueryPlayerInfo_Rsp = 2;
  inline bool has_queryplayerinfo_rsp() const;
  inline void clear_queryplayerinfo_rsp();
  static const int kQueryPlayerInfoRspFieldNumber = 2;
  inline const ::vmsg::CSQueryPlayerInfoRsp& queryplayerinfo_rsp() const;
  inline ::vmsg::CSQueryPlayerInfoRsp* mutable_queryplayerinfo_rsp();
  inline ::vmsg::CSQueryPlayerInfoRsp* release_queryplayerinfo_rsp();
  inline void set_allocated_queryplayerinfo_rsp(::vmsg::CSQueryPlayerInfoRsp* queryplayerinfo_rsp);

  // optional .vmsg.CSChangeArmorRsp ChangeArmor_Rsp = 3;
  inline bool has_changearmor_rsp() const;
  inline void clear_changearmor_rsp();
  static const int kChangeArmorRspFieldNumber = 3;
  inline const ::vmsg::CSChangeArmorRsp& changearmor_rsp() const;
  inline ::vmsg::CSChangeArmorRsp* mutable_changearmor_rsp();
  inline ::vmsg::CSChangeArmorRsp* release_changearmor_rsp();
  inline void set_allocated_changearmor_rsp(::vmsg::CSChangeArmorRsp* changearmor_rsp);

  // optional .vmsg.CSQueryRoleLstRsp RoleLst_Rsp = 4;
  inline bool has_rolelst_rsp() const;
  inline void clear_rolelst_rsp();
  static const int kRoleLstRspFieldNumber = 4;
  inline const ::vmsg::CSQueryRoleLstRsp& rolelst_rsp() const;
  inline ::vmsg::CSQueryRoleLstRsp* mutable_rolelst_rsp();
  inline ::vmsg::CSQueryRoleLstRsp* release_rolelst_rsp();
  inline void set_allocated_rolelst_rsp(::vmsg::CSQueryRoleLstRsp* rolelst_rsp);

  // optional .vmsg.CSRoleLoginRsp RoleLogin_Rsp = 5;
  inline bool has_rolelogin_rsp() const;
  inline void clear_rolelogin_rsp();
  static const int kRoleLoginRspFieldNumber = 5;
  inline const ::vmsg::CSRoleLoginRsp& rolelogin_rsp() const;
  inline ::vmsg::CSRoleLoginRsp* mutable_rolelogin_rsp();
  inline ::vmsg::CSRoleLoginRsp* release_rolelogin_rsp();
  inline void set_allocated_rolelogin_rsp(::vmsg::CSRoleLoginRsp* rolelogin_rsp);

  // optional .vmsg.CSRoleLogoutRsp RoleLogout_Rsp = 6;
  inline bool has_rolelogout_rsp() const;
  inline void clear_rolelogout_rsp();
  static const int kRoleLogoutRspFieldNumber = 6;
  inline const ::vmsg::CSRoleLogoutRsp& rolelogout_rsp() const;
  inline ::vmsg::CSRoleLogoutRsp* mutable_rolelogout_rsp();
  inline ::vmsg::CSRoleLogoutRsp* release_rolelogout_rsp();
  inline void set_allocated_rolelogout_rsp(::vmsg::CSRoleLogoutRsp* rolelogout_rsp);

  // optional .vmsg.CSPlayerManualNotify Manual_Notify = 7;
  inline bool has_manual_notify() const;
  inline void clear_manual_notify();
  static const int kManualNotifyFieldNumber = 7;
  inline const ::vmsg::CSPlayerManualNotify& manual_notify() const;
  inline ::vmsg::CSPlayerManualNotify* mutable_manual_notify();
  inline ::vmsg::CSPlayerManualNotify* release_manual_notify();
  inline void set_allocated_manual_notify(::vmsg::CSPlayerManualNotify* manual_notify);

  // optional .vmsg.CSBuyManualInfo QueryBuyManual_Rsp = 8;
  inline bool has_querybuymanual_rsp() const;
  inline void clear_querybuymanual_rsp();
  static const int kQueryBuyManualRspFieldNumber = 8;
  inline const ::vmsg::CSBuyManualInfo& querybuymanual_rsp() const;
  inline ::vmsg::CSBuyManualInfo* mutable_querybuymanual_rsp();
  inline ::vmsg::CSBuyManualInfo* release_querybuymanual_rsp();
  inline void set_allocated_querybuymanual_rsp(::vmsg::CSBuyManualInfo* querybuymanual_rsp);

  // optional .vmsg.CSBuyManualInfo BuyManual_Rsp = 9;
  inline bool has_buymanual_rsp() const;
  inline void clear_buymanual_rsp();
  static const int kBuyManualRspFieldNumber = 9;
  inline const ::vmsg::CSBuyManualInfo& buymanual_rsp() const;
  inline ::vmsg::CSBuyManualInfo* mutable_buymanual_rsp();
  inline ::vmsg::CSBuyManualInfo* release_buymanual_rsp();
  inline void set_allocated_buymanual_rsp(::vmsg::CSBuyManualInfo* buymanual_rsp);

  // optional .vmsg.CSQueryPlayerManualRsp QueryManual_Rsp = 10;
  inline bool has_querymanual_rsp() const;
  inline void clear_querymanual_rsp();
  static const int kQueryManualRspFieldNumber = 10;
  inline const ::vmsg::CSQueryPlayerManualRsp& querymanual_rsp() const;
  inline ::vmsg::CSQueryPlayerManualRsp* mutable_querymanual_rsp();
  inline ::vmsg::CSQueryPlayerManualRsp* release_querymanual_rsp();
  inline void set_allocated_querymanual_rsp(::vmsg::CSQueryPlayerManualRsp* querymanual_rsp);

  // optional .vmsg.CSPlayerDetailInfo QueryDetailInfo_Rsp = 11;
  inline bool has_querydetailinfo_rsp() const;
  inline void clear_querydetailinfo_rsp();
  static const int kQueryDetailInfoRspFieldNumber = 11;
  inline const ::vmsg::CSPlayerDetailInfo& querydetailinfo_rsp() const;
  inline ::vmsg::CSPlayerDetailInfo* mutable_querydetailinfo_rsp();
  inline ::vmsg::CSPlayerDetailInfo* release_querydetailinfo_rsp();
  inline void set_allocated_querydetailinfo_rsp(::vmsg::CSPlayerDetailInfo* querydetailinfo_rsp);

  // optional .vmsg.CSPlayerEvolutionInfo QueryEvolution_Rsp = 12;
  inline bool has_queryevolution_rsp() const;
  inline void clear_queryevolution_rsp();
  static const int kQueryEvolutionRspFieldNumber = 12;
  inline const ::vmsg::CSPlayerEvolutionInfo& queryevolution_rsp() const;
  inline ::vmsg::CSPlayerEvolutionInfo* mutable_queryevolution_rsp();
  inline ::vmsg::CSPlayerEvolutionInfo* release_queryevolution_rsp();
  inline void set_allocated_queryevolution_rsp(::vmsg::CSPlayerEvolutionInfo* queryevolution_rsp);

  // optional .vmsg.CSPlayerEvolutionSkillInfo QueryEvolutionSkill_Rsp = 13;
  inline bool has_queryevolutionskill_rsp() const;
  inline void clear_queryevolutionskill_rsp();
  static const int kQueryEvolutionSkillRspFieldNumber = 13;
  inline const ::vmsg::CSPlayerEvolutionSkillInfo& queryevolutionskill_rsp() const;
  inline ::vmsg::CSPlayerEvolutionSkillInfo* mutable_queryevolutionskill_rsp();
  inline ::vmsg::CSPlayerEvolutionSkillInfo* release_queryevolutionskill_rsp();
  inline void set_allocated_queryevolutionskill_rsp(::vmsg::CSPlayerEvolutionSkillInfo* queryevolutionskill_rsp);

  // optional .vmsg.CSChangePlayerEvolutionSkillRsp ChangeEvolutionSkill_Rsp = 14;
  inline bool has_changeevolutionskill_rsp() const;
  inline void clear_changeevolutionskill_rsp();
  static const int kChangeEvolutionSkillRspFieldNumber = 14;
  inline const ::vmsg::CSChangePlayerEvolutionSkillRsp& changeevolutionskill_rsp() const;
  inline ::vmsg::CSChangePlayerEvolutionSkillRsp* mutable_changeevolutionskill_rsp();
  inline ::vmsg::CSChangePlayerEvolutionSkillRsp* release_changeevolutionskill_rsp();
  inline void set_allocated_changeevolutionskill_rsp(::vmsg::CSChangePlayerEvolutionSkillRsp* changeevolutionskill_rsp);

  // optional .vmsg.CSPlayerEvolutionInfo Evolution_Rsp = 15;
  inline bool has_evolution_rsp() const;
  inline void clear_evolution_rsp();
  static const int kEvolutionRspFieldNumber = 15;
  inline const ::vmsg::CSPlayerEvolutionInfo& evolution_rsp() const;
  inline ::vmsg::CSPlayerEvolutionInfo* mutable_evolution_rsp();
  inline ::vmsg::CSPlayerEvolutionInfo* release_evolution_rsp();
  inline void set_allocated_evolution_rsp(::vmsg::CSPlayerEvolutionInfo* evolution_rsp);

  // optional .vmsg.CSAttrStrengthenInfo QueryAttrStengthen_Rsp = 16;
  inline bool has_queryattrstengthen_rsp() const;
  inline void clear_queryattrstengthen_rsp();
  static const int kQueryAttrStengthenRspFieldNumber = 16;
  inline const ::vmsg::CSAttrStrengthenInfo& queryattrstengthen_rsp() const;
  inline ::vmsg::CSAttrStrengthenInfo* mutable_queryattrstengthen_rsp();
  inline ::vmsg::CSAttrStrengthenInfo* release_queryattrstengthen_rsp();
  inline void set_allocated_queryattrstengthen_rsp(::vmsg::CSAttrStrengthenInfo* queryattrstengthen_rsp);

  // optional .vmsg.CSAttrStrengthenInfo AttrStengthen_Rsp = 17;
  inline bool has_attrstengthen_rsp() const;
  inline void clear_attrstengthen_rsp();
  static const int kAttrStengthenRspFieldNumber = 17;
  inline const ::vmsg::CSAttrStrengthenInfo& attrstengthen_rsp() const;
  inline ::vmsg::CSAttrStrengthenInfo* mutable_attrstengthen_rsp();
  inline ::vmsg::CSAttrStrengthenInfo* release_attrstengthen_rsp();
  inline void set_allocated_attrstengthen_rsp(::vmsg::CSAttrStrengthenInfo* attrstengthen_rsp);

  // optional .vmsg.CSWeaponLotQueryRsp QueryWeaponLot_Rsp = 18;
  inline bool has_queryweaponlot_rsp() const;
  inline void clear_queryweaponlot_rsp();
  static const int kQueryWeaponLotRspFieldNumber = 18;
  inline const ::vmsg::CSWeaponLotQueryRsp& queryweaponlot_rsp() const;
  inline ::vmsg::CSWeaponLotQueryRsp* mutable_queryweaponlot_rsp();
  inline ::vmsg::CSWeaponLotQueryRsp* release_queryweaponlot_rsp();
  inline void set_allocated_queryweaponlot_rsp(::vmsg::CSWeaponLotQueryRsp* queryweaponlot_rsp);

  // optional .vmsg.CSWeaponLotRsp WeaponLot_Rsp = 19;
  inline bool has_weaponlot_rsp() const;
  inline void clear_weaponlot_rsp();
  static const int kWeaponLotRspFieldNumber = 19;
  inline const ::vmsg::CSWeaponLotRsp& weaponlot_rsp() const;
  inline ::vmsg::CSWeaponLotRsp* mutable_weaponlot_rsp();
  inline ::vmsg::CSWeaponLotRsp* release_weaponlot_rsp();
  inline void set_allocated_weaponlot_rsp(::vmsg::CSWeaponLotRsp* weaponlot_rsp);

  // optional .vmsg.CSAwardRankRsp QueryAwardRank_Rsp = 20;
  inline bool has_queryawardrank_rsp() const;
  inline void clear_queryawardrank_rsp();
  static const int kQueryAwardRankRspFieldNumber = 20;
  inline const ::vmsg::CSAwardRankRsp& queryawardrank_rsp() const;
  inline ::vmsg::CSAwardRankRsp* mutable_queryawardrank_rsp();
  inline ::vmsg::CSAwardRankRsp* release_queryawardrank_rsp();
  inline void set_allocated_queryawardrank_rsp(::vmsg::CSAwardRankRsp* queryawardrank_rsp);

  // optional .vmsg.CSAwardRankRsp FetchRankAward_Rsp = 21;
  inline bool has_fetchrankaward_rsp() const;
  inline void clear_fetchrankaward_rsp();
  static const int kFetchRankAwardRspFieldNumber = 21;
  inline const ::vmsg::CSAwardRankRsp& fetchrankaward_rsp() const;
  inline ::vmsg::CSAwardRankRsp* mutable_fetchrankaward_rsp();
  inline ::vmsg::CSAwardRankRsp* release_fetchrankaward_rsp();
  inline void set_allocated_fetchrankaward_rsp(::vmsg::CSAwardRankRsp* fetchrankaward_rsp);

  // optional .vmsg.CSPlayerLvUpRsp PlayerLvUp_Rsp = 22;
  inline bool has_playerlvup_rsp() const;
  inline void clear_playerlvup_rsp();
  static const int kPlayerLvUpRspFieldNumber = 22;
  inline const ::vmsg::CSPlayerLvUpRsp& playerlvup_rsp() const;
  inline ::vmsg::CSPlayerLvUpRsp* mutable_playerlvup_rsp();
  inline ::vmsg::CSPlayerLvUpRsp* release_playerlvup_rsp();
  inline void set_allocated_playerlvup_rsp(::vmsg::CSPlayerLvUpRsp* playerlvup_rsp);

  // optional uint64 PlayerCoin_Notify = 23;
  inline bool has_playercoin_notify() const;
  inline void clear_playercoin_notify();
  static const int kPlayerCoinNotifyFieldNumber = 23;
  inline ::google::protobuf::uint64 playercoin_notify() const;
  inline void set_playercoin_notify(::google::protobuf::uint64 value);

  // optional .vmsg.CSVIPNotify VIP_Notify = 24;
  inline bool has_vip_notify() const;
  inline void clear_vip_notify();
  static const int kVIPNotifyFieldNumber = 24;
  inline const ::vmsg::CSVIPNotify& vip_notify() const;
  inline ::vmsg::CSVIPNotify* mutable_vip_notify();
  inline ::vmsg::CSVIPNotify* release_vip_notify();
  inline void set_allocated_vip_notify(::vmsg::CSVIPNotify* vip_notify);

  // optional .vmsg.CSVIPInfos QueryVIPInfo_Rsp = 25;
  inline bool has_queryvipinfo_rsp() const;
  inline void clear_queryvipinfo_rsp();
  static const int kQueryVIPInfoRspFieldNumber = 25;
  inline const ::vmsg::CSVIPInfos& queryvipinfo_rsp() const;
  inline ::vmsg::CSVIPInfos* mutable_queryvipinfo_rsp();
  inline ::vmsg::CSVIPInfos* release_queryvipinfo_rsp();
  inline void set_allocated_queryvipinfo_rsp(::vmsg::CSVIPInfos* queryvipinfo_rsp);

  // optional .vmsg.CSFightPowerNotify FightPower_Notify = 26;
  inline bool has_fightpower_notify() const;
  inline void clear_fightpower_notify();
  static const int kFightPowerNotifyFieldNumber = 26;
  inline const ::vmsg::CSFightPowerNotify& fightpower_notify() const;
  inline ::vmsg::CSFightPowerNotify* mutable_fightpower_notify();
  inline ::vmsg::CSFightPowerNotify* release_fightpower_notify();
  inline void set_allocated_fightpower_notify(::vmsg::CSFightPowerNotify* fightpower_notify);

  // optional .vmsg.CSOtherPlayerInfoRsp QueryOtherPlayer_Rsp = 27;
  inline bool has_queryotherplayer_rsp() const;
  inline void clear_queryotherplayer_rsp();
  static const int kQueryOtherPlayerRspFieldNumber = 27;
  inline const ::vmsg::CSOtherPlayerInfoRsp& queryotherplayer_rsp() const;
  inline ::vmsg::CSOtherPlayerInfoRsp* mutable_queryotherplayer_rsp();
  inline ::vmsg::CSOtherPlayerInfoRsp* release_queryotherplayer_rsp();
  inline void set_allocated_queryotherplayer_rsp(::vmsg::CSOtherPlayerInfoRsp* queryotherplayer_rsp);

  // optional .vmsg.CSBlackMarketInfo QueryBlackMarket_Rsp = 28;
  inline bool has_queryblackmarket_rsp() const;
  inline void clear_queryblackmarket_rsp();
  static const int kQueryBlackMarketRspFieldNumber = 28;
  inline const ::vmsg::CSBlackMarketInfo& queryblackmarket_rsp() const;
  inline ::vmsg::CSBlackMarketInfo* mutable_queryblackmarket_rsp();
  inline ::vmsg::CSBlackMarketInfo* release_queryblackmarket_rsp();
  inline void set_allocated_queryblackmarket_rsp(::vmsg::CSBlackMarketInfo* queryblackmarket_rsp);

  // optional .vmsg.CSBlackMarketInfo BuyBlackMarket_Rsp = 29;
  inline bool has_buyblackmarket_rsp() const;
  inline void clear_buyblackmarket_rsp();
  static const int kBuyBlackMarketRspFieldNumber = 29;
  inline const ::vmsg::CSBlackMarketInfo& buyblackmarket_rsp() const;
  inline ::vmsg::CSBlackMarketInfo* mutable_buyblackmarket_rsp();
  inline ::vmsg::CSBlackMarketInfo* release_buyblackmarket_rsp();
  inline void set_allocated_buyblackmarket_rsp(::vmsg::CSBlackMarketInfo* buyblackmarket_rsp);

  // optional .vmsg.CSBlackMarketInfo ResetBlackMarket_Rsp = 30;
  inline bool has_resetblackmarket_rsp() const;
  inline void clear_resetblackmarket_rsp();
  static const int kResetBlackMarketRspFieldNumber = 30;
  inline const ::vmsg::CSBlackMarketInfo& resetblackmarket_rsp() const;
  inline ::vmsg::CSBlackMarketInfo* mutable_resetblackmarket_rsp();
  inline ::vmsg::CSBlackMarketInfo* release_resetblackmarket_rsp();
  inline void set_allocated_resetblackmarket_rsp(::vmsg::CSBlackMarketInfo* resetblackmarket_rsp);

  // optional .vmsg.CSQuickLoginRsp QuickLogin_Rsp = 31;
  inline bool has_quicklogin_rsp() const;
  inline void clear_quicklogin_rsp();
  static const int kQuickLoginRspFieldNumber = 31;
  inline const ::vmsg::CSQuickLoginRsp& quicklogin_rsp() const;
  inline ::vmsg::CSQuickLoginRsp* mutable_quicklogin_rsp();
  inline ::vmsg::CSQuickLoginRsp* release_quicklogin_rsp();
  inline void set_allocated_quicklogin_rsp(::vmsg::CSQuickLoginRsp* quicklogin_rsp);

  // optional .vmsg.CSBuyCoinInfo QueryBuyCoin_Rsp = 32;
  inline bool has_querybuycoin_rsp() const;
  inline void clear_querybuycoin_rsp();
  static const int kQueryBuyCoinRspFieldNumber = 32;
  inline const ::vmsg::CSBuyCoinInfo& querybuycoin_rsp() const;
  inline ::vmsg::CSBuyCoinInfo* mutable_querybuycoin_rsp();
  inline ::vmsg::CSBuyCoinInfo* release_querybuycoin_rsp();
  inline void set_allocated_querybuycoin_rsp(::vmsg::CSBuyCoinInfo* querybuycoin_rsp);

  // optional .vmsg.CSBuyCoinRsp BuyCoin_Rsp = 33;
  inline bool has_buycoin_rsp() const;
  inline void clear_buycoin_rsp();
  static const int kBuyCoinRspFieldNumber = 33;
  inline const ::vmsg::CSBuyCoinRsp& buycoin_rsp() const;
  inline ::vmsg::CSBuyCoinRsp* mutable_buycoin_rsp();
  inline ::vmsg::CSBuyCoinRsp* release_buycoin_rsp();
  inline void set_allocated_buycoin_rsp(::vmsg::CSBuyCoinRsp* buycoin_rsp);

  // optional .vmsg.CSDailyRegInfo DailyReg_Rsp = 34;
  inline bool has_dailyreg_rsp() const;
  inline void clear_dailyreg_rsp();
  static const int kDailyRegRspFieldNumber = 34;
  inline const ::vmsg::CSDailyRegInfo& dailyreg_rsp() const;
  inline ::vmsg::CSDailyRegInfo* mutable_dailyreg_rsp();
  inline ::vmsg::CSDailyRegInfo* release_dailyreg_rsp();
  inline void set_allocated_dailyreg_rsp(::vmsg::CSDailyRegInfo* dailyreg_rsp);

  // optional .vmsg.CSMonthCardInfo GetMonthCardAward_Rsp = 35;
  inline bool has_getmonthcardaward_rsp() const;
  inline void clear_getmonthcardaward_rsp();
  static const int kGetMonthCardAwardRspFieldNumber = 35;
  inline const ::vmsg::CSMonthCardInfo& getmonthcardaward_rsp() const;
  inline ::vmsg::CSMonthCardInfo* mutable_getmonthcardaward_rsp();
  inline ::vmsg::CSMonthCardInfo* release_getmonthcardaward_rsp();
  inline void set_allocated_getmonthcardaward_rsp(::vmsg::CSMonthCardInfo* getmonthcardaward_rsp);

  // optional .vmsg.CSMonthCardInfo PushMonthCard_Notify = 36;
  inline bool has_pushmonthcard_notify() const;
  inline void clear_pushmonthcard_notify();
  static const int kPushMonthCardNotifyFieldNumber = 36;
  inline const ::vmsg::CSMonthCardInfo& pushmonthcard_notify() const;
  inline ::vmsg::CSMonthCardInfo* mutable_pushmonthcard_notify();
  inline ::vmsg::CSMonthCardInfo* release_pushmonthcard_notify();
  inline void set_allocated_pushmonthcard_notify(::vmsg::CSMonthCardInfo* pushmonthcard_notify);

  // optional uint32 ClaimedManual = 37;
  inline bool has_claimedmanual() const;
  inline void clear_claimedmanual();
  static const int kClaimedManualFieldNumber = 37;
  inline ::google::protobuf::uint32 claimedmanual() const;
  inline void set_claimedmanual(::google::protobuf::uint32 value);

  // optional .vmsg.CSGuestRegisterRsp GuestRegister_Rsp = 38;
  inline bool has_guestregister_rsp() const;
  inline void clear_guestregister_rsp();
  static const int kGuestRegisterRspFieldNumber = 38;
  inline const ::vmsg::CSGuestRegisterRsp& guestregister_rsp() const;
  inline ::vmsg::CSGuestRegisterRsp* mutable_guestregister_rsp();
  inline ::vmsg::CSGuestRegisterRsp* release_guestregister_rsp();
  inline void set_allocated_guestregister_rsp(::vmsg::CSGuestRegisterRsp* guestregister_rsp);

  // optional .vmsg.CSPlayerEnforceMyselfRsp PlayerEnforce_Rsp = 39;
  inline bool has_playerenforce_rsp() const;
  inline void clear_playerenforce_rsp();
  static const int kPlayerEnforceRspFieldNumber = 39;
  inline const ::vmsg::CSPlayerEnforceMyselfRsp& playerenforce_rsp() const;
  inline ::vmsg::CSPlayerEnforceMyselfRsp* mutable_playerenforce_rsp();
  inline ::vmsg::CSPlayerEnforceMyselfRsp* release_playerenforce_rsp();
  inline void set_allocated_playerenforce_rsp(::vmsg::CSPlayerEnforceMyselfRsp* playerenforce_rsp);

  // optional .vmsg.CSPlayerEnforceMyselfConfirmRsp PlayerEnforceConfirm_Rsp = 40;
  inline bool has_playerenforceconfirm_rsp() const;
  inline void clear_playerenforceconfirm_rsp();
  static const int kPlayerEnforceConfirmRspFieldNumber = 40;
  inline const ::vmsg::CSPlayerEnforceMyselfConfirmRsp& playerenforceconfirm_rsp() const;
  inline ::vmsg::CSPlayerEnforceMyselfConfirmRsp* mutable_playerenforceconfirm_rsp();
  inline ::vmsg::CSPlayerEnforceMyselfConfirmRsp* release_playerenforceconfirm_rsp();
  inline void set_allocated_playerenforceconfirm_rsp(::vmsg::CSPlayerEnforceMyselfConfirmRsp* playerenforceconfirm_rsp);

  // optional .vmsg.CSPlayerEnforceMyselfQueryRsp PlayerEnforceQuery_Rsp = 41;
  inline bool has_playerenforcequery_rsp() const;
  inline void clear_playerenforcequery_rsp();
  static const int kPlayerEnforceQueryRspFieldNumber = 41;
  inline const ::vmsg::CSPlayerEnforceMyselfQueryRsp& playerenforcequery_rsp() const;
  inline ::vmsg::CSPlayerEnforceMyselfQueryRsp* mutable_playerenforcequery_rsp();
  inline ::vmsg::CSPlayerEnforceMyselfQueryRsp* release_playerenforcequery_rsp();
  inline void set_allocated_playerenforcequery_rsp(::vmsg::CSPlayerEnforceMyselfQueryRsp* playerenforcequery_rsp);

  // @@protoc_insertion_point(class_scope:vmsg.CSPlayerRespond)
 private:
  inline void set_has_regplayerinfo_rsp();
  inline void clear_has_regplayerinfo_rsp();
  inline void set_has_queryplayerinfo_rsp();
  inline void clear_has_queryplayerinfo_rsp();
  inline void set_has_changearmor_rsp();
  inline void clear_has_changearmor_rsp();
  inline void set_has_rolelst_rsp();
  inline void clear_has_rolelst_rsp();
  inline void set_has_rolelogin_rsp();
  inline void clear_has_rolelogin_rsp();
  inline void set_has_rolelogout_rsp();
  inline void clear_has_rolelogout_rsp();
  inline void set_has_manual_notify();
  inline void clear_has_manual_notify();
  inline void set_has_querybuymanual_rsp();
  inline void clear_has_querybuymanual_rsp();
  inline void set_has_buymanual_rsp();
  inline void clear_has_buymanual_rsp();
  inline void set_has_querymanual_rsp();
  inline void clear_has_querymanual_rsp();
  inline void set_has_querydetailinfo_rsp();
  inline void clear_has_querydetailinfo_rsp();
  inline void set_has_queryevolution_rsp();
  inline void clear_has_queryevolution_rsp();
  inline void set_has_queryevolutionskill_rsp();
  inline void clear_has_queryevolutionskill_rsp();
  inline void set_has_changeevolutionskill_rsp();
  inline void clear_has_changeevolutionskill_rsp();
  inline void set_has_evolution_rsp();
  inline void clear_has_evolution_rsp();
  inline void set_has_queryattrstengthen_rsp();
  inline void clear_has_queryattrstengthen_rsp();
  inline void set_has_attrstengthen_rsp();
  inline void clear_has_attrstengthen_rsp();
  inline void set_has_queryweaponlot_rsp();
  inline void clear_has_queryweaponlot_rsp();
  inline void set_has_weaponlot_rsp();
  inline void clear_has_weaponlot_rsp();
  inline void set_has_queryawardrank_rsp();
  inline void clear_has_queryawardrank_rsp();
  inline void set_has_fetchrankaward_rsp();
  inline void clear_has_fetchrankaward_rsp();
  inline void set_has_playerlvup_rsp();
  inline void clear_has_playerlvup_rsp();
  inline void set_has_playercoin_notify();
  inline void clear_has_playercoin_notify();
  inline void set_has_vip_notify();
  inline void clear_has_vip_notify();
  inline void set_has_queryvipinfo_rsp();
  inline void clear_has_queryvipinfo_rsp();
  inline void set_has_fightpower_notify();
  inline void clear_has_fightpower_notify();
  inline void set_has_queryotherplayer_rsp();
  inline void clear_has_queryotherplayer_rsp();
  inline void set_has_queryblackmarket_rsp();
  inline void clear_has_queryblackmarket_rsp();
  inline void set_has_buyblackmarket_rsp();
  inline void clear_has_buyblackmarket_rsp();
  inline void set_has_resetblackmarket_rsp();
  inline void clear_has_resetblackmarket_rsp();
  inline void set_has_quicklogin_rsp();
  inline void clear_has_quicklogin_rsp();
  inline void set_has_querybuycoin_rsp();
  inline void clear_has_querybuycoin_rsp();
  inline void set_has_buycoin_rsp();
  inline void clear_has_buycoin_rsp();
  inline void set_has_dailyreg_rsp();
  inline void clear_has_dailyreg_rsp();
  inline void set_has_getmonthcardaward_rsp();
  inline void clear_has_getmonthcardaward_rsp();
  inline void set_has_pushmonthcard_notify();
  inline void clear_has_pushmonthcard_notify();
  inline void set_has_claimedmanual();
  inline void clear_has_claimedmanual();
  inline void set_has_guestregister_rsp();
  inline void clear_has_guestregister_rsp();
  inline void set_has_playerenforce_rsp();
  inline void clear_has_playerenforce_rsp();
  inline void set_has_playerenforceconfirm_rsp();
  inline void clear_has_playerenforceconfirm_rsp();
  inline void set_has_playerenforcequery_rsp();
  inline void clear_has_playerenforcequery_rsp();

  ::vmsg::CSRegPlayerInfoRsp* regplayerinfo_rsp_;
  ::vmsg::CSQueryPlayerInfoRsp* queryplayerinfo_rsp_;
  ::vmsg::CSChangeArmorRsp* changearmor_rsp_;
  ::vmsg::CSQueryRoleLstRsp* rolelst_rsp_;
  ::vmsg::CSRoleLoginRsp* rolelogin_rsp_;
  ::vmsg::CSRoleLogoutRsp* rolelogout_rsp_;
  ::vmsg::CSPlayerManualNotify* manual_notify_;
  ::vmsg::CSBuyManualInfo* querybuymanual_rsp_;
  ::vmsg::CSBuyManualInfo* buymanual_rsp_;
  ::vmsg::CSQueryPlayerManualRsp* querymanual_rsp_;
  ::vmsg::CSPlayerDetailInfo* querydetailinfo_rsp_;
  ::vmsg::CSPlayerEvolutionInfo* queryevolution_rsp_;
  ::vmsg::CSPlayerEvolutionSkillInfo* queryevolutionskill_rsp_;
  ::vmsg::CSChangePlayerEvolutionSkillRsp* changeevolutionskill_rsp_;
  ::vmsg::CSPlayerEvolutionInfo* evolution_rsp_;
  ::vmsg::CSAttrStrengthenInfo* queryattrstengthen_rsp_;
  ::vmsg::CSAttrStrengthenInfo* attrstengthen_rsp_;
  ::vmsg::CSWeaponLotQueryRsp* queryweaponlot_rsp_;
  ::vmsg::CSWeaponLotRsp* weaponlot_rsp_;
  ::vmsg::CSAwardRankRsp* queryawardrank_rsp_;
  ::vmsg::CSAwardRankRsp* fetchrankaward_rsp_;
  ::vmsg::CSPlayerLvUpRsp* playerlvup_rsp_;
  ::google::protobuf::uint64 playercoin_notify_;
  ::vmsg::CSVIPNotify* vip_notify_;
  ::vmsg::CSVIPInfos* queryvipinfo_rsp_;
  ::vmsg::CSFightPowerNotify* fightpower_notify_;
  ::vmsg::CSOtherPlayerInfoRsp* queryotherplayer_rsp_;
  ::vmsg::CSBlackMarketInfo* queryblackmarket_rsp_;
  ::vmsg::CSBlackMarketInfo* buyblackmarket_rsp_;
  ::vmsg::CSBlackMarketInfo* resetblackmarket_rsp_;
  ::vmsg::CSQuickLoginRsp* quicklogin_rsp_;
  ::vmsg::CSBuyCoinInfo* querybuycoin_rsp_;
  ::vmsg::CSBuyCoinRsp* buycoin_rsp_;
  ::vmsg::CSDailyRegInfo* dailyreg_rsp_;
  ::vmsg::CSMonthCardInfo* getmonthcardaward_rsp_;
  ::vmsg::CSMonthCardInfo* pushmonthcard_notify_;
  ::vmsg::CSGuestRegisterRsp* guestregister_rsp_;
  ::vmsg::CSPlayerEnforceMyselfRsp* playerenforce_rsp_;
  ::vmsg::CSPlayerEnforceMyselfConfirmRsp* playerenforceconfirm_rsp_;
  ::vmsg::CSPlayerEnforceMyselfQueryRsp* playerenforcequery_rsp_;
  ::google::protobuf::uint32 claimedmanual_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(41 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSPlayerMsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSPlayerMsg_2eproto();
  friend void protobuf_ShutdownFile_CSPlayerMsg_2eproto();

  void InitAsDefaultInstance();
  static CSPlayerRespond* default_instance_;
};
// ===================================================================


// ===================================================================

// CSPlayerAttr

// required uint32 AttrType = 1;
inline bool CSPlayerAttr::has_attrtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerAttr::set_has_attrtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerAttr::clear_has_attrtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerAttr::clear_attrtype() {
  attrtype_ = 0u;
  clear_has_attrtype();
}
inline ::google::protobuf::uint32 CSPlayerAttr::attrtype() const {
  return attrtype_;
}
inline void CSPlayerAttr::set_attrtype(::google::protobuf::uint32 value) {
  set_has_attrtype();
  attrtype_ = value;
}

// required uint32 AttrVal = 2;
inline bool CSPlayerAttr::has_attrval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerAttr::set_has_attrval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerAttr::clear_has_attrval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerAttr::clear_attrval() {
  attrval_ = 0u;
  clear_has_attrval();
}
inline ::google::protobuf::uint32 CSPlayerAttr::attrval() const {
  return attrval_;
}
inline void CSPlayerAttr::set_attrval(::google::protobuf::uint32 value) {
  set_has_attrval();
  attrval_ = value;
}

// -------------------------------------------------------------------

// CSPlayerDetailInfo

// required uint32 HP = 1;
inline bool CSPlayerDetailInfo::has_hp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerDetailInfo::set_has_hp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerDetailInfo::clear_has_hp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerDetailInfo::clear_hp() {
  hp_ = 0u;
  clear_has_hp();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::hp() const {
  return hp_;
}
inline void CSPlayerDetailInfo::set_hp(::google::protobuf::uint32 value) {
  set_has_hp();
  hp_ = value;
}

// required uint32 MP = 2;
inline bool CSPlayerDetailInfo::has_mp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerDetailInfo::set_has_mp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerDetailInfo::clear_has_mp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerDetailInfo::clear_mp() {
  mp_ = 0u;
  clear_has_mp();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::mp() const {
  return mp_;
}
inline void CSPlayerDetailInfo::set_mp(::google::protobuf::uint32 value) {
  set_has_mp();
  mp_ = value;
}

// required uint32 DEF = 3;
inline bool CSPlayerDetailInfo::has_def() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPlayerDetailInfo::set_has_def() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPlayerDetailInfo::clear_has_def() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPlayerDetailInfo::clear_def() {
  def_ = 0u;
  clear_has_def();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::def() const {
  return def_;
}
inline void CSPlayerDetailInfo::set_def(::google::protobuf::uint32 value) {
  set_has_def();
  def_ = value;
}

// required uint32 ATK = 4;
inline bool CSPlayerDetailInfo::has_atk() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPlayerDetailInfo::set_has_atk() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPlayerDetailInfo::clear_has_atk() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPlayerDetailInfo::clear_atk() {
  atk_ = 0u;
  clear_has_atk();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::atk() const {
  return atk_;
}
inline void CSPlayerDetailInfo::set_atk(::google::protobuf::uint32 value) {
  set_has_atk();
  atk_ = value;
}

// required uint32 DEFType = 5;
inline bool CSPlayerDetailInfo::has_deftype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPlayerDetailInfo::set_has_deftype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPlayerDetailInfo::clear_has_deftype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPlayerDetailInfo::clear_deftype() {
  deftype_ = 0u;
  clear_has_deftype();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::deftype() const {
  return deftype_;
}
inline void CSPlayerDetailInfo::set_deftype(::google::protobuf::uint32 value) {
  set_has_deftype();
  deftype_ = value;
}

// required uint32 ATKType = 6;
inline bool CSPlayerDetailInfo::has_atktype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSPlayerDetailInfo::set_has_atktype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSPlayerDetailInfo::clear_has_atktype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSPlayerDetailInfo::clear_atktype() {
  atktype_ = 0u;
  clear_has_atktype();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::atktype() const {
  return atktype_;
}
inline void CSPlayerDetailInfo::set_atktype(::google::protobuf::uint32 value) {
  set_has_atktype();
  atktype_ = value;
}

// repeated .vmsg.CSPlayerAttr ATKAttrs = 7;
inline int CSPlayerDetailInfo::atkattrs_size() const {
  return atkattrs_.size();
}
inline void CSPlayerDetailInfo::clear_atkattrs() {
  atkattrs_.Clear();
}
inline const ::vmsg::CSPlayerAttr& CSPlayerDetailInfo::atkattrs(int index) const {
  return atkattrs_.Get(index);
}
inline ::vmsg::CSPlayerAttr* CSPlayerDetailInfo::mutable_atkattrs(int index) {
  return atkattrs_.Mutable(index);
}
inline ::vmsg::CSPlayerAttr* CSPlayerDetailInfo::add_atkattrs() {
  return atkattrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerAttr >&
CSPlayerDetailInfo::atkattrs() const {
  return atkattrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerAttr >*
CSPlayerDetailInfo::mutable_atkattrs() {
  return &atkattrs_;
}

// repeated .vmsg.CSPlayerAttr DEFAttrs = 8;
inline int CSPlayerDetailInfo::defattrs_size() const {
  return defattrs_.size();
}
inline void CSPlayerDetailInfo::clear_defattrs() {
  defattrs_.Clear();
}
inline const ::vmsg::CSPlayerAttr& CSPlayerDetailInfo::defattrs(int index) const {
  return defattrs_.Get(index);
}
inline ::vmsg::CSPlayerAttr* CSPlayerDetailInfo::mutable_defattrs(int index) {
  return defattrs_.Mutable(index);
}
inline ::vmsg::CSPlayerAttr* CSPlayerDetailInfo::add_defattrs() {
  return defattrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerAttr >&
CSPlayerDetailInfo::defattrs() const {
  return defattrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerAttr >*
CSPlayerDetailInfo::mutable_defattrs() {
  return &defattrs_;
}

// required uint32 MoveSpeed = 9;
inline bool CSPlayerDetailInfo::has_movespeed() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSPlayerDetailInfo::set_has_movespeed() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSPlayerDetailInfo::clear_has_movespeed() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSPlayerDetailInfo::clear_movespeed() {
  movespeed_ = 0u;
  clear_has_movespeed();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::movespeed() const {
  return movespeed_;
}
inline void CSPlayerDetailInfo::set_movespeed(::google::protobuf::uint32 value) {
  set_has_movespeed();
  movespeed_ = value;
}

// required uint32 RunSpeed = 10;
inline bool CSPlayerDetailInfo::has_runspeed() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CSPlayerDetailInfo::set_has_runspeed() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CSPlayerDetailInfo::clear_has_runspeed() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CSPlayerDetailInfo::clear_runspeed() {
  runspeed_ = 0u;
  clear_has_runspeed();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::runspeed() const {
  return runspeed_;
}
inline void CSPlayerDetailInfo::set_runspeed(::google::protobuf::uint32 value) {
  set_has_runspeed();
  runspeed_ = value;
}

// required uint32 BackSpeed = 11;
inline bool CSPlayerDetailInfo::has_backspeed() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CSPlayerDetailInfo::set_has_backspeed() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CSPlayerDetailInfo::clear_has_backspeed() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CSPlayerDetailInfo::clear_backspeed() {
  backspeed_ = 0u;
  clear_has_backspeed();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::backspeed() const {
  return backspeed_;
}
inline void CSPlayerDetailInfo::set_backspeed(::google::protobuf::uint32 value) {
  set_has_backspeed();
  backspeed_ = value;
}

// required uint64 FightPower = 12;
inline bool CSPlayerDetailInfo::has_fightpower() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CSPlayerDetailInfo::set_has_fightpower() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CSPlayerDetailInfo::clear_has_fightpower() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CSPlayerDetailInfo::clear_fightpower() {
  fightpower_ = GOOGLE_ULONGLONG(0);
  clear_has_fightpower();
}
inline ::google::protobuf::uint64 CSPlayerDetailInfo::fightpower() const {
  return fightpower_;
}
inline void CSPlayerDetailInfo::set_fightpower(::google::protobuf::uint64 value) {
  set_has_fightpower();
  fightpower_ = value;
}

// repeated .vmsg.CSEquipInfo EquipLst = 13;
inline int CSPlayerDetailInfo::equiplst_size() const {
  return equiplst_.size();
}
inline void CSPlayerDetailInfo::clear_equiplst() {
  equiplst_.Clear();
}
inline const ::vmsg::CSEquipInfo& CSPlayerDetailInfo::equiplst(int index) const {
  return equiplst_.Get(index);
}
inline ::vmsg::CSEquipInfo* CSPlayerDetailInfo::mutable_equiplst(int index) {
  return equiplst_.Mutable(index);
}
inline ::vmsg::CSEquipInfo* CSPlayerDetailInfo::add_equiplst() {
  return equiplst_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSEquipInfo >&
CSPlayerDetailInfo::equiplst() const {
  return equiplst_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSEquipInfo >*
CSPlayerDetailInfo::mutable_equiplst() {
  return &equiplst_;
}

// required .vmsg.CSEquipInfo SpareEquip = 14;
inline bool CSPlayerDetailInfo::has_spareequip() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CSPlayerDetailInfo::set_has_spareequip() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CSPlayerDetailInfo::clear_has_spareequip() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CSPlayerDetailInfo::clear_spareequip() {
  if (spareequip_ != NULL) spareequip_->::vmsg::CSEquipInfo::Clear();
  clear_has_spareequip();
}
inline const ::vmsg::CSEquipInfo& CSPlayerDetailInfo::spareequip() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return spareequip_ != NULL ? *spareequip_ : *default_instance().spareequip_;
#else
  return spareequip_ != NULL ? *spareequip_ : *default_instance_->spareequip_;
#endif
}
inline ::vmsg::CSEquipInfo* CSPlayerDetailInfo::mutable_spareequip() {
  set_has_spareequip();
  if (spareequip_ == NULL) spareequip_ = new ::vmsg::CSEquipInfo;
  return spareequip_;
}
inline ::vmsg::CSEquipInfo* CSPlayerDetailInfo::release_spareequip() {
  clear_has_spareequip();
  ::vmsg::CSEquipInfo* temp = spareequip_;
  spareequip_ = NULL;
  return temp;
}
inline void CSPlayerDetailInfo::set_allocated_spareequip(::vmsg::CSEquipInfo* spareequip) {
  delete spareequip_;
  spareequip_ = spareequip;
  if (spareequip) {
    set_has_spareequip();
  } else {
    clear_has_spareequip();
  }
}

// required .vmsg.CSWeapon Weapon = 15;
inline bool CSPlayerDetailInfo::has_weapon() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CSPlayerDetailInfo::set_has_weapon() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CSPlayerDetailInfo::clear_has_weapon() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CSPlayerDetailInfo::clear_weapon() {
  if (weapon_ != NULL) weapon_->::vmsg::CSWeapon::Clear();
  clear_has_weapon();
}
inline const ::vmsg::CSWeapon& CSPlayerDetailInfo::weapon() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return weapon_ != NULL ? *weapon_ : *default_instance().weapon_;
#else
  return weapon_ != NULL ? *weapon_ : *default_instance_->weapon_;
#endif
}
inline ::vmsg::CSWeapon* CSPlayerDetailInfo::mutable_weapon() {
  set_has_weapon();
  if (weapon_ == NULL) weapon_ = new ::vmsg::CSWeapon;
  return weapon_;
}
inline ::vmsg::CSWeapon* CSPlayerDetailInfo::release_weapon() {
  clear_has_weapon();
  ::vmsg::CSWeapon* temp = weapon_;
  weapon_ = NULL;
  return temp;
}
inline void CSPlayerDetailInfo::set_allocated_weapon(::vmsg::CSWeapon* weapon) {
  delete weapon_;
  weapon_ = weapon;
  if (weapon) {
    set_has_weapon();
  } else {
    clear_has_weapon();
  }
}

// required uint32 ShowID = 16;
inline bool CSPlayerDetailInfo::has_showid() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CSPlayerDetailInfo::set_has_showid() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CSPlayerDetailInfo::clear_has_showid() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CSPlayerDetailInfo::clear_showid() {
  showid_ = 0u;
  clear_has_showid();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::showid() const {
  return showid_;
}
inline void CSPlayerDetailInfo::set_showid(::google::protobuf::uint32 value) {
  set_has_showid();
  showid_ = value;
}

// required uint32 DodgeDist = 17;
inline bool CSPlayerDetailInfo::has_dodgedist() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CSPlayerDetailInfo::set_has_dodgedist() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CSPlayerDetailInfo::clear_has_dodgedist() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CSPlayerDetailInfo::clear_dodgedist() {
  dodgedist_ = 0u;
  clear_has_dodgedist();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::dodgedist() const {
  return dodgedist_;
}
inline void CSPlayerDetailInfo::set_dodgedist(::google::protobuf::uint32 value) {
  set_has_dodgedist();
  dodgedist_ = value;
}

// required uint32 DodgeCD = 18;
inline bool CSPlayerDetailInfo::has_dodgecd() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CSPlayerDetailInfo::set_has_dodgecd() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CSPlayerDetailInfo::clear_has_dodgecd() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CSPlayerDetailInfo::clear_dodgecd() {
  dodgecd_ = 0u;
  clear_has_dodgecd();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::dodgecd() const {
  return dodgecd_;
}
inline void CSPlayerDetailInfo::set_dodgecd(::google::protobuf::uint32 value) {
  set_has_dodgecd();
  dodgecd_ = value;
}

// required uint32 AtkSpeed = 19;
inline bool CSPlayerDetailInfo::has_atkspeed() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CSPlayerDetailInfo::set_has_atkspeed() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CSPlayerDetailInfo::clear_has_atkspeed() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CSPlayerDetailInfo::clear_atkspeed() {
  atkspeed_ = 0u;
  clear_has_atkspeed();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::atkspeed() const {
  return atkspeed_;
}
inline void CSPlayerDetailInfo::set_atkspeed(::google::protobuf::uint32 value) {
  set_has_atkspeed();
  atkspeed_ = value;
}

// required uint32 EvolutionSkillID = 20;
inline bool CSPlayerDetailInfo::has_evolutionskillid() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CSPlayerDetailInfo::set_has_evolutionskillid() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CSPlayerDetailInfo::clear_has_evolutionskillid() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CSPlayerDetailInfo::clear_evolutionskillid() {
  evolutionskillid_ = 0u;
  clear_has_evolutionskillid();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::evolutionskillid() const {
  return evolutionskillid_;
}
inline void CSPlayerDetailInfo::set_evolutionskillid(::google::protobuf::uint32 value) {
  set_has_evolutionskillid();
  evolutionskillid_ = value;
}

// required uint32 Level = 21;
inline bool CSPlayerDetailInfo::has_level() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CSPlayerDetailInfo::set_has_level() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CSPlayerDetailInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CSPlayerDetailInfo::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::level() const {
  return level_;
}
inline void CSPlayerDetailInfo::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// required uint32 Hit = 22;
inline bool CSPlayerDetailInfo::has_hit() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CSPlayerDetailInfo::set_has_hit() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CSPlayerDetailInfo::clear_has_hit() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CSPlayerDetailInfo::clear_hit() {
  hit_ = 0u;
  clear_has_hit();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::hit() const {
  return hit_;
}
inline void CSPlayerDetailInfo::set_hit(::google::protobuf::uint32 value) {
  set_has_hit();
  hit_ = value;
}

// required uint32 HitWithoutInitVal = 23;
inline bool CSPlayerDetailInfo::has_hitwithoutinitval() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CSPlayerDetailInfo::set_has_hitwithoutinitval() {
  _has_bits_[0] |= 0x00400000u;
}
inline void CSPlayerDetailInfo::clear_has_hitwithoutinitval() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void CSPlayerDetailInfo::clear_hitwithoutinitval() {
  hitwithoutinitval_ = 0u;
  clear_has_hitwithoutinitval();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::hitwithoutinitval() const {
  return hitwithoutinitval_;
}
inline void CSPlayerDetailInfo::set_hitwithoutinitval(::google::protobuf::uint32 value) {
  set_has_hitwithoutinitval();
  hitwithoutinitval_ = value;
}

// repeated .vmsg.CSInbattleWeaponElmt InBattleWeapons = 24;
inline int CSPlayerDetailInfo::inbattleweapons_size() const {
  return inbattleweapons_.size();
}
inline void CSPlayerDetailInfo::clear_inbattleweapons() {
  inbattleweapons_.Clear();
}
inline const ::vmsg::CSInbattleWeaponElmt& CSPlayerDetailInfo::inbattleweapons(int index) const {
  return inbattleweapons_.Get(index);
}
inline ::vmsg::CSInbattleWeaponElmt* CSPlayerDetailInfo::mutable_inbattleweapons(int index) {
  return inbattleweapons_.Mutable(index);
}
inline ::vmsg::CSInbattleWeaponElmt* CSPlayerDetailInfo::add_inbattleweapons() {
  return inbattleweapons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSInbattleWeaponElmt >&
CSPlayerDetailInfo::inbattleweapons() const {
  return inbattleweapons_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSInbattleWeaponElmt >*
CSPlayerDetailInfo::mutable_inbattleweapons() {
  return &inbattleweapons_;
}

// required uint32 HPAddEff = 25;
inline bool CSPlayerDetailInfo::has_hpaddeff() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void CSPlayerDetailInfo::set_has_hpaddeff() {
  _has_bits_[0] |= 0x01000000u;
}
inline void CSPlayerDetailInfo::clear_has_hpaddeff() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void CSPlayerDetailInfo::clear_hpaddeff() {
  hpaddeff_ = 0u;
  clear_has_hpaddeff();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::hpaddeff() const {
  return hpaddeff_;
}
inline void CSPlayerDetailInfo::set_hpaddeff(::google::protobuf::uint32 value) {
  set_has_hpaddeff();
  hpaddeff_ = value;
}

// required uint32 AtkAddEff = 26;
inline bool CSPlayerDetailInfo::has_atkaddeff() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void CSPlayerDetailInfo::set_has_atkaddeff() {
  _has_bits_[0] |= 0x02000000u;
}
inline void CSPlayerDetailInfo::clear_has_atkaddeff() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void CSPlayerDetailInfo::clear_atkaddeff() {
  atkaddeff_ = 0u;
  clear_has_atkaddeff();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::atkaddeff() const {
  return atkaddeff_;
}
inline void CSPlayerDetailInfo::set_atkaddeff(::google::protobuf::uint32 value) {
  set_has_atkaddeff();
  atkaddeff_ = value;
}

// required uint32 DefAddEff = 27;
inline bool CSPlayerDetailInfo::has_defaddeff() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void CSPlayerDetailInfo::set_has_defaddeff() {
  _has_bits_[0] |= 0x04000000u;
}
inline void CSPlayerDetailInfo::clear_has_defaddeff() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void CSPlayerDetailInfo::clear_defaddeff() {
  defaddeff_ = 0u;
  clear_has_defaddeff();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::defaddeff() const {
  return defaddeff_;
}
inline void CSPlayerDetailInfo::set_defaddeff(::google::protobuf::uint32 value) {
  set_has_defaddeff();
  defaddeff_ = value;
}

// required uint32 TotalHpEnforceAdd = 28;
inline bool CSPlayerDetailInfo::has_totalhpenforceadd() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void CSPlayerDetailInfo::set_has_totalhpenforceadd() {
  _has_bits_[0] |= 0x08000000u;
}
inline void CSPlayerDetailInfo::clear_has_totalhpenforceadd() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void CSPlayerDetailInfo::clear_totalhpenforceadd() {
  totalhpenforceadd_ = 0u;
  clear_has_totalhpenforceadd();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::totalhpenforceadd() const {
  return totalhpenforceadd_;
}
inline void CSPlayerDetailInfo::set_totalhpenforceadd(::google::protobuf::uint32 value) {
  set_has_totalhpenforceadd();
  totalhpenforceadd_ = value;
}

// required uint32 TotalAtkEnforceAdd = 29;
inline bool CSPlayerDetailInfo::has_totalatkenforceadd() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void CSPlayerDetailInfo::set_has_totalatkenforceadd() {
  _has_bits_[0] |= 0x10000000u;
}
inline void CSPlayerDetailInfo::clear_has_totalatkenforceadd() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void CSPlayerDetailInfo::clear_totalatkenforceadd() {
  totalatkenforceadd_ = 0u;
  clear_has_totalatkenforceadd();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::totalatkenforceadd() const {
  return totalatkenforceadd_;
}
inline void CSPlayerDetailInfo::set_totalatkenforceadd(::google::protobuf::uint32 value) {
  set_has_totalatkenforceadd();
  totalatkenforceadd_ = value;
}

// required uint32 TotalDefEnforceAdd = 30;
inline bool CSPlayerDetailInfo::has_totaldefenforceadd() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void CSPlayerDetailInfo::set_has_totaldefenforceadd() {
  _has_bits_[0] |= 0x20000000u;
}
inline void CSPlayerDetailInfo::clear_has_totaldefenforceadd() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void CSPlayerDetailInfo::clear_totaldefenforceadd() {
  totaldefenforceadd_ = 0u;
  clear_has_totaldefenforceadd();
}
inline ::google::protobuf::uint32 CSPlayerDetailInfo::totaldefenforceadd() const {
  return totaldefenforceadd_;
}
inline void CSPlayerDetailInfo::set_totaldefenforceadd(::google::protobuf::uint32 value) {
  set_has_totaldefenforceadd();
  totaldefenforceadd_ = value;
}

// -------------------------------------------------------------------

// CSNothinglandInfo

// required uint32 Score = 2;
inline bool CSNothinglandInfo::has_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSNothinglandInfo::set_has_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSNothinglandInfo::clear_has_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSNothinglandInfo::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 CSNothinglandInfo::score() const {
  return score_;
}
inline void CSNothinglandInfo::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
}

// required uint32 Floor = 3;
inline bool CSNothinglandInfo::has_floor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSNothinglandInfo::set_has_floor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSNothinglandInfo::clear_has_floor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSNothinglandInfo::clear_floor() {
  floor_ = 0u;
  clear_has_floor();
}
inline ::google::protobuf::uint32 CSNothinglandInfo::floor() const {
  return floor_;
}
inline void CSNothinglandInfo::set_floor(::google::protobuf::uint32 value) {
  set_has_floor();
  floor_ = value;
}

// required uint32 MaxFloorScore = 4;
inline bool CSNothinglandInfo::has_maxfloorscore() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSNothinglandInfo::set_has_maxfloorscore() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSNothinglandInfo::clear_has_maxfloorscore() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSNothinglandInfo::clear_maxfloorscore() {
  maxfloorscore_ = 0u;
  clear_has_maxfloorscore();
}
inline ::google::protobuf::uint32 CSNothinglandInfo::maxfloorscore() const {
  return maxfloorscore_;
}
inline void CSNothinglandInfo::set_maxfloorscore(::google::protobuf::uint32 value) {
  set_has_maxfloorscore();
  maxfloorscore_ = value;
}

// -------------------------------------------------------------------

// CSDailyRegInfo

// required uint32 RegCnt = 1;
inline bool CSDailyRegInfo::has_regcnt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSDailyRegInfo::set_has_regcnt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSDailyRegInfo::clear_has_regcnt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSDailyRegInfo::clear_regcnt() {
  regcnt_ = 0u;
  clear_has_regcnt();
}
inline ::google::protobuf::uint32 CSDailyRegInfo::regcnt() const {
  return regcnt_;
}
inline void CSDailyRegInfo::set_regcnt(::google::protobuf::uint32 value) {
  set_has_regcnt();
  regcnt_ = value;
}

// required uint32 CanReg = 2;
inline bool CSDailyRegInfo::has_canreg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSDailyRegInfo::set_has_canreg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSDailyRegInfo::clear_has_canreg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSDailyRegInfo::clear_canreg() {
  canreg_ = 0u;
  clear_has_canreg();
}
inline ::google::protobuf::uint32 CSDailyRegInfo::canreg() const {
  return canreg_;
}
inline void CSDailyRegInfo::set_canreg(::google::protobuf::uint32 value) {
  set_has_canreg();
  canreg_ = value;
}

// -------------------------------------------------------------------

// CSMonthCardInfo

// required uint32 Gold = 1;
inline bool CSMonthCardInfo::has_gold() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSMonthCardInfo::set_has_gold() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSMonthCardInfo::clear_has_gold() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSMonthCardInfo::clear_gold() {
  gold_ = 0u;
  clear_has_gold();
}
inline ::google::protobuf::uint32 CSMonthCardInfo::gold() const {
  return gold_;
}
inline void CSMonthCardInfo::set_gold(::google::protobuf::uint32 value) {
  set_has_gold();
  gold_ = value;
}

// required int32 EndTime = 2;
inline bool CSMonthCardInfo::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSMonthCardInfo::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSMonthCardInfo::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSMonthCardInfo::clear_endtime() {
  endtime_ = 0;
  clear_has_endtime();
}
inline ::google::protobuf::int32 CSMonthCardInfo::endtime() const {
  return endtime_;
}
inline void CSMonthCardInfo::set_endtime(::google::protobuf::int32 value) {
  set_has_endtime();
  endtime_ = value;
}

// required uint32 TotalDays = 3;
inline bool CSMonthCardInfo::has_totaldays() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSMonthCardInfo::set_has_totaldays() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSMonthCardInfo::clear_has_totaldays() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSMonthCardInfo::clear_totaldays() {
  totaldays_ = 0u;
  clear_has_totaldays();
}
inline ::google::protobuf::uint32 CSMonthCardInfo::totaldays() const {
  return totaldays_;
}
inline void CSMonthCardInfo::set_totaldays(::google::protobuf::uint32 value) {
  set_has_totaldays();
  totaldays_ = value;
}

// required int32 LastAwardTime = 4;
inline bool CSMonthCardInfo::has_lastawardtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSMonthCardInfo::set_has_lastawardtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSMonthCardInfo::clear_has_lastawardtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSMonthCardInfo::clear_lastawardtime() {
  lastawardtime_ = 0;
  clear_has_lastawardtime();
}
inline ::google::protobuf::int32 CSMonthCardInfo::lastawardtime() const {
  return lastawardtime_;
}
inline void CSMonthCardInfo::set_lastawardtime(::google::protobuf::int32 value) {
  set_has_lastawardtime();
  lastawardtime_ = value;
}

// -------------------------------------------------------------------

// CSPlayerInfo

// required uint64 Uin = 1;
inline bool CSPlayerInfo::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerInfo::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerInfo::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerInfo::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSPlayerInfo::uin() const {
  return uin_;
}
inline void CSPlayerInfo::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
}

// required string Nick = 3;
inline bool CSPlayerInfo::has_nick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerInfo::set_has_nick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerInfo::clear_has_nick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerInfo::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& CSPlayerInfo::nick() const {
  return *nick_;
}
inline void CSPlayerInfo::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void CSPlayerInfo::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void CSPlayerInfo::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSPlayerInfo::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* CSPlayerInfo::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSPlayerInfo::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 Level = 4;
inline bool CSPlayerInfo::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPlayerInfo::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPlayerInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPlayerInfo::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 CSPlayerInfo::level() const {
  return level_;
}
inline void CSPlayerInfo::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// required uint64 Exp = 5;
inline bool CSPlayerInfo::has_exp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPlayerInfo::set_has_exp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPlayerInfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPlayerInfo::clear_exp() {
  exp_ = GOOGLE_ULONGLONG(0);
  clear_has_exp();
}
inline ::google::protobuf::uint64 CSPlayerInfo::exp() const {
  return exp_;
}
inline void CSPlayerInfo::set_exp(::google::protobuf::uint64 value) {
  set_has_exp();
  exp_ = value;
}

// required uint32 WeaponCfgID = 6;
inline bool CSPlayerInfo::has_weaponcfgid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPlayerInfo::set_has_weaponcfgid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPlayerInfo::clear_has_weaponcfgid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPlayerInfo::clear_weaponcfgid() {
  weaponcfgid_ = 0u;
  clear_has_weaponcfgid();
}
inline ::google::protobuf::uint32 CSPlayerInfo::weaponcfgid() const {
  return weaponcfgid_;
}
inline void CSPlayerInfo::set_weaponcfgid(::google::protobuf::uint32 value) {
  set_has_weaponcfgid();
  weaponcfgid_ = value;
}

// required uint64 Coin = 7;
inline bool CSPlayerInfo::has_coin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSPlayerInfo::set_has_coin() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSPlayerInfo::clear_has_coin() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSPlayerInfo::clear_coin() {
  coin_ = GOOGLE_ULONGLONG(0);
  clear_has_coin();
}
inline ::google::protobuf::uint64 CSPlayerInfo::coin() const {
  return coin_;
}
inline void CSPlayerInfo::set_coin(::google::protobuf::uint64 value) {
  set_has_coin();
  coin_ = value;
}

// required uint32 RemainManual = 8;
inline bool CSPlayerInfo::has_remainmanual() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSPlayerInfo::set_has_remainmanual() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSPlayerInfo::clear_has_remainmanual() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSPlayerInfo::clear_remainmanual() {
  remainmanual_ = 0u;
  clear_has_remainmanual();
}
inline ::google::protobuf::uint32 CSPlayerInfo::remainmanual() const {
  return remainmanual_;
}
inline void CSPlayerInfo::set_remainmanual(::google::protobuf::uint32 value) {
  set_has_remainmanual();
  remainmanual_ = value;
}

// required int32 UpdateRemainTime = 9;
inline bool CSPlayerInfo::has_updateremaintime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSPlayerInfo::set_has_updateremaintime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSPlayerInfo::clear_has_updateremaintime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSPlayerInfo::clear_updateremaintime() {
  updateremaintime_ = 0;
  clear_has_updateremaintime();
}
inline ::google::protobuf::int32 CSPlayerInfo::updateremaintime() const {
  return updateremaintime_;
}
inline void CSPlayerInfo::set_updateremaintime(::google::protobuf::int32 value) {
  set_has_updateremaintime();
  updateremaintime_ = value;
}

// required uint32 ShowID = 10;
inline bool CSPlayerInfo::has_showid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSPlayerInfo::set_has_showid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSPlayerInfo::clear_has_showid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSPlayerInfo::clear_showid() {
  showid_ = 0u;
  clear_has_showid();
}
inline ::google::protobuf::uint32 CSPlayerInfo::showid() const {
  return showid_;
}
inline void CSPlayerInfo::set_showid(::google::protobuf::uint32 value) {
  set_has_showid();
  showid_ = value;
}

// required uint32 SceneID = 11;
inline bool CSPlayerInfo::has_sceneid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CSPlayerInfo::set_has_sceneid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CSPlayerInfo::clear_has_sceneid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CSPlayerInfo::clear_sceneid() {
  sceneid_ = 0u;
  clear_has_sceneid();
}
inline ::google::protobuf::uint32 CSPlayerInfo::sceneid() const {
  return sceneid_;
}
inline void CSPlayerInfo::set_sceneid(::google::protobuf::uint32 value) {
  set_has_sceneid();
  sceneid_ = value;
}

// required uint32 NewestWarMapID = 12;
inline bool CSPlayerInfo::has_newestwarmapid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CSPlayerInfo::set_has_newestwarmapid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CSPlayerInfo::clear_has_newestwarmapid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CSPlayerInfo::clear_newestwarmapid() {
  newestwarmapid_ = 0u;
  clear_has_newestwarmapid();
}
inline ::google::protobuf::uint32 CSPlayerInfo::newestwarmapid() const {
  return newestwarmapid_;
}
inline void CSPlayerInfo::set_newestwarmapid(::google::protobuf::uint32 value) {
  set_has_newestwarmapid();
  newestwarmapid_ = value;
}

// required uint32 VIPLv = 13;
inline bool CSPlayerInfo::has_viplv() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CSPlayerInfo::set_has_viplv() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CSPlayerInfo::clear_has_viplv() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CSPlayerInfo::clear_viplv() {
  viplv_ = 0u;
  clear_has_viplv();
}
inline ::google::protobuf::uint32 CSPlayerInfo::viplv() const {
  return viplv_;
}
inline void CSPlayerInfo::set_viplv(::google::protobuf::uint32 value) {
  set_has_viplv();
  viplv_ = value;
}

// required uint64 FightPower = 14;
inline bool CSPlayerInfo::has_fightpower() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CSPlayerInfo::set_has_fightpower() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CSPlayerInfo::clear_has_fightpower() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CSPlayerInfo::clear_fightpower() {
  fightpower_ = GOOGLE_ULONGLONG(0);
  clear_has_fightpower();
}
inline ::google::protobuf::uint64 CSPlayerInfo::fightpower() const {
  return fightpower_;
}
inline void CSPlayerInfo::set_fightpower(::google::protobuf::uint64 value) {
  set_has_fightpower();
  fightpower_ = value;
}

// required uint64 GuildID = 15;
inline bool CSPlayerInfo::has_guildid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CSPlayerInfo::set_has_guildid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CSPlayerInfo::clear_has_guildid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CSPlayerInfo::clear_guildid() {
  guildid_ = GOOGLE_ULONGLONG(0);
  clear_has_guildid();
}
inline ::google::protobuf::uint64 CSPlayerInfo::guildid() const {
  return guildid_;
}
inline void CSPlayerInfo::set_guildid(::google::protobuf::uint64 value) {
  set_has_guildid();
  guildid_ = value;
}

// required string SettingParam = 16;
inline bool CSPlayerInfo::has_settingparam() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CSPlayerInfo::set_has_settingparam() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CSPlayerInfo::clear_has_settingparam() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CSPlayerInfo::clear_settingparam() {
  if (settingparam_ != &::google::protobuf::internal::kEmptyString) {
    settingparam_->clear();
  }
  clear_has_settingparam();
}
inline const ::std::string& CSPlayerInfo::settingparam() const {
  return *settingparam_;
}
inline void CSPlayerInfo::set_settingparam(const ::std::string& value) {
  set_has_settingparam();
  if (settingparam_ == &::google::protobuf::internal::kEmptyString) {
    settingparam_ = new ::std::string;
  }
  settingparam_->assign(value);
}
inline void CSPlayerInfo::set_settingparam(const char* value) {
  set_has_settingparam();
  if (settingparam_ == &::google::protobuf::internal::kEmptyString) {
    settingparam_ = new ::std::string;
  }
  settingparam_->assign(value);
}
inline void CSPlayerInfo::set_settingparam(const char* value, size_t size) {
  set_has_settingparam();
  if (settingparam_ == &::google::protobuf::internal::kEmptyString) {
    settingparam_ = new ::std::string;
  }
  settingparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSPlayerInfo::mutable_settingparam() {
  set_has_settingparam();
  if (settingparam_ == &::google::protobuf::internal::kEmptyString) {
    settingparam_ = new ::std::string;
  }
  return settingparam_;
}
inline ::std::string* CSPlayerInfo::release_settingparam() {
  clear_has_settingparam();
  if (settingparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = settingparam_;
    settingparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSPlayerInfo::set_allocated_settingparam(::std::string* settingparam) {
  if (settingparam_ != &::google::protobuf::internal::kEmptyString) {
    delete settingparam_;
  }
  if (settingparam) {
    set_has_settingparam();
    settingparam_ = settingparam;
  } else {
    clear_has_settingparam();
    settingparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .vmsg.CSNothinglandInfo NothinglandInfo = 17;
inline bool CSPlayerInfo::has_nothinglandinfo() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CSPlayerInfo::set_has_nothinglandinfo() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CSPlayerInfo::clear_has_nothinglandinfo() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CSPlayerInfo::clear_nothinglandinfo() {
  if (nothinglandinfo_ != NULL) nothinglandinfo_->::vmsg::CSNothinglandInfo::Clear();
  clear_has_nothinglandinfo();
}
inline const ::vmsg::CSNothinglandInfo& CSPlayerInfo::nothinglandinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return nothinglandinfo_ != NULL ? *nothinglandinfo_ : *default_instance().nothinglandinfo_;
#else
  return nothinglandinfo_ != NULL ? *nothinglandinfo_ : *default_instance_->nothinglandinfo_;
#endif
}
inline ::vmsg::CSNothinglandInfo* CSPlayerInfo::mutable_nothinglandinfo() {
  set_has_nothinglandinfo();
  if (nothinglandinfo_ == NULL) nothinglandinfo_ = new ::vmsg::CSNothinglandInfo;
  return nothinglandinfo_;
}
inline ::vmsg::CSNothinglandInfo* CSPlayerInfo::release_nothinglandinfo() {
  clear_has_nothinglandinfo();
  ::vmsg::CSNothinglandInfo* temp = nothinglandinfo_;
  nothinglandinfo_ = NULL;
  return temp;
}
inline void CSPlayerInfo::set_allocated_nothinglandinfo(::vmsg::CSNothinglandInfo* nothinglandinfo) {
  delete nothinglandinfo_;
  nothinglandinfo_ = nothinglandinfo;
  if (nothinglandinfo) {
    set_has_nothinglandinfo();
  } else {
    clear_has_nothinglandinfo();
  }
}

// required uint64 QuickLoginKey = 18;
inline bool CSPlayerInfo::has_quickloginkey() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CSPlayerInfo::set_has_quickloginkey() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CSPlayerInfo::clear_has_quickloginkey() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CSPlayerInfo::clear_quickloginkey() {
  quickloginkey_ = GOOGLE_ULONGLONG(0);
  clear_has_quickloginkey();
}
inline ::google::protobuf::uint64 CSPlayerInfo::quickloginkey() const {
  return quickloginkey_;
}
inline void CSPlayerInfo::set_quickloginkey(::google::protobuf::uint64 value) {
  set_has_quickloginkey();
  quickloginkey_ = value;
}

// required .vmsg.CSDailyRegInfo DailyRegInfo = 19;
inline bool CSPlayerInfo::has_dailyreginfo() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CSPlayerInfo::set_has_dailyreginfo() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CSPlayerInfo::clear_has_dailyreginfo() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CSPlayerInfo::clear_dailyreginfo() {
  if (dailyreginfo_ != NULL) dailyreginfo_->::vmsg::CSDailyRegInfo::Clear();
  clear_has_dailyreginfo();
}
inline const ::vmsg::CSDailyRegInfo& CSPlayerInfo::dailyreginfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dailyreginfo_ != NULL ? *dailyreginfo_ : *default_instance().dailyreginfo_;
#else
  return dailyreginfo_ != NULL ? *dailyreginfo_ : *default_instance_->dailyreginfo_;
#endif
}
inline ::vmsg::CSDailyRegInfo* CSPlayerInfo::mutable_dailyreginfo() {
  set_has_dailyreginfo();
  if (dailyreginfo_ == NULL) dailyreginfo_ = new ::vmsg::CSDailyRegInfo;
  return dailyreginfo_;
}
inline ::vmsg::CSDailyRegInfo* CSPlayerInfo::release_dailyreginfo() {
  clear_has_dailyreginfo();
  ::vmsg::CSDailyRegInfo* temp = dailyreginfo_;
  dailyreginfo_ = NULL;
  return temp;
}
inline void CSPlayerInfo::set_allocated_dailyreginfo(::vmsg::CSDailyRegInfo* dailyreginfo) {
  delete dailyreginfo_;
  dailyreginfo_ = dailyreginfo;
  if (dailyreginfo) {
    set_has_dailyreginfo();
  } else {
    clear_has_dailyreginfo();
  }
}

// required .vmsg.CSMonthCardInfo MonthCardInfo = 20;
inline bool CSPlayerInfo::has_monthcardinfo() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CSPlayerInfo::set_has_monthcardinfo() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CSPlayerInfo::clear_has_monthcardinfo() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CSPlayerInfo::clear_monthcardinfo() {
  if (monthcardinfo_ != NULL) monthcardinfo_->::vmsg::CSMonthCardInfo::Clear();
  clear_has_monthcardinfo();
}
inline const ::vmsg::CSMonthCardInfo& CSPlayerInfo::monthcardinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return monthcardinfo_ != NULL ? *monthcardinfo_ : *default_instance().monthcardinfo_;
#else
  return monthcardinfo_ != NULL ? *monthcardinfo_ : *default_instance_->monthcardinfo_;
#endif
}
inline ::vmsg::CSMonthCardInfo* CSPlayerInfo::mutable_monthcardinfo() {
  set_has_monthcardinfo();
  if (monthcardinfo_ == NULL) monthcardinfo_ = new ::vmsg::CSMonthCardInfo;
  return monthcardinfo_;
}
inline ::vmsg::CSMonthCardInfo* CSPlayerInfo::release_monthcardinfo() {
  clear_has_monthcardinfo();
  ::vmsg::CSMonthCardInfo* temp = monthcardinfo_;
  monthcardinfo_ = NULL;
  return temp;
}
inline void CSPlayerInfo::set_allocated_monthcardinfo(::vmsg::CSMonthCardInfo* monthcardinfo) {
  delete monthcardinfo_;
  monthcardinfo_ = monthcardinfo;
  if (monthcardinfo) {
    set_has_monthcardinfo();
  } else {
    clear_has_monthcardinfo();
  }
}

// required uint32 VIPDailyClaimed = 21;
inline bool CSPlayerInfo::has_vipdailyclaimed() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CSPlayerInfo::set_has_vipdailyclaimed() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CSPlayerInfo::clear_has_vipdailyclaimed() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CSPlayerInfo::clear_vipdailyclaimed() {
  vipdailyclaimed_ = 0u;
  clear_has_vipdailyclaimed();
}
inline ::google::protobuf::uint32 CSPlayerInfo::vipdailyclaimed() const {
  return vipdailyclaimed_;
}
inline void CSPlayerInfo::set_vipdailyclaimed(::google::protobuf::uint32 value) {
  set_has_vipdailyclaimed();
  vipdailyclaimed_ = value;
}

// -------------------------------------------------------------------

// CSQueryPlayerInfoRsp

// required .vmsg.CSPlayerInfo PlayerInfo = 1;
inline bool CSQueryPlayerInfoRsp::has_playerinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSQueryPlayerInfoRsp::set_has_playerinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSQueryPlayerInfoRsp::clear_has_playerinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSQueryPlayerInfoRsp::clear_playerinfo() {
  if (playerinfo_ != NULL) playerinfo_->::vmsg::CSPlayerInfo::Clear();
  clear_has_playerinfo();
}
inline const ::vmsg::CSPlayerInfo& CSQueryPlayerInfoRsp::playerinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerinfo_ != NULL ? *playerinfo_ : *default_instance().playerinfo_;
#else
  return playerinfo_ != NULL ? *playerinfo_ : *default_instance_->playerinfo_;
#endif
}
inline ::vmsg::CSPlayerInfo* CSQueryPlayerInfoRsp::mutable_playerinfo() {
  set_has_playerinfo();
  if (playerinfo_ == NULL) playerinfo_ = new ::vmsg::CSPlayerInfo;
  return playerinfo_;
}
inline ::vmsg::CSPlayerInfo* CSQueryPlayerInfoRsp::release_playerinfo() {
  clear_has_playerinfo();
  ::vmsg::CSPlayerInfo* temp = playerinfo_;
  playerinfo_ = NULL;
  return temp;
}
inline void CSQueryPlayerInfoRsp::set_allocated_playerinfo(::vmsg::CSPlayerInfo* playerinfo) {
  delete playerinfo_;
  playerinfo_ = playerinfo;
  if (playerinfo) {
    set_has_playerinfo();
  } else {
    clear_has_playerinfo();
  }
}

// optional uint32 ServerOpenTime = 2;
inline bool CSQueryPlayerInfoRsp::has_serveropentime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSQueryPlayerInfoRsp::set_has_serveropentime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSQueryPlayerInfoRsp::clear_has_serveropentime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSQueryPlayerInfoRsp::clear_serveropentime() {
  serveropentime_ = 0u;
  clear_has_serveropentime();
}
inline ::google::protobuf::uint32 CSQueryPlayerInfoRsp::serveropentime() const {
  return serveropentime_;
}
inline void CSQueryPlayerInfoRsp::set_serveropentime(::google::protobuf::uint32 value) {
  set_has_serveropentime();
  serveropentime_ = value;
}

// -------------------------------------------------------------------

// CSSetSettingParamRqst

// required string SettingParam = 1;
inline bool CSSetSettingParamRqst::has_settingparam() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSSetSettingParamRqst::set_has_settingparam() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSSetSettingParamRqst::clear_has_settingparam() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSSetSettingParamRqst::clear_settingparam() {
  if (settingparam_ != &::google::protobuf::internal::kEmptyString) {
    settingparam_->clear();
  }
  clear_has_settingparam();
}
inline const ::std::string& CSSetSettingParamRqst::settingparam() const {
  return *settingparam_;
}
inline void CSSetSettingParamRqst::set_settingparam(const ::std::string& value) {
  set_has_settingparam();
  if (settingparam_ == &::google::protobuf::internal::kEmptyString) {
    settingparam_ = new ::std::string;
  }
  settingparam_->assign(value);
}
inline void CSSetSettingParamRqst::set_settingparam(const char* value) {
  set_has_settingparam();
  if (settingparam_ == &::google::protobuf::internal::kEmptyString) {
    settingparam_ = new ::std::string;
  }
  settingparam_->assign(value);
}
inline void CSSetSettingParamRqst::set_settingparam(const char* value, size_t size) {
  set_has_settingparam();
  if (settingparam_ == &::google::protobuf::internal::kEmptyString) {
    settingparam_ = new ::std::string;
  }
  settingparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSSetSettingParamRqst::mutable_settingparam() {
  set_has_settingparam();
  if (settingparam_ == &::google::protobuf::internal::kEmptyString) {
    settingparam_ = new ::std::string;
  }
  return settingparam_;
}
inline ::std::string* CSSetSettingParamRqst::release_settingparam() {
  clear_has_settingparam();
  if (settingparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = settingparam_;
    settingparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSSetSettingParamRqst::set_allocated_settingparam(::std::string* settingparam) {
  if (settingparam_ != &::google::protobuf::internal::kEmptyString) {
    delete settingparam_;
  }
  if (settingparam) {
    set_has_settingparam();
    settingparam_ = settingparam;
  } else {
    clear_has_settingparam();
    settingparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSRegPlayerInfoRqst

// required uint32 PlayerID = 1;
inline bool CSRegPlayerInfoRqst::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRegPlayerInfoRqst::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRegPlayerInfoRqst::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRegPlayerInfoRqst::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 CSRegPlayerInfoRqst::playerid() const {
  return playerid_;
}
inline void CSRegPlayerInfoRqst::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// required string Nick = 2;
inline bool CSRegPlayerInfoRqst::has_nick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSRegPlayerInfoRqst::set_has_nick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSRegPlayerInfoRqst::clear_has_nick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSRegPlayerInfoRqst::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& CSRegPlayerInfoRqst::nick() const {
  return *nick_;
}
inline void CSRegPlayerInfoRqst::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void CSRegPlayerInfoRqst::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void CSRegPlayerInfoRqst::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSRegPlayerInfoRqst::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* CSRegPlayerInfoRqst::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSRegPlayerInfoRqst::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSRegPlayerInfoRsp

// required .vmsg.CSPlayerInfo PlayerInfo = 1;
inline bool CSRegPlayerInfoRsp::has_playerinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRegPlayerInfoRsp::set_has_playerinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRegPlayerInfoRsp::clear_has_playerinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRegPlayerInfoRsp::clear_playerinfo() {
  if (playerinfo_ != NULL) playerinfo_->::vmsg::CSPlayerInfo::Clear();
  clear_has_playerinfo();
}
inline const ::vmsg::CSPlayerInfo& CSRegPlayerInfoRsp::playerinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerinfo_ != NULL ? *playerinfo_ : *default_instance().playerinfo_;
#else
  return playerinfo_ != NULL ? *playerinfo_ : *default_instance_->playerinfo_;
#endif
}
inline ::vmsg::CSPlayerInfo* CSRegPlayerInfoRsp::mutable_playerinfo() {
  set_has_playerinfo();
  if (playerinfo_ == NULL) playerinfo_ = new ::vmsg::CSPlayerInfo;
  return playerinfo_;
}
inline ::vmsg::CSPlayerInfo* CSRegPlayerInfoRsp::release_playerinfo() {
  clear_has_playerinfo();
  ::vmsg::CSPlayerInfo* temp = playerinfo_;
  playerinfo_ = NULL;
  return temp;
}
inline void CSRegPlayerInfoRsp::set_allocated_playerinfo(::vmsg::CSPlayerInfo* playerinfo) {
  delete playerinfo_;
  playerinfo_ = playerinfo;
  if (playerinfo) {
    set_has_playerinfo();
  } else {
    clear_has_playerinfo();
  }
}

// -------------------------------------------------------------------

// CSChangeArmorRsp

// required .vmsg.CSPlayerDetailInfo PlayerDetailInfo = 1;
inline bool CSChangeArmorRsp::has_playerdetailinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSChangeArmorRsp::set_has_playerdetailinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSChangeArmorRsp::clear_has_playerdetailinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSChangeArmorRsp::clear_playerdetailinfo() {
  if (playerdetailinfo_ != NULL) playerdetailinfo_->::vmsg::CSPlayerDetailInfo::Clear();
  clear_has_playerdetailinfo();
}
inline const ::vmsg::CSPlayerDetailInfo& CSChangeArmorRsp::playerdetailinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerdetailinfo_ != NULL ? *playerdetailinfo_ : *default_instance().playerdetailinfo_;
#else
  return playerdetailinfo_ != NULL ? *playerdetailinfo_ : *default_instance_->playerdetailinfo_;
#endif
}
inline ::vmsg::CSPlayerDetailInfo* CSChangeArmorRsp::mutable_playerdetailinfo() {
  set_has_playerdetailinfo();
  if (playerdetailinfo_ == NULL) playerdetailinfo_ = new ::vmsg::CSPlayerDetailInfo;
  return playerdetailinfo_;
}
inline ::vmsg::CSPlayerDetailInfo* CSChangeArmorRsp::release_playerdetailinfo() {
  clear_has_playerdetailinfo();
  ::vmsg::CSPlayerDetailInfo* temp = playerdetailinfo_;
  playerdetailinfo_ = NULL;
  return temp;
}
inline void CSChangeArmorRsp::set_allocated_playerdetailinfo(::vmsg::CSPlayerDetailInfo* playerdetailinfo) {
  delete playerdetailinfo_;
  playerdetailinfo_ = playerdetailinfo;
  if (playerdetailinfo) {
    set_has_playerdetailinfo();
  } else {
    clear_has_playerdetailinfo();
  }
}

// -------------------------------------------------------------------

// CSPlayerRoleInfo

// required uint64 Uin = 1;
inline bool CSPlayerRoleInfo::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerRoleInfo::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerRoleInfo::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerRoleInfo::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSPlayerRoleInfo::uin() const {
  return uin_;
}
inline void CSPlayerRoleInfo::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
}

// required uint32 ShowID = 2;
inline bool CSPlayerRoleInfo::has_showid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerRoleInfo::set_has_showid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerRoleInfo::clear_has_showid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerRoleInfo::clear_showid() {
  showid_ = 0u;
  clear_has_showid();
}
inline ::google::protobuf::uint32 CSPlayerRoleInfo::showid() const {
  return showid_;
}
inline void CSPlayerRoleInfo::set_showid(::google::protobuf::uint32 value) {
  set_has_showid();
  showid_ = value;
}

// required string Nick = 3;
inline bool CSPlayerRoleInfo::has_nick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPlayerRoleInfo::set_has_nick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPlayerRoleInfo::clear_has_nick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPlayerRoleInfo::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& CSPlayerRoleInfo::nick() const {
  return *nick_;
}
inline void CSPlayerRoleInfo::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void CSPlayerRoleInfo::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void CSPlayerRoleInfo::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSPlayerRoleInfo::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* CSPlayerRoleInfo::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSPlayerRoleInfo::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 Level = 4;
inline bool CSPlayerRoleInfo::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPlayerRoleInfo::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPlayerRoleInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPlayerRoleInfo::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 CSPlayerRoleInfo::level() const {
  return level_;
}
inline void CSPlayerRoleInfo::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// required uint64 Exp = 5;
inline bool CSPlayerRoleInfo::has_exp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPlayerRoleInfo::set_has_exp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPlayerRoleInfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPlayerRoleInfo::clear_exp() {
  exp_ = GOOGLE_ULONGLONG(0);
  clear_has_exp();
}
inline ::google::protobuf::uint64 CSPlayerRoleInfo::exp() const {
  return exp_;
}
inline void CSPlayerRoleInfo::set_exp(::google::protobuf::uint64 value) {
  set_has_exp();
  exp_ = value;
}

// required uint32 WeaponCfgID = 6;
inline bool CSPlayerRoleInfo::has_weaponcfgid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSPlayerRoleInfo::set_has_weaponcfgid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSPlayerRoleInfo::clear_has_weaponcfgid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSPlayerRoleInfo::clear_weaponcfgid() {
  weaponcfgid_ = 0u;
  clear_has_weaponcfgid();
}
inline ::google::protobuf::uint32 CSPlayerRoleInfo::weaponcfgid() const {
  return weaponcfgid_;
}
inline void CSPlayerRoleInfo::set_weaponcfgid(::google::protobuf::uint32 value) {
  set_has_weaponcfgid();
  weaponcfgid_ = value;
}

// -------------------------------------------------------------------

// CSQueryRoleLstRsp

// repeated .vmsg.CSPlayerRoleInfo RoleLst = 1;
inline int CSQueryRoleLstRsp::rolelst_size() const {
  return rolelst_.size();
}
inline void CSQueryRoleLstRsp::clear_rolelst() {
  rolelst_.Clear();
}
inline const ::vmsg::CSPlayerRoleInfo& CSQueryRoleLstRsp::rolelst(int index) const {
  return rolelst_.Get(index);
}
inline ::vmsg::CSPlayerRoleInfo* CSQueryRoleLstRsp::mutable_rolelst(int index) {
  return rolelst_.Mutable(index);
}
inline ::vmsg::CSPlayerRoleInfo* CSQueryRoleLstRsp::add_rolelst() {
  return rolelst_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerRoleInfo >&
CSQueryRoleLstRsp::rolelst() const {
  return rolelst_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSPlayerRoleInfo >*
CSQueryRoleLstRsp::mutable_rolelst() {
  return &rolelst_;
}

// -------------------------------------------------------------------

// CSRoleLoginRqst

// required uint64 Uin = 1;
inline bool CSRoleLoginRqst::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRoleLoginRqst::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRoleLoginRqst::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRoleLoginRqst::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSRoleLoginRqst::uin() const {
  return uin_;
}
inline void CSRoleLoginRqst::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
}

// -------------------------------------------------------------------

// CSRoleLoginRsp

// required uint32 RetCode = 1;
inline bool CSRoleLoginRsp::has_retcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRoleLoginRsp::set_has_retcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRoleLoginRsp::clear_has_retcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRoleLoginRsp::clear_retcode() {
  retcode_ = 0u;
  clear_has_retcode();
}
inline ::google::protobuf::uint32 CSRoleLoginRsp::retcode() const {
  return retcode_;
}
inline void CSRoleLoginRsp::set_retcode(::google::protobuf::uint32 value) {
  set_has_retcode();
  retcode_ = value;
}

// -------------------------------------------------------------------

// CSRoleLogoutRqst

// required uint64 Uin = 1;
inline bool CSRoleLogoutRqst::has_uin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRoleLogoutRqst::set_has_uin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRoleLogoutRqst::clear_has_uin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRoleLogoutRqst::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSRoleLogoutRqst::uin() const {
  return uin_;
}
inline void CSRoleLogoutRqst::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
}

// -------------------------------------------------------------------

// CSRoleLogoutRsp

// required uint32 RetCode = 1;
inline bool CSRoleLogoutRsp::has_retcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSRoleLogoutRsp::set_has_retcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSRoleLogoutRsp::clear_has_retcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSRoleLogoutRsp::clear_retcode() {
  retcode_ = 0u;
  clear_has_retcode();
}
inline ::google::protobuf::uint32 CSRoleLogoutRsp::retcode() const {
  return retcode_;
}
inline void CSRoleLogoutRsp::set_retcode(::google::protobuf::uint32 value) {
  set_has_retcode();
  retcode_ = value;
}

// -------------------------------------------------------------------

// CSPlayerManualNotify

// required uint32 RemainManual = 1;
inline bool CSPlayerManualNotify::has_remainmanual() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerManualNotify::set_has_remainmanual() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerManualNotify::clear_has_remainmanual() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerManualNotify::clear_remainmanual() {
  remainmanual_ = 0u;
  clear_has_remainmanual();
}
inline ::google::protobuf::uint32 CSPlayerManualNotify::remainmanual() const {
  return remainmanual_;
}
inline void CSPlayerManualNotify::set_remainmanual(::google::protobuf::uint32 value) {
  set_has_remainmanual();
  remainmanual_ = value;
}

// required int32 UpdateRemainTime = 2;
inline bool CSPlayerManualNotify::has_updateremaintime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerManualNotify::set_has_updateremaintime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerManualNotify::clear_has_updateremaintime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerManualNotify::clear_updateremaintime() {
  updateremaintime_ = 0;
  clear_has_updateremaintime();
}
inline ::google::protobuf::int32 CSPlayerManualNotify::updateremaintime() const {
  return updateremaintime_;
}
inline void CSPlayerManualNotify::set_updateremaintime(::google::protobuf::int32 value) {
  set_has_updateremaintime();
  updateremaintime_ = value;
}

// -------------------------------------------------------------------

// CSBuyManualInfo

// required uint32 BuyCnt = 1;
inline bool CSBuyManualInfo::has_buycnt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBuyManualInfo::set_has_buycnt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBuyManualInfo::clear_has_buycnt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBuyManualInfo::clear_buycnt() {
  buycnt_ = 0u;
  clear_has_buycnt();
}
inline ::google::protobuf::uint32 CSBuyManualInfo::buycnt() const {
  return buycnt_;
}
inline void CSBuyManualInfo::set_buycnt(::google::protobuf::uint32 value) {
  set_has_buycnt();
  buycnt_ = value;
}

// required uint32 MaxCnt = 2;
inline bool CSBuyManualInfo::has_maxcnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBuyManualInfo::set_has_maxcnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBuyManualInfo::clear_has_maxcnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBuyManualInfo::clear_maxcnt() {
  maxcnt_ = 0u;
  clear_has_maxcnt();
}
inline ::google::protobuf::uint32 CSBuyManualInfo::maxcnt() const {
  return maxcnt_;
}
inline void CSBuyManualInfo::set_maxcnt(::google::protobuf::uint32 value) {
  set_has_maxcnt();
  maxcnt_ = value;
}

// required uint32 GoldCost = 3;
inline bool CSBuyManualInfo::has_goldcost() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBuyManualInfo::set_has_goldcost() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBuyManualInfo::clear_has_goldcost() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBuyManualInfo::clear_goldcost() {
  goldcost_ = 0u;
  clear_has_goldcost();
}
inline ::google::protobuf::uint32 CSBuyManualInfo::goldcost() const {
  return goldcost_;
}
inline void CSBuyManualInfo::set_goldcost(::google::protobuf::uint32 value) {
  set_has_goldcost();
  goldcost_ = value;
}

// -------------------------------------------------------------------

// CSQueryPlayerManualRsp

// required uint32 RemainManual = 1;
inline bool CSQueryPlayerManualRsp::has_remainmanual() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSQueryPlayerManualRsp::set_has_remainmanual() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSQueryPlayerManualRsp::clear_has_remainmanual() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSQueryPlayerManualRsp::clear_remainmanual() {
  remainmanual_ = 0u;
  clear_has_remainmanual();
}
inline ::google::protobuf::uint32 CSQueryPlayerManualRsp::remainmanual() const {
  return remainmanual_;
}
inline void CSQueryPlayerManualRsp::set_remainmanual(::google::protobuf::uint32 value) {
  set_has_remainmanual();
  remainmanual_ = value;
}

// required int32 UpdateRemainTime = 2;
inline bool CSQueryPlayerManualRsp::has_updateremaintime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSQueryPlayerManualRsp::set_has_updateremaintime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSQueryPlayerManualRsp::clear_has_updateremaintime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSQueryPlayerManualRsp::clear_updateremaintime() {
  updateremaintime_ = 0;
  clear_has_updateremaintime();
}
inline ::google::protobuf::int32 CSQueryPlayerManualRsp::updateremaintime() const {
  return updateremaintime_;
}
inline void CSQueryPlayerManualRsp::set_updateremaintime(::google::protobuf::int32 value) {
  set_has_updateremaintime();
  updateremaintime_ = value;
}

// required .vmsg.CSBuyManualInfo ManualInfo = 3;
inline bool CSQueryPlayerManualRsp::has_manualinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSQueryPlayerManualRsp::set_has_manualinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSQueryPlayerManualRsp::clear_has_manualinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSQueryPlayerManualRsp::clear_manualinfo() {
  if (manualinfo_ != NULL) manualinfo_->::vmsg::CSBuyManualInfo::Clear();
  clear_has_manualinfo();
}
inline const ::vmsg::CSBuyManualInfo& CSQueryPlayerManualRsp::manualinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return manualinfo_ != NULL ? *manualinfo_ : *default_instance().manualinfo_;
#else
  return manualinfo_ != NULL ? *manualinfo_ : *default_instance_->manualinfo_;
#endif
}
inline ::vmsg::CSBuyManualInfo* CSQueryPlayerManualRsp::mutable_manualinfo() {
  set_has_manualinfo();
  if (manualinfo_ == NULL) manualinfo_ = new ::vmsg::CSBuyManualInfo;
  return manualinfo_;
}
inline ::vmsg::CSBuyManualInfo* CSQueryPlayerManualRsp::release_manualinfo() {
  clear_has_manualinfo();
  ::vmsg::CSBuyManualInfo* temp = manualinfo_;
  manualinfo_ = NULL;
  return temp;
}
inline void CSQueryPlayerManualRsp::set_allocated_manualinfo(::vmsg::CSBuyManualInfo* manualinfo) {
  delete manualinfo_;
  manualinfo_ = manualinfo;
  if (manualinfo) {
    set_has_manualinfo();
  } else {
    clear_has_manualinfo();
  }
}

// -------------------------------------------------------------------

// CSPlayerEvolutionInfo

// required uint32 EvolutionID = 1;
inline bool CSPlayerEvolutionInfo::has_evolutionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerEvolutionInfo::set_has_evolutionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerEvolutionInfo::clear_has_evolutionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerEvolutionInfo::clear_evolutionid() {
  evolutionid_ = 0u;
  clear_has_evolutionid();
}
inline ::google::protobuf::uint32 CSPlayerEvolutionInfo::evolutionid() const {
  return evolutionid_;
}
inline void CSPlayerEvolutionInfo::set_evolutionid(::google::protobuf::uint32 value) {
  set_has_evolutionid();
  evolutionid_ = value;
}

// -------------------------------------------------------------------

// CSEvolutionSkill

// required uint32 StartSkillID = 1;
inline bool CSEvolutionSkill::has_startskillid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSEvolutionSkill::set_has_startskillid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSEvolutionSkill::clear_has_startskillid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSEvolutionSkill::clear_startskillid() {
  startskillid_ = 0u;
  clear_has_startskillid();
}
inline ::google::protobuf::uint32 CSEvolutionSkill::startskillid() const {
  return startskillid_;
}
inline void CSEvolutionSkill::set_startskillid(::google::protobuf::uint32 value) {
  set_has_startskillid();
  startskillid_ = value;
}

// required uint64 Exp = 2;
inline bool CSEvolutionSkill::has_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSEvolutionSkill::set_has_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSEvolutionSkill::clear_has_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSEvolutionSkill::clear_exp() {
  exp_ = GOOGLE_ULONGLONG(0);
  clear_has_exp();
}
inline ::google::protobuf::uint64 CSEvolutionSkill::exp() const {
  return exp_;
}
inline void CSEvolutionSkill::set_exp(::google::protobuf::uint64 value) {
  set_has_exp();
  exp_ = value;
}

// required uint32 Level = 3;
inline bool CSEvolutionSkill::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSEvolutionSkill::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSEvolutionSkill::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSEvolutionSkill::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 CSEvolutionSkill::level() const {
  return level_;
}
inline void CSEvolutionSkill::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// CSPlayerEvolutionSkillInfo

// repeated .vmsg.CSEvolutionSkill Skills = 1;
inline int CSPlayerEvolutionSkillInfo::skills_size() const {
  return skills_.size();
}
inline void CSPlayerEvolutionSkillInfo::clear_skills() {
  skills_.Clear();
}
inline const ::vmsg::CSEvolutionSkill& CSPlayerEvolutionSkillInfo::skills(int index) const {
  return skills_.Get(index);
}
inline ::vmsg::CSEvolutionSkill* CSPlayerEvolutionSkillInfo::mutable_skills(int index) {
  return skills_.Mutable(index);
}
inline ::vmsg::CSEvolutionSkill* CSPlayerEvolutionSkillInfo::add_skills() {
  return skills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSEvolutionSkill >&
CSPlayerEvolutionSkillInfo::skills() const {
  return skills_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSEvolutionSkill >*
CSPlayerEvolutionSkillInfo::mutable_skills() {
  return &skills_;
}

// required int32 UseSkillIdx = 2;
inline bool CSPlayerEvolutionSkillInfo::has_useskillidx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerEvolutionSkillInfo::set_has_useskillidx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerEvolutionSkillInfo::clear_has_useskillidx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerEvolutionSkillInfo::clear_useskillidx() {
  useskillidx_ = 0;
  clear_has_useskillidx();
}
inline ::google::protobuf::int32 CSPlayerEvolutionSkillInfo::useskillidx() const {
  return useskillidx_;
}
inline void CSPlayerEvolutionSkillInfo::set_useskillidx(::google::protobuf::int32 value) {
  set_has_useskillidx();
  useskillidx_ = value;
}

// -------------------------------------------------------------------

// CSChangePlayerEvolutionSkillRqst

// required int32 UseSkillIdx = 1;
inline bool CSChangePlayerEvolutionSkillRqst::has_useskillidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSChangePlayerEvolutionSkillRqst::set_has_useskillidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSChangePlayerEvolutionSkillRqst::clear_has_useskillidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSChangePlayerEvolutionSkillRqst::clear_useskillidx() {
  useskillidx_ = 0;
  clear_has_useskillidx();
}
inline ::google::protobuf::int32 CSChangePlayerEvolutionSkillRqst::useskillidx() const {
  return useskillidx_;
}
inline void CSChangePlayerEvolutionSkillRqst::set_useskillidx(::google::protobuf::int32 value) {
  set_has_useskillidx();
  useskillidx_ = value;
}

// -------------------------------------------------------------------

// CSChangePlayerEvolutionSkillRsp

// required uint32 UseSkillIdx = 1;
inline bool CSChangePlayerEvolutionSkillRsp::has_useskillidx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSChangePlayerEvolutionSkillRsp::set_has_useskillidx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSChangePlayerEvolutionSkillRsp::clear_has_useskillidx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSChangePlayerEvolutionSkillRsp::clear_useskillidx() {
  useskillidx_ = 0u;
  clear_has_useskillidx();
}
inline ::google::protobuf::uint32 CSChangePlayerEvolutionSkillRsp::useskillidx() const {
  return useskillidx_;
}
inline void CSChangePlayerEvolutionSkillRsp::set_useskillidx(::google::protobuf::uint32 value) {
  set_has_useskillidx();
  useskillidx_ = value;
}

// -------------------------------------------------------------------

// CSAttrStrengthenRqst

// required uint32 Type = 1;
inline bool CSAttrStrengthenRqst::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAttrStrengthenRqst::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAttrStrengthenRqst::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAttrStrengthenRqst::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSAttrStrengthenRqst::type() const {
  return type_;
}
inline void CSAttrStrengthenRqst::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required uint32 MagicType = 2;
inline bool CSAttrStrengthenRqst::has_magictype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSAttrStrengthenRqst::set_has_magictype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSAttrStrengthenRqst::clear_has_magictype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSAttrStrengthenRqst::clear_magictype() {
  magictype_ = 0u;
  clear_has_magictype();
}
inline ::google::protobuf::uint32 CSAttrStrengthenRqst::magictype() const {
  return magictype_;
}
inline void CSAttrStrengthenRqst::set_magictype(::google::protobuf::uint32 value) {
  set_has_magictype();
  magictype_ = value;
}

// -------------------------------------------------------------------

// CSAttrStrengthenInfo

// repeated uint32 AtkMagics = 1;
inline int CSAttrStrengthenInfo::atkmagics_size() const {
  return atkmagics_.size();
}
inline void CSAttrStrengthenInfo::clear_atkmagics() {
  atkmagics_.Clear();
}
inline ::google::protobuf::uint32 CSAttrStrengthenInfo::atkmagics(int index) const {
  return atkmagics_.Get(index);
}
inline void CSAttrStrengthenInfo::set_atkmagics(int index, ::google::protobuf::uint32 value) {
  atkmagics_.Set(index, value);
}
inline void CSAttrStrengthenInfo::add_atkmagics(::google::protobuf::uint32 value) {
  atkmagics_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSAttrStrengthenInfo::atkmagics() const {
  return atkmagics_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSAttrStrengthenInfo::mutable_atkmagics() {
  return &atkmagics_;
}

// repeated uint32 DefMagics = 2;
inline int CSAttrStrengthenInfo::defmagics_size() const {
  return defmagics_.size();
}
inline void CSAttrStrengthenInfo::clear_defmagics() {
  defmagics_.Clear();
}
inline ::google::protobuf::uint32 CSAttrStrengthenInfo::defmagics(int index) const {
  return defmagics_.Get(index);
}
inline void CSAttrStrengthenInfo::set_defmagics(int index, ::google::protobuf::uint32 value) {
  defmagics_.Set(index, value);
}
inline void CSAttrStrengthenInfo::add_defmagics(::google::protobuf::uint32 value) {
  defmagics_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSAttrStrengthenInfo::defmagics() const {
  return defmagics_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSAttrStrengthenInfo::mutable_defmagics() {
  return &defmagics_;
}

// -------------------------------------------------------------------

// CSWeaponLotQueryRsp

// required uint32 NormalLotRemainTime = 1;
inline bool CSWeaponLotQueryRsp::has_normallotremaintime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWeaponLotQueryRsp::set_has_normallotremaintime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWeaponLotQueryRsp::clear_has_normallotremaintime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWeaponLotQueryRsp::clear_normallotremaintime() {
  normallotremaintime_ = 0u;
  clear_has_normallotremaintime();
}
inline ::google::protobuf::uint32 CSWeaponLotQueryRsp::normallotremaintime() const {
  return normallotremaintime_;
}
inline void CSWeaponLotQueryRsp::set_normallotremaintime(::google::protobuf::uint32 value) {
  set_has_normallotremaintime();
  normallotremaintime_ = value;
}

// required uint32 AdvanceLotRemainTime = 2;
inline bool CSWeaponLotQueryRsp::has_advancelotremaintime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWeaponLotQueryRsp::set_has_advancelotremaintime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWeaponLotQueryRsp::clear_has_advancelotremaintime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWeaponLotQueryRsp::clear_advancelotremaintime() {
  advancelotremaintime_ = 0u;
  clear_has_advancelotremaintime();
}
inline ::google::protobuf::uint32 CSWeaponLotQueryRsp::advancelotremaintime() const {
  return advancelotremaintime_;
}
inline void CSWeaponLotQueryRsp::set_advancelotremaintime(::google::protobuf::uint32 value) {
  set_has_advancelotremaintime();
  advancelotremaintime_ = value;
}

// required uint32 RemainGoldCardCnt = 3;
inline bool CSWeaponLotQueryRsp::has_remaingoldcardcnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSWeaponLotQueryRsp::set_has_remaingoldcardcnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSWeaponLotQueryRsp::clear_has_remaingoldcardcnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSWeaponLotQueryRsp::clear_remaingoldcardcnt() {
  remaingoldcardcnt_ = 0u;
  clear_has_remaingoldcardcnt();
}
inline ::google::protobuf::uint32 CSWeaponLotQueryRsp::remaingoldcardcnt() const {
  return remaingoldcardcnt_;
}
inline void CSWeaponLotQueryRsp::set_remaingoldcardcnt(::google::protobuf::uint32 value) {
  set_has_remaingoldcardcnt();
  remaingoldcardcnt_ = value;
}

// required uint32 RemainVipAwardCntToday = 4;
inline bool CSWeaponLotQueryRsp::has_remainvipawardcnttoday() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSWeaponLotQueryRsp::set_has_remainvipawardcnttoday() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSWeaponLotQueryRsp::clear_has_remainvipawardcnttoday() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSWeaponLotQueryRsp::clear_remainvipawardcnttoday() {
  remainvipawardcnttoday_ = 0u;
  clear_has_remainvipawardcnttoday();
}
inline ::google::protobuf::uint32 CSWeaponLotQueryRsp::remainvipawardcnttoday() const {
  return remainvipawardcnttoday_;
}
inline void CSWeaponLotQueryRsp::set_remainvipawardcnttoday(::google::protobuf::uint32 value) {
  set_has_remainvipawardcnttoday();
  remainvipawardcnttoday_ = value;
}

// required uint32 RemainVipAwardCntTotal = 5;
inline bool CSWeaponLotQueryRsp::has_remainvipawardcnttotal() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSWeaponLotQueryRsp::set_has_remainvipawardcnttotal() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSWeaponLotQueryRsp::clear_has_remainvipawardcnttotal() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSWeaponLotQueryRsp::clear_remainvipawardcnttotal() {
  remainvipawardcnttotal_ = 0u;
  clear_has_remainvipawardcnttotal();
}
inline ::google::protobuf::uint32 CSWeaponLotQueryRsp::remainvipawardcnttotal() const {
  return remainvipawardcnttotal_;
}
inline void CSWeaponLotQueryRsp::set_remainvipawardcnttotal(::google::protobuf::uint32 value) {
  set_has_remainvipawardcnttotal();
  remainvipawardcnttotal_ = value;
}

// -------------------------------------------------------------------

// CSWeaponLotRqst

// required uint32 Type = 1;
inline bool CSWeaponLotRqst::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWeaponLotRqst::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWeaponLotRqst::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWeaponLotRqst::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSWeaponLotRqst::type() const {
  return type_;
}
inline void CSWeaponLotRqst::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// CSWeaponLotRsp

// required uint32 Type = 1;
inline bool CSWeaponLotRsp::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSWeaponLotRsp::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSWeaponLotRsp::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSWeaponLotRsp::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CSWeaponLotRsp::type() const {
  return type_;
}
inline void CSWeaponLotRsp::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required .vmsg.CSAwardElement FixedElmt = 2;
inline bool CSWeaponLotRsp::has_fixedelmt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSWeaponLotRsp::set_has_fixedelmt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSWeaponLotRsp::clear_has_fixedelmt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSWeaponLotRsp::clear_fixedelmt() {
  if (fixedelmt_ != NULL) fixedelmt_->::vmsg::CSAwardElement::Clear();
  clear_has_fixedelmt();
}
inline const ::vmsg::CSAwardElement& CSWeaponLotRsp::fixedelmt() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fixedelmt_ != NULL ? *fixedelmt_ : *default_instance().fixedelmt_;
#else
  return fixedelmt_ != NULL ? *fixedelmt_ : *default_instance_->fixedelmt_;
#endif
}
inline ::vmsg::CSAwardElement* CSWeaponLotRsp::mutable_fixedelmt() {
  set_has_fixedelmt();
  if (fixedelmt_ == NULL) fixedelmt_ = new ::vmsg::CSAwardElement;
  return fixedelmt_;
}
inline ::vmsg::CSAwardElement* CSWeaponLotRsp::release_fixedelmt() {
  clear_has_fixedelmt();
  ::vmsg::CSAwardElement* temp = fixedelmt_;
  fixedelmt_ = NULL;
  return temp;
}
inline void CSWeaponLotRsp::set_allocated_fixedelmt(::vmsg::CSAwardElement* fixedelmt) {
  delete fixedelmt_;
  fixedelmt_ = fixedelmt;
  if (fixedelmt) {
    set_has_fixedelmt();
  } else {
    clear_has_fixedelmt();
  }
}

// repeated .vmsg.CSAwardElement ElmtLst = 3;
inline int CSWeaponLotRsp::elmtlst_size() const {
  return elmtlst_.size();
}
inline void CSWeaponLotRsp::clear_elmtlst() {
  elmtlst_.Clear();
}
inline const ::vmsg::CSAwardElement& CSWeaponLotRsp::elmtlst(int index) const {
  return elmtlst_.Get(index);
}
inline ::vmsg::CSAwardElement* CSWeaponLotRsp::mutable_elmtlst(int index) {
  return elmtlst_.Mutable(index);
}
inline ::vmsg::CSAwardElement* CSWeaponLotRsp::add_elmtlst() {
  return elmtlst_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >&
CSWeaponLotRsp::elmtlst() const {
  return elmtlst_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardElement >*
CSWeaponLotRsp::mutable_elmtlst() {
  return &elmtlst_;
}

// -------------------------------------------------------------------

// CSAwardRankInfo

// required uint32 RankType = 1;
inline bool CSAwardRankInfo::has_ranktype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSAwardRankInfo::set_has_ranktype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSAwardRankInfo::clear_has_ranktype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSAwardRankInfo::clear_ranktype() {
  ranktype_ = 0u;
  clear_has_ranktype();
}
inline ::google::protobuf::uint32 CSAwardRankInfo::ranktype() const {
  return ranktype_;
}
inline void CSAwardRankInfo::set_ranktype(::google::protobuf::uint32 value) {
  set_has_ranktype();
  ranktype_ = value;
}

// required uint32 HasLastAward = 2;
inline bool CSAwardRankInfo::has_haslastaward() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSAwardRankInfo::set_has_haslastaward() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSAwardRankInfo::clear_has_haslastaward() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSAwardRankInfo::clear_haslastaward() {
  haslastaward_ = 0u;
  clear_has_haslastaward();
}
inline ::google::protobuf::uint32 CSAwardRankInfo::haslastaward() const {
  return haslastaward_;
}
inline void CSAwardRankInfo::set_haslastaward(::google::protobuf::uint32 value) {
  set_has_haslastaward();
  haslastaward_ = value;
}

// required uint32 Coin = 3;
inline bool CSAwardRankInfo::has_coin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSAwardRankInfo::set_has_coin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSAwardRankInfo::clear_has_coin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSAwardRankInfo::clear_coin() {
  coin_ = 0u;
  clear_has_coin();
}
inline ::google::protobuf::uint32 CSAwardRankInfo::coin() const {
  return coin_;
}
inline void CSAwardRankInfo::set_coin(::google::protobuf::uint32 value) {
  set_has_coin();
  coin_ = value;
}

// required uint32 ArenaMoney = 4;
inline bool CSAwardRankInfo::has_arenamoney() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSAwardRankInfo::set_has_arenamoney() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSAwardRankInfo::clear_has_arenamoney() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSAwardRankInfo::clear_arenamoney() {
  arenamoney_ = 0u;
  clear_has_arenamoney();
}
inline ::google::protobuf::uint32 CSAwardRankInfo::arenamoney() const {
  return arenamoney_;
}
inline void CSAwardRankInfo::set_arenamoney(::google::protobuf::uint32 value) {
  set_has_arenamoney();
  arenamoney_ = value;
}

// -------------------------------------------------------------------

// CSAwardRankRsp

// repeated .vmsg.CSAwardRankInfo Infos = 1;
inline int CSAwardRankRsp::infos_size() const {
  return infos_.size();
}
inline void CSAwardRankRsp::clear_infos() {
  infos_.Clear();
}
inline const ::vmsg::CSAwardRankInfo& CSAwardRankRsp::infos(int index) const {
  return infos_.Get(index);
}
inline ::vmsg::CSAwardRankInfo* CSAwardRankRsp::mutable_infos(int index) {
  return infos_.Mutable(index);
}
inline ::vmsg::CSAwardRankInfo* CSAwardRankRsp::add_infos() {
  return infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardRankInfo >&
CSAwardRankRsp::infos() const {
  return infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSAwardRankInfo >*
CSAwardRankRsp::mutable_infos() {
  return &infos_;
}

// required int32 RemainTime = 2;
inline bool CSAwardRankRsp::has_remaintime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSAwardRankRsp::set_has_remaintime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSAwardRankRsp::clear_has_remaintime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSAwardRankRsp::clear_remaintime() {
  remaintime_ = 0;
  clear_has_remaintime();
}
inline ::google::protobuf::int32 CSAwardRankRsp::remaintime() const {
  return remaintime_;
}
inline void CSAwardRankRsp::set_remaintime(::google::protobuf::int32 value) {
  set_has_remaintime();
  remaintime_ = value;
}

// -------------------------------------------------------------------

// CSFetchRankAwardRqst

// required uint32 RankType = 1;
inline bool CSFetchRankAwardRqst::has_ranktype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSFetchRankAwardRqst::set_has_ranktype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSFetchRankAwardRqst::clear_has_ranktype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSFetchRankAwardRqst::clear_ranktype() {
  ranktype_ = 0u;
  clear_has_ranktype();
}
inline ::google::protobuf::uint32 CSFetchRankAwardRqst::ranktype() const {
  return ranktype_;
}
inline void CSFetchRankAwardRqst::set_ranktype(::google::protobuf::uint32 value) {
  set_has_ranktype();
  ranktype_ = value;
}

// -------------------------------------------------------------------

// CSPlayerLvUpRsp

// required uint32 Lv = 1;
inline bool CSPlayerLvUpRsp::has_lv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerLvUpRsp::set_has_lv() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerLvUpRsp::clear_has_lv() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerLvUpRsp::clear_lv() {
  lv_ = 0u;
  clear_has_lv();
}
inline ::google::protobuf::uint32 CSPlayerLvUpRsp::lv() const {
  return lv_;
}
inline void CSPlayerLvUpRsp::set_lv(::google::protobuf::uint32 value) {
  set_has_lv();
  lv_ = value;
}

// required uint64 Exp = 2;
inline bool CSPlayerLvUpRsp::has_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerLvUpRsp::set_has_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerLvUpRsp::clear_has_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerLvUpRsp::clear_exp() {
  exp_ = GOOGLE_ULONGLONG(0);
  clear_has_exp();
}
inline ::google::protobuf::uint64 CSPlayerLvUpRsp::exp() const {
  return exp_;
}
inline void CSPlayerLvUpRsp::set_exp(::google::protobuf::uint64 value) {
  set_has_exp();
  exp_ = value;
}

// -------------------------------------------------------------------

// CSVIPNotify

// required uint32 VIPLv = 1;
inline bool CSVIPNotify::has_viplv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSVIPNotify::set_has_viplv() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSVIPNotify::clear_has_viplv() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSVIPNotify::clear_viplv() {
  viplv_ = 0u;
  clear_has_viplv();
}
inline ::google::protobuf::uint32 CSVIPNotify::viplv() const {
  return viplv_;
}
inline void CSVIPNotify::set_viplv(::google::protobuf::uint32 value) {
  set_has_viplv();
  viplv_ = value;
}

// -------------------------------------------------------------------

// CSVIPInfos

// repeated uint32 VIPAward = 1;
inline int CSVIPInfos::vipaward_size() const {
  return vipaward_.size();
}
inline void CSVIPInfos::clear_vipaward() {
  vipaward_.Clear();
}
inline ::google::protobuf::uint32 CSVIPInfos::vipaward(int index) const {
  return vipaward_.Get(index);
}
inline void CSVIPInfos::set_vipaward(int index, ::google::protobuf::uint32 value) {
  vipaward_.Set(index, value);
}
inline void CSVIPInfos::add_vipaward(::google::protobuf::uint32 value) {
  vipaward_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CSVIPInfos::vipaward() const {
  return vipaward_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CSVIPInfos::mutable_vipaward() {
  return &vipaward_;
}

// -------------------------------------------------------------------

// CSFightPowerNotify

// required uint64 FightPower = 1;
inline bool CSFightPowerNotify::has_fightpower() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSFightPowerNotify::set_has_fightpower() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSFightPowerNotify::clear_has_fightpower() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSFightPowerNotify::clear_fightpower() {
  fightpower_ = GOOGLE_ULONGLONG(0);
  clear_has_fightpower();
}
inline ::google::protobuf::uint64 CSFightPowerNotify::fightpower() const {
  return fightpower_;
}
inline void CSFightPowerNotify::set_fightpower(::google::protobuf::uint64 value) {
  set_has_fightpower();
  fightpower_ = value;
}

// -------------------------------------------------------------------

// CSOtherPlayerInfoRsp

// required .vmsg.CSPlayerInfo PlayerInfo = 1;
inline bool CSOtherPlayerInfoRsp::has_playerinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSOtherPlayerInfoRsp::set_has_playerinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSOtherPlayerInfoRsp::clear_has_playerinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSOtherPlayerInfoRsp::clear_playerinfo() {
  if (playerinfo_ != NULL) playerinfo_->::vmsg::CSPlayerInfo::Clear();
  clear_has_playerinfo();
}
inline const ::vmsg::CSPlayerInfo& CSOtherPlayerInfoRsp::playerinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerinfo_ != NULL ? *playerinfo_ : *default_instance().playerinfo_;
#else
  return playerinfo_ != NULL ? *playerinfo_ : *default_instance_->playerinfo_;
#endif
}
inline ::vmsg::CSPlayerInfo* CSOtherPlayerInfoRsp::mutable_playerinfo() {
  set_has_playerinfo();
  if (playerinfo_ == NULL) playerinfo_ = new ::vmsg::CSPlayerInfo;
  return playerinfo_;
}
inline ::vmsg::CSPlayerInfo* CSOtherPlayerInfoRsp::release_playerinfo() {
  clear_has_playerinfo();
  ::vmsg::CSPlayerInfo* temp = playerinfo_;
  playerinfo_ = NULL;
  return temp;
}
inline void CSOtherPlayerInfoRsp::set_allocated_playerinfo(::vmsg::CSPlayerInfo* playerinfo) {
  delete playerinfo_;
  playerinfo_ = playerinfo;
  if (playerinfo) {
    set_has_playerinfo();
  } else {
    clear_has_playerinfo();
  }
}

// required .vmsg.CSPlayerDetailInfo DetailInfo = 2;
inline bool CSOtherPlayerInfoRsp::has_detailinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSOtherPlayerInfoRsp::set_has_detailinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSOtherPlayerInfoRsp::clear_has_detailinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSOtherPlayerInfoRsp::clear_detailinfo() {
  if (detailinfo_ != NULL) detailinfo_->::vmsg::CSPlayerDetailInfo::Clear();
  clear_has_detailinfo();
}
inline const ::vmsg::CSPlayerDetailInfo& CSOtherPlayerInfoRsp::detailinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return detailinfo_ != NULL ? *detailinfo_ : *default_instance().detailinfo_;
#else
  return detailinfo_ != NULL ? *detailinfo_ : *default_instance_->detailinfo_;
#endif
}
inline ::vmsg::CSPlayerDetailInfo* CSOtherPlayerInfoRsp::mutable_detailinfo() {
  set_has_detailinfo();
  if (detailinfo_ == NULL) detailinfo_ = new ::vmsg::CSPlayerDetailInfo;
  return detailinfo_;
}
inline ::vmsg::CSPlayerDetailInfo* CSOtherPlayerInfoRsp::release_detailinfo() {
  clear_has_detailinfo();
  ::vmsg::CSPlayerDetailInfo* temp = detailinfo_;
  detailinfo_ = NULL;
  return temp;
}
inline void CSOtherPlayerInfoRsp::set_allocated_detailinfo(::vmsg::CSPlayerDetailInfo* detailinfo) {
  delete detailinfo_;
  detailinfo_ = detailinfo;
  if (detailinfo) {
    set_has_detailinfo();
  } else {
    clear_has_detailinfo();
  }
}

// -------------------------------------------------------------------

// CSBlackProductInfo

// required uint32 ProductType = 1;
inline bool CSBlackProductInfo::has_producttype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBlackProductInfo::set_has_producttype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBlackProductInfo::clear_has_producttype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBlackProductInfo::clear_producttype() {
  producttype_ = 0u;
  clear_has_producttype();
}
inline ::google::protobuf::uint32 CSBlackProductInfo::producttype() const {
  return producttype_;
}
inline void CSBlackProductInfo::set_producttype(::google::protobuf::uint32 value) {
  set_has_producttype();
  producttype_ = value;
}

// required uint32 ProductCfgID = 2;
inline bool CSBlackProductInfo::has_productcfgid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBlackProductInfo::set_has_productcfgid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBlackProductInfo::clear_has_productcfgid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBlackProductInfo::clear_productcfgid() {
  productcfgid_ = 0u;
  clear_has_productcfgid();
}
inline ::google::protobuf::uint32 CSBlackProductInfo::productcfgid() const {
  return productcfgid_;
}
inline void CSBlackProductInfo::set_productcfgid(::google::protobuf::uint32 value) {
  set_has_productcfgid();
  productcfgid_ = value;
}

// required uint32 ProductCnt = 3;
inline bool CSBlackProductInfo::has_productcnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBlackProductInfo::set_has_productcnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBlackProductInfo::clear_has_productcnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBlackProductInfo::clear_productcnt() {
  productcnt_ = 0u;
  clear_has_productcnt();
}
inline ::google::protobuf::uint32 CSBlackProductInfo::productcnt() const {
  return productcnt_;
}
inline void CSBlackProductInfo::set_productcnt(::google::protobuf::uint32 value) {
  set_has_productcnt();
  productcnt_ = value;
}

// required uint32 CurrType = 4;
inline bool CSBlackProductInfo::has_currtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSBlackProductInfo::set_has_currtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSBlackProductInfo::clear_has_currtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSBlackProductInfo::clear_currtype() {
  currtype_ = 0u;
  clear_has_currtype();
}
inline ::google::protobuf::uint32 CSBlackProductInfo::currtype() const {
  return currtype_;
}
inline void CSBlackProductInfo::set_currtype(::google::protobuf::uint32 value) {
  set_has_currtype();
  currtype_ = value;
}

// required uint32 CurrCnt = 5;
inline bool CSBlackProductInfo::has_currcnt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSBlackProductInfo::set_has_currcnt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSBlackProductInfo::clear_has_currcnt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSBlackProductInfo::clear_currcnt() {
  currcnt_ = 0u;
  clear_has_currcnt();
}
inline ::google::protobuf::uint32 CSBlackProductInfo::currcnt() const {
  return currcnt_;
}
inline void CSBlackProductInfo::set_currcnt(::google::protobuf::uint32 value) {
  set_has_currcnt();
  currcnt_ = value;
}

// required uint32 HasBought = 6;
inline bool CSBlackProductInfo::has_hasbought() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSBlackProductInfo::set_has_hasbought() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSBlackProductInfo::clear_has_hasbought() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSBlackProductInfo::clear_hasbought() {
  hasbought_ = 0u;
  clear_has_hasbought();
}
inline ::google::protobuf::uint32 CSBlackProductInfo::hasbought() const {
  return hasbought_;
}
inline void CSBlackProductInfo::set_hasbought(::google::protobuf::uint32 value) {
  set_has_hasbought();
  hasbought_ = value;
}

// -------------------------------------------------------------------

// CSBlackMarketInfo

// required uint32 RemainTime = 1;
inline bool CSBlackMarketInfo::has_remaintime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBlackMarketInfo::set_has_remaintime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBlackMarketInfo::clear_has_remaintime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBlackMarketInfo::clear_remaintime() {
  remaintime_ = 0u;
  clear_has_remaintime();
}
inline ::google::protobuf::uint32 CSBlackMarketInfo::remaintime() const {
  return remaintime_;
}
inline void CSBlackMarketInfo::set_remaintime(::google::protobuf::uint32 value) {
  set_has_remaintime();
  remaintime_ = value;
}

// required uint32 ResetCost = 2;
inline bool CSBlackMarketInfo::has_resetcost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBlackMarketInfo::set_has_resetcost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBlackMarketInfo::clear_has_resetcost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBlackMarketInfo::clear_resetcost() {
  resetcost_ = 0u;
  clear_has_resetcost();
}
inline ::google::protobuf::uint32 CSBlackMarketInfo::resetcost() const {
  return resetcost_;
}
inline void CSBlackMarketInfo::set_resetcost(::google::protobuf::uint32 value) {
  set_has_resetcost();
  resetcost_ = value;
}

// required uint32 RemainResetCnt = 3;
inline bool CSBlackMarketInfo::has_remainresetcnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBlackMarketInfo::set_has_remainresetcnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBlackMarketInfo::clear_has_remainresetcnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBlackMarketInfo::clear_remainresetcnt() {
  remainresetcnt_ = 0u;
  clear_has_remainresetcnt();
}
inline ::google::protobuf::uint32 CSBlackMarketInfo::remainresetcnt() const {
  return remainresetcnt_;
}
inline void CSBlackMarketInfo::set_remainresetcnt(::google::protobuf::uint32 value) {
  set_has_remainresetcnt();
  remainresetcnt_ = value;
}

// repeated .vmsg.CSBlackProductInfo Products = 4;
inline int CSBlackMarketInfo::products_size() const {
  return products_.size();
}
inline void CSBlackMarketInfo::clear_products() {
  products_.Clear();
}
inline const ::vmsg::CSBlackProductInfo& CSBlackMarketInfo::products(int index) const {
  return products_.Get(index);
}
inline ::vmsg::CSBlackProductInfo* CSBlackMarketInfo::mutable_products(int index) {
  return products_.Mutable(index);
}
inline ::vmsg::CSBlackProductInfo* CSBlackMarketInfo::add_products() {
  return products_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::vmsg::CSBlackProductInfo >&
CSBlackMarketInfo::products() const {
  return products_;
}
inline ::google::protobuf::RepeatedPtrField< ::vmsg::CSBlackProductInfo >*
CSBlackMarketInfo::mutable_products() {
  return &products_;
}

// -------------------------------------------------------------------

// CSQuickLoginRqst

// required uint32 NeedOSDCast = 1;
inline bool CSQuickLoginRqst::has_needosdcast() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSQuickLoginRqst::set_has_needosdcast() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSQuickLoginRqst::clear_has_needosdcast() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSQuickLoginRqst::clear_needosdcast() {
  needosdcast_ = 0u;
  clear_has_needosdcast();
}
inline ::google::protobuf::uint32 CSQuickLoginRqst::needosdcast() const {
  return needosdcast_;
}
inline void CSQuickLoginRqst::set_needosdcast(::google::protobuf::uint32 value) {
  set_has_needosdcast();
  needosdcast_ = value;
}

// -------------------------------------------------------------------

// CSQuickLoginRsp

// required uint64 QuickKey = 1;
inline bool CSQuickLoginRsp::has_quickkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSQuickLoginRsp::set_has_quickkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSQuickLoginRsp::clear_has_quickkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSQuickLoginRsp::clear_quickkey() {
  quickkey_ = GOOGLE_ULONGLONG(0);
  clear_has_quickkey();
}
inline ::google::protobuf::uint64 CSQuickLoginRsp::quickkey() const {
  return quickkey_;
}
inline void CSQuickLoginRsp::set_quickkey(::google::protobuf::uint64 value) {
  set_has_quickkey();
  quickkey_ = value;
}

// -------------------------------------------------------------------

// CSBuyCoinInfo

// required uint32 RemainCnt = 1;
inline bool CSBuyCoinInfo::has_remaincnt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBuyCoinInfo::set_has_remaincnt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBuyCoinInfo::clear_has_remaincnt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBuyCoinInfo::clear_remaincnt() {
  remaincnt_ = 0u;
  clear_has_remaincnt();
}
inline ::google::protobuf::uint32 CSBuyCoinInfo::remaincnt() const {
  return remaincnt_;
}
inline void CSBuyCoinInfo::set_remaincnt(::google::protobuf::uint32 value) {
  set_has_remaincnt();
  remaincnt_ = value;
}

// required uint32 NextCostGold = 2;
inline bool CSBuyCoinInfo::has_nextcostgold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBuyCoinInfo::set_has_nextcostgold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBuyCoinInfo::clear_has_nextcostgold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBuyCoinInfo::clear_nextcostgold() {
  nextcostgold_ = 0u;
  clear_has_nextcostgold();
}
inline ::google::protobuf::uint32 CSBuyCoinInfo::nextcostgold() const {
  return nextcostgold_;
}
inline void CSBuyCoinInfo::set_nextcostgold(::google::protobuf::uint32 value) {
  set_has_nextcostgold();
  nextcostgold_ = value;
}

// required uint32 NextCoin = 3;
inline bool CSBuyCoinInfo::has_nextcoin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBuyCoinInfo::set_has_nextcoin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBuyCoinInfo::clear_has_nextcoin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBuyCoinInfo::clear_nextcoin() {
  nextcoin_ = 0u;
  clear_has_nextcoin();
}
inline ::google::protobuf::uint32 CSBuyCoinInfo::nextcoin() const {
  return nextcoin_;
}
inline void CSBuyCoinInfo::set_nextcoin(::google::protobuf::uint32 value) {
  set_has_nextcoin();
  nextcoin_ = value;
}

// required uint32 MaxCnt = 4;
inline bool CSBuyCoinInfo::has_maxcnt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSBuyCoinInfo::set_has_maxcnt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSBuyCoinInfo::clear_has_maxcnt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSBuyCoinInfo::clear_maxcnt() {
  maxcnt_ = 0u;
  clear_has_maxcnt();
}
inline ::google::protobuf::uint32 CSBuyCoinInfo::maxcnt() const {
  return maxcnt_;
}
inline void CSBuyCoinInfo::set_maxcnt(::google::protobuf::uint32 value) {
  set_has_maxcnt();
  maxcnt_ = value;
}

// -------------------------------------------------------------------

// CSBuyCoinRsp

// required .vmsg.CSBuyCoinInfo Info = 1;
inline bool CSBuyCoinRsp::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSBuyCoinRsp::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSBuyCoinRsp::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSBuyCoinRsp::clear_info() {
  if (info_ != NULL) info_->::vmsg::CSBuyCoinInfo::Clear();
  clear_has_info();
}
inline const ::vmsg::CSBuyCoinInfo& CSBuyCoinRsp::info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return info_ != NULL ? *info_ : *default_instance().info_;
#else
  return info_ != NULL ? *info_ : *default_instance_->info_;
#endif
}
inline ::vmsg::CSBuyCoinInfo* CSBuyCoinRsp::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::vmsg::CSBuyCoinInfo;
  return info_;
}
inline ::vmsg::CSBuyCoinInfo* CSBuyCoinRsp::release_info() {
  clear_has_info();
  ::vmsg::CSBuyCoinInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void CSBuyCoinRsp::set_allocated_info(::vmsg::CSBuyCoinInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// required uint32 CritMulti = 2;
inline bool CSBuyCoinRsp::has_critmulti() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSBuyCoinRsp::set_has_critmulti() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSBuyCoinRsp::clear_has_critmulti() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSBuyCoinRsp::clear_critmulti() {
  critmulti_ = 0u;
  clear_has_critmulti();
}
inline ::google::protobuf::uint32 CSBuyCoinRsp::critmulti() const {
  return critmulti_;
}
inline void CSBuyCoinRsp::set_critmulti(::google::protobuf::uint32 value) {
  set_has_critmulti();
  critmulti_ = value;
}

// required uint32 Coin = 3;
inline bool CSBuyCoinRsp::has_coin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSBuyCoinRsp::set_has_coin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSBuyCoinRsp::clear_has_coin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSBuyCoinRsp::clear_coin() {
  coin_ = 0u;
  clear_has_coin();
}
inline ::google::protobuf::uint32 CSBuyCoinRsp::coin() const {
  return coin_;
}
inline void CSBuyCoinRsp::set_coin(::google::protobuf::uint32 value) {
  set_has_coin();
  coin_ = value;
}

// -------------------------------------------------------------------

// CSGuestRegisterRsp

// required string GuestOpenID = 1;
inline bool CSGuestRegisterRsp::has_guestopenid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGuestRegisterRsp::set_has_guestopenid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGuestRegisterRsp::clear_has_guestopenid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGuestRegisterRsp::clear_guestopenid() {
  if (guestopenid_ != &::google::protobuf::internal::kEmptyString) {
    guestopenid_->clear();
  }
  clear_has_guestopenid();
}
inline const ::std::string& CSGuestRegisterRsp::guestopenid() const {
  return *guestopenid_;
}
inline void CSGuestRegisterRsp::set_guestopenid(const ::std::string& value) {
  set_has_guestopenid();
  if (guestopenid_ == &::google::protobuf::internal::kEmptyString) {
    guestopenid_ = new ::std::string;
  }
  guestopenid_->assign(value);
}
inline void CSGuestRegisterRsp::set_guestopenid(const char* value) {
  set_has_guestopenid();
  if (guestopenid_ == &::google::protobuf::internal::kEmptyString) {
    guestopenid_ = new ::std::string;
  }
  guestopenid_->assign(value);
}
inline void CSGuestRegisterRsp::set_guestopenid(const char* value, size_t size) {
  set_has_guestopenid();
  if (guestopenid_ == &::google::protobuf::internal::kEmptyString) {
    guestopenid_ = new ::std::string;
  }
  guestopenid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSGuestRegisterRsp::mutable_guestopenid() {
  set_has_guestopenid();
  if (guestopenid_ == &::google::protobuf::internal::kEmptyString) {
    guestopenid_ = new ::std::string;
  }
  return guestopenid_;
}
inline ::std::string* CSGuestRegisterRsp::release_guestopenid() {
  clear_has_guestopenid();
  if (guestopenid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guestopenid_;
    guestopenid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSGuestRegisterRsp::set_allocated_guestopenid(::std::string* guestopenid) {
  if (guestopenid_ != &::google::protobuf::internal::kEmptyString) {
    delete guestopenid_;
  }
  if (guestopenid) {
    set_has_guestopenid();
    guestopenid_ = guestopenid;
  } else {
    clear_has_guestopenid();
    guestopenid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 Uin = 2;
inline bool CSGuestRegisterRsp::has_uin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGuestRegisterRsp::set_has_uin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGuestRegisterRsp::clear_has_uin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGuestRegisterRsp::clear_uin() {
  uin_ = GOOGLE_ULONGLONG(0);
  clear_has_uin();
}
inline ::google::protobuf::uint64 CSGuestRegisterRsp::uin() const {
  return uin_;
}
inline void CSGuestRegisterRsp::set_uin(::google::protobuf::uint64 value) {
  set_has_uin();
  uin_ = value;
}

// -------------------------------------------------------------------

// CSGuestBindRqst

// required string GuestOpenID = 1;
inline bool CSGuestBindRqst::has_guestopenid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGuestBindRqst::set_has_guestopenid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGuestBindRqst::clear_has_guestopenid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGuestBindRqst::clear_guestopenid() {
  if (guestopenid_ != &::google::protobuf::internal::kEmptyString) {
    guestopenid_->clear();
  }
  clear_has_guestopenid();
}
inline const ::std::string& CSGuestBindRqst::guestopenid() const {
  return *guestopenid_;
}
inline void CSGuestBindRqst::set_guestopenid(const ::std::string& value) {
  set_has_guestopenid();
  if (guestopenid_ == &::google::protobuf::internal::kEmptyString) {
    guestopenid_ = new ::std::string;
  }
  guestopenid_->assign(value);
}
inline void CSGuestBindRqst::set_guestopenid(const char* value) {
  set_has_guestopenid();
  if (guestopenid_ == &::google::protobuf::internal::kEmptyString) {
    guestopenid_ = new ::std::string;
  }
  guestopenid_->assign(value);
}
inline void CSGuestBindRqst::set_guestopenid(const char* value, size_t size) {
  set_has_guestopenid();
  if (guestopenid_ == &::google::protobuf::internal::kEmptyString) {
    guestopenid_ = new ::std::string;
  }
  guestopenid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSGuestBindRqst::mutable_guestopenid() {
  set_has_guestopenid();
  if (guestopenid_ == &::google::protobuf::internal::kEmptyString) {
    guestopenid_ = new ::std::string;
  }
  return guestopenid_;
}
inline ::std::string* CSGuestBindRqst::release_guestopenid() {
  clear_has_guestopenid();
  if (guestopenid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guestopenid_;
    guestopenid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSGuestBindRqst::set_allocated_guestopenid(::std::string* guestopenid) {
  if (guestopenid_ != &::google::protobuf::internal::kEmptyString) {
    delete guestopenid_;
  }
  if (guestopenid) {
    set_has_guestopenid();
    guestopenid_ = guestopenid;
  } else {
    clear_has_guestopenid();
    guestopenid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string FormalOpenID = 2;
inline bool CSGuestBindRqst::has_formalopenid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSGuestBindRqst::set_has_formalopenid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSGuestBindRqst::clear_has_formalopenid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSGuestBindRqst::clear_formalopenid() {
  if (formalopenid_ != &::google::protobuf::internal::kEmptyString) {
    formalopenid_->clear();
  }
  clear_has_formalopenid();
}
inline const ::std::string& CSGuestBindRqst::formalopenid() const {
  return *formalopenid_;
}
inline void CSGuestBindRqst::set_formalopenid(const ::std::string& value) {
  set_has_formalopenid();
  if (formalopenid_ == &::google::protobuf::internal::kEmptyString) {
    formalopenid_ = new ::std::string;
  }
  formalopenid_->assign(value);
}
inline void CSGuestBindRqst::set_formalopenid(const char* value) {
  set_has_formalopenid();
  if (formalopenid_ == &::google::protobuf::internal::kEmptyString) {
    formalopenid_ = new ::std::string;
  }
  formalopenid_->assign(value);
}
inline void CSGuestBindRqst::set_formalopenid(const char* value, size_t size) {
  set_has_formalopenid();
  if (formalopenid_ == &::google::protobuf::internal::kEmptyString) {
    formalopenid_ = new ::std::string;
  }
  formalopenid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSGuestBindRqst::mutable_formalopenid() {
  set_has_formalopenid();
  if (formalopenid_ == &::google::protobuf::internal::kEmptyString) {
    formalopenid_ = new ::std::string;
  }
  return formalopenid_;
}
inline ::std::string* CSGuestBindRqst::release_formalopenid() {
  clear_has_formalopenid();
  if (formalopenid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = formalopenid_;
    formalopenid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSGuestBindRqst::set_allocated_formalopenid(::std::string* formalopenid) {
  if (formalopenid_ != &::google::protobuf::internal::kEmptyString) {
    delete formalopenid_;
  }
  if (formalopenid) {
    set_has_formalopenid();
    formalopenid_ = formalopenid;
  } else {
    clear_has_formalopenid();
    formalopenid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSPlayerEnforceMyselfRqst

// required uint32 EnforceType = 1;
inline bool CSPlayerEnforceMyselfRqst::has_enforcetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerEnforceMyselfRqst::set_has_enforcetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerEnforceMyselfRqst::clear_has_enforcetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerEnforceMyselfRqst::clear_enforcetype() {
  enforcetype_ = 0u;
  clear_has_enforcetype();
}
inline ::google::protobuf::uint32 CSPlayerEnforceMyselfRqst::enforcetype() const {
  return enforcetype_;
}
inline void CSPlayerEnforceMyselfRqst::set_enforcetype(::google::protobuf::uint32 value) {
  set_has_enforcetype();
  enforcetype_ = value;
}

// -------------------------------------------------------------------

// CSPlayerEnforceMyselfRsp

// required int32 HPAdd = 1;
inline bool CSPlayerEnforceMyselfRsp::has_hpadd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerEnforceMyselfRsp::set_has_hpadd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerEnforceMyselfRsp::clear_has_hpadd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerEnforceMyselfRsp::clear_hpadd() {
  hpadd_ = 0;
  clear_has_hpadd();
}
inline ::google::protobuf::int32 CSPlayerEnforceMyselfRsp::hpadd() const {
  return hpadd_;
}
inline void CSPlayerEnforceMyselfRsp::set_hpadd(::google::protobuf::int32 value) {
  set_has_hpadd();
  hpadd_ = value;
}

// required int32 AtkAdd = 2;
inline bool CSPlayerEnforceMyselfRsp::has_atkadd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerEnforceMyselfRsp::set_has_atkadd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerEnforceMyselfRsp::clear_has_atkadd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerEnforceMyselfRsp::clear_atkadd() {
  atkadd_ = 0;
  clear_has_atkadd();
}
inline ::google::protobuf::int32 CSPlayerEnforceMyselfRsp::atkadd() const {
  return atkadd_;
}
inline void CSPlayerEnforceMyselfRsp::set_atkadd(::google::protobuf::int32 value) {
  set_has_atkadd();
  atkadd_ = value;
}

// required int32 DefAdd = 3;
inline bool CSPlayerEnforceMyselfRsp::has_defadd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPlayerEnforceMyselfRsp::set_has_defadd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPlayerEnforceMyselfRsp::clear_has_defadd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPlayerEnforceMyselfRsp::clear_defadd() {
  defadd_ = 0;
  clear_has_defadd();
}
inline ::google::protobuf::int32 CSPlayerEnforceMyselfRsp::defadd() const {
  return defadd_;
}
inline void CSPlayerEnforceMyselfRsp::set_defadd(::google::protobuf::int32 value) {
  set_has_defadd();
  defadd_ = value;
}

// required uint32 TotalHPAdd = 4;
inline bool CSPlayerEnforceMyselfRsp::has_totalhpadd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPlayerEnforceMyselfRsp::set_has_totalhpadd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPlayerEnforceMyselfRsp::clear_has_totalhpadd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPlayerEnforceMyselfRsp::clear_totalhpadd() {
  totalhpadd_ = 0u;
  clear_has_totalhpadd();
}
inline ::google::protobuf::uint32 CSPlayerEnforceMyselfRsp::totalhpadd() const {
  return totalhpadd_;
}
inline void CSPlayerEnforceMyselfRsp::set_totalhpadd(::google::protobuf::uint32 value) {
  set_has_totalhpadd();
  totalhpadd_ = value;
}

// required uint32 TotalAtkAdd = 5;
inline bool CSPlayerEnforceMyselfRsp::has_totalatkadd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPlayerEnforceMyselfRsp::set_has_totalatkadd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPlayerEnforceMyselfRsp::clear_has_totalatkadd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPlayerEnforceMyselfRsp::clear_totalatkadd() {
  totalatkadd_ = 0u;
  clear_has_totalatkadd();
}
inline ::google::protobuf::uint32 CSPlayerEnforceMyselfRsp::totalatkadd() const {
  return totalatkadd_;
}
inline void CSPlayerEnforceMyselfRsp::set_totalatkadd(::google::protobuf::uint32 value) {
  set_has_totalatkadd();
  totalatkadd_ = value;
}

// required uint32 TotalDefAdd = 6;
inline bool CSPlayerEnforceMyselfRsp::has_totaldefadd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSPlayerEnforceMyselfRsp::set_has_totaldefadd() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSPlayerEnforceMyselfRsp::clear_has_totaldefadd() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSPlayerEnforceMyselfRsp::clear_totaldefadd() {
  totaldefadd_ = 0u;
  clear_has_totaldefadd();
}
inline ::google::protobuf::uint32 CSPlayerEnforceMyselfRsp::totaldefadd() const {
  return totaldefadd_;
}
inline void CSPlayerEnforceMyselfRsp::set_totaldefadd(::google::protobuf::uint32 value) {
  set_has_totaldefadd();
  totaldefadd_ = value;
}

// -------------------------------------------------------------------

// CSPlayerEnforceMyselfConfirmRqst

// required uint32 IsAccept = 1;
inline bool CSPlayerEnforceMyselfConfirmRqst::has_isaccept() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerEnforceMyselfConfirmRqst::set_has_isaccept() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerEnforceMyselfConfirmRqst::clear_has_isaccept() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerEnforceMyselfConfirmRqst::clear_isaccept() {
  isaccept_ = 0u;
  clear_has_isaccept();
}
inline ::google::protobuf::uint32 CSPlayerEnforceMyselfConfirmRqst::isaccept() const {
  return isaccept_;
}
inline void CSPlayerEnforceMyselfConfirmRqst::set_isaccept(::google::protobuf::uint32 value) {
  set_has_isaccept();
  isaccept_ = value;
}

// -------------------------------------------------------------------

// CSPlayerEnforceMyselfConfirmRsp

// required uint32 TotalHPAdd = 1;
inline bool CSPlayerEnforceMyselfConfirmRsp::has_totalhpadd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerEnforceMyselfConfirmRsp::set_has_totalhpadd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerEnforceMyselfConfirmRsp::clear_has_totalhpadd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerEnforceMyselfConfirmRsp::clear_totalhpadd() {
  totalhpadd_ = 0u;
  clear_has_totalhpadd();
}
inline ::google::protobuf::uint32 CSPlayerEnforceMyselfConfirmRsp::totalhpadd() const {
  return totalhpadd_;
}
inline void CSPlayerEnforceMyselfConfirmRsp::set_totalhpadd(::google::protobuf::uint32 value) {
  set_has_totalhpadd();
  totalhpadd_ = value;
}

// required uint32 TotalAtkAdd = 2;
inline bool CSPlayerEnforceMyselfConfirmRsp::has_totalatkadd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerEnforceMyselfConfirmRsp::set_has_totalatkadd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerEnforceMyselfConfirmRsp::clear_has_totalatkadd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerEnforceMyselfConfirmRsp::clear_totalatkadd() {
  totalatkadd_ = 0u;
  clear_has_totalatkadd();
}
inline ::google::protobuf::uint32 CSPlayerEnforceMyselfConfirmRsp::totalatkadd() const {
  return totalatkadd_;
}
inline void CSPlayerEnforceMyselfConfirmRsp::set_totalatkadd(::google::protobuf::uint32 value) {
  set_has_totalatkadd();
  totalatkadd_ = value;
}

// required uint32 TotalDefAdd = 3;
inline bool CSPlayerEnforceMyselfConfirmRsp::has_totaldefadd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPlayerEnforceMyselfConfirmRsp::set_has_totaldefadd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPlayerEnforceMyselfConfirmRsp::clear_has_totaldefadd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPlayerEnforceMyselfConfirmRsp::clear_totaldefadd() {
  totaldefadd_ = 0u;
  clear_has_totaldefadd();
}
inline ::google::protobuf::uint32 CSPlayerEnforceMyselfConfirmRsp::totaldefadd() const {
  return totaldefadd_;
}
inline void CSPlayerEnforceMyselfConfirmRsp::set_totaldefadd(::google::protobuf::uint32 value) {
  set_has_totaldefadd();
  totaldefadd_ = value;
}

// -------------------------------------------------------------------

// CSPlayerEnforceMyselfQueryRsp

// required uint32 TotalHPAdd = 1;
inline bool CSPlayerEnforceMyselfQueryRsp::has_totalhpadd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerEnforceMyselfQueryRsp::set_has_totalhpadd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerEnforceMyselfQueryRsp::clear_has_totalhpadd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerEnforceMyselfQueryRsp::clear_totalhpadd() {
  totalhpadd_ = 0u;
  clear_has_totalhpadd();
}
inline ::google::protobuf::uint32 CSPlayerEnforceMyselfQueryRsp::totalhpadd() const {
  return totalhpadd_;
}
inline void CSPlayerEnforceMyselfQueryRsp::set_totalhpadd(::google::protobuf::uint32 value) {
  set_has_totalhpadd();
  totalhpadd_ = value;
}

// required uint32 TotalAtkAdd = 2;
inline bool CSPlayerEnforceMyselfQueryRsp::has_totalatkadd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerEnforceMyselfQueryRsp::set_has_totalatkadd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerEnforceMyselfQueryRsp::clear_has_totalatkadd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerEnforceMyselfQueryRsp::clear_totalatkadd() {
  totalatkadd_ = 0u;
  clear_has_totalatkadd();
}
inline ::google::protobuf::uint32 CSPlayerEnforceMyselfQueryRsp::totalatkadd() const {
  return totalatkadd_;
}
inline void CSPlayerEnforceMyselfQueryRsp::set_totalatkadd(::google::protobuf::uint32 value) {
  set_has_totalatkadd();
  totalatkadd_ = value;
}

// required uint32 TotalDefAdd = 3;
inline bool CSPlayerEnforceMyselfQueryRsp::has_totaldefadd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPlayerEnforceMyselfQueryRsp::set_has_totaldefadd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPlayerEnforceMyselfQueryRsp::clear_has_totaldefadd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPlayerEnforceMyselfQueryRsp::clear_totaldefadd() {
  totaldefadd_ = 0u;
  clear_has_totaldefadd();
}
inline ::google::protobuf::uint32 CSPlayerEnforceMyselfQueryRsp::totaldefadd() const {
  return totaldefadd_;
}
inline void CSPlayerEnforceMyselfQueryRsp::set_totaldefadd(::google::protobuf::uint32 value) {
  set_has_totaldefadd();
  totaldefadd_ = value;
}

// -------------------------------------------------------------------

// CSPlayerRequest

// optional .vmsg.CSRegPlayerInfoRqst RegPlayerInfo_Rqst = 1;
inline bool CSPlayerRequest::has_regplayerinfo_rqst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerRequest::set_has_regplayerinfo_rqst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerRequest::clear_has_regplayerinfo_rqst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerRequest::clear_regplayerinfo_rqst() {
  if (regplayerinfo_rqst_ != NULL) regplayerinfo_rqst_->::vmsg::CSRegPlayerInfoRqst::Clear();
  clear_has_regplayerinfo_rqst();
}
inline const ::vmsg::CSRegPlayerInfoRqst& CSPlayerRequest::regplayerinfo_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return regplayerinfo_rqst_ != NULL ? *regplayerinfo_rqst_ : *default_instance().regplayerinfo_rqst_;
#else
  return regplayerinfo_rqst_ != NULL ? *regplayerinfo_rqst_ : *default_instance_->regplayerinfo_rqst_;
#endif
}
inline ::vmsg::CSRegPlayerInfoRqst* CSPlayerRequest::mutable_regplayerinfo_rqst() {
  set_has_regplayerinfo_rqst();
  if (regplayerinfo_rqst_ == NULL) regplayerinfo_rqst_ = new ::vmsg::CSRegPlayerInfoRqst;
  return regplayerinfo_rqst_;
}
inline ::vmsg::CSRegPlayerInfoRqst* CSPlayerRequest::release_regplayerinfo_rqst() {
  clear_has_regplayerinfo_rqst();
  ::vmsg::CSRegPlayerInfoRqst* temp = regplayerinfo_rqst_;
  regplayerinfo_rqst_ = NULL;
  return temp;
}
inline void CSPlayerRequest::set_allocated_regplayerinfo_rqst(::vmsg::CSRegPlayerInfoRqst* regplayerinfo_rqst) {
  delete regplayerinfo_rqst_;
  regplayerinfo_rqst_ = regplayerinfo_rqst;
  if (regplayerinfo_rqst) {
    set_has_regplayerinfo_rqst();
  } else {
    clear_has_regplayerinfo_rqst();
  }
}

// optional .vmsg.CSRoleLoginRqst RoleLogin_Rqst = 2;
inline bool CSPlayerRequest::has_rolelogin_rqst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerRequest::set_has_rolelogin_rqst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerRequest::clear_has_rolelogin_rqst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerRequest::clear_rolelogin_rqst() {
  if (rolelogin_rqst_ != NULL) rolelogin_rqst_->::vmsg::CSRoleLoginRqst::Clear();
  clear_has_rolelogin_rqst();
}
inline const ::vmsg::CSRoleLoginRqst& CSPlayerRequest::rolelogin_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return rolelogin_rqst_ != NULL ? *rolelogin_rqst_ : *default_instance().rolelogin_rqst_;
#else
  return rolelogin_rqst_ != NULL ? *rolelogin_rqst_ : *default_instance_->rolelogin_rqst_;
#endif
}
inline ::vmsg::CSRoleLoginRqst* CSPlayerRequest::mutable_rolelogin_rqst() {
  set_has_rolelogin_rqst();
  if (rolelogin_rqst_ == NULL) rolelogin_rqst_ = new ::vmsg::CSRoleLoginRqst;
  return rolelogin_rqst_;
}
inline ::vmsg::CSRoleLoginRqst* CSPlayerRequest::release_rolelogin_rqst() {
  clear_has_rolelogin_rqst();
  ::vmsg::CSRoleLoginRqst* temp = rolelogin_rqst_;
  rolelogin_rqst_ = NULL;
  return temp;
}
inline void CSPlayerRequest::set_allocated_rolelogin_rqst(::vmsg::CSRoleLoginRqst* rolelogin_rqst) {
  delete rolelogin_rqst_;
  rolelogin_rqst_ = rolelogin_rqst;
  if (rolelogin_rqst) {
    set_has_rolelogin_rqst();
  } else {
    clear_has_rolelogin_rqst();
  }
}

// optional .vmsg.CSRoleLogoutRqst RoleLogout_Rqst = 3;
inline bool CSPlayerRequest::has_rolelogout_rqst() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPlayerRequest::set_has_rolelogout_rqst() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPlayerRequest::clear_has_rolelogout_rqst() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPlayerRequest::clear_rolelogout_rqst() {
  if (rolelogout_rqst_ != NULL) rolelogout_rqst_->::vmsg::CSRoleLogoutRqst::Clear();
  clear_has_rolelogout_rqst();
}
inline const ::vmsg::CSRoleLogoutRqst& CSPlayerRequest::rolelogout_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return rolelogout_rqst_ != NULL ? *rolelogout_rqst_ : *default_instance().rolelogout_rqst_;
#else
  return rolelogout_rqst_ != NULL ? *rolelogout_rqst_ : *default_instance_->rolelogout_rqst_;
#endif
}
inline ::vmsg::CSRoleLogoutRqst* CSPlayerRequest::mutable_rolelogout_rqst() {
  set_has_rolelogout_rqst();
  if (rolelogout_rqst_ == NULL) rolelogout_rqst_ = new ::vmsg::CSRoleLogoutRqst;
  return rolelogout_rqst_;
}
inline ::vmsg::CSRoleLogoutRqst* CSPlayerRequest::release_rolelogout_rqst() {
  clear_has_rolelogout_rqst();
  ::vmsg::CSRoleLogoutRqst* temp = rolelogout_rqst_;
  rolelogout_rqst_ = NULL;
  return temp;
}
inline void CSPlayerRequest::set_allocated_rolelogout_rqst(::vmsg::CSRoleLogoutRqst* rolelogout_rqst) {
  delete rolelogout_rqst_;
  rolelogout_rqst_ = rolelogout_rqst;
  if (rolelogout_rqst) {
    set_has_rolelogout_rqst();
  } else {
    clear_has_rolelogout_rqst();
  }
}

// optional .vmsg.CSChangePlayerEvolutionSkillRqst ChangeEvolutionSkill_Rqst = 4;
inline bool CSPlayerRequest::has_changeevolutionskill_rqst() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPlayerRequest::set_has_changeevolutionskill_rqst() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPlayerRequest::clear_has_changeevolutionskill_rqst() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPlayerRequest::clear_changeevolutionskill_rqst() {
  if (changeevolutionskill_rqst_ != NULL) changeevolutionskill_rqst_->::vmsg::CSChangePlayerEvolutionSkillRqst::Clear();
  clear_has_changeevolutionskill_rqst();
}
inline const ::vmsg::CSChangePlayerEvolutionSkillRqst& CSPlayerRequest::changeevolutionskill_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return changeevolutionskill_rqst_ != NULL ? *changeevolutionskill_rqst_ : *default_instance().changeevolutionskill_rqst_;
#else
  return changeevolutionskill_rqst_ != NULL ? *changeevolutionskill_rqst_ : *default_instance_->changeevolutionskill_rqst_;
#endif
}
inline ::vmsg::CSChangePlayerEvolutionSkillRqst* CSPlayerRequest::mutable_changeevolutionskill_rqst() {
  set_has_changeevolutionskill_rqst();
  if (changeevolutionskill_rqst_ == NULL) changeevolutionskill_rqst_ = new ::vmsg::CSChangePlayerEvolutionSkillRqst;
  return changeevolutionskill_rqst_;
}
inline ::vmsg::CSChangePlayerEvolutionSkillRqst* CSPlayerRequest::release_changeevolutionskill_rqst() {
  clear_has_changeevolutionskill_rqst();
  ::vmsg::CSChangePlayerEvolutionSkillRqst* temp = changeevolutionskill_rqst_;
  changeevolutionskill_rqst_ = NULL;
  return temp;
}
inline void CSPlayerRequest::set_allocated_changeevolutionskill_rqst(::vmsg::CSChangePlayerEvolutionSkillRqst* changeevolutionskill_rqst) {
  delete changeevolutionskill_rqst_;
  changeevolutionskill_rqst_ = changeevolutionskill_rqst;
  if (changeevolutionskill_rqst) {
    set_has_changeevolutionskill_rqst();
  } else {
    clear_has_changeevolutionskill_rqst();
  }
}

// optional .vmsg.CSAttrStrengthenRqst AttrStrengthen_Rqst = 5;
inline bool CSPlayerRequest::has_attrstrengthen_rqst() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPlayerRequest::set_has_attrstrengthen_rqst() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPlayerRequest::clear_has_attrstrengthen_rqst() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPlayerRequest::clear_attrstrengthen_rqst() {
  if (attrstrengthen_rqst_ != NULL) attrstrengthen_rqst_->::vmsg::CSAttrStrengthenRqst::Clear();
  clear_has_attrstrengthen_rqst();
}
inline const ::vmsg::CSAttrStrengthenRqst& CSPlayerRequest::attrstrengthen_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return attrstrengthen_rqst_ != NULL ? *attrstrengthen_rqst_ : *default_instance().attrstrengthen_rqst_;
#else
  return attrstrengthen_rqst_ != NULL ? *attrstrengthen_rqst_ : *default_instance_->attrstrengthen_rqst_;
#endif
}
inline ::vmsg::CSAttrStrengthenRqst* CSPlayerRequest::mutable_attrstrengthen_rqst() {
  set_has_attrstrengthen_rqst();
  if (attrstrengthen_rqst_ == NULL) attrstrengthen_rqst_ = new ::vmsg::CSAttrStrengthenRqst;
  return attrstrengthen_rqst_;
}
inline ::vmsg::CSAttrStrengthenRqst* CSPlayerRequest::release_attrstrengthen_rqst() {
  clear_has_attrstrengthen_rqst();
  ::vmsg::CSAttrStrengthenRqst* temp = attrstrengthen_rqst_;
  attrstrengthen_rqst_ = NULL;
  return temp;
}
inline void CSPlayerRequest::set_allocated_attrstrengthen_rqst(::vmsg::CSAttrStrengthenRqst* attrstrengthen_rqst) {
  delete attrstrengthen_rqst_;
  attrstrengthen_rqst_ = attrstrengthen_rqst;
  if (attrstrengthen_rqst) {
    set_has_attrstrengthen_rqst();
  } else {
    clear_has_attrstrengthen_rqst();
  }
}

// optional .vmsg.CSWeaponLotRqst WeaponLot_Rqst = 6;
inline bool CSPlayerRequest::has_weaponlot_rqst() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSPlayerRequest::set_has_weaponlot_rqst() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSPlayerRequest::clear_has_weaponlot_rqst() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSPlayerRequest::clear_weaponlot_rqst() {
  if (weaponlot_rqst_ != NULL) weaponlot_rqst_->::vmsg::CSWeaponLotRqst::Clear();
  clear_has_weaponlot_rqst();
}
inline const ::vmsg::CSWeaponLotRqst& CSPlayerRequest::weaponlot_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return weaponlot_rqst_ != NULL ? *weaponlot_rqst_ : *default_instance().weaponlot_rqst_;
#else
  return weaponlot_rqst_ != NULL ? *weaponlot_rqst_ : *default_instance_->weaponlot_rqst_;
#endif
}
inline ::vmsg::CSWeaponLotRqst* CSPlayerRequest::mutable_weaponlot_rqst() {
  set_has_weaponlot_rqst();
  if (weaponlot_rqst_ == NULL) weaponlot_rqst_ = new ::vmsg::CSWeaponLotRqst;
  return weaponlot_rqst_;
}
inline ::vmsg::CSWeaponLotRqst* CSPlayerRequest::release_weaponlot_rqst() {
  clear_has_weaponlot_rqst();
  ::vmsg::CSWeaponLotRqst* temp = weaponlot_rqst_;
  weaponlot_rqst_ = NULL;
  return temp;
}
inline void CSPlayerRequest::set_allocated_weaponlot_rqst(::vmsg::CSWeaponLotRqst* weaponlot_rqst) {
  delete weaponlot_rqst_;
  weaponlot_rqst_ = weaponlot_rqst;
  if (weaponlot_rqst) {
    set_has_weaponlot_rqst();
  } else {
    clear_has_weaponlot_rqst();
  }
}

// optional .vmsg.CSFetchRankAwardRqst FetchRankAward_Rqst = 7;
inline bool CSPlayerRequest::has_fetchrankaward_rqst() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSPlayerRequest::set_has_fetchrankaward_rqst() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSPlayerRequest::clear_has_fetchrankaward_rqst() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSPlayerRequest::clear_fetchrankaward_rqst() {
  if (fetchrankaward_rqst_ != NULL) fetchrankaward_rqst_->::vmsg::CSFetchRankAwardRqst::Clear();
  clear_has_fetchrankaward_rqst();
}
inline const ::vmsg::CSFetchRankAwardRqst& CSPlayerRequest::fetchrankaward_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fetchrankaward_rqst_ != NULL ? *fetchrankaward_rqst_ : *default_instance().fetchrankaward_rqst_;
#else
  return fetchrankaward_rqst_ != NULL ? *fetchrankaward_rqst_ : *default_instance_->fetchrankaward_rqst_;
#endif
}
inline ::vmsg::CSFetchRankAwardRqst* CSPlayerRequest::mutable_fetchrankaward_rqst() {
  set_has_fetchrankaward_rqst();
  if (fetchrankaward_rqst_ == NULL) fetchrankaward_rqst_ = new ::vmsg::CSFetchRankAwardRqst;
  return fetchrankaward_rqst_;
}
inline ::vmsg::CSFetchRankAwardRqst* CSPlayerRequest::release_fetchrankaward_rqst() {
  clear_has_fetchrankaward_rqst();
  ::vmsg::CSFetchRankAwardRqst* temp = fetchrankaward_rqst_;
  fetchrankaward_rqst_ = NULL;
  return temp;
}
inline void CSPlayerRequest::set_allocated_fetchrankaward_rqst(::vmsg::CSFetchRankAwardRqst* fetchrankaward_rqst) {
  delete fetchrankaward_rqst_;
  fetchrankaward_rqst_ = fetchrankaward_rqst;
  if (fetchrankaward_rqst) {
    set_has_fetchrankaward_rqst();
  } else {
    clear_has_fetchrankaward_rqst();
  }
}

// optional uint32 TalkWithNPC_Rqst = 8;
inline bool CSPlayerRequest::has_talkwithnpc_rqst() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSPlayerRequest::set_has_talkwithnpc_rqst() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSPlayerRequest::clear_has_talkwithnpc_rqst() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSPlayerRequest::clear_talkwithnpc_rqst() {
  talkwithnpc_rqst_ = 0u;
  clear_has_talkwithnpc_rqst();
}
inline ::google::protobuf::uint32 CSPlayerRequest::talkwithnpc_rqst() const {
  return talkwithnpc_rqst_;
}
inline void CSPlayerRequest::set_talkwithnpc_rqst(::google::protobuf::uint32 value) {
  set_has_talkwithnpc_rqst();
  talkwithnpc_rqst_ = value;
}

// optional uint32 GetVIPAward_Rqst = 9;
inline bool CSPlayerRequest::has_getvipaward_rqst() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSPlayerRequest::set_has_getvipaward_rqst() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSPlayerRequest::clear_has_getvipaward_rqst() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSPlayerRequest::clear_getvipaward_rqst() {
  getvipaward_rqst_ = 0u;
  clear_has_getvipaward_rqst();
}
inline ::google::protobuf::uint32 CSPlayerRequest::getvipaward_rqst() const {
  return getvipaward_rqst_;
}
inline void CSPlayerRequest::set_getvipaward_rqst(::google::protobuf::uint32 value) {
  set_has_getvipaward_rqst();
  getvipaward_rqst_ = value;
}

// optional uint64 QueryOtherPlayer_Rqst = 10;
inline bool CSPlayerRequest::has_queryotherplayer_rqst() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CSPlayerRequest::set_has_queryotherplayer_rqst() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CSPlayerRequest::clear_has_queryotherplayer_rqst() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CSPlayerRequest::clear_queryotherplayer_rqst() {
  queryotherplayer_rqst_ = GOOGLE_ULONGLONG(0);
  clear_has_queryotherplayer_rqst();
}
inline ::google::protobuf::uint64 CSPlayerRequest::queryotherplayer_rqst() const {
  return queryotherplayer_rqst_;
}
inline void CSPlayerRequest::set_queryotherplayer_rqst(::google::protobuf::uint64 value) {
  set_has_queryotherplayer_rqst();
  queryotherplayer_rqst_ = value;
}

// optional .vmsg.CSSetSettingParamRqst SetSettingParam_Rqst = 11;
inline bool CSPlayerRequest::has_setsettingparam_rqst() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CSPlayerRequest::set_has_setsettingparam_rqst() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CSPlayerRequest::clear_has_setsettingparam_rqst() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CSPlayerRequest::clear_setsettingparam_rqst() {
  if (setsettingparam_rqst_ != NULL) setsettingparam_rqst_->::vmsg::CSSetSettingParamRqst::Clear();
  clear_has_setsettingparam_rqst();
}
inline const ::vmsg::CSSetSettingParamRqst& CSPlayerRequest::setsettingparam_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return setsettingparam_rqst_ != NULL ? *setsettingparam_rqst_ : *default_instance().setsettingparam_rqst_;
#else
  return setsettingparam_rqst_ != NULL ? *setsettingparam_rqst_ : *default_instance_->setsettingparam_rqst_;
#endif
}
inline ::vmsg::CSSetSettingParamRqst* CSPlayerRequest::mutable_setsettingparam_rqst() {
  set_has_setsettingparam_rqst();
  if (setsettingparam_rqst_ == NULL) setsettingparam_rqst_ = new ::vmsg::CSSetSettingParamRqst;
  return setsettingparam_rqst_;
}
inline ::vmsg::CSSetSettingParamRqst* CSPlayerRequest::release_setsettingparam_rqst() {
  clear_has_setsettingparam_rqst();
  ::vmsg::CSSetSettingParamRqst* temp = setsettingparam_rqst_;
  setsettingparam_rqst_ = NULL;
  return temp;
}
inline void CSPlayerRequest::set_allocated_setsettingparam_rqst(::vmsg::CSSetSettingParamRqst* setsettingparam_rqst) {
  delete setsettingparam_rqst_;
  setsettingparam_rqst_ = setsettingparam_rqst;
  if (setsettingparam_rqst) {
    set_has_setsettingparam_rqst();
  } else {
    clear_has_setsettingparam_rqst();
  }
}

// optional uint32 BuyBlackMarket_Rqst = 12;
inline bool CSPlayerRequest::has_buyblackmarket_rqst() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CSPlayerRequest::set_has_buyblackmarket_rqst() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CSPlayerRequest::clear_has_buyblackmarket_rqst() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CSPlayerRequest::clear_buyblackmarket_rqst() {
  buyblackmarket_rqst_ = 0u;
  clear_has_buyblackmarket_rqst();
}
inline ::google::protobuf::uint32 CSPlayerRequest::buyblackmarket_rqst() const {
  return buyblackmarket_rqst_;
}
inline void CSPlayerRequest::set_buyblackmarket_rqst(::google::protobuf::uint32 value) {
  set_has_buyblackmarket_rqst();
  buyblackmarket_rqst_ = value;
}

// optional .vmsg.CSQuickLoginRqst QuickLogin_Rqst = 13;
inline bool CSPlayerRequest::has_quicklogin_rqst() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CSPlayerRequest::set_has_quicklogin_rqst() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CSPlayerRequest::clear_has_quicklogin_rqst() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CSPlayerRequest::clear_quicklogin_rqst() {
  if (quicklogin_rqst_ != NULL) quicklogin_rqst_->::vmsg::CSQuickLoginRqst::Clear();
  clear_has_quicklogin_rqst();
}
inline const ::vmsg::CSQuickLoginRqst& CSPlayerRequest::quicklogin_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return quicklogin_rqst_ != NULL ? *quicklogin_rqst_ : *default_instance().quicklogin_rqst_;
#else
  return quicklogin_rqst_ != NULL ? *quicklogin_rqst_ : *default_instance_->quicklogin_rqst_;
#endif
}
inline ::vmsg::CSQuickLoginRqst* CSPlayerRequest::mutable_quicklogin_rqst() {
  set_has_quicklogin_rqst();
  if (quicklogin_rqst_ == NULL) quicklogin_rqst_ = new ::vmsg::CSQuickLoginRqst;
  return quicklogin_rqst_;
}
inline ::vmsg::CSQuickLoginRqst* CSPlayerRequest::release_quicklogin_rqst() {
  clear_has_quicklogin_rqst();
  ::vmsg::CSQuickLoginRqst* temp = quicklogin_rqst_;
  quicklogin_rqst_ = NULL;
  return temp;
}
inline void CSPlayerRequest::set_allocated_quicklogin_rqst(::vmsg::CSQuickLoginRqst* quicklogin_rqst) {
  delete quicklogin_rqst_;
  quicklogin_rqst_ = quicklogin_rqst;
  if (quicklogin_rqst) {
    set_has_quicklogin_rqst();
  } else {
    clear_has_quicklogin_rqst();
  }
}

// optional .vmsg.CSGuestBindRqst GuestBind_Rqst = 14;
inline bool CSPlayerRequest::has_guestbind_rqst() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CSPlayerRequest::set_has_guestbind_rqst() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CSPlayerRequest::clear_has_guestbind_rqst() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CSPlayerRequest::clear_guestbind_rqst() {
  if (guestbind_rqst_ != NULL) guestbind_rqst_->::vmsg::CSGuestBindRqst::Clear();
  clear_has_guestbind_rqst();
}
inline const ::vmsg::CSGuestBindRqst& CSPlayerRequest::guestbind_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return guestbind_rqst_ != NULL ? *guestbind_rqst_ : *default_instance().guestbind_rqst_;
#else
  return guestbind_rqst_ != NULL ? *guestbind_rqst_ : *default_instance_->guestbind_rqst_;
#endif
}
inline ::vmsg::CSGuestBindRqst* CSPlayerRequest::mutable_guestbind_rqst() {
  set_has_guestbind_rqst();
  if (guestbind_rqst_ == NULL) guestbind_rqst_ = new ::vmsg::CSGuestBindRqst;
  return guestbind_rqst_;
}
inline ::vmsg::CSGuestBindRqst* CSPlayerRequest::release_guestbind_rqst() {
  clear_has_guestbind_rqst();
  ::vmsg::CSGuestBindRqst* temp = guestbind_rqst_;
  guestbind_rqst_ = NULL;
  return temp;
}
inline void CSPlayerRequest::set_allocated_guestbind_rqst(::vmsg::CSGuestBindRqst* guestbind_rqst) {
  delete guestbind_rqst_;
  guestbind_rqst_ = guestbind_rqst;
  if (guestbind_rqst) {
    set_has_guestbind_rqst();
  } else {
    clear_has_guestbind_rqst();
  }
}

// optional .vmsg.CSPlayerEnforceMyselfRqst PlayerEnforce_Rqst = 15;
inline bool CSPlayerRequest::has_playerenforce_rqst() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CSPlayerRequest::set_has_playerenforce_rqst() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CSPlayerRequest::clear_has_playerenforce_rqst() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CSPlayerRequest::clear_playerenforce_rqst() {
  if (playerenforce_rqst_ != NULL) playerenforce_rqst_->::vmsg::CSPlayerEnforceMyselfRqst::Clear();
  clear_has_playerenforce_rqst();
}
inline const ::vmsg::CSPlayerEnforceMyselfRqst& CSPlayerRequest::playerenforce_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerenforce_rqst_ != NULL ? *playerenforce_rqst_ : *default_instance().playerenforce_rqst_;
#else
  return playerenforce_rqst_ != NULL ? *playerenforce_rqst_ : *default_instance_->playerenforce_rqst_;
#endif
}
inline ::vmsg::CSPlayerEnforceMyselfRqst* CSPlayerRequest::mutable_playerenforce_rqst() {
  set_has_playerenforce_rqst();
  if (playerenforce_rqst_ == NULL) playerenforce_rqst_ = new ::vmsg::CSPlayerEnforceMyselfRqst;
  return playerenforce_rqst_;
}
inline ::vmsg::CSPlayerEnforceMyselfRqst* CSPlayerRequest::release_playerenforce_rqst() {
  clear_has_playerenforce_rqst();
  ::vmsg::CSPlayerEnforceMyselfRqst* temp = playerenforce_rqst_;
  playerenforce_rqst_ = NULL;
  return temp;
}
inline void CSPlayerRequest::set_allocated_playerenforce_rqst(::vmsg::CSPlayerEnforceMyselfRqst* playerenforce_rqst) {
  delete playerenforce_rqst_;
  playerenforce_rqst_ = playerenforce_rqst;
  if (playerenforce_rqst) {
    set_has_playerenforce_rqst();
  } else {
    clear_has_playerenforce_rqst();
  }
}

// optional .vmsg.CSPlayerEnforceMyselfConfirmRqst PlayerEnforceConfirm_Rqst = 16;
inline bool CSPlayerRequest::has_playerenforceconfirm_rqst() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CSPlayerRequest::set_has_playerenforceconfirm_rqst() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CSPlayerRequest::clear_has_playerenforceconfirm_rqst() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CSPlayerRequest::clear_playerenforceconfirm_rqst() {
  if (playerenforceconfirm_rqst_ != NULL) playerenforceconfirm_rqst_->::vmsg::CSPlayerEnforceMyselfConfirmRqst::Clear();
  clear_has_playerenforceconfirm_rqst();
}
inline const ::vmsg::CSPlayerEnforceMyselfConfirmRqst& CSPlayerRequest::playerenforceconfirm_rqst() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerenforceconfirm_rqst_ != NULL ? *playerenforceconfirm_rqst_ : *default_instance().playerenforceconfirm_rqst_;
#else
  return playerenforceconfirm_rqst_ != NULL ? *playerenforceconfirm_rqst_ : *default_instance_->playerenforceconfirm_rqst_;
#endif
}
inline ::vmsg::CSPlayerEnforceMyselfConfirmRqst* CSPlayerRequest::mutable_playerenforceconfirm_rqst() {
  set_has_playerenforceconfirm_rqst();
  if (playerenforceconfirm_rqst_ == NULL) playerenforceconfirm_rqst_ = new ::vmsg::CSPlayerEnforceMyselfConfirmRqst;
  return playerenforceconfirm_rqst_;
}
inline ::vmsg::CSPlayerEnforceMyselfConfirmRqst* CSPlayerRequest::release_playerenforceconfirm_rqst() {
  clear_has_playerenforceconfirm_rqst();
  ::vmsg::CSPlayerEnforceMyselfConfirmRqst* temp = playerenforceconfirm_rqst_;
  playerenforceconfirm_rqst_ = NULL;
  return temp;
}
inline void CSPlayerRequest::set_allocated_playerenforceconfirm_rqst(::vmsg::CSPlayerEnforceMyselfConfirmRqst* playerenforceconfirm_rqst) {
  delete playerenforceconfirm_rqst_;
  playerenforceconfirm_rqst_ = playerenforceconfirm_rqst;
  if (playerenforceconfirm_rqst) {
    set_has_playerenforceconfirm_rqst();
  } else {
    clear_has_playerenforceconfirm_rqst();
  }
}

// -------------------------------------------------------------------

// CSPlayerRespond

// optional .vmsg.CSRegPlayerInfoRsp RegPlayerInfo_Rsp = 1;
inline bool CSPlayerRespond::has_regplayerinfo_rsp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSPlayerRespond::set_has_regplayerinfo_rsp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSPlayerRespond::clear_has_regplayerinfo_rsp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSPlayerRespond::clear_regplayerinfo_rsp() {
  if (regplayerinfo_rsp_ != NULL) regplayerinfo_rsp_->::vmsg::CSRegPlayerInfoRsp::Clear();
  clear_has_regplayerinfo_rsp();
}
inline const ::vmsg::CSRegPlayerInfoRsp& CSPlayerRespond::regplayerinfo_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return regplayerinfo_rsp_ != NULL ? *regplayerinfo_rsp_ : *default_instance().regplayerinfo_rsp_;
#else
  return regplayerinfo_rsp_ != NULL ? *regplayerinfo_rsp_ : *default_instance_->regplayerinfo_rsp_;
#endif
}
inline ::vmsg::CSRegPlayerInfoRsp* CSPlayerRespond::mutable_regplayerinfo_rsp() {
  set_has_regplayerinfo_rsp();
  if (regplayerinfo_rsp_ == NULL) regplayerinfo_rsp_ = new ::vmsg::CSRegPlayerInfoRsp;
  return regplayerinfo_rsp_;
}
inline ::vmsg::CSRegPlayerInfoRsp* CSPlayerRespond::release_regplayerinfo_rsp() {
  clear_has_regplayerinfo_rsp();
  ::vmsg::CSRegPlayerInfoRsp* temp = regplayerinfo_rsp_;
  regplayerinfo_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_regplayerinfo_rsp(::vmsg::CSRegPlayerInfoRsp* regplayerinfo_rsp) {
  delete regplayerinfo_rsp_;
  regplayerinfo_rsp_ = regplayerinfo_rsp;
  if (regplayerinfo_rsp) {
    set_has_regplayerinfo_rsp();
  } else {
    clear_has_regplayerinfo_rsp();
  }
}

// optional .vmsg.CSQueryPlayerInfoRsp QueryPlayerInfo_Rsp = 2;
inline bool CSPlayerRespond::has_queryplayerinfo_rsp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSPlayerRespond::set_has_queryplayerinfo_rsp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSPlayerRespond::clear_has_queryplayerinfo_rsp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSPlayerRespond::clear_queryplayerinfo_rsp() {
  if (queryplayerinfo_rsp_ != NULL) queryplayerinfo_rsp_->::vmsg::CSQueryPlayerInfoRsp::Clear();
  clear_has_queryplayerinfo_rsp();
}
inline const ::vmsg::CSQueryPlayerInfoRsp& CSPlayerRespond::queryplayerinfo_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return queryplayerinfo_rsp_ != NULL ? *queryplayerinfo_rsp_ : *default_instance().queryplayerinfo_rsp_;
#else
  return queryplayerinfo_rsp_ != NULL ? *queryplayerinfo_rsp_ : *default_instance_->queryplayerinfo_rsp_;
#endif
}
inline ::vmsg::CSQueryPlayerInfoRsp* CSPlayerRespond::mutable_queryplayerinfo_rsp() {
  set_has_queryplayerinfo_rsp();
  if (queryplayerinfo_rsp_ == NULL) queryplayerinfo_rsp_ = new ::vmsg::CSQueryPlayerInfoRsp;
  return queryplayerinfo_rsp_;
}
inline ::vmsg::CSQueryPlayerInfoRsp* CSPlayerRespond::release_queryplayerinfo_rsp() {
  clear_has_queryplayerinfo_rsp();
  ::vmsg::CSQueryPlayerInfoRsp* temp = queryplayerinfo_rsp_;
  queryplayerinfo_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_queryplayerinfo_rsp(::vmsg::CSQueryPlayerInfoRsp* queryplayerinfo_rsp) {
  delete queryplayerinfo_rsp_;
  queryplayerinfo_rsp_ = queryplayerinfo_rsp;
  if (queryplayerinfo_rsp) {
    set_has_queryplayerinfo_rsp();
  } else {
    clear_has_queryplayerinfo_rsp();
  }
}

// optional .vmsg.CSChangeArmorRsp ChangeArmor_Rsp = 3;
inline bool CSPlayerRespond::has_changearmor_rsp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSPlayerRespond::set_has_changearmor_rsp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSPlayerRespond::clear_has_changearmor_rsp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSPlayerRespond::clear_changearmor_rsp() {
  if (changearmor_rsp_ != NULL) changearmor_rsp_->::vmsg::CSChangeArmorRsp::Clear();
  clear_has_changearmor_rsp();
}
inline const ::vmsg::CSChangeArmorRsp& CSPlayerRespond::changearmor_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return changearmor_rsp_ != NULL ? *changearmor_rsp_ : *default_instance().changearmor_rsp_;
#else
  return changearmor_rsp_ != NULL ? *changearmor_rsp_ : *default_instance_->changearmor_rsp_;
#endif
}
inline ::vmsg::CSChangeArmorRsp* CSPlayerRespond::mutable_changearmor_rsp() {
  set_has_changearmor_rsp();
  if (changearmor_rsp_ == NULL) changearmor_rsp_ = new ::vmsg::CSChangeArmorRsp;
  return changearmor_rsp_;
}
inline ::vmsg::CSChangeArmorRsp* CSPlayerRespond::release_changearmor_rsp() {
  clear_has_changearmor_rsp();
  ::vmsg::CSChangeArmorRsp* temp = changearmor_rsp_;
  changearmor_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_changearmor_rsp(::vmsg::CSChangeArmorRsp* changearmor_rsp) {
  delete changearmor_rsp_;
  changearmor_rsp_ = changearmor_rsp;
  if (changearmor_rsp) {
    set_has_changearmor_rsp();
  } else {
    clear_has_changearmor_rsp();
  }
}

// optional .vmsg.CSQueryRoleLstRsp RoleLst_Rsp = 4;
inline bool CSPlayerRespond::has_rolelst_rsp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSPlayerRespond::set_has_rolelst_rsp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSPlayerRespond::clear_has_rolelst_rsp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSPlayerRespond::clear_rolelst_rsp() {
  if (rolelst_rsp_ != NULL) rolelst_rsp_->::vmsg::CSQueryRoleLstRsp::Clear();
  clear_has_rolelst_rsp();
}
inline const ::vmsg::CSQueryRoleLstRsp& CSPlayerRespond::rolelst_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return rolelst_rsp_ != NULL ? *rolelst_rsp_ : *default_instance().rolelst_rsp_;
#else
  return rolelst_rsp_ != NULL ? *rolelst_rsp_ : *default_instance_->rolelst_rsp_;
#endif
}
inline ::vmsg::CSQueryRoleLstRsp* CSPlayerRespond::mutable_rolelst_rsp() {
  set_has_rolelst_rsp();
  if (rolelst_rsp_ == NULL) rolelst_rsp_ = new ::vmsg::CSQueryRoleLstRsp;
  return rolelst_rsp_;
}
inline ::vmsg::CSQueryRoleLstRsp* CSPlayerRespond::release_rolelst_rsp() {
  clear_has_rolelst_rsp();
  ::vmsg::CSQueryRoleLstRsp* temp = rolelst_rsp_;
  rolelst_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_rolelst_rsp(::vmsg::CSQueryRoleLstRsp* rolelst_rsp) {
  delete rolelst_rsp_;
  rolelst_rsp_ = rolelst_rsp;
  if (rolelst_rsp) {
    set_has_rolelst_rsp();
  } else {
    clear_has_rolelst_rsp();
  }
}

// optional .vmsg.CSRoleLoginRsp RoleLogin_Rsp = 5;
inline bool CSPlayerRespond::has_rolelogin_rsp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSPlayerRespond::set_has_rolelogin_rsp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSPlayerRespond::clear_has_rolelogin_rsp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSPlayerRespond::clear_rolelogin_rsp() {
  if (rolelogin_rsp_ != NULL) rolelogin_rsp_->::vmsg::CSRoleLoginRsp::Clear();
  clear_has_rolelogin_rsp();
}
inline const ::vmsg::CSRoleLoginRsp& CSPlayerRespond::rolelogin_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return rolelogin_rsp_ != NULL ? *rolelogin_rsp_ : *default_instance().rolelogin_rsp_;
#else
  return rolelogin_rsp_ != NULL ? *rolelogin_rsp_ : *default_instance_->rolelogin_rsp_;
#endif
}
inline ::vmsg::CSRoleLoginRsp* CSPlayerRespond::mutable_rolelogin_rsp() {
  set_has_rolelogin_rsp();
  if (rolelogin_rsp_ == NULL) rolelogin_rsp_ = new ::vmsg::CSRoleLoginRsp;
  return rolelogin_rsp_;
}
inline ::vmsg::CSRoleLoginRsp* CSPlayerRespond::release_rolelogin_rsp() {
  clear_has_rolelogin_rsp();
  ::vmsg::CSRoleLoginRsp* temp = rolelogin_rsp_;
  rolelogin_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_rolelogin_rsp(::vmsg::CSRoleLoginRsp* rolelogin_rsp) {
  delete rolelogin_rsp_;
  rolelogin_rsp_ = rolelogin_rsp;
  if (rolelogin_rsp) {
    set_has_rolelogin_rsp();
  } else {
    clear_has_rolelogin_rsp();
  }
}

// optional .vmsg.CSRoleLogoutRsp RoleLogout_Rsp = 6;
inline bool CSPlayerRespond::has_rolelogout_rsp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSPlayerRespond::set_has_rolelogout_rsp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSPlayerRespond::clear_has_rolelogout_rsp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSPlayerRespond::clear_rolelogout_rsp() {
  if (rolelogout_rsp_ != NULL) rolelogout_rsp_->::vmsg::CSRoleLogoutRsp::Clear();
  clear_has_rolelogout_rsp();
}
inline const ::vmsg::CSRoleLogoutRsp& CSPlayerRespond::rolelogout_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return rolelogout_rsp_ != NULL ? *rolelogout_rsp_ : *default_instance().rolelogout_rsp_;
#else
  return rolelogout_rsp_ != NULL ? *rolelogout_rsp_ : *default_instance_->rolelogout_rsp_;
#endif
}
inline ::vmsg::CSRoleLogoutRsp* CSPlayerRespond::mutable_rolelogout_rsp() {
  set_has_rolelogout_rsp();
  if (rolelogout_rsp_ == NULL) rolelogout_rsp_ = new ::vmsg::CSRoleLogoutRsp;
  return rolelogout_rsp_;
}
inline ::vmsg::CSRoleLogoutRsp* CSPlayerRespond::release_rolelogout_rsp() {
  clear_has_rolelogout_rsp();
  ::vmsg::CSRoleLogoutRsp* temp = rolelogout_rsp_;
  rolelogout_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_rolelogout_rsp(::vmsg::CSRoleLogoutRsp* rolelogout_rsp) {
  delete rolelogout_rsp_;
  rolelogout_rsp_ = rolelogout_rsp;
  if (rolelogout_rsp) {
    set_has_rolelogout_rsp();
  } else {
    clear_has_rolelogout_rsp();
  }
}

// optional .vmsg.CSPlayerManualNotify Manual_Notify = 7;
inline bool CSPlayerRespond::has_manual_notify() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSPlayerRespond::set_has_manual_notify() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSPlayerRespond::clear_has_manual_notify() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSPlayerRespond::clear_manual_notify() {
  if (manual_notify_ != NULL) manual_notify_->::vmsg::CSPlayerManualNotify::Clear();
  clear_has_manual_notify();
}
inline const ::vmsg::CSPlayerManualNotify& CSPlayerRespond::manual_notify() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return manual_notify_ != NULL ? *manual_notify_ : *default_instance().manual_notify_;
#else
  return manual_notify_ != NULL ? *manual_notify_ : *default_instance_->manual_notify_;
#endif
}
inline ::vmsg::CSPlayerManualNotify* CSPlayerRespond::mutable_manual_notify() {
  set_has_manual_notify();
  if (manual_notify_ == NULL) manual_notify_ = new ::vmsg::CSPlayerManualNotify;
  return manual_notify_;
}
inline ::vmsg::CSPlayerManualNotify* CSPlayerRespond::release_manual_notify() {
  clear_has_manual_notify();
  ::vmsg::CSPlayerManualNotify* temp = manual_notify_;
  manual_notify_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_manual_notify(::vmsg::CSPlayerManualNotify* manual_notify) {
  delete manual_notify_;
  manual_notify_ = manual_notify;
  if (manual_notify) {
    set_has_manual_notify();
  } else {
    clear_has_manual_notify();
  }
}

// optional .vmsg.CSBuyManualInfo QueryBuyManual_Rsp = 8;
inline bool CSPlayerRespond::has_querybuymanual_rsp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSPlayerRespond::set_has_querybuymanual_rsp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSPlayerRespond::clear_has_querybuymanual_rsp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSPlayerRespond::clear_querybuymanual_rsp() {
  if (querybuymanual_rsp_ != NULL) querybuymanual_rsp_->::vmsg::CSBuyManualInfo::Clear();
  clear_has_querybuymanual_rsp();
}
inline const ::vmsg::CSBuyManualInfo& CSPlayerRespond::querybuymanual_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return querybuymanual_rsp_ != NULL ? *querybuymanual_rsp_ : *default_instance().querybuymanual_rsp_;
#else
  return querybuymanual_rsp_ != NULL ? *querybuymanual_rsp_ : *default_instance_->querybuymanual_rsp_;
#endif
}
inline ::vmsg::CSBuyManualInfo* CSPlayerRespond::mutable_querybuymanual_rsp() {
  set_has_querybuymanual_rsp();
  if (querybuymanual_rsp_ == NULL) querybuymanual_rsp_ = new ::vmsg::CSBuyManualInfo;
  return querybuymanual_rsp_;
}
inline ::vmsg::CSBuyManualInfo* CSPlayerRespond::release_querybuymanual_rsp() {
  clear_has_querybuymanual_rsp();
  ::vmsg::CSBuyManualInfo* temp = querybuymanual_rsp_;
  querybuymanual_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_querybuymanual_rsp(::vmsg::CSBuyManualInfo* querybuymanual_rsp) {
  delete querybuymanual_rsp_;
  querybuymanual_rsp_ = querybuymanual_rsp;
  if (querybuymanual_rsp) {
    set_has_querybuymanual_rsp();
  } else {
    clear_has_querybuymanual_rsp();
  }
}

// optional .vmsg.CSBuyManualInfo BuyManual_Rsp = 9;
inline bool CSPlayerRespond::has_buymanual_rsp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSPlayerRespond::set_has_buymanual_rsp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSPlayerRespond::clear_has_buymanual_rsp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSPlayerRespond::clear_buymanual_rsp() {
  if (buymanual_rsp_ != NULL) buymanual_rsp_->::vmsg::CSBuyManualInfo::Clear();
  clear_has_buymanual_rsp();
}
inline const ::vmsg::CSBuyManualInfo& CSPlayerRespond::buymanual_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return buymanual_rsp_ != NULL ? *buymanual_rsp_ : *default_instance().buymanual_rsp_;
#else
  return buymanual_rsp_ != NULL ? *buymanual_rsp_ : *default_instance_->buymanual_rsp_;
#endif
}
inline ::vmsg::CSBuyManualInfo* CSPlayerRespond::mutable_buymanual_rsp() {
  set_has_buymanual_rsp();
  if (buymanual_rsp_ == NULL) buymanual_rsp_ = new ::vmsg::CSBuyManualInfo;
  return buymanual_rsp_;
}
inline ::vmsg::CSBuyManualInfo* CSPlayerRespond::release_buymanual_rsp() {
  clear_has_buymanual_rsp();
  ::vmsg::CSBuyManualInfo* temp = buymanual_rsp_;
  buymanual_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_buymanual_rsp(::vmsg::CSBuyManualInfo* buymanual_rsp) {
  delete buymanual_rsp_;
  buymanual_rsp_ = buymanual_rsp;
  if (buymanual_rsp) {
    set_has_buymanual_rsp();
  } else {
    clear_has_buymanual_rsp();
  }
}

// optional .vmsg.CSQueryPlayerManualRsp QueryManual_Rsp = 10;
inline bool CSPlayerRespond::has_querymanual_rsp() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CSPlayerRespond::set_has_querymanual_rsp() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CSPlayerRespond::clear_has_querymanual_rsp() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CSPlayerRespond::clear_querymanual_rsp() {
  if (querymanual_rsp_ != NULL) querymanual_rsp_->::vmsg::CSQueryPlayerManualRsp::Clear();
  clear_has_querymanual_rsp();
}
inline const ::vmsg::CSQueryPlayerManualRsp& CSPlayerRespond::querymanual_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return querymanual_rsp_ != NULL ? *querymanual_rsp_ : *default_instance().querymanual_rsp_;
#else
  return querymanual_rsp_ != NULL ? *querymanual_rsp_ : *default_instance_->querymanual_rsp_;
#endif
}
inline ::vmsg::CSQueryPlayerManualRsp* CSPlayerRespond::mutable_querymanual_rsp() {
  set_has_querymanual_rsp();
  if (querymanual_rsp_ == NULL) querymanual_rsp_ = new ::vmsg::CSQueryPlayerManualRsp;
  return querymanual_rsp_;
}
inline ::vmsg::CSQueryPlayerManualRsp* CSPlayerRespond::release_querymanual_rsp() {
  clear_has_querymanual_rsp();
  ::vmsg::CSQueryPlayerManualRsp* temp = querymanual_rsp_;
  querymanual_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_querymanual_rsp(::vmsg::CSQueryPlayerManualRsp* querymanual_rsp) {
  delete querymanual_rsp_;
  querymanual_rsp_ = querymanual_rsp;
  if (querymanual_rsp) {
    set_has_querymanual_rsp();
  } else {
    clear_has_querymanual_rsp();
  }
}

// optional .vmsg.CSPlayerDetailInfo QueryDetailInfo_Rsp = 11;
inline bool CSPlayerRespond::has_querydetailinfo_rsp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CSPlayerRespond::set_has_querydetailinfo_rsp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CSPlayerRespond::clear_has_querydetailinfo_rsp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CSPlayerRespond::clear_querydetailinfo_rsp() {
  if (querydetailinfo_rsp_ != NULL) querydetailinfo_rsp_->::vmsg::CSPlayerDetailInfo::Clear();
  clear_has_querydetailinfo_rsp();
}
inline const ::vmsg::CSPlayerDetailInfo& CSPlayerRespond::querydetailinfo_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return querydetailinfo_rsp_ != NULL ? *querydetailinfo_rsp_ : *default_instance().querydetailinfo_rsp_;
#else
  return querydetailinfo_rsp_ != NULL ? *querydetailinfo_rsp_ : *default_instance_->querydetailinfo_rsp_;
#endif
}
inline ::vmsg::CSPlayerDetailInfo* CSPlayerRespond::mutable_querydetailinfo_rsp() {
  set_has_querydetailinfo_rsp();
  if (querydetailinfo_rsp_ == NULL) querydetailinfo_rsp_ = new ::vmsg::CSPlayerDetailInfo;
  return querydetailinfo_rsp_;
}
inline ::vmsg::CSPlayerDetailInfo* CSPlayerRespond::release_querydetailinfo_rsp() {
  clear_has_querydetailinfo_rsp();
  ::vmsg::CSPlayerDetailInfo* temp = querydetailinfo_rsp_;
  querydetailinfo_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_querydetailinfo_rsp(::vmsg::CSPlayerDetailInfo* querydetailinfo_rsp) {
  delete querydetailinfo_rsp_;
  querydetailinfo_rsp_ = querydetailinfo_rsp;
  if (querydetailinfo_rsp) {
    set_has_querydetailinfo_rsp();
  } else {
    clear_has_querydetailinfo_rsp();
  }
}

// optional .vmsg.CSPlayerEvolutionInfo QueryEvolution_Rsp = 12;
inline bool CSPlayerRespond::has_queryevolution_rsp() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CSPlayerRespond::set_has_queryevolution_rsp() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CSPlayerRespond::clear_has_queryevolution_rsp() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CSPlayerRespond::clear_queryevolution_rsp() {
  if (queryevolution_rsp_ != NULL) queryevolution_rsp_->::vmsg::CSPlayerEvolutionInfo::Clear();
  clear_has_queryevolution_rsp();
}
inline const ::vmsg::CSPlayerEvolutionInfo& CSPlayerRespond::queryevolution_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return queryevolution_rsp_ != NULL ? *queryevolution_rsp_ : *default_instance().queryevolution_rsp_;
#else
  return queryevolution_rsp_ != NULL ? *queryevolution_rsp_ : *default_instance_->queryevolution_rsp_;
#endif
}
inline ::vmsg::CSPlayerEvolutionInfo* CSPlayerRespond::mutable_queryevolution_rsp() {
  set_has_queryevolution_rsp();
  if (queryevolution_rsp_ == NULL) queryevolution_rsp_ = new ::vmsg::CSPlayerEvolutionInfo;
  return queryevolution_rsp_;
}
inline ::vmsg::CSPlayerEvolutionInfo* CSPlayerRespond::release_queryevolution_rsp() {
  clear_has_queryevolution_rsp();
  ::vmsg::CSPlayerEvolutionInfo* temp = queryevolution_rsp_;
  queryevolution_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_queryevolution_rsp(::vmsg::CSPlayerEvolutionInfo* queryevolution_rsp) {
  delete queryevolution_rsp_;
  queryevolution_rsp_ = queryevolution_rsp;
  if (queryevolution_rsp) {
    set_has_queryevolution_rsp();
  } else {
    clear_has_queryevolution_rsp();
  }
}

// optional .vmsg.CSPlayerEvolutionSkillInfo QueryEvolutionSkill_Rsp = 13;
inline bool CSPlayerRespond::has_queryevolutionskill_rsp() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CSPlayerRespond::set_has_queryevolutionskill_rsp() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CSPlayerRespond::clear_has_queryevolutionskill_rsp() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CSPlayerRespond::clear_queryevolutionskill_rsp() {
  if (queryevolutionskill_rsp_ != NULL) queryevolutionskill_rsp_->::vmsg::CSPlayerEvolutionSkillInfo::Clear();
  clear_has_queryevolutionskill_rsp();
}
inline const ::vmsg::CSPlayerEvolutionSkillInfo& CSPlayerRespond::queryevolutionskill_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return queryevolutionskill_rsp_ != NULL ? *queryevolutionskill_rsp_ : *default_instance().queryevolutionskill_rsp_;
#else
  return queryevolutionskill_rsp_ != NULL ? *queryevolutionskill_rsp_ : *default_instance_->queryevolutionskill_rsp_;
#endif
}
inline ::vmsg::CSPlayerEvolutionSkillInfo* CSPlayerRespond::mutable_queryevolutionskill_rsp() {
  set_has_queryevolutionskill_rsp();
  if (queryevolutionskill_rsp_ == NULL) queryevolutionskill_rsp_ = new ::vmsg::CSPlayerEvolutionSkillInfo;
  return queryevolutionskill_rsp_;
}
inline ::vmsg::CSPlayerEvolutionSkillInfo* CSPlayerRespond::release_queryevolutionskill_rsp() {
  clear_has_queryevolutionskill_rsp();
  ::vmsg::CSPlayerEvolutionSkillInfo* temp = queryevolutionskill_rsp_;
  queryevolutionskill_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_queryevolutionskill_rsp(::vmsg::CSPlayerEvolutionSkillInfo* queryevolutionskill_rsp) {
  delete queryevolutionskill_rsp_;
  queryevolutionskill_rsp_ = queryevolutionskill_rsp;
  if (queryevolutionskill_rsp) {
    set_has_queryevolutionskill_rsp();
  } else {
    clear_has_queryevolutionskill_rsp();
  }
}

// optional .vmsg.CSChangePlayerEvolutionSkillRsp ChangeEvolutionSkill_Rsp = 14;
inline bool CSPlayerRespond::has_changeevolutionskill_rsp() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CSPlayerRespond::set_has_changeevolutionskill_rsp() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CSPlayerRespond::clear_has_changeevolutionskill_rsp() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CSPlayerRespond::clear_changeevolutionskill_rsp() {
  if (changeevolutionskill_rsp_ != NULL) changeevolutionskill_rsp_->::vmsg::CSChangePlayerEvolutionSkillRsp::Clear();
  clear_has_changeevolutionskill_rsp();
}
inline const ::vmsg::CSChangePlayerEvolutionSkillRsp& CSPlayerRespond::changeevolutionskill_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return changeevolutionskill_rsp_ != NULL ? *changeevolutionskill_rsp_ : *default_instance().changeevolutionskill_rsp_;
#else
  return changeevolutionskill_rsp_ != NULL ? *changeevolutionskill_rsp_ : *default_instance_->changeevolutionskill_rsp_;
#endif
}
inline ::vmsg::CSChangePlayerEvolutionSkillRsp* CSPlayerRespond::mutable_changeevolutionskill_rsp() {
  set_has_changeevolutionskill_rsp();
  if (changeevolutionskill_rsp_ == NULL) changeevolutionskill_rsp_ = new ::vmsg::CSChangePlayerEvolutionSkillRsp;
  return changeevolutionskill_rsp_;
}
inline ::vmsg::CSChangePlayerEvolutionSkillRsp* CSPlayerRespond::release_changeevolutionskill_rsp() {
  clear_has_changeevolutionskill_rsp();
  ::vmsg::CSChangePlayerEvolutionSkillRsp* temp = changeevolutionskill_rsp_;
  changeevolutionskill_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_changeevolutionskill_rsp(::vmsg::CSChangePlayerEvolutionSkillRsp* changeevolutionskill_rsp) {
  delete changeevolutionskill_rsp_;
  changeevolutionskill_rsp_ = changeevolutionskill_rsp;
  if (changeevolutionskill_rsp) {
    set_has_changeevolutionskill_rsp();
  } else {
    clear_has_changeevolutionskill_rsp();
  }
}

// optional .vmsg.CSPlayerEvolutionInfo Evolution_Rsp = 15;
inline bool CSPlayerRespond::has_evolution_rsp() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CSPlayerRespond::set_has_evolution_rsp() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CSPlayerRespond::clear_has_evolution_rsp() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CSPlayerRespond::clear_evolution_rsp() {
  if (evolution_rsp_ != NULL) evolution_rsp_->::vmsg::CSPlayerEvolutionInfo::Clear();
  clear_has_evolution_rsp();
}
inline const ::vmsg::CSPlayerEvolutionInfo& CSPlayerRespond::evolution_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return evolution_rsp_ != NULL ? *evolution_rsp_ : *default_instance().evolution_rsp_;
#else
  return evolution_rsp_ != NULL ? *evolution_rsp_ : *default_instance_->evolution_rsp_;
#endif
}
inline ::vmsg::CSPlayerEvolutionInfo* CSPlayerRespond::mutable_evolution_rsp() {
  set_has_evolution_rsp();
  if (evolution_rsp_ == NULL) evolution_rsp_ = new ::vmsg::CSPlayerEvolutionInfo;
  return evolution_rsp_;
}
inline ::vmsg::CSPlayerEvolutionInfo* CSPlayerRespond::release_evolution_rsp() {
  clear_has_evolution_rsp();
  ::vmsg::CSPlayerEvolutionInfo* temp = evolution_rsp_;
  evolution_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_evolution_rsp(::vmsg::CSPlayerEvolutionInfo* evolution_rsp) {
  delete evolution_rsp_;
  evolution_rsp_ = evolution_rsp;
  if (evolution_rsp) {
    set_has_evolution_rsp();
  } else {
    clear_has_evolution_rsp();
  }
}

// optional .vmsg.CSAttrStrengthenInfo QueryAttrStengthen_Rsp = 16;
inline bool CSPlayerRespond::has_queryattrstengthen_rsp() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CSPlayerRespond::set_has_queryattrstengthen_rsp() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CSPlayerRespond::clear_has_queryattrstengthen_rsp() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CSPlayerRespond::clear_queryattrstengthen_rsp() {
  if (queryattrstengthen_rsp_ != NULL) queryattrstengthen_rsp_->::vmsg::CSAttrStrengthenInfo::Clear();
  clear_has_queryattrstengthen_rsp();
}
inline const ::vmsg::CSAttrStrengthenInfo& CSPlayerRespond::queryattrstengthen_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return queryattrstengthen_rsp_ != NULL ? *queryattrstengthen_rsp_ : *default_instance().queryattrstengthen_rsp_;
#else
  return queryattrstengthen_rsp_ != NULL ? *queryattrstengthen_rsp_ : *default_instance_->queryattrstengthen_rsp_;
#endif
}
inline ::vmsg::CSAttrStrengthenInfo* CSPlayerRespond::mutable_queryattrstengthen_rsp() {
  set_has_queryattrstengthen_rsp();
  if (queryattrstengthen_rsp_ == NULL) queryattrstengthen_rsp_ = new ::vmsg::CSAttrStrengthenInfo;
  return queryattrstengthen_rsp_;
}
inline ::vmsg::CSAttrStrengthenInfo* CSPlayerRespond::release_queryattrstengthen_rsp() {
  clear_has_queryattrstengthen_rsp();
  ::vmsg::CSAttrStrengthenInfo* temp = queryattrstengthen_rsp_;
  queryattrstengthen_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_queryattrstengthen_rsp(::vmsg::CSAttrStrengthenInfo* queryattrstengthen_rsp) {
  delete queryattrstengthen_rsp_;
  queryattrstengthen_rsp_ = queryattrstengthen_rsp;
  if (queryattrstengthen_rsp) {
    set_has_queryattrstengthen_rsp();
  } else {
    clear_has_queryattrstengthen_rsp();
  }
}

// optional .vmsg.CSAttrStrengthenInfo AttrStengthen_Rsp = 17;
inline bool CSPlayerRespond::has_attrstengthen_rsp() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CSPlayerRespond::set_has_attrstengthen_rsp() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CSPlayerRespond::clear_has_attrstengthen_rsp() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CSPlayerRespond::clear_attrstengthen_rsp() {
  if (attrstengthen_rsp_ != NULL) attrstengthen_rsp_->::vmsg::CSAttrStrengthenInfo::Clear();
  clear_has_attrstengthen_rsp();
}
inline const ::vmsg::CSAttrStrengthenInfo& CSPlayerRespond::attrstengthen_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return attrstengthen_rsp_ != NULL ? *attrstengthen_rsp_ : *default_instance().attrstengthen_rsp_;
#else
  return attrstengthen_rsp_ != NULL ? *attrstengthen_rsp_ : *default_instance_->attrstengthen_rsp_;
#endif
}
inline ::vmsg::CSAttrStrengthenInfo* CSPlayerRespond::mutable_attrstengthen_rsp() {
  set_has_attrstengthen_rsp();
  if (attrstengthen_rsp_ == NULL) attrstengthen_rsp_ = new ::vmsg::CSAttrStrengthenInfo;
  return attrstengthen_rsp_;
}
inline ::vmsg::CSAttrStrengthenInfo* CSPlayerRespond::release_attrstengthen_rsp() {
  clear_has_attrstengthen_rsp();
  ::vmsg::CSAttrStrengthenInfo* temp = attrstengthen_rsp_;
  attrstengthen_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_attrstengthen_rsp(::vmsg::CSAttrStrengthenInfo* attrstengthen_rsp) {
  delete attrstengthen_rsp_;
  attrstengthen_rsp_ = attrstengthen_rsp;
  if (attrstengthen_rsp) {
    set_has_attrstengthen_rsp();
  } else {
    clear_has_attrstengthen_rsp();
  }
}

// optional .vmsg.CSWeaponLotQueryRsp QueryWeaponLot_Rsp = 18;
inline bool CSPlayerRespond::has_queryweaponlot_rsp() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CSPlayerRespond::set_has_queryweaponlot_rsp() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CSPlayerRespond::clear_has_queryweaponlot_rsp() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CSPlayerRespond::clear_queryweaponlot_rsp() {
  if (queryweaponlot_rsp_ != NULL) queryweaponlot_rsp_->::vmsg::CSWeaponLotQueryRsp::Clear();
  clear_has_queryweaponlot_rsp();
}
inline const ::vmsg::CSWeaponLotQueryRsp& CSPlayerRespond::queryweaponlot_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return queryweaponlot_rsp_ != NULL ? *queryweaponlot_rsp_ : *default_instance().queryweaponlot_rsp_;
#else
  return queryweaponlot_rsp_ != NULL ? *queryweaponlot_rsp_ : *default_instance_->queryweaponlot_rsp_;
#endif
}
inline ::vmsg::CSWeaponLotQueryRsp* CSPlayerRespond::mutable_queryweaponlot_rsp() {
  set_has_queryweaponlot_rsp();
  if (queryweaponlot_rsp_ == NULL) queryweaponlot_rsp_ = new ::vmsg::CSWeaponLotQueryRsp;
  return queryweaponlot_rsp_;
}
inline ::vmsg::CSWeaponLotQueryRsp* CSPlayerRespond::release_queryweaponlot_rsp() {
  clear_has_queryweaponlot_rsp();
  ::vmsg::CSWeaponLotQueryRsp* temp = queryweaponlot_rsp_;
  queryweaponlot_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_queryweaponlot_rsp(::vmsg::CSWeaponLotQueryRsp* queryweaponlot_rsp) {
  delete queryweaponlot_rsp_;
  queryweaponlot_rsp_ = queryweaponlot_rsp;
  if (queryweaponlot_rsp) {
    set_has_queryweaponlot_rsp();
  } else {
    clear_has_queryweaponlot_rsp();
  }
}

// optional .vmsg.CSWeaponLotRsp WeaponLot_Rsp = 19;
inline bool CSPlayerRespond::has_weaponlot_rsp() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CSPlayerRespond::set_has_weaponlot_rsp() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CSPlayerRespond::clear_has_weaponlot_rsp() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CSPlayerRespond::clear_weaponlot_rsp() {
  if (weaponlot_rsp_ != NULL) weaponlot_rsp_->::vmsg::CSWeaponLotRsp::Clear();
  clear_has_weaponlot_rsp();
}
inline const ::vmsg::CSWeaponLotRsp& CSPlayerRespond::weaponlot_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return weaponlot_rsp_ != NULL ? *weaponlot_rsp_ : *default_instance().weaponlot_rsp_;
#else
  return weaponlot_rsp_ != NULL ? *weaponlot_rsp_ : *default_instance_->weaponlot_rsp_;
#endif
}
inline ::vmsg::CSWeaponLotRsp* CSPlayerRespond::mutable_weaponlot_rsp() {
  set_has_weaponlot_rsp();
  if (weaponlot_rsp_ == NULL) weaponlot_rsp_ = new ::vmsg::CSWeaponLotRsp;
  return weaponlot_rsp_;
}
inline ::vmsg::CSWeaponLotRsp* CSPlayerRespond::release_weaponlot_rsp() {
  clear_has_weaponlot_rsp();
  ::vmsg::CSWeaponLotRsp* temp = weaponlot_rsp_;
  weaponlot_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_weaponlot_rsp(::vmsg::CSWeaponLotRsp* weaponlot_rsp) {
  delete weaponlot_rsp_;
  weaponlot_rsp_ = weaponlot_rsp;
  if (weaponlot_rsp) {
    set_has_weaponlot_rsp();
  } else {
    clear_has_weaponlot_rsp();
  }
}

// optional .vmsg.CSAwardRankRsp QueryAwardRank_Rsp = 20;
inline bool CSPlayerRespond::has_queryawardrank_rsp() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CSPlayerRespond::set_has_queryawardrank_rsp() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CSPlayerRespond::clear_has_queryawardrank_rsp() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CSPlayerRespond::clear_queryawardrank_rsp() {
  if (queryawardrank_rsp_ != NULL) queryawardrank_rsp_->::vmsg::CSAwardRankRsp::Clear();
  clear_has_queryawardrank_rsp();
}
inline const ::vmsg::CSAwardRankRsp& CSPlayerRespond::queryawardrank_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return queryawardrank_rsp_ != NULL ? *queryawardrank_rsp_ : *default_instance().queryawardrank_rsp_;
#else
  return queryawardrank_rsp_ != NULL ? *queryawardrank_rsp_ : *default_instance_->queryawardrank_rsp_;
#endif
}
inline ::vmsg::CSAwardRankRsp* CSPlayerRespond::mutable_queryawardrank_rsp() {
  set_has_queryawardrank_rsp();
  if (queryawardrank_rsp_ == NULL) queryawardrank_rsp_ = new ::vmsg::CSAwardRankRsp;
  return queryawardrank_rsp_;
}
inline ::vmsg::CSAwardRankRsp* CSPlayerRespond::release_queryawardrank_rsp() {
  clear_has_queryawardrank_rsp();
  ::vmsg::CSAwardRankRsp* temp = queryawardrank_rsp_;
  queryawardrank_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_queryawardrank_rsp(::vmsg::CSAwardRankRsp* queryawardrank_rsp) {
  delete queryawardrank_rsp_;
  queryawardrank_rsp_ = queryawardrank_rsp;
  if (queryawardrank_rsp) {
    set_has_queryawardrank_rsp();
  } else {
    clear_has_queryawardrank_rsp();
  }
}

// optional .vmsg.CSAwardRankRsp FetchRankAward_Rsp = 21;
inline bool CSPlayerRespond::has_fetchrankaward_rsp() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CSPlayerRespond::set_has_fetchrankaward_rsp() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CSPlayerRespond::clear_has_fetchrankaward_rsp() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CSPlayerRespond::clear_fetchrankaward_rsp() {
  if (fetchrankaward_rsp_ != NULL) fetchrankaward_rsp_->::vmsg::CSAwardRankRsp::Clear();
  clear_has_fetchrankaward_rsp();
}
inline const ::vmsg::CSAwardRankRsp& CSPlayerRespond::fetchrankaward_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fetchrankaward_rsp_ != NULL ? *fetchrankaward_rsp_ : *default_instance().fetchrankaward_rsp_;
#else
  return fetchrankaward_rsp_ != NULL ? *fetchrankaward_rsp_ : *default_instance_->fetchrankaward_rsp_;
#endif
}
inline ::vmsg::CSAwardRankRsp* CSPlayerRespond::mutable_fetchrankaward_rsp() {
  set_has_fetchrankaward_rsp();
  if (fetchrankaward_rsp_ == NULL) fetchrankaward_rsp_ = new ::vmsg::CSAwardRankRsp;
  return fetchrankaward_rsp_;
}
inline ::vmsg::CSAwardRankRsp* CSPlayerRespond::release_fetchrankaward_rsp() {
  clear_has_fetchrankaward_rsp();
  ::vmsg::CSAwardRankRsp* temp = fetchrankaward_rsp_;
  fetchrankaward_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_fetchrankaward_rsp(::vmsg::CSAwardRankRsp* fetchrankaward_rsp) {
  delete fetchrankaward_rsp_;
  fetchrankaward_rsp_ = fetchrankaward_rsp;
  if (fetchrankaward_rsp) {
    set_has_fetchrankaward_rsp();
  } else {
    clear_has_fetchrankaward_rsp();
  }
}

// optional .vmsg.CSPlayerLvUpRsp PlayerLvUp_Rsp = 22;
inline bool CSPlayerRespond::has_playerlvup_rsp() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CSPlayerRespond::set_has_playerlvup_rsp() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CSPlayerRespond::clear_has_playerlvup_rsp() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CSPlayerRespond::clear_playerlvup_rsp() {
  if (playerlvup_rsp_ != NULL) playerlvup_rsp_->::vmsg::CSPlayerLvUpRsp::Clear();
  clear_has_playerlvup_rsp();
}
inline const ::vmsg::CSPlayerLvUpRsp& CSPlayerRespond::playerlvup_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerlvup_rsp_ != NULL ? *playerlvup_rsp_ : *default_instance().playerlvup_rsp_;
#else
  return playerlvup_rsp_ != NULL ? *playerlvup_rsp_ : *default_instance_->playerlvup_rsp_;
#endif
}
inline ::vmsg::CSPlayerLvUpRsp* CSPlayerRespond::mutable_playerlvup_rsp() {
  set_has_playerlvup_rsp();
  if (playerlvup_rsp_ == NULL) playerlvup_rsp_ = new ::vmsg::CSPlayerLvUpRsp;
  return playerlvup_rsp_;
}
inline ::vmsg::CSPlayerLvUpRsp* CSPlayerRespond::release_playerlvup_rsp() {
  clear_has_playerlvup_rsp();
  ::vmsg::CSPlayerLvUpRsp* temp = playerlvup_rsp_;
  playerlvup_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_playerlvup_rsp(::vmsg::CSPlayerLvUpRsp* playerlvup_rsp) {
  delete playerlvup_rsp_;
  playerlvup_rsp_ = playerlvup_rsp;
  if (playerlvup_rsp) {
    set_has_playerlvup_rsp();
  } else {
    clear_has_playerlvup_rsp();
  }
}

// optional uint64 PlayerCoin_Notify = 23;
inline bool CSPlayerRespond::has_playercoin_notify() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CSPlayerRespond::set_has_playercoin_notify() {
  _has_bits_[0] |= 0x00400000u;
}
inline void CSPlayerRespond::clear_has_playercoin_notify() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void CSPlayerRespond::clear_playercoin_notify() {
  playercoin_notify_ = GOOGLE_ULONGLONG(0);
  clear_has_playercoin_notify();
}
inline ::google::protobuf::uint64 CSPlayerRespond::playercoin_notify() const {
  return playercoin_notify_;
}
inline void CSPlayerRespond::set_playercoin_notify(::google::protobuf::uint64 value) {
  set_has_playercoin_notify();
  playercoin_notify_ = value;
}

// optional .vmsg.CSVIPNotify VIP_Notify = 24;
inline bool CSPlayerRespond::has_vip_notify() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void CSPlayerRespond::set_has_vip_notify() {
  _has_bits_[0] |= 0x00800000u;
}
inline void CSPlayerRespond::clear_has_vip_notify() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void CSPlayerRespond::clear_vip_notify() {
  if (vip_notify_ != NULL) vip_notify_->::vmsg::CSVIPNotify::Clear();
  clear_has_vip_notify();
}
inline const ::vmsg::CSVIPNotify& CSPlayerRespond::vip_notify() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return vip_notify_ != NULL ? *vip_notify_ : *default_instance().vip_notify_;
#else
  return vip_notify_ != NULL ? *vip_notify_ : *default_instance_->vip_notify_;
#endif
}
inline ::vmsg::CSVIPNotify* CSPlayerRespond::mutable_vip_notify() {
  set_has_vip_notify();
  if (vip_notify_ == NULL) vip_notify_ = new ::vmsg::CSVIPNotify;
  return vip_notify_;
}
inline ::vmsg::CSVIPNotify* CSPlayerRespond::release_vip_notify() {
  clear_has_vip_notify();
  ::vmsg::CSVIPNotify* temp = vip_notify_;
  vip_notify_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_vip_notify(::vmsg::CSVIPNotify* vip_notify) {
  delete vip_notify_;
  vip_notify_ = vip_notify;
  if (vip_notify) {
    set_has_vip_notify();
  } else {
    clear_has_vip_notify();
  }
}

// optional .vmsg.CSVIPInfos QueryVIPInfo_Rsp = 25;
inline bool CSPlayerRespond::has_queryvipinfo_rsp() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void CSPlayerRespond::set_has_queryvipinfo_rsp() {
  _has_bits_[0] |= 0x01000000u;
}
inline void CSPlayerRespond::clear_has_queryvipinfo_rsp() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void CSPlayerRespond::clear_queryvipinfo_rsp() {
  if (queryvipinfo_rsp_ != NULL) queryvipinfo_rsp_->::vmsg::CSVIPInfos::Clear();
  clear_has_queryvipinfo_rsp();
}
inline const ::vmsg::CSVIPInfos& CSPlayerRespond::queryvipinfo_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return queryvipinfo_rsp_ != NULL ? *queryvipinfo_rsp_ : *default_instance().queryvipinfo_rsp_;
#else
  return queryvipinfo_rsp_ != NULL ? *queryvipinfo_rsp_ : *default_instance_->queryvipinfo_rsp_;
#endif
}
inline ::vmsg::CSVIPInfos* CSPlayerRespond::mutable_queryvipinfo_rsp() {
  set_has_queryvipinfo_rsp();
  if (queryvipinfo_rsp_ == NULL) queryvipinfo_rsp_ = new ::vmsg::CSVIPInfos;
  return queryvipinfo_rsp_;
}
inline ::vmsg::CSVIPInfos* CSPlayerRespond::release_queryvipinfo_rsp() {
  clear_has_queryvipinfo_rsp();
  ::vmsg::CSVIPInfos* temp = queryvipinfo_rsp_;
  queryvipinfo_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_queryvipinfo_rsp(::vmsg::CSVIPInfos* queryvipinfo_rsp) {
  delete queryvipinfo_rsp_;
  queryvipinfo_rsp_ = queryvipinfo_rsp;
  if (queryvipinfo_rsp) {
    set_has_queryvipinfo_rsp();
  } else {
    clear_has_queryvipinfo_rsp();
  }
}

// optional .vmsg.CSFightPowerNotify FightPower_Notify = 26;
inline bool CSPlayerRespond::has_fightpower_notify() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void CSPlayerRespond::set_has_fightpower_notify() {
  _has_bits_[0] |= 0x02000000u;
}
inline void CSPlayerRespond::clear_has_fightpower_notify() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void CSPlayerRespond::clear_fightpower_notify() {
  if (fightpower_notify_ != NULL) fightpower_notify_->::vmsg::CSFightPowerNotify::Clear();
  clear_has_fightpower_notify();
}
inline const ::vmsg::CSFightPowerNotify& CSPlayerRespond::fightpower_notify() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fightpower_notify_ != NULL ? *fightpower_notify_ : *default_instance().fightpower_notify_;
#else
  return fightpower_notify_ != NULL ? *fightpower_notify_ : *default_instance_->fightpower_notify_;
#endif
}
inline ::vmsg::CSFightPowerNotify* CSPlayerRespond::mutable_fightpower_notify() {
  set_has_fightpower_notify();
  if (fightpower_notify_ == NULL) fightpower_notify_ = new ::vmsg::CSFightPowerNotify;
  return fightpower_notify_;
}
inline ::vmsg::CSFightPowerNotify* CSPlayerRespond::release_fightpower_notify() {
  clear_has_fightpower_notify();
  ::vmsg::CSFightPowerNotify* temp = fightpower_notify_;
  fightpower_notify_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_fightpower_notify(::vmsg::CSFightPowerNotify* fightpower_notify) {
  delete fightpower_notify_;
  fightpower_notify_ = fightpower_notify;
  if (fightpower_notify) {
    set_has_fightpower_notify();
  } else {
    clear_has_fightpower_notify();
  }
}

// optional .vmsg.CSOtherPlayerInfoRsp QueryOtherPlayer_Rsp = 27;
inline bool CSPlayerRespond::has_queryotherplayer_rsp() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void CSPlayerRespond::set_has_queryotherplayer_rsp() {
  _has_bits_[0] |= 0x04000000u;
}
inline void CSPlayerRespond::clear_has_queryotherplayer_rsp() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void CSPlayerRespond::clear_queryotherplayer_rsp() {
  if (queryotherplayer_rsp_ != NULL) queryotherplayer_rsp_->::vmsg::CSOtherPlayerInfoRsp::Clear();
  clear_has_queryotherplayer_rsp();
}
inline const ::vmsg::CSOtherPlayerInfoRsp& CSPlayerRespond::queryotherplayer_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return queryotherplayer_rsp_ != NULL ? *queryotherplayer_rsp_ : *default_instance().queryotherplayer_rsp_;
#else
  return queryotherplayer_rsp_ != NULL ? *queryotherplayer_rsp_ : *default_instance_->queryotherplayer_rsp_;
#endif
}
inline ::vmsg::CSOtherPlayerInfoRsp* CSPlayerRespond::mutable_queryotherplayer_rsp() {
  set_has_queryotherplayer_rsp();
  if (queryotherplayer_rsp_ == NULL) queryotherplayer_rsp_ = new ::vmsg::CSOtherPlayerInfoRsp;
  return queryotherplayer_rsp_;
}
inline ::vmsg::CSOtherPlayerInfoRsp* CSPlayerRespond::release_queryotherplayer_rsp() {
  clear_has_queryotherplayer_rsp();
  ::vmsg::CSOtherPlayerInfoRsp* temp = queryotherplayer_rsp_;
  queryotherplayer_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_queryotherplayer_rsp(::vmsg::CSOtherPlayerInfoRsp* queryotherplayer_rsp) {
  delete queryotherplayer_rsp_;
  queryotherplayer_rsp_ = queryotherplayer_rsp;
  if (queryotherplayer_rsp) {
    set_has_queryotherplayer_rsp();
  } else {
    clear_has_queryotherplayer_rsp();
  }
}

// optional .vmsg.CSBlackMarketInfo QueryBlackMarket_Rsp = 28;
inline bool CSPlayerRespond::has_queryblackmarket_rsp() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void CSPlayerRespond::set_has_queryblackmarket_rsp() {
  _has_bits_[0] |= 0x08000000u;
}
inline void CSPlayerRespond::clear_has_queryblackmarket_rsp() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void CSPlayerRespond::clear_queryblackmarket_rsp() {
  if (queryblackmarket_rsp_ != NULL) queryblackmarket_rsp_->::vmsg::CSBlackMarketInfo::Clear();
  clear_has_queryblackmarket_rsp();
}
inline const ::vmsg::CSBlackMarketInfo& CSPlayerRespond::queryblackmarket_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return queryblackmarket_rsp_ != NULL ? *queryblackmarket_rsp_ : *default_instance().queryblackmarket_rsp_;
#else
  return queryblackmarket_rsp_ != NULL ? *queryblackmarket_rsp_ : *default_instance_->queryblackmarket_rsp_;
#endif
}
inline ::vmsg::CSBlackMarketInfo* CSPlayerRespond::mutable_queryblackmarket_rsp() {
  set_has_queryblackmarket_rsp();
  if (queryblackmarket_rsp_ == NULL) queryblackmarket_rsp_ = new ::vmsg::CSBlackMarketInfo;
  return queryblackmarket_rsp_;
}
inline ::vmsg::CSBlackMarketInfo* CSPlayerRespond::release_queryblackmarket_rsp() {
  clear_has_queryblackmarket_rsp();
  ::vmsg::CSBlackMarketInfo* temp = queryblackmarket_rsp_;
  queryblackmarket_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_queryblackmarket_rsp(::vmsg::CSBlackMarketInfo* queryblackmarket_rsp) {
  delete queryblackmarket_rsp_;
  queryblackmarket_rsp_ = queryblackmarket_rsp;
  if (queryblackmarket_rsp) {
    set_has_queryblackmarket_rsp();
  } else {
    clear_has_queryblackmarket_rsp();
  }
}

// optional .vmsg.CSBlackMarketInfo BuyBlackMarket_Rsp = 29;
inline bool CSPlayerRespond::has_buyblackmarket_rsp() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void CSPlayerRespond::set_has_buyblackmarket_rsp() {
  _has_bits_[0] |= 0x10000000u;
}
inline void CSPlayerRespond::clear_has_buyblackmarket_rsp() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void CSPlayerRespond::clear_buyblackmarket_rsp() {
  if (buyblackmarket_rsp_ != NULL) buyblackmarket_rsp_->::vmsg::CSBlackMarketInfo::Clear();
  clear_has_buyblackmarket_rsp();
}
inline const ::vmsg::CSBlackMarketInfo& CSPlayerRespond::buyblackmarket_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return buyblackmarket_rsp_ != NULL ? *buyblackmarket_rsp_ : *default_instance().buyblackmarket_rsp_;
#else
  return buyblackmarket_rsp_ != NULL ? *buyblackmarket_rsp_ : *default_instance_->buyblackmarket_rsp_;
#endif
}
inline ::vmsg::CSBlackMarketInfo* CSPlayerRespond::mutable_buyblackmarket_rsp() {
  set_has_buyblackmarket_rsp();
  if (buyblackmarket_rsp_ == NULL) buyblackmarket_rsp_ = new ::vmsg::CSBlackMarketInfo;
  return buyblackmarket_rsp_;
}
inline ::vmsg::CSBlackMarketInfo* CSPlayerRespond::release_buyblackmarket_rsp() {
  clear_has_buyblackmarket_rsp();
  ::vmsg::CSBlackMarketInfo* temp = buyblackmarket_rsp_;
  buyblackmarket_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_buyblackmarket_rsp(::vmsg::CSBlackMarketInfo* buyblackmarket_rsp) {
  delete buyblackmarket_rsp_;
  buyblackmarket_rsp_ = buyblackmarket_rsp;
  if (buyblackmarket_rsp) {
    set_has_buyblackmarket_rsp();
  } else {
    clear_has_buyblackmarket_rsp();
  }
}

// optional .vmsg.CSBlackMarketInfo ResetBlackMarket_Rsp = 30;
inline bool CSPlayerRespond::has_resetblackmarket_rsp() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void CSPlayerRespond::set_has_resetblackmarket_rsp() {
  _has_bits_[0] |= 0x20000000u;
}
inline void CSPlayerRespond::clear_has_resetblackmarket_rsp() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void CSPlayerRespond::clear_resetblackmarket_rsp() {
  if (resetblackmarket_rsp_ != NULL) resetblackmarket_rsp_->::vmsg::CSBlackMarketInfo::Clear();
  clear_has_resetblackmarket_rsp();
}
inline const ::vmsg::CSBlackMarketInfo& CSPlayerRespond::resetblackmarket_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return resetblackmarket_rsp_ != NULL ? *resetblackmarket_rsp_ : *default_instance().resetblackmarket_rsp_;
#else
  return resetblackmarket_rsp_ != NULL ? *resetblackmarket_rsp_ : *default_instance_->resetblackmarket_rsp_;
#endif
}
inline ::vmsg::CSBlackMarketInfo* CSPlayerRespond::mutable_resetblackmarket_rsp() {
  set_has_resetblackmarket_rsp();
  if (resetblackmarket_rsp_ == NULL) resetblackmarket_rsp_ = new ::vmsg::CSBlackMarketInfo;
  return resetblackmarket_rsp_;
}
inline ::vmsg::CSBlackMarketInfo* CSPlayerRespond::release_resetblackmarket_rsp() {
  clear_has_resetblackmarket_rsp();
  ::vmsg::CSBlackMarketInfo* temp = resetblackmarket_rsp_;
  resetblackmarket_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_resetblackmarket_rsp(::vmsg::CSBlackMarketInfo* resetblackmarket_rsp) {
  delete resetblackmarket_rsp_;
  resetblackmarket_rsp_ = resetblackmarket_rsp;
  if (resetblackmarket_rsp) {
    set_has_resetblackmarket_rsp();
  } else {
    clear_has_resetblackmarket_rsp();
  }
}

// optional .vmsg.CSQuickLoginRsp QuickLogin_Rsp = 31;
inline bool CSPlayerRespond::has_quicklogin_rsp() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void CSPlayerRespond::set_has_quicklogin_rsp() {
  _has_bits_[0] |= 0x40000000u;
}
inline void CSPlayerRespond::clear_has_quicklogin_rsp() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void CSPlayerRespond::clear_quicklogin_rsp() {
  if (quicklogin_rsp_ != NULL) quicklogin_rsp_->::vmsg::CSQuickLoginRsp::Clear();
  clear_has_quicklogin_rsp();
}
inline const ::vmsg::CSQuickLoginRsp& CSPlayerRespond::quicklogin_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return quicklogin_rsp_ != NULL ? *quicklogin_rsp_ : *default_instance().quicklogin_rsp_;
#else
  return quicklogin_rsp_ != NULL ? *quicklogin_rsp_ : *default_instance_->quicklogin_rsp_;
#endif
}
inline ::vmsg::CSQuickLoginRsp* CSPlayerRespond::mutable_quicklogin_rsp() {
  set_has_quicklogin_rsp();
  if (quicklogin_rsp_ == NULL) quicklogin_rsp_ = new ::vmsg::CSQuickLoginRsp;
  return quicklogin_rsp_;
}
inline ::vmsg::CSQuickLoginRsp* CSPlayerRespond::release_quicklogin_rsp() {
  clear_has_quicklogin_rsp();
  ::vmsg::CSQuickLoginRsp* temp = quicklogin_rsp_;
  quicklogin_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_quicklogin_rsp(::vmsg::CSQuickLoginRsp* quicklogin_rsp) {
  delete quicklogin_rsp_;
  quicklogin_rsp_ = quicklogin_rsp;
  if (quicklogin_rsp) {
    set_has_quicklogin_rsp();
  } else {
    clear_has_quicklogin_rsp();
  }
}

// optional .vmsg.CSBuyCoinInfo QueryBuyCoin_Rsp = 32;
inline bool CSPlayerRespond::has_querybuycoin_rsp() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void CSPlayerRespond::set_has_querybuycoin_rsp() {
  _has_bits_[0] |= 0x80000000u;
}
inline void CSPlayerRespond::clear_has_querybuycoin_rsp() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void CSPlayerRespond::clear_querybuycoin_rsp() {
  if (querybuycoin_rsp_ != NULL) querybuycoin_rsp_->::vmsg::CSBuyCoinInfo::Clear();
  clear_has_querybuycoin_rsp();
}
inline const ::vmsg::CSBuyCoinInfo& CSPlayerRespond::querybuycoin_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return querybuycoin_rsp_ != NULL ? *querybuycoin_rsp_ : *default_instance().querybuycoin_rsp_;
#else
  return querybuycoin_rsp_ != NULL ? *querybuycoin_rsp_ : *default_instance_->querybuycoin_rsp_;
#endif
}
inline ::vmsg::CSBuyCoinInfo* CSPlayerRespond::mutable_querybuycoin_rsp() {
  set_has_querybuycoin_rsp();
  if (querybuycoin_rsp_ == NULL) querybuycoin_rsp_ = new ::vmsg::CSBuyCoinInfo;
  return querybuycoin_rsp_;
}
inline ::vmsg::CSBuyCoinInfo* CSPlayerRespond::release_querybuycoin_rsp() {
  clear_has_querybuycoin_rsp();
  ::vmsg::CSBuyCoinInfo* temp = querybuycoin_rsp_;
  querybuycoin_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_querybuycoin_rsp(::vmsg::CSBuyCoinInfo* querybuycoin_rsp) {
  delete querybuycoin_rsp_;
  querybuycoin_rsp_ = querybuycoin_rsp;
  if (querybuycoin_rsp) {
    set_has_querybuycoin_rsp();
  } else {
    clear_has_querybuycoin_rsp();
  }
}

// optional .vmsg.CSBuyCoinRsp BuyCoin_Rsp = 33;
inline bool CSPlayerRespond::has_buycoin_rsp() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void CSPlayerRespond::set_has_buycoin_rsp() {
  _has_bits_[1] |= 0x00000001u;
}
inline void CSPlayerRespond::clear_has_buycoin_rsp() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void CSPlayerRespond::clear_buycoin_rsp() {
  if (buycoin_rsp_ != NULL) buycoin_rsp_->::vmsg::CSBuyCoinRsp::Clear();
  clear_has_buycoin_rsp();
}
inline const ::vmsg::CSBuyCoinRsp& CSPlayerRespond::buycoin_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return buycoin_rsp_ != NULL ? *buycoin_rsp_ : *default_instance().buycoin_rsp_;
#else
  return buycoin_rsp_ != NULL ? *buycoin_rsp_ : *default_instance_->buycoin_rsp_;
#endif
}
inline ::vmsg::CSBuyCoinRsp* CSPlayerRespond::mutable_buycoin_rsp() {
  set_has_buycoin_rsp();
  if (buycoin_rsp_ == NULL) buycoin_rsp_ = new ::vmsg::CSBuyCoinRsp;
  return buycoin_rsp_;
}
inline ::vmsg::CSBuyCoinRsp* CSPlayerRespond::release_buycoin_rsp() {
  clear_has_buycoin_rsp();
  ::vmsg::CSBuyCoinRsp* temp = buycoin_rsp_;
  buycoin_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_buycoin_rsp(::vmsg::CSBuyCoinRsp* buycoin_rsp) {
  delete buycoin_rsp_;
  buycoin_rsp_ = buycoin_rsp;
  if (buycoin_rsp) {
    set_has_buycoin_rsp();
  } else {
    clear_has_buycoin_rsp();
  }
}

// optional .vmsg.CSDailyRegInfo DailyReg_Rsp = 34;
inline bool CSPlayerRespond::has_dailyreg_rsp() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void CSPlayerRespond::set_has_dailyreg_rsp() {
  _has_bits_[1] |= 0x00000002u;
}
inline void CSPlayerRespond::clear_has_dailyreg_rsp() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void CSPlayerRespond::clear_dailyreg_rsp() {
  if (dailyreg_rsp_ != NULL) dailyreg_rsp_->::vmsg::CSDailyRegInfo::Clear();
  clear_has_dailyreg_rsp();
}
inline const ::vmsg::CSDailyRegInfo& CSPlayerRespond::dailyreg_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dailyreg_rsp_ != NULL ? *dailyreg_rsp_ : *default_instance().dailyreg_rsp_;
#else
  return dailyreg_rsp_ != NULL ? *dailyreg_rsp_ : *default_instance_->dailyreg_rsp_;
#endif
}
inline ::vmsg::CSDailyRegInfo* CSPlayerRespond::mutable_dailyreg_rsp() {
  set_has_dailyreg_rsp();
  if (dailyreg_rsp_ == NULL) dailyreg_rsp_ = new ::vmsg::CSDailyRegInfo;
  return dailyreg_rsp_;
}
inline ::vmsg::CSDailyRegInfo* CSPlayerRespond::release_dailyreg_rsp() {
  clear_has_dailyreg_rsp();
  ::vmsg::CSDailyRegInfo* temp = dailyreg_rsp_;
  dailyreg_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_dailyreg_rsp(::vmsg::CSDailyRegInfo* dailyreg_rsp) {
  delete dailyreg_rsp_;
  dailyreg_rsp_ = dailyreg_rsp;
  if (dailyreg_rsp) {
    set_has_dailyreg_rsp();
  } else {
    clear_has_dailyreg_rsp();
  }
}

// optional .vmsg.CSMonthCardInfo GetMonthCardAward_Rsp = 35;
inline bool CSPlayerRespond::has_getmonthcardaward_rsp() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void CSPlayerRespond::set_has_getmonthcardaward_rsp() {
  _has_bits_[1] |= 0x00000004u;
}
inline void CSPlayerRespond::clear_has_getmonthcardaward_rsp() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void CSPlayerRespond::clear_getmonthcardaward_rsp() {
  if (getmonthcardaward_rsp_ != NULL) getmonthcardaward_rsp_->::vmsg::CSMonthCardInfo::Clear();
  clear_has_getmonthcardaward_rsp();
}
inline const ::vmsg::CSMonthCardInfo& CSPlayerRespond::getmonthcardaward_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return getmonthcardaward_rsp_ != NULL ? *getmonthcardaward_rsp_ : *default_instance().getmonthcardaward_rsp_;
#else
  return getmonthcardaward_rsp_ != NULL ? *getmonthcardaward_rsp_ : *default_instance_->getmonthcardaward_rsp_;
#endif
}
inline ::vmsg::CSMonthCardInfo* CSPlayerRespond::mutable_getmonthcardaward_rsp() {
  set_has_getmonthcardaward_rsp();
  if (getmonthcardaward_rsp_ == NULL) getmonthcardaward_rsp_ = new ::vmsg::CSMonthCardInfo;
  return getmonthcardaward_rsp_;
}
inline ::vmsg::CSMonthCardInfo* CSPlayerRespond::release_getmonthcardaward_rsp() {
  clear_has_getmonthcardaward_rsp();
  ::vmsg::CSMonthCardInfo* temp = getmonthcardaward_rsp_;
  getmonthcardaward_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_getmonthcardaward_rsp(::vmsg::CSMonthCardInfo* getmonthcardaward_rsp) {
  delete getmonthcardaward_rsp_;
  getmonthcardaward_rsp_ = getmonthcardaward_rsp;
  if (getmonthcardaward_rsp) {
    set_has_getmonthcardaward_rsp();
  } else {
    clear_has_getmonthcardaward_rsp();
  }
}

// optional .vmsg.CSMonthCardInfo PushMonthCard_Notify = 36;
inline bool CSPlayerRespond::has_pushmonthcard_notify() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void CSPlayerRespond::set_has_pushmonthcard_notify() {
  _has_bits_[1] |= 0x00000008u;
}
inline void CSPlayerRespond::clear_has_pushmonthcard_notify() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void CSPlayerRespond::clear_pushmonthcard_notify() {
  if (pushmonthcard_notify_ != NULL) pushmonthcard_notify_->::vmsg::CSMonthCardInfo::Clear();
  clear_has_pushmonthcard_notify();
}
inline const ::vmsg::CSMonthCardInfo& CSPlayerRespond::pushmonthcard_notify() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return pushmonthcard_notify_ != NULL ? *pushmonthcard_notify_ : *default_instance().pushmonthcard_notify_;
#else
  return pushmonthcard_notify_ != NULL ? *pushmonthcard_notify_ : *default_instance_->pushmonthcard_notify_;
#endif
}
inline ::vmsg::CSMonthCardInfo* CSPlayerRespond::mutable_pushmonthcard_notify() {
  set_has_pushmonthcard_notify();
  if (pushmonthcard_notify_ == NULL) pushmonthcard_notify_ = new ::vmsg::CSMonthCardInfo;
  return pushmonthcard_notify_;
}
inline ::vmsg::CSMonthCardInfo* CSPlayerRespond::release_pushmonthcard_notify() {
  clear_has_pushmonthcard_notify();
  ::vmsg::CSMonthCardInfo* temp = pushmonthcard_notify_;
  pushmonthcard_notify_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_pushmonthcard_notify(::vmsg::CSMonthCardInfo* pushmonthcard_notify) {
  delete pushmonthcard_notify_;
  pushmonthcard_notify_ = pushmonthcard_notify;
  if (pushmonthcard_notify) {
    set_has_pushmonthcard_notify();
  } else {
    clear_has_pushmonthcard_notify();
  }
}

// optional uint32 ClaimedManual = 37;
inline bool CSPlayerRespond::has_claimedmanual() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void CSPlayerRespond::set_has_claimedmanual() {
  _has_bits_[1] |= 0x00000010u;
}
inline void CSPlayerRespond::clear_has_claimedmanual() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void CSPlayerRespond::clear_claimedmanual() {
  claimedmanual_ = 0u;
  clear_has_claimedmanual();
}
inline ::google::protobuf::uint32 CSPlayerRespond::claimedmanual() const {
  return claimedmanual_;
}
inline void CSPlayerRespond::set_claimedmanual(::google::protobuf::uint32 value) {
  set_has_claimedmanual();
  claimedmanual_ = value;
}

// optional .vmsg.CSGuestRegisterRsp GuestRegister_Rsp = 38;
inline bool CSPlayerRespond::has_guestregister_rsp() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void CSPlayerRespond::set_has_guestregister_rsp() {
  _has_bits_[1] |= 0x00000020u;
}
inline void CSPlayerRespond::clear_has_guestregister_rsp() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void CSPlayerRespond::clear_guestregister_rsp() {
  if (guestregister_rsp_ != NULL) guestregister_rsp_->::vmsg::CSGuestRegisterRsp::Clear();
  clear_has_guestregister_rsp();
}
inline const ::vmsg::CSGuestRegisterRsp& CSPlayerRespond::guestregister_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return guestregister_rsp_ != NULL ? *guestregister_rsp_ : *default_instance().guestregister_rsp_;
#else
  return guestregister_rsp_ != NULL ? *guestregister_rsp_ : *default_instance_->guestregister_rsp_;
#endif
}
inline ::vmsg::CSGuestRegisterRsp* CSPlayerRespond::mutable_guestregister_rsp() {
  set_has_guestregister_rsp();
  if (guestregister_rsp_ == NULL) guestregister_rsp_ = new ::vmsg::CSGuestRegisterRsp;
  return guestregister_rsp_;
}
inline ::vmsg::CSGuestRegisterRsp* CSPlayerRespond::release_guestregister_rsp() {
  clear_has_guestregister_rsp();
  ::vmsg::CSGuestRegisterRsp* temp = guestregister_rsp_;
  guestregister_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_guestregister_rsp(::vmsg::CSGuestRegisterRsp* guestregister_rsp) {
  delete guestregister_rsp_;
  guestregister_rsp_ = guestregister_rsp;
  if (guestregister_rsp) {
    set_has_guestregister_rsp();
  } else {
    clear_has_guestregister_rsp();
  }
}

// optional .vmsg.CSPlayerEnforceMyselfRsp PlayerEnforce_Rsp = 39;
inline bool CSPlayerRespond::has_playerenforce_rsp() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void CSPlayerRespond::set_has_playerenforce_rsp() {
  _has_bits_[1] |= 0x00000040u;
}
inline void CSPlayerRespond::clear_has_playerenforce_rsp() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void CSPlayerRespond::clear_playerenforce_rsp() {
  if (playerenforce_rsp_ != NULL) playerenforce_rsp_->::vmsg::CSPlayerEnforceMyselfRsp::Clear();
  clear_has_playerenforce_rsp();
}
inline const ::vmsg::CSPlayerEnforceMyselfRsp& CSPlayerRespond::playerenforce_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerenforce_rsp_ != NULL ? *playerenforce_rsp_ : *default_instance().playerenforce_rsp_;
#else
  return playerenforce_rsp_ != NULL ? *playerenforce_rsp_ : *default_instance_->playerenforce_rsp_;
#endif
}
inline ::vmsg::CSPlayerEnforceMyselfRsp* CSPlayerRespond::mutable_playerenforce_rsp() {
  set_has_playerenforce_rsp();
  if (playerenforce_rsp_ == NULL) playerenforce_rsp_ = new ::vmsg::CSPlayerEnforceMyselfRsp;
  return playerenforce_rsp_;
}
inline ::vmsg::CSPlayerEnforceMyselfRsp* CSPlayerRespond::release_playerenforce_rsp() {
  clear_has_playerenforce_rsp();
  ::vmsg::CSPlayerEnforceMyselfRsp* temp = playerenforce_rsp_;
  playerenforce_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_playerenforce_rsp(::vmsg::CSPlayerEnforceMyselfRsp* playerenforce_rsp) {
  delete playerenforce_rsp_;
  playerenforce_rsp_ = playerenforce_rsp;
  if (playerenforce_rsp) {
    set_has_playerenforce_rsp();
  } else {
    clear_has_playerenforce_rsp();
  }
}

// optional .vmsg.CSPlayerEnforceMyselfConfirmRsp PlayerEnforceConfirm_Rsp = 40;
inline bool CSPlayerRespond::has_playerenforceconfirm_rsp() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void CSPlayerRespond::set_has_playerenforceconfirm_rsp() {
  _has_bits_[1] |= 0x00000080u;
}
inline void CSPlayerRespond::clear_has_playerenforceconfirm_rsp() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void CSPlayerRespond::clear_playerenforceconfirm_rsp() {
  if (playerenforceconfirm_rsp_ != NULL) playerenforceconfirm_rsp_->::vmsg::CSPlayerEnforceMyselfConfirmRsp::Clear();
  clear_has_playerenforceconfirm_rsp();
}
inline const ::vmsg::CSPlayerEnforceMyselfConfirmRsp& CSPlayerRespond::playerenforceconfirm_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerenforceconfirm_rsp_ != NULL ? *playerenforceconfirm_rsp_ : *default_instance().playerenforceconfirm_rsp_;
#else
  return playerenforceconfirm_rsp_ != NULL ? *playerenforceconfirm_rsp_ : *default_instance_->playerenforceconfirm_rsp_;
#endif
}
inline ::vmsg::CSPlayerEnforceMyselfConfirmRsp* CSPlayerRespond::mutable_playerenforceconfirm_rsp() {
  set_has_playerenforceconfirm_rsp();
  if (playerenforceconfirm_rsp_ == NULL) playerenforceconfirm_rsp_ = new ::vmsg::CSPlayerEnforceMyselfConfirmRsp;
  return playerenforceconfirm_rsp_;
}
inline ::vmsg::CSPlayerEnforceMyselfConfirmRsp* CSPlayerRespond::release_playerenforceconfirm_rsp() {
  clear_has_playerenforceconfirm_rsp();
  ::vmsg::CSPlayerEnforceMyselfConfirmRsp* temp = playerenforceconfirm_rsp_;
  playerenforceconfirm_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_playerenforceconfirm_rsp(::vmsg::CSPlayerEnforceMyselfConfirmRsp* playerenforceconfirm_rsp) {
  delete playerenforceconfirm_rsp_;
  playerenforceconfirm_rsp_ = playerenforceconfirm_rsp;
  if (playerenforceconfirm_rsp) {
    set_has_playerenforceconfirm_rsp();
  } else {
    clear_has_playerenforceconfirm_rsp();
  }
}

// optional .vmsg.CSPlayerEnforceMyselfQueryRsp PlayerEnforceQuery_Rsp = 41;
inline bool CSPlayerRespond::has_playerenforcequery_rsp() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void CSPlayerRespond::set_has_playerenforcequery_rsp() {
  _has_bits_[1] |= 0x00000100u;
}
inline void CSPlayerRespond::clear_has_playerenforcequery_rsp() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void CSPlayerRespond::clear_playerenforcequery_rsp() {
  if (playerenforcequery_rsp_ != NULL) playerenforcequery_rsp_->::vmsg::CSPlayerEnforceMyselfQueryRsp::Clear();
  clear_has_playerenforcequery_rsp();
}
inline const ::vmsg::CSPlayerEnforceMyselfQueryRsp& CSPlayerRespond::playerenforcequery_rsp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return playerenforcequery_rsp_ != NULL ? *playerenforcequery_rsp_ : *default_instance().playerenforcequery_rsp_;
#else
  return playerenforcequery_rsp_ != NULL ? *playerenforcequery_rsp_ : *default_instance_->playerenforcequery_rsp_;
#endif
}
inline ::vmsg::CSPlayerEnforceMyselfQueryRsp* CSPlayerRespond::mutable_playerenforcequery_rsp() {
  set_has_playerenforcequery_rsp();
  if (playerenforcequery_rsp_ == NULL) playerenforcequery_rsp_ = new ::vmsg::CSPlayerEnforceMyselfQueryRsp;
  return playerenforcequery_rsp_;
}
inline ::vmsg::CSPlayerEnforceMyselfQueryRsp* CSPlayerRespond::release_playerenforcequery_rsp() {
  clear_has_playerenforcequery_rsp();
  ::vmsg::CSPlayerEnforceMyselfQueryRsp* temp = playerenforcequery_rsp_;
  playerenforcequery_rsp_ = NULL;
  return temp;
}
inline void CSPlayerRespond::set_allocated_playerenforcequery_rsp(::vmsg::CSPlayerEnforceMyselfQueryRsp* playerenforcequery_rsp) {
  delete playerenforcequery_rsp_;
  playerenforcequery_rsp_ = playerenforcequery_rsp;
  if (playerenforcequery_rsp) {
    set_has_playerenforcequery_rsp();
  } else {
    clear_has_playerenforcequery_rsp();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CSPlayerMsg_2eproto__INCLUDED
