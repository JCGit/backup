// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSDotaItemMsg.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "CSDotaItemMsg.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace vmsg {

void protobuf_ShutdownFile_CSDotaItemMsg_2eproto() {
  delete CSDotaItem::default_instance_;
  delete CSDotaPart::default_instance_;
  delete CSDotaPartInfo::default_instance_;
  delete CSDotaItemBag::default_instance_;
  delete CSDotaInfo::default_instance_;
  delete CSDotaItemComposeRqst::default_instance_;
  delete CSDotaItemMosaicRqst::default_instance_;
  delete CSDotaItemLvUpRqst::default_instance_;
  delete CSDotaItemRequest::default_instance_;
  delete CSDotaItemRespond::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_CSDotaItemMsg_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_CSDotaItemMsg_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::vmsg::protobuf_AddDesc_MsgBase_2eproto();
  ::vmsg::protobuf_AddDesc_ShareByClient_2eproto();
  CSDotaItem::default_instance_ = new CSDotaItem();
  CSDotaPart::default_instance_ = new CSDotaPart();
  CSDotaPartInfo::default_instance_ = new CSDotaPartInfo();
  CSDotaItemBag::default_instance_ = new CSDotaItemBag();
  CSDotaInfo::default_instance_ = new CSDotaInfo();
  CSDotaItemComposeRqst::default_instance_ = new CSDotaItemComposeRqst();
  CSDotaItemMosaicRqst::default_instance_ = new CSDotaItemMosaicRqst();
  CSDotaItemLvUpRqst::default_instance_ = new CSDotaItemLvUpRqst();
  CSDotaItemRequest::default_instance_ = new CSDotaItemRequest();
  CSDotaItemRespond::default_instance_ = new CSDotaItemRespond();
  CSDotaItem::default_instance_->InitAsDefaultInstance();
  CSDotaPart::default_instance_->InitAsDefaultInstance();
  CSDotaPartInfo::default_instance_->InitAsDefaultInstance();
  CSDotaItemBag::default_instance_->InitAsDefaultInstance();
  CSDotaInfo::default_instance_->InitAsDefaultInstance();
  CSDotaItemComposeRqst::default_instance_->InitAsDefaultInstance();
  CSDotaItemMosaicRqst::default_instance_->InitAsDefaultInstance();
  CSDotaItemLvUpRqst::default_instance_->InitAsDefaultInstance();
  CSDotaItemRequest::default_instance_->InitAsDefaultInstance();
  CSDotaItemRespond::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_CSDotaItemMsg_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_CSDotaItemMsg_2eproto_once_);
void protobuf_AddDesc_CSDotaItemMsg_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_CSDotaItemMsg_2eproto_once_,
                 &protobuf_AddDesc_CSDotaItemMsg_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_CSDotaItemMsg_2eproto {
  StaticDescriptorInitializer_CSDotaItemMsg_2eproto() {
    protobuf_AddDesc_CSDotaItemMsg_2eproto();
  }
} static_descriptor_initializer_CSDotaItemMsg_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int CSDotaItem::kDotaItemIDFieldNumber;
const int CSDotaItem::kDotaItemCntFieldNumber;
#endif  // !_MSC_VER

CSDotaItem::CSDotaItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSDotaItem::InitAsDefaultInstance() {
}

CSDotaItem::CSDotaItem(const CSDotaItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSDotaItem::SharedCtor() {
  _cached_size_ = 0;
  dotaitemid_ = 0u;
  dotaitemcnt_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSDotaItem::~CSDotaItem() {
  SharedDtor();
}

void CSDotaItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSDotaItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSDotaItem& CSDotaItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSDotaItemMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSDotaItemMsg_2eproto();
#endif
  return *default_instance_;
}

CSDotaItem* CSDotaItem::default_instance_ = NULL;

CSDotaItem* CSDotaItem::New() const {
  return new CSDotaItem;
}

void CSDotaItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    dotaitemid_ = 0u;
    dotaitemcnt_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSDotaItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 DotaItemID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dotaitemid_)));
          set_has_dotaitemid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_DotaItemCnt;
        break;
      }

      // required uint32 DotaItemCnt = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_DotaItemCnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dotaitemcnt_)));
          set_has_dotaitemcnt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSDotaItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 DotaItemID = 1;
  if (has_dotaitemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->dotaitemid(), output);
  }

  // required uint32 DotaItemCnt = 2;
  if (has_dotaitemcnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->dotaitemcnt(), output);
  }

}

int CSDotaItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 DotaItemID = 1;
    if (has_dotaitemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dotaitemid());
    }

    // required uint32 DotaItemCnt = 2;
    if (has_dotaitemcnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dotaitemcnt());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSDotaItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSDotaItem*>(&from));
}

void CSDotaItem::MergeFrom(const CSDotaItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dotaitemid()) {
      set_dotaitemid(from.dotaitemid());
    }
    if (from.has_dotaitemcnt()) {
      set_dotaitemcnt(from.dotaitemcnt());
    }
  }
}

void CSDotaItem::CopyFrom(const CSDotaItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSDotaItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSDotaItem::Swap(CSDotaItem* other) {
  if (other != this) {
    std::swap(dotaitemid_, other->dotaitemid_);
    std::swap(dotaitemcnt_, other->dotaitemcnt_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSDotaItem::GetTypeName() const {
  return "vmsg.CSDotaItem";
}


// ===================================================================

#ifndef _MSC_VER
const int CSDotaPart::kATKFieldNumber;
const int CSDotaPart::kDEFFieldNumber;
const int CSDotaPart::kHPFieldNumber;
const int CSDotaPart::kHITFieldNumber;
const int CSDotaPart::kLvFieldNumber;
const int CSDotaPart::kItemsFieldNumber;
#endif  // !_MSC_VER

CSDotaPart::CSDotaPart()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSDotaPart::InitAsDefaultInstance() {
}

CSDotaPart::CSDotaPart(const CSDotaPart& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSDotaPart::SharedCtor() {
  _cached_size_ = 0;
  atk_ = 0u;
  def_ = 0u;
  hp_ = 0u;
  hit_ = 0u;
  lv_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSDotaPart::~CSDotaPart() {
  SharedDtor();
}

void CSDotaPart::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSDotaPart::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSDotaPart& CSDotaPart::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSDotaItemMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSDotaItemMsg_2eproto();
#endif
  return *default_instance_;
}

CSDotaPart* CSDotaPart::default_instance_ = NULL;

CSDotaPart* CSDotaPart::New() const {
  return new CSDotaPart;
}

void CSDotaPart::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    atk_ = 0u;
    def_ = 0u;
    hp_ = 0u;
    hit_ = 0u;
    lv_ = 0u;
  }
  items_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSDotaPart::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ATK = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &atk_)));
          set_has_atk();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_DEF;
        break;
      }

      // required uint32 DEF = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_DEF:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &def_)));
          set_has_def();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_HP;
        break;
      }

      // required uint32 HP = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_HP:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hp_)));
          set_has_hp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_HIT;
        break;
      }

      // required uint32 HIT = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_HIT:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hit_)));
          set_has_hit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_Lv;
        break;
      }

      // required uint32 Lv = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Lv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lv_)));
          set_has_lv();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_Items;
        break;
      }

      // repeated uint32 Items = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Items:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 48, input, this->mutable_items())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_items())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_Items;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSDotaPart::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 ATK = 1;
  if (has_atk()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->atk(), output);
  }

  // required uint32 DEF = 2;
  if (has_def()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->def(), output);
  }

  // required uint32 HP = 3;
  if (has_hp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->hp(), output);
  }

  // required uint32 HIT = 4;
  if (has_hit()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->hit(), output);
  }

  // required uint32 Lv = 5;
  if (has_lv()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->lv(), output);
  }

  // repeated uint32 Items = 6;
  for (int i = 0; i < this->items_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      6, this->items(i), output);
  }

}

int CSDotaPart::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ATK = 1;
    if (has_atk()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->atk());
    }

    // required uint32 DEF = 2;
    if (has_def()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->def());
    }

    // required uint32 HP = 3;
    if (has_hp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->hp());
    }

    // required uint32 HIT = 4;
    if (has_hit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->hit());
    }

    // required uint32 Lv = 5;
    if (has_lv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lv());
    }

  }
  // repeated uint32 Items = 6;
  {
    int data_size = 0;
    for (int i = 0; i < this->items_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->items(i));
    }
    total_size += 1 * this->items_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSDotaPart::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSDotaPart*>(&from));
}

void CSDotaPart::MergeFrom(const CSDotaPart& from) {
  GOOGLE_CHECK_NE(&from, this);
  items_.MergeFrom(from.items_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_atk()) {
      set_atk(from.atk());
    }
    if (from.has_def()) {
      set_def(from.def());
    }
    if (from.has_hp()) {
      set_hp(from.hp());
    }
    if (from.has_hit()) {
      set_hit(from.hit());
    }
    if (from.has_lv()) {
      set_lv(from.lv());
    }
  }
}

void CSDotaPart::CopyFrom(const CSDotaPart& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSDotaPart::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void CSDotaPart::Swap(CSDotaPart* other) {
  if (other != this) {
    std::swap(atk_, other->atk_);
    std::swap(def_, other->def_);
    std::swap(hp_, other->hp_);
    std::swap(hit_, other->hit_);
    std::swap(lv_, other->lv_);
    items_.Swap(&other->items_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSDotaPart::GetTypeName() const {
  return "vmsg.CSDotaPart";
}


// ===================================================================

#ifndef _MSC_VER
const int CSDotaPartInfo::kPartsFieldNumber;
#endif  // !_MSC_VER

CSDotaPartInfo::CSDotaPartInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSDotaPartInfo::InitAsDefaultInstance() {
}

CSDotaPartInfo::CSDotaPartInfo(const CSDotaPartInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSDotaPartInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSDotaPartInfo::~CSDotaPartInfo() {
  SharedDtor();
}

void CSDotaPartInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSDotaPartInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSDotaPartInfo& CSDotaPartInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSDotaItemMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSDotaItemMsg_2eproto();
#endif
  return *default_instance_;
}

CSDotaPartInfo* CSDotaPartInfo::default_instance_ = NULL;

CSDotaPartInfo* CSDotaPartInfo::New() const {
  return new CSDotaPartInfo;
}

void CSDotaPartInfo::Clear() {
  parts_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSDotaPartInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .vmsg.CSDotaPart Parts = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Parts:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_parts()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_Parts;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSDotaPartInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .vmsg.CSDotaPart Parts = 1;
  for (int i = 0; i < this->parts_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->parts(i), output);
  }

}

int CSDotaPartInfo::ByteSize() const {
  int total_size = 0;

  // repeated .vmsg.CSDotaPart Parts = 1;
  total_size += 1 * this->parts_size();
  for (int i = 0; i < this->parts_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->parts(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSDotaPartInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSDotaPartInfo*>(&from));
}

void CSDotaPartInfo::MergeFrom(const CSDotaPartInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  parts_.MergeFrom(from.parts_);
}

void CSDotaPartInfo::CopyFrom(const CSDotaPartInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSDotaPartInfo::IsInitialized() const {

  for (int i = 0; i < parts_size(); i++) {
    if (!this->parts(i).IsInitialized()) return false;
  }
  return true;
}

void CSDotaPartInfo::Swap(CSDotaPartInfo* other) {
  if (other != this) {
    parts_.Swap(&other->parts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSDotaPartInfo::GetTypeName() const {
  return "vmsg.CSDotaPartInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CSDotaItemBag::kItemsFieldNumber;
#endif  // !_MSC_VER

CSDotaItemBag::CSDotaItemBag()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSDotaItemBag::InitAsDefaultInstance() {
}

CSDotaItemBag::CSDotaItemBag(const CSDotaItemBag& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSDotaItemBag::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSDotaItemBag::~CSDotaItemBag() {
  SharedDtor();
}

void CSDotaItemBag::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSDotaItemBag::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSDotaItemBag& CSDotaItemBag::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSDotaItemMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSDotaItemMsg_2eproto();
#endif
  return *default_instance_;
}

CSDotaItemBag* CSDotaItemBag::default_instance_ = NULL;

CSDotaItemBag* CSDotaItemBag::New() const {
  return new CSDotaItemBag;
}

void CSDotaItemBag::Clear() {
  items_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSDotaItemBag::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .vmsg.CSDotaItem Items = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Items:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_items()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_Items;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSDotaItemBag::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .vmsg.CSDotaItem Items = 1;
  for (int i = 0; i < this->items_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->items(i), output);
  }

}

int CSDotaItemBag::ByteSize() const {
  int total_size = 0;

  // repeated .vmsg.CSDotaItem Items = 1;
  total_size += 1 * this->items_size();
  for (int i = 0; i < this->items_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->items(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSDotaItemBag::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSDotaItemBag*>(&from));
}

void CSDotaItemBag::MergeFrom(const CSDotaItemBag& from) {
  GOOGLE_CHECK_NE(&from, this);
  items_.MergeFrom(from.items_);
}

void CSDotaItemBag::CopyFrom(const CSDotaItemBag& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSDotaItemBag::IsInitialized() const {

  for (int i = 0; i < items_size(); i++) {
    if (!this->items(i).IsInitialized()) return false;
  }
  return true;
}

void CSDotaItemBag::Swap(CSDotaItemBag* other) {
  if (other != this) {
    items_.Swap(&other->items_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSDotaItemBag::GetTypeName() const {
  return "vmsg.CSDotaItemBag";
}


// ===================================================================

#ifndef _MSC_VER
const int CSDotaInfo::kBagInfoFieldNumber;
const int CSDotaInfo::kPartInfoFieldNumber;
#endif  // !_MSC_VER

CSDotaInfo::CSDotaInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSDotaInfo::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  baginfo_ = const_cast< ::vmsg::CSDotaItemBag*>(
      ::vmsg::CSDotaItemBag::internal_default_instance());
#else
  baginfo_ = const_cast< ::vmsg::CSDotaItemBag*>(&::vmsg::CSDotaItemBag::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  partinfo_ = const_cast< ::vmsg::CSDotaPartInfo*>(
      ::vmsg::CSDotaPartInfo::internal_default_instance());
#else
  partinfo_ = const_cast< ::vmsg::CSDotaPartInfo*>(&::vmsg::CSDotaPartInfo::default_instance());
#endif
}

CSDotaInfo::CSDotaInfo(const CSDotaInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSDotaInfo::SharedCtor() {
  _cached_size_ = 0;
  baginfo_ = NULL;
  partinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSDotaInfo::~CSDotaInfo() {
  SharedDtor();
}

void CSDotaInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete baginfo_;
    delete partinfo_;
  }
}

void CSDotaInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSDotaInfo& CSDotaInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSDotaItemMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSDotaItemMsg_2eproto();
#endif
  return *default_instance_;
}

CSDotaInfo* CSDotaInfo::default_instance_ = NULL;

CSDotaInfo* CSDotaInfo::New() const {
  return new CSDotaInfo;
}

void CSDotaInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_baginfo()) {
      if (baginfo_ != NULL) baginfo_->::vmsg::CSDotaItemBag::Clear();
    }
    if (has_partinfo()) {
      if (partinfo_ != NULL) partinfo_->::vmsg::CSDotaPartInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSDotaInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vmsg.CSDotaItemBag BagInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_baginfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_PartInfo;
        break;
      }

      // required .vmsg.CSDotaPartInfo PartInfo = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_PartInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_partinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSDotaInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .vmsg.CSDotaItemBag BagInfo = 1;
  if (has_baginfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->baginfo(), output);
  }

  // required .vmsg.CSDotaPartInfo PartInfo = 2;
  if (has_partinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->partinfo(), output);
  }

}

int CSDotaInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .vmsg.CSDotaItemBag BagInfo = 1;
    if (has_baginfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->baginfo());
    }

    // required .vmsg.CSDotaPartInfo PartInfo = 2;
    if (has_partinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->partinfo());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSDotaInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSDotaInfo*>(&from));
}

void CSDotaInfo::MergeFrom(const CSDotaInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_baginfo()) {
      mutable_baginfo()->::vmsg::CSDotaItemBag::MergeFrom(from.baginfo());
    }
    if (from.has_partinfo()) {
      mutable_partinfo()->::vmsg::CSDotaPartInfo::MergeFrom(from.partinfo());
    }
  }
}

void CSDotaInfo::CopyFrom(const CSDotaInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSDotaInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_baginfo()) {
    if (!this->baginfo().IsInitialized()) return false;
  }
  if (has_partinfo()) {
    if (!this->partinfo().IsInitialized()) return false;
  }
  return true;
}

void CSDotaInfo::Swap(CSDotaInfo* other) {
  if (other != this) {
    std::swap(baginfo_, other->baginfo_);
    std::swap(partinfo_, other->partinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSDotaInfo::GetTypeName() const {
  return "vmsg.CSDotaInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int CSDotaItemComposeRqst::kDotaItemIDFieldNumber;
#endif  // !_MSC_VER

CSDotaItemComposeRqst::CSDotaItemComposeRqst()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSDotaItemComposeRqst::InitAsDefaultInstance() {
}

CSDotaItemComposeRqst::CSDotaItemComposeRqst(const CSDotaItemComposeRqst& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSDotaItemComposeRqst::SharedCtor() {
  _cached_size_ = 0;
  dotaitemid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSDotaItemComposeRqst::~CSDotaItemComposeRqst() {
  SharedDtor();
}

void CSDotaItemComposeRqst::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSDotaItemComposeRqst::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSDotaItemComposeRqst& CSDotaItemComposeRqst::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSDotaItemMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSDotaItemMsg_2eproto();
#endif
  return *default_instance_;
}

CSDotaItemComposeRqst* CSDotaItemComposeRqst::default_instance_ = NULL;

CSDotaItemComposeRqst* CSDotaItemComposeRqst::New() const {
  return new CSDotaItemComposeRqst;
}

void CSDotaItemComposeRqst::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    dotaitemid_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSDotaItemComposeRqst::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 DotaItemID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dotaitemid_)));
          set_has_dotaitemid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSDotaItemComposeRqst::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 DotaItemID = 1;
  if (has_dotaitemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->dotaitemid(), output);
  }

}

int CSDotaItemComposeRqst::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 DotaItemID = 1;
    if (has_dotaitemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dotaitemid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSDotaItemComposeRqst::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSDotaItemComposeRqst*>(&from));
}

void CSDotaItemComposeRqst::MergeFrom(const CSDotaItemComposeRqst& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dotaitemid()) {
      set_dotaitemid(from.dotaitemid());
    }
  }
}

void CSDotaItemComposeRqst::CopyFrom(const CSDotaItemComposeRqst& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSDotaItemComposeRqst::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSDotaItemComposeRqst::Swap(CSDotaItemComposeRqst* other) {
  if (other != this) {
    std::swap(dotaitemid_, other->dotaitemid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSDotaItemComposeRqst::GetTypeName() const {
  return "vmsg.CSDotaItemComposeRqst";
}


// ===================================================================

#ifndef _MSC_VER
const int CSDotaItemMosaicRqst::kPartFieldNumber;
const int CSDotaItemMosaicRqst::kDotaItemIDFieldNumber;
#endif  // !_MSC_VER

CSDotaItemMosaicRqst::CSDotaItemMosaicRqst()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSDotaItemMosaicRqst::InitAsDefaultInstance() {
}

CSDotaItemMosaicRqst::CSDotaItemMosaicRqst(const CSDotaItemMosaicRqst& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSDotaItemMosaicRqst::SharedCtor() {
  _cached_size_ = 0;
  part_ = 0u;
  dotaitemid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSDotaItemMosaicRqst::~CSDotaItemMosaicRqst() {
  SharedDtor();
}

void CSDotaItemMosaicRqst::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSDotaItemMosaicRqst::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSDotaItemMosaicRqst& CSDotaItemMosaicRqst::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSDotaItemMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSDotaItemMsg_2eproto();
#endif
  return *default_instance_;
}

CSDotaItemMosaicRqst* CSDotaItemMosaicRqst::default_instance_ = NULL;

CSDotaItemMosaicRqst* CSDotaItemMosaicRqst::New() const {
  return new CSDotaItemMosaicRqst;
}

void CSDotaItemMosaicRqst::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    part_ = 0u;
    dotaitemid_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSDotaItemMosaicRqst::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Part = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &part_)));
          set_has_part();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_DotaItemID;
        break;
      }

      // required uint32 DotaItemID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_DotaItemID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dotaitemid_)));
          set_has_dotaitemid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSDotaItemMosaicRqst::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 Part = 1;
  if (has_part()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->part(), output);
  }

  // required uint32 DotaItemID = 2;
  if (has_dotaitemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->dotaitemid(), output);
  }

}

int CSDotaItemMosaicRqst::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Part = 1;
    if (has_part()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->part());
    }

    // required uint32 DotaItemID = 2;
    if (has_dotaitemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dotaitemid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSDotaItemMosaicRqst::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSDotaItemMosaicRqst*>(&from));
}

void CSDotaItemMosaicRqst::MergeFrom(const CSDotaItemMosaicRqst& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_part()) {
      set_part(from.part());
    }
    if (from.has_dotaitemid()) {
      set_dotaitemid(from.dotaitemid());
    }
  }
}

void CSDotaItemMosaicRqst::CopyFrom(const CSDotaItemMosaicRqst& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSDotaItemMosaicRqst::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSDotaItemMosaicRqst::Swap(CSDotaItemMosaicRqst* other) {
  if (other != this) {
    std::swap(part_, other->part_);
    std::swap(dotaitemid_, other->dotaitemid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSDotaItemMosaicRqst::GetTypeName() const {
  return "vmsg.CSDotaItemMosaicRqst";
}


// ===================================================================

#ifndef _MSC_VER
const int CSDotaItemLvUpRqst::kPartFieldNumber;
#endif  // !_MSC_VER

CSDotaItemLvUpRqst::CSDotaItemLvUpRqst()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSDotaItemLvUpRqst::InitAsDefaultInstance() {
}

CSDotaItemLvUpRqst::CSDotaItemLvUpRqst(const CSDotaItemLvUpRqst& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSDotaItemLvUpRqst::SharedCtor() {
  _cached_size_ = 0;
  part_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSDotaItemLvUpRqst::~CSDotaItemLvUpRqst() {
  SharedDtor();
}

void CSDotaItemLvUpRqst::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSDotaItemLvUpRqst::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSDotaItemLvUpRqst& CSDotaItemLvUpRqst::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSDotaItemMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSDotaItemMsg_2eproto();
#endif
  return *default_instance_;
}

CSDotaItemLvUpRqst* CSDotaItemLvUpRqst::default_instance_ = NULL;

CSDotaItemLvUpRqst* CSDotaItemLvUpRqst::New() const {
  return new CSDotaItemLvUpRqst;
}

void CSDotaItemLvUpRqst::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    part_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSDotaItemLvUpRqst::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Part = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &part_)));
          set_has_part();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSDotaItemLvUpRqst::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 Part = 1;
  if (has_part()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->part(), output);
  }

}

int CSDotaItemLvUpRqst::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Part = 1;
    if (has_part()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->part());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSDotaItemLvUpRqst::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSDotaItemLvUpRqst*>(&from));
}

void CSDotaItemLvUpRqst::MergeFrom(const CSDotaItemLvUpRqst& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_part()) {
      set_part(from.part());
    }
  }
}

void CSDotaItemLvUpRqst::CopyFrom(const CSDotaItemLvUpRqst& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSDotaItemLvUpRqst::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CSDotaItemLvUpRqst::Swap(CSDotaItemLvUpRqst* other) {
  if (other != this) {
    std::swap(part_, other->part_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSDotaItemLvUpRqst::GetTypeName() const {
  return "vmsg.CSDotaItemLvUpRqst";
}


// ===================================================================

#ifndef _MSC_VER
const int CSDotaItemRequest::kDotaItemComposeRqstFieldNumber;
const int CSDotaItemRequest::kDotaItemMosaicRqstFieldNumber;
const int CSDotaItemRequest::kDotaItemLvUpRqstFieldNumber;
#endif  // !_MSC_VER

CSDotaItemRequest::CSDotaItemRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSDotaItemRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  dotaitemcompose_rqst_ = const_cast< ::vmsg::CSDotaItemComposeRqst*>(
      ::vmsg::CSDotaItemComposeRqst::internal_default_instance());
#else
  dotaitemcompose_rqst_ = const_cast< ::vmsg::CSDotaItemComposeRqst*>(&::vmsg::CSDotaItemComposeRqst::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  dotaitemmosaic_rqst_ = const_cast< ::vmsg::CSDotaItemMosaicRqst*>(
      ::vmsg::CSDotaItemMosaicRqst::internal_default_instance());
#else
  dotaitemmosaic_rqst_ = const_cast< ::vmsg::CSDotaItemMosaicRqst*>(&::vmsg::CSDotaItemMosaicRqst::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  dotaitemlvup_rqst_ = const_cast< ::vmsg::CSDotaItemLvUpRqst*>(
      ::vmsg::CSDotaItemLvUpRqst::internal_default_instance());
#else
  dotaitemlvup_rqst_ = const_cast< ::vmsg::CSDotaItemLvUpRqst*>(&::vmsg::CSDotaItemLvUpRqst::default_instance());
#endif
}

CSDotaItemRequest::CSDotaItemRequest(const CSDotaItemRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSDotaItemRequest::SharedCtor() {
  _cached_size_ = 0;
  dotaitemcompose_rqst_ = NULL;
  dotaitemmosaic_rqst_ = NULL;
  dotaitemlvup_rqst_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSDotaItemRequest::~CSDotaItemRequest() {
  SharedDtor();
}

void CSDotaItemRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete dotaitemcompose_rqst_;
    delete dotaitemmosaic_rqst_;
    delete dotaitemlvup_rqst_;
  }
}

void CSDotaItemRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSDotaItemRequest& CSDotaItemRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSDotaItemMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSDotaItemMsg_2eproto();
#endif
  return *default_instance_;
}

CSDotaItemRequest* CSDotaItemRequest::default_instance_ = NULL;

CSDotaItemRequest* CSDotaItemRequest::New() const {
  return new CSDotaItemRequest;
}

void CSDotaItemRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_dotaitemcompose_rqst()) {
      if (dotaitemcompose_rqst_ != NULL) dotaitemcompose_rqst_->::vmsg::CSDotaItemComposeRqst::Clear();
    }
    if (has_dotaitemmosaic_rqst()) {
      if (dotaitemmosaic_rqst_ != NULL) dotaitemmosaic_rqst_->::vmsg::CSDotaItemMosaicRqst::Clear();
    }
    if (has_dotaitemlvup_rqst()) {
      if (dotaitemlvup_rqst_ != NULL) dotaitemlvup_rqst_->::vmsg::CSDotaItemLvUpRqst::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSDotaItemRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .vmsg.CSDotaItemComposeRqst DotaItemCompose_Rqst = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dotaitemcompose_rqst()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_DotaItemMosaic_Rqst;
        break;
      }

      // optional .vmsg.CSDotaItemMosaicRqst DotaItemMosaic_Rqst = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_DotaItemMosaic_Rqst:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dotaitemmosaic_rqst()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_DotaItemLvUp_Rqst;
        break;
      }

      // optional .vmsg.CSDotaItemLvUpRqst DotaItemLvUp_Rqst = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_DotaItemLvUp_Rqst:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dotaitemlvup_rqst()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSDotaItemRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .vmsg.CSDotaItemComposeRqst DotaItemCompose_Rqst = 1;
  if (has_dotaitemcompose_rqst()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->dotaitemcompose_rqst(), output);
  }

  // optional .vmsg.CSDotaItemMosaicRqst DotaItemMosaic_Rqst = 2;
  if (has_dotaitemmosaic_rqst()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->dotaitemmosaic_rqst(), output);
  }

  // optional .vmsg.CSDotaItemLvUpRqst DotaItemLvUp_Rqst = 3;
  if (has_dotaitemlvup_rqst()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->dotaitemlvup_rqst(), output);
  }

}

int CSDotaItemRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .vmsg.CSDotaItemComposeRqst DotaItemCompose_Rqst = 1;
    if (has_dotaitemcompose_rqst()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dotaitemcompose_rqst());
    }

    // optional .vmsg.CSDotaItemMosaicRqst DotaItemMosaic_Rqst = 2;
    if (has_dotaitemmosaic_rqst()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dotaitemmosaic_rqst());
    }

    // optional .vmsg.CSDotaItemLvUpRqst DotaItemLvUp_Rqst = 3;
    if (has_dotaitemlvup_rqst()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dotaitemlvup_rqst());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSDotaItemRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSDotaItemRequest*>(&from));
}

void CSDotaItemRequest::MergeFrom(const CSDotaItemRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dotaitemcompose_rqst()) {
      mutable_dotaitemcompose_rqst()->::vmsg::CSDotaItemComposeRqst::MergeFrom(from.dotaitemcompose_rqst());
    }
    if (from.has_dotaitemmosaic_rqst()) {
      mutable_dotaitemmosaic_rqst()->::vmsg::CSDotaItemMosaicRqst::MergeFrom(from.dotaitemmosaic_rqst());
    }
    if (from.has_dotaitemlvup_rqst()) {
      mutable_dotaitemlvup_rqst()->::vmsg::CSDotaItemLvUpRqst::MergeFrom(from.dotaitemlvup_rqst());
    }
  }
}

void CSDotaItemRequest::CopyFrom(const CSDotaItemRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSDotaItemRequest::IsInitialized() const {

  if (has_dotaitemcompose_rqst()) {
    if (!this->dotaitemcompose_rqst().IsInitialized()) return false;
  }
  if (has_dotaitemmosaic_rqst()) {
    if (!this->dotaitemmosaic_rqst().IsInitialized()) return false;
  }
  if (has_dotaitemlvup_rqst()) {
    if (!this->dotaitemlvup_rqst().IsInitialized()) return false;
  }
  return true;
}

void CSDotaItemRequest::Swap(CSDotaItemRequest* other) {
  if (other != this) {
    std::swap(dotaitemcompose_rqst_, other->dotaitemcompose_rqst_);
    std::swap(dotaitemmosaic_rqst_, other->dotaitemmosaic_rqst_);
    std::swap(dotaitemlvup_rqst_, other->dotaitemlvup_rqst_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSDotaItemRequest::GetTypeName() const {
  return "vmsg.CSDotaItemRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int CSDotaItemRespond::kDotaItemBagQueryRspFieldNumber;
const int CSDotaItemRespond::kDotaItemComposeRspFieldNumber;
const int CSDotaItemRespond::kDotaItemMosaicRspFieldNumber;
const int CSDotaItemRespond::kDotaItemLvUpRspFieldNumber;
#endif  // !_MSC_VER

CSDotaItemRespond::CSDotaItemRespond()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSDotaItemRespond::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  dotaitembagquery_rsp_ = const_cast< ::vmsg::CSDotaInfo*>(
      ::vmsg::CSDotaInfo::internal_default_instance());
#else
  dotaitembagquery_rsp_ = const_cast< ::vmsg::CSDotaInfo*>(&::vmsg::CSDotaInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  dotaitemcompose_rsp_ = const_cast< ::vmsg::CSDotaItemBag*>(
      ::vmsg::CSDotaItemBag::internal_default_instance());
#else
  dotaitemcompose_rsp_ = const_cast< ::vmsg::CSDotaItemBag*>(&::vmsg::CSDotaItemBag::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  dotaitemmosaic_rsp_ = const_cast< ::vmsg::CSDotaInfo*>(
      ::vmsg::CSDotaInfo::internal_default_instance());
#else
  dotaitemmosaic_rsp_ = const_cast< ::vmsg::CSDotaInfo*>(&::vmsg::CSDotaInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  dotaitemlvup_rsp_ = const_cast< ::vmsg::CSDotaPartInfo*>(
      ::vmsg::CSDotaPartInfo::internal_default_instance());
#else
  dotaitemlvup_rsp_ = const_cast< ::vmsg::CSDotaPartInfo*>(&::vmsg::CSDotaPartInfo::default_instance());
#endif
}

CSDotaItemRespond::CSDotaItemRespond(const CSDotaItemRespond& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSDotaItemRespond::SharedCtor() {
  _cached_size_ = 0;
  dotaitembagquery_rsp_ = NULL;
  dotaitemcompose_rsp_ = NULL;
  dotaitemmosaic_rsp_ = NULL;
  dotaitemlvup_rsp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSDotaItemRespond::~CSDotaItemRespond() {
  SharedDtor();
}

void CSDotaItemRespond::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete dotaitembagquery_rsp_;
    delete dotaitemcompose_rsp_;
    delete dotaitemmosaic_rsp_;
    delete dotaitemlvup_rsp_;
  }
}

void CSDotaItemRespond::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSDotaItemRespond& CSDotaItemRespond::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSDotaItemMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSDotaItemMsg_2eproto();
#endif
  return *default_instance_;
}

CSDotaItemRespond* CSDotaItemRespond::default_instance_ = NULL;

CSDotaItemRespond* CSDotaItemRespond::New() const {
  return new CSDotaItemRespond;
}

void CSDotaItemRespond::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_dotaitembagquery_rsp()) {
      if (dotaitembagquery_rsp_ != NULL) dotaitembagquery_rsp_->::vmsg::CSDotaInfo::Clear();
    }
    if (has_dotaitemcompose_rsp()) {
      if (dotaitemcompose_rsp_ != NULL) dotaitemcompose_rsp_->::vmsg::CSDotaItemBag::Clear();
    }
    if (has_dotaitemmosaic_rsp()) {
      if (dotaitemmosaic_rsp_ != NULL) dotaitemmosaic_rsp_->::vmsg::CSDotaInfo::Clear();
    }
    if (has_dotaitemlvup_rsp()) {
      if (dotaitemlvup_rsp_ != NULL) dotaitemlvup_rsp_->::vmsg::CSDotaPartInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSDotaItemRespond::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .vmsg.CSDotaInfo DotaItemBagQuery_Rsp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dotaitembagquery_rsp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_DotaItemCompose_Rsp;
        break;
      }

      // optional .vmsg.CSDotaItemBag DotaItemCompose_Rsp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_DotaItemCompose_Rsp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dotaitemcompose_rsp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_DotaItemMosaic_Rsp;
        break;
      }

      // optional .vmsg.CSDotaInfo DotaItemMosaic_Rsp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_DotaItemMosaic_Rsp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dotaitemmosaic_rsp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_DotaItemLvUp_Rsp;
        break;
      }

      // optional .vmsg.CSDotaPartInfo DotaItemLvUp_Rsp = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_DotaItemLvUp_Rsp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dotaitemlvup_rsp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSDotaItemRespond::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .vmsg.CSDotaInfo DotaItemBagQuery_Rsp = 1;
  if (has_dotaitembagquery_rsp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->dotaitembagquery_rsp(), output);
  }

  // optional .vmsg.CSDotaItemBag DotaItemCompose_Rsp = 2;
  if (has_dotaitemcompose_rsp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->dotaitemcompose_rsp(), output);
  }

  // optional .vmsg.CSDotaInfo DotaItemMosaic_Rsp = 3;
  if (has_dotaitemmosaic_rsp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->dotaitemmosaic_rsp(), output);
  }

  // optional .vmsg.CSDotaPartInfo DotaItemLvUp_Rsp = 4;
  if (has_dotaitemlvup_rsp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->dotaitemlvup_rsp(), output);
  }

}

int CSDotaItemRespond::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .vmsg.CSDotaInfo DotaItemBagQuery_Rsp = 1;
    if (has_dotaitembagquery_rsp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dotaitembagquery_rsp());
    }

    // optional .vmsg.CSDotaItemBag DotaItemCompose_Rsp = 2;
    if (has_dotaitemcompose_rsp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dotaitemcompose_rsp());
    }

    // optional .vmsg.CSDotaInfo DotaItemMosaic_Rsp = 3;
    if (has_dotaitemmosaic_rsp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dotaitemmosaic_rsp());
    }

    // optional .vmsg.CSDotaPartInfo DotaItemLvUp_Rsp = 4;
    if (has_dotaitemlvup_rsp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dotaitemlvup_rsp());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSDotaItemRespond::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSDotaItemRespond*>(&from));
}

void CSDotaItemRespond::MergeFrom(const CSDotaItemRespond& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dotaitembagquery_rsp()) {
      mutable_dotaitembagquery_rsp()->::vmsg::CSDotaInfo::MergeFrom(from.dotaitembagquery_rsp());
    }
    if (from.has_dotaitemcompose_rsp()) {
      mutable_dotaitemcompose_rsp()->::vmsg::CSDotaItemBag::MergeFrom(from.dotaitemcompose_rsp());
    }
    if (from.has_dotaitemmosaic_rsp()) {
      mutable_dotaitemmosaic_rsp()->::vmsg::CSDotaInfo::MergeFrom(from.dotaitemmosaic_rsp());
    }
    if (from.has_dotaitemlvup_rsp()) {
      mutable_dotaitemlvup_rsp()->::vmsg::CSDotaPartInfo::MergeFrom(from.dotaitemlvup_rsp());
    }
  }
}

void CSDotaItemRespond::CopyFrom(const CSDotaItemRespond& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSDotaItemRespond::IsInitialized() const {

  if (has_dotaitembagquery_rsp()) {
    if (!this->dotaitembagquery_rsp().IsInitialized()) return false;
  }
  if (has_dotaitemcompose_rsp()) {
    if (!this->dotaitemcompose_rsp().IsInitialized()) return false;
  }
  if (has_dotaitemmosaic_rsp()) {
    if (!this->dotaitemmosaic_rsp().IsInitialized()) return false;
  }
  if (has_dotaitemlvup_rsp()) {
    if (!this->dotaitemlvup_rsp().IsInitialized()) return false;
  }
  return true;
}

void CSDotaItemRespond::Swap(CSDotaItemRespond* other) {
  if (other != this) {
    std::swap(dotaitembagquery_rsp_, other->dotaitembagquery_rsp_);
    std::swap(dotaitemcompose_rsp_, other->dotaitemcompose_rsp_);
    std::swap(dotaitemmosaic_rsp_, other->dotaitemmosaic_rsp_);
    std::swap(dotaitemlvup_rsp_, other->dotaitemlvup_rsp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSDotaItemRespond::GetTypeName() const {
  return "vmsg.CSDotaItemRespond";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)
