// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSWeaponMsg.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "CSWeaponMsg.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace vmsg {

void protobuf_ShutdownFile_CSWeaponMsg_2eproto() {
  delete CSWeaponBag::default_instance_;
  delete CSWeaponChangeRqst::default_instance_;
  delete CSWeaponLvUpConsume::default_instance_;
  delete CSWeaponLvUpRqst::default_instance_;
  delete CSWeaponStarStepRqst::default_instance_;
  delete CSWeaponRefitRqst::default_instance_;
  delete CSInbattleWeaponElmtBrief::default_instance_;
  delete CSWeaponInBattleRqst::default_instance_;
  delete CSWeaponInBattleRsp::default_instance_;
  delete CSWeaponLvUpRsp::default_instance_;
  delete CSWeaponRequest::default_instance_;
  delete CSWeaponRespond::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_CSWeaponMsg_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_CSWeaponMsg_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::vmsg::protobuf_AddDesc_MsgBase_2eproto();
  ::vmsg::protobuf_AddDesc_CSBagMsg_2eproto();
  ::vmsg::protobuf_AddDesc_CSEquipItemMsg_2eproto();
  CSWeaponBag::default_instance_ = new CSWeaponBag();
  CSWeaponChangeRqst::default_instance_ = new CSWeaponChangeRqst();
  CSWeaponLvUpConsume::default_instance_ = new CSWeaponLvUpConsume();
  CSWeaponLvUpRqst::default_instance_ = new CSWeaponLvUpRqst();
  CSWeaponStarStepRqst::default_instance_ = new CSWeaponStarStepRqst();
  CSWeaponRefitRqst::default_instance_ = new CSWeaponRefitRqst();
  CSInbattleWeaponElmtBrief::default_instance_ = new CSInbattleWeaponElmtBrief();
  CSWeaponInBattleRqst::default_instance_ = new CSWeaponInBattleRqst();
  CSWeaponInBattleRsp::default_instance_ = new CSWeaponInBattleRsp();
  CSWeaponLvUpRsp::default_instance_ = new CSWeaponLvUpRsp();
  CSWeaponRequest::default_instance_ = new CSWeaponRequest();
  CSWeaponRespond::default_instance_ = new CSWeaponRespond();
  CSWeaponBag::default_instance_->InitAsDefaultInstance();
  CSWeaponChangeRqst::default_instance_->InitAsDefaultInstance();
  CSWeaponLvUpConsume::default_instance_->InitAsDefaultInstance();
  CSWeaponLvUpRqst::default_instance_->InitAsDefaultInstance();
  CSWeaponStarStepRqst::default_instance_->InitAsDefaultInstance();
  CSWeaponRefitRqst::default_instance_->InitAsDefaultInstance();
  CSInbattleWeaponElmtBrief::default_instance_->InitAsDefaultInstance();
  CSWeaponInBattleRqst::default_instance_->InitAsDefaultInstance();
  CSWeaponInBattleRsp::default_instance_->InitAsDefaultInstance();
  CSWeaponLvUpRsp::default_instance_->InitAsDefaultInstance();
  CSWeaponRequest::default_instance_->InitAsDefaultInstance();
  CSWeaponRespond::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_CSWeaponMsg_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_CSWeaponMsg_2eproto_once_);
void protobuf_AddDesc_CSWeaponMsg_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_CSWeaponMsg_2eproto_once_,
                 &protobuf_AddDesc_CSWeaponMsg_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_CSWeaponMsg_2eproto {
  StaticDescriptorInitializer_CSWeaponMsg_2eproto() {
    protobuf_AddDesc_CSWeaponMsg_2eproto();
  }
} static_descriptor_initializer_CSWeaponMsg_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int CSWeaponBag::kWeaponsFieldNumber;
const int CSWeaponBag::kPlayerWeaponFieldNumber;
const int CSWeaponBag::kCapacityFieldNumber;
#endif  // !_MSC_VER

CSWeaponBag::CSWeaponBag()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSWeaponBag::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  playerweapon_ = const_cast< ::vmsg::CSWeapon*>(
      ::vmsg::CSWeapon::internal_default_instance());
#else
  playerweapon_ = const_cast< ::vmsg::CSWeapon*>(&::vmsg::CSWeapon::default_instance());
#endif
}

CSWeaponBag::CSWeaponBag(const CSWeaponBag& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSWeaponBag::SharedCtor() {
  _cached_size_ = 0;
  playerweapon_ = NULL;
  capacity_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSWeaponBag::~CSWeaponBag() {
  SharedDtor();
}

void CSWeaponBag::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete playerweapon_;
  }
}

void CSWeaponBag::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSWeaponBag& CSWeaponBag::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSWeaponMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSWeaponMsg_2eproto();
#endif
  return *default_instance_;
}

CSWeaponBag* CSWeaponBag::default_instance_ = NULL;

CSWeaponBag* CSWeaponBag::New() const {
  return new CSWeaponBag;
}

void CSWeaponBag::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_playerweapon()) {
      if (playerweapon_ != NULL) playerweapon_->::vmsg::CSWeapon::Clear();
    }
    capacity_ = 0u;
  }
  weapons_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSWeaponBag::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .vmsg.CSWeapon Weapons = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Weapons:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_weapons()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_Weapons;
        if (input->ExpectTag(18)) goto parse_PlayerWeapon;
        break;
      }

      // required .vmsg.CSWeapon PlayerWeapon = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_PlayerWeapon:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_playerweapon()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_Capacity;
        break;
      }

      // required uint32 Capacity = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Capacity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &capacity_)));
          set_has_capacity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSWeaponBag::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .vmsg.CSWeapon Weapons = 1;
  for (int i = 0; i < this->weapons_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->weapons(i), output);
  }

  // required .vmsg.CSWeapon PlayerWeapon = 2;
  if (has_playerweapon()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->playerweapon(), output);
  }

  // required uint32 Capacity = 3;
  if (has_capacity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->capacity(), output);
  }

}

int CSWeaponBag::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required .vmsg.CSWeapon PlayerWeapon = 2;
    if (has_playerweapon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->playerweapon());
    }

    // required uint32 Capacity = 3;
    if (has_capacity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->capacity());
    }

  }
  // repeated .vmsg.CSWeapon Weapons = 1;
  total_size += 1 * this->weapons_size();
  for (int i = 0; i < this->weapons_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->weapons(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSWeaponBag::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSWeaponBag*>(&from));
}

void CSWeaponBag::MergeFrom(const CSWeaponBag& from) {
  GOOGLE_CHECK_NE(&from, this);
  weapons_.MergeFrom(from.weapons_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_playerweapon()) {
      mutable_playerweapon()->::vmsg::CSWeapon::MergeFrom(from.playerweapon());
    }
    if (from.has_capacity()) {
      set_capacity(from.capacity());
    }
  }
}

void CSWeaponBag::CopyFrom(const CSWeaponBag& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSWeaponBag::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  for (int i = 0; i < weapons_size(); i++) {
    if (!this->weapons(i).IsInitialized()) return false;
  }
  if (has_playerweapon()) {
    if (!this->playerweapon().IsInitialized()) return false;
  }
  return true;
}

void CSWeaponBag::Swap(CSWeaponBag* other) {
  if (other != this) {
    weapons_.Swap(&other->weapons_);
    std::swap(playerweapon_, other->playerweapon_);
    std::swap(capacity_, other->capacity_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSWeaponBag::GetTypeName() const {
  return "vmsg.CSWeaponBag";
}


// ===================================================================

#ifndef _MSC_VER
const int CSWeaponChangeRqst::kBagIdxFieldNumber;
const int CSWeaponChangeRqst::kWeaponGUIDFieldNumber;
#endif  // !_MSC_VER

CSWeaponChangeRqst::CSWeaponChangeRqst()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSWeaponChangeRqst::InitAsDefaultInstance() {
}

CSWeaponChangeRqst::CSWeaponChangeRqst(const CSWeaponChangeRqst& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSWeaponChangeRqst::SharedCtor() {
  _cached_size_ = 0;
  bagidx_ = 0;
  weaponguid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSWeaponChangeRqst::~CSWeaponChangeRqst() {
  SharedDtor();
}

void CSWeaponChangeRqst::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSWeaponChangeRqst::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSWeaponChangeRqst& CSWeaponChangeRqst::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSWeaponMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSWeaponMsg_2eproto();
#endif
  return *default_instance_;
}

CSWeaponChangeRqst* CSWeaponChangeRqst::default_instance_ = NULL;

CSWeaponChangeRqst* CSWeaponChangeRqst::New() const {
  return new CSWeaponChangeRqst;
}

void CSWeaponChangeRqst::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    bagidx_ = 0;
    weaponguid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSWeaponChangeRqst::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 BagIdx = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bagidx_)));
          set_has_bagidx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_WeaponGUID;
        break;
      }

      // required uint64 WeaponGUID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_WeaponGUID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &weaponguid_)));
          set_has_weaponguid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSWeaponChangeRqst::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 BagIdx = 1;
  if (has_bagidx()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->bagidx(), output);
  }

  // required uint64 WeaponGUID = 2;
  if (has_weaponguid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->weaponguid(), output);
  }

}

int CSWeaponChangeRqst::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 BagIdx = 1;
    if (has_bagidx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bagidx());
    }

    // required uint64 WeaponGUID = 2;
    if (has_weaponguid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->weaponguid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSWeaponChangeRqst::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSWeaponChangeRqst*>(&from));
}

void CSWeaponChangeRqst::MergeFrom(const CSWeaponChangeRqst& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_bagidx()) {
      set_bagidx(from.bagidx());
    }
    if (from.has_weaponguid()) {
      set_weaponguid(from.weaponguid());
    }
  }
}

void CSWeaponChangeRqst::CopyFrom(const CSWeaponChangeRqst& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSWeaponChangeRqst::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSWeaponChangeRqst::Swap(CSWeaponChangeRqst* other) {
  if (other != this) {
    std::swap(bagidx_, other->bagidx_);
    std::swap(weaponguid_, other->weaponguid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSWeaponChangeRqst::GetTypeName() const {
  return "vmsg.CSWeaponChangeRqst";
}


// ===================================================================

#ifndef _MSC_VER
const int CSWeaponLvUpConsume::kTypeFieldNumber;
const int CSWeaponLvUpConsume::kIDFieldNumber;
const int CSWeaponLvUpConsume::kCntFieldNumber;
#endif  // !_MSC_VER

CSWeaponLvUpConsume::CSWeaponLvUpConsume()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSWeaponLvUpConsume::InitAsDefaultInstance() {
}

CSWeaponLvUpConsume::CSWeaponLvUpConsume(const CSWeaponLvUpConsume& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSWeaponLvUpConsume::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0u;
  id_ = GOOGLE_ULONGLONG(0);
  cnt_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSWeaponLvUpConsume::~CSWeaponLvUpConsume() {
  SharedDtor();
}

void CSWeaponLvUpConsume::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSWeaponLvUpConsume::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSWeaponLvUpConsume& CSWeaponLvUpConsume::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSWeaponMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSWeaponMsg_2eproto();
#endif
  return *default_instance_;
}

CSWeaponLvUpConsume* CSWeaponLvUpConsume::default_instance_ = NULL;

CSWeaponLvUpConsume* CSWeaponLvUpConsume::New() const {
  return new CSWeaponLvUpConsume;
}

void CSWeaponLvUpConsume::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0u;
    id_ = GOOGLE_ULONGLONG(0);
    cnt_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSWeaponLvUpConsume::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 Type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_ID;
        break;
      }

      // required uint64 ID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_Cnt;
        break;
      }

      // required uint64 Cnt = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &cnt_)));
          set_has_cnt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSWeaponLvUpConsume::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 Type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
  }

  // required uint64 ID = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->id(), output);
  }

  // required uint64 Cnt = 3;
  if (has_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->cnt(), output);
  }

}

int CSWeaponLvUpConsume::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 Type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // required uint64 ID = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->id());
    }

    // required uint64 Cnt = 3;
    if (has_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->cnt());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSWeaponLvUpConsume::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSWeaponLvUpConsume*>(&from));
}

void CSWeaponLvUpConsume::MergeFrom(const CSWeaponLvUpConsume& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_cnt()) {
      set_cnt(from.cnt());
    }
  }
}

void CSWeaponLvUpConsume::CopyFrom(const CSWeaponLvUpConsume& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSWeaponLvUpConsume::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSWeaponLvUpConsume::Swap(CSWeaponLvUpConsume* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(id_, other->id_);
    std::swap(cnt_, other->cnt_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSWeaponLvUpConsume::GetTypeName() const {
  return "vmsg.CSWeaponLvUpConsume";
}


// ===================================================================

#ifndef _MSC_VER
const int CSWeaponLvUpRqst::kBagIdxFieldNumber;
const int CSWeaponLvUpRqst::kWeaponGUIDFieldNumber;
const int CSWeaponLvUpRqst::kConsumesFieldNumber;
#endif  // !_MSC_VER

CSWeaponLvUpRqst::CSWeaponLvUpRqst()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSWeaponLvUpRqst::InitAsDefaultInstance() {
}

CSWeaponLvUpRqst::CSWeaponLvUpRqst(const CSWeaponLvUpRqst& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSWeaponLvUpRqst::SharedCtor() {
  _cached_size_ = 0;
  bagidx_ = 0;
  weaponguid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSWeaponLvUpRqst::~CSWeaponLvUpRqst() {
  SharedDtor();
}

void CSWeaponLvUpRqst::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSWeaponLvUpRqst::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSWeaponLvUpRqst& CSWeaponLvUpRqst::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSWeaponMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSWeaponMsg_2eproto();
#endif
  return *default_instance_;
}

CSWeaponLvUpRqst* CSWeaponLvUpRqst::default_instance_ = NULL;

CSWeaponLvUpRqst* CSWeaponLvUpRqst::New() const {
  return new CSWeaponLvUpRqst;
}

void CSWeaponLvUpRqst::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    bagidx_ = 0;
    weaponguid_ = GOOGLE_ULONGLONG(0);
  }
  consumes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSWeaponLvUpRqst::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 BagIdx = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bagidx_)));
          set_has_bagidx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_WeaponGUID;
        break;
      }

      // required uint64 WeaponGUID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_WeaponGUID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &weaponguid_)));
          set_has_weaponguid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_Consumes;
        break;
      }

      // repeated .vmsg.CSWeaponLvUpConsume Consumes = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Consumes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_consumes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_Consumes;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSWeaponLvUpRqst::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 BagIdx = 1;
  if (has_bagidx()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->bagidx(), output);
  }

  // required uint64 WeaponGUID = 2;
  if (has_weaponguid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->weaponguid(), output);
  }

  // repeated .vmsg.CSWeaponLvUpConsume Consumes = 3;
  for (int i = 0; i < this->consumes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->consumes(i), output);
  }

}

int CSWeaponLvUpRqst::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 BagIdx = 1;
    if (has_bagidx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bagidx());
    }

    // required uint64 WeaponGUID = 2;
    if (has_weaponguid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->weaponguid());
    }

  }
  // repeated .vmsg.CSWeaponLvUpConsume Consumes = 3;
  total_size += 1 * this->consumes_size();
  for (int i = 0; i < this->consumes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->consumes(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSWeaponLvUpRqst::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSWeaponLvUpRqst*>(&from));
}

void CSWeaponLvUpRqst::MergeFrom(const CSWeaponLvUpRqst& from) {
  GOOGLE_CHECK_NE(&from, this);
  consumes_.MergeFrom(from.consumes_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_bagidx()) {
      set_bagidx(from.bagidx());
    }
    if (from.has_weaponguid()) {
      set_weaponguid(from.weaponguid());
    }
  }
}

void CSWeaponLvUpRqst::CopyFrom(const CSWeaponLvUpRqst& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSWeaponLvUpRqst::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  for (int i = 0; i < consumes_size(); i++) {
    if (!this->consumes(i).IsInitialized()) return false;
  }
  return true;
}

void CSWeaponLvUpRqst::Swap(CSWeaponLvUpRqst* other) {
  if (other != this) {
    std::swap(bagidx_, other->bagidx_);
    std::swap(weaponguid_, other->weaponguid_);
    consumes_.Swap(&other->consumes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSWeaponLvUpRqst::GetTypeName() const {
  return "vmsg.CSWeaponLvUpRqst";
}


// ===================================================================

#ifndef _MSC_VER
const int CSWeaponStarStepRqst::kBagIdxFieldNumber;
const int CSWeaponStarStepRqst::kWeaponGUIDFieldNumber;
const int CSWeaponStarStepRqst::kNeedWeaponGUIDsFieldNumber;
#endif  // !_MSC_VER

CSWeaponStarStepRqst::CSWeaponStarStepRqst()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSWeaponStarStepRqst::InitAsDefaultInstance() {
}

CSWeaponStarStepRqst::CSWeaponStarStepRqst(const CSWeaponStarStepRqst& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSWeaponStarStepRqst::SharedCtor() {
  _cached_size_ = 0;
  bagidx_ = 0;
  weaponguid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSWeaponStarStepRqst::~CSWeaponStarStepRqst() {
  SharedDtor();
}

void CSWeaponStarStepRqst::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSWeaponStarStepRqst::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSWeaponStarStepRqst& CSWeaponStarStepRqst::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSWeaponMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSWeaponMsg_2eproto();
#endif
  return *default_instance_;
}

CSWeaponStarStepRqst* CSWeaponStarStepRqst::default_instance_ = NULL;

CSWeaponStarStepRqst* CSWeaponStarStepRqst::New() const {
  return new CSWeaponStarStepRqst;
}

void CSWeaponStarStepRqst::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    bagidx_ = 0;
    weaponguid_ = GOOGLE_ULONGLONG(0);
  }
  needweaponguids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSWeaponStarStepRqst::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 BagIdx = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bagidx_)));
          set_has_bagidx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_WeaponGUID;
        break;
      }

      // required uint64 WeaponGUID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_WeaponGUID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &weaponguid_)));
          set_has_weaponguid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_NeedWeaponGUIDs;
        break;
      }

      // repeated uint64 NeedWeaponGUIDs = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_NeedWeaponGUIDs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 24, input, this->mutable_needweaponguids())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_needweaponguids())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_NeedWeaponGUIDs;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSWeaponStarStepRqst::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 BagIdx = 1;
  if (has_bagidx()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->bagidx(), output);
  }

  // required uint64 WeaponGUID = 2;
  if (has_weaponguid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->weaponguid(), output);
  }

  // repeated uint64 NeedWeaponGUIDs = 3;
  for (int i = 0; i < this->needweaponguids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      3, this->needweaponguids(i), output);
  }

}

int CSWeaponStarStepRqst::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 BagIdx = 1;
    if (has_bagidx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bagidx());
    }

    // required uint64 WeaponGUID = 2;
    if (has_weaponguid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->weaponguid());
    }

  }
  // repeated uint64 NeedWeaponGUIDs = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->needweaponguids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->needweaponguids(i));
    }
    total_size += 1 * this->needweaponguids_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSWeaponStarStepRqst::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSWeaponStarStepRqst*>(&from));
}

void CSWeaponStarStepRqst::MergeFrom(const CSWeaponStarStepRqst& from) {
  GOOGLE_CHECK_NE(&from, this);
  needweaponguids_.MergeFrom(from.needweaponguids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_bagidx()) {
      set_bagidx(from.bagidx());
    }
    if (from.has_weaponguid()) {
      set_weaponguid(from.weaponguid());
    }
  }
}

void CSWeaponStarStepRqst::CopyFrom(const CSWeaponStarStepRqst& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSWeaponStarStepRqst::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSWeaponStarStepRqst::Swap(CSWeaponStarStepRqst* other) {
  if (other != this) {
    std::swap(bagidx_, other->bagidx_);
    std::swap(weaponguid_, other->weaponguid_);
    needweaponguids_.Swap(&other->needweaponguids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSWeaponStarStepRqst::GetTypeName() const {
  return "vmsg.CSWeaponStarStepRqst";
}


// ===================================================================

#ifndef _MSC_VER
const int CSWeaponRefitRqst::kBagIdxFieldNumber;
const int CSWeaponRefitRqst::kWeaponGUIDFieldNumber;
#endif  // !_MSC_VER

CSWeaponRefitRqst::CSWeaponRefitRqst()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSWeaponRefitRqst::InitAsDefaultInstance() {
}

CSWeaponRefitRqst::CSWeaponRefitRqst(const CSWeaponRefitRqst& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSWeaponRefitRqst::SharedCtor() {
  _cached_size_ = 0;
  bagidx_ = 0;
  weaponguid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSWeaponRefitRqst::~CSWeaponRefitRqst() {
  SharedDtor();
}

void CSWeaponRefitRqst::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSWeaponRefitRqst::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSWeaponRefitRqst& CSWeaponRefitRqst::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSWeaponMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSWeaponMsg_2eproto();
#endif
  return *default_instance_;
}

CSWeaponRefitRqst* CSWeaponRefitRqst::default_instance_ = NULL;

CSWeaponRefitRqst* CSWeaponRefitRqst::New() const {
  return new CSWeaponRefitRqst;
}

void CSWeaponRefitRqst::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    bagidx_ = 0;
    weaponguid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSWeaponRefitRqst::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 BagIdx = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bagidx_)));
          set_has_bagidx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_WeaponGUID;
        break;
      }

      // required uint64 WeaponGUID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_WeaponGUID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &weaponguid_)));
          set_has_weaponguid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSWeaponRefitRqst::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 BagIdx = 1;
  if (has_bagidx()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->bagidx(), output);
  }

  // required uint64 WeaponGUID = 2;
  if (has_weaponguid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->weaponguid(), output);
  }

}

int CSWeaponRefitRqst::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 BagIdx = 1;
    if (has_bagidx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bagidx());
    }

    // required uint64 WeaponGUID = 2;
    if (has_weaponguid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->weaponguid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSWeaponRefitRqst::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSWeaponRefitRqst*>(&from));
}

void CSWeaponRefitRqst::MergeFrom(const CSWeaponRefitRqst& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_bagidx()) {
      set_bagidx(from.bagidx());
    }
    if (from.has_weaponguid()) {
      set_weaponguid(from.weaponguid());
    }
  }
}

void CSWeaponRefitRqst::CopyFrom(const CSWeaponRefitRqst& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSWeaponRefitRqst::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CSWeaponRefitRqst::Swap(CSWeaponRefitRqst* other) {
  if (other != this) {
    std::swap(bagidx_, other->bagidx_);
    std::swap(weaponguid_, other->weaponguid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSWeaponRefitRqst::GetTypeName() const {
  return "vmsg.CSWeaponRefitRqst";
}


// ===================================================================

#ifndef _MSC_VER
const int CSInbattleWeaponElmtBrief::kWeaponGUIDFieldNumber;
const int CSInbattleWeaponElmtBrief::kBagIdxFieldNumber;
const int CSInbattleWeaponElmtBrief::kArrayIdxFieldNumber;
#endif  // !_MSC_VER

CSInbattleWeaponElmtBrief::CSInbattleWeaponElmtBrief()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSInbattleWeaponElmtBrief::InitAsDefaultInstance() {
}

CSInbattleWeaponElmtBrief::CSInbattleWeaponElmtBrief(const CSInbattleWeaponElmtBrief& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSInbattleWeaponElmtBrief::SharedCtor() {
  _cached_size_ = 0;
  weaponguid_ = GOOGLE_ULONGLONG(0);
  bagidx_ = 0;
  arrayidx_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSInbattleWeaponElmtBrief::~CSInbattleWeaponElmtBrief() {
  SharedDtor();
}

void CSInbattleWeaponElmtBrief::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CSInbattleWeaponElmtBrief::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSInbattleWeaponElmtBrief& CSInbattleWeaponElmtBrief::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSWeaponMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSWeaponMsg_2eproto();
#endif
  return *default_instance_;
}

CSInbattleWeaponElmtBrief* CSInbattleWeaponElmtBrief::default_instance_ = NULL;

CSInbattleWeaponElmtBrief* CSInbattleWeaponElmtBrief::New() const {
  return new CSInbattleWeaponElmtBrief;
}

void CSInbattleWeaponElmtBrief::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    weaponguid_ = GOOGLE_ULONGLONG(0);
    bagidx_ = 0;
    arrayidx_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSInbattleWeaponElmtBrief::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 WeaponGUID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &weaponguid_)));
          set_has_weaponguid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_BagIdx;
        break;
      }

      // required int32 BagIdx = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_BagIdx:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bagidx_)));
          set_has_bagidx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_ArrayIdx;
        break;
      }

      // required int32 ArrayIdx = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ArrayIdx:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &arrayidx_)));
          set_has_arrayidx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSInbattleWeaponElmtBrief::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 WeaponGUID = 1;
  if (has_weaponguid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->weaponguid(), output);
  }

  // required int32 BagIdx = 2;
  if (has_bagidx()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->bagidx(), output);
  }

  // required int32 ArrayIdx = 3;
  if (has_arrayidx()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->arrayidx(), output);
  }

}

int CSInbattleWeaponElmtBrief::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 WeaponGUID = 1;
    if (has_weaponguid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->weaponguid());
    }

    // required int32 BagIdx = 2;
    if (has_bagidx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bagidx());
    }

    // required int32 ArrayIdx = 3;
    if (has_arrayidx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->arrayidx());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSInbattleWeaponElmtBrief::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSInbattleWeaponElmtBrief*>(&from));
}

void CSInbattleWeaponElmtBrief::MergeFrom(const CSInbattleWeaponElmtBrief& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_weaponguid()) {
      set_weaponguid(from.weaponguid());
    }
    if (from.has_bagidx()) {
      set_bagidx(from.bagidx());
    }
    if (from.has_arrayidx()) {
      set_arrayidx(from.arrayidx());
    }
  }
}

void CSInbattleWeaponElmtBrief::CopyFrom(const CSInbattleWeaponElmtBrief& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSInbattleWeaponElmtBrief::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CSInbattleWeaponElmtBrief::Swap(CSInbattleWeaponElmtBrief* other) {
  if (other != this) {
    std::swap(weaponguid_, other->weaponguid_);
    std::swap(bagidx_, other->bagidx_);
    std::swap(arrayidx_, other->arrayidx_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSInbattleWeaponElmtBrief::GetTypeName() const {
  return "vmsg.CSInbattleWeaponElmtBrief";
}


// ===================================================================

#ifndef _MSC_VER
const int CSWeaponInBattleRqst::kOldWeaponFieldNumber;
const int CSWeaponInBattleRqst::kNewWeaponFieldNumber;
#endif  // !_MSC_VER

CSWeaponInBattleRqst::CSWeaponInBattleRqst()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSWeaponInBattleRqst::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  oldweapon_ = const_cast< ::vmsg::CSInbattleWeaponElmtBrief*>(
      ::vmsg::CSInbattleWeaponElmtBrief::internal_default_instance());
#else
  oldweapon_ = const_cast< ::vmsg::CSInbattleWeaponElmtBrief*>(&::vmsg::CSInbattleWeaponElmtBrief::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  newweapon_ = const_cast< ::vmsg::CSInbattleWeaponElmtBrief*>(
      ::vmsg::CSInbattleWeaponElmtBrief::internal_default_instance());
#else
  newweapon_ = const_cast< ::vmsg::CSInbattleWeaponElmtBrief*>(&::vmsg::CSInbattleWeaponElmtBrief::default_instance());
#endif
}

CSWeaponInBattleRqst::CSWeaponInBattleRqst(const CSWeaponInBattleRqst& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSWeaponInBattleRqst::SharedCtor() {
  _cached_size_ = 0;
  oldweapon_ = NULL;
  newweapon_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSWeaponInBattleRqst::~CSWeaponInBattleRqst() {
  SharedDtor();
}

void CSWeaponInBattleRqst::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete oldweapon_;
    delete newweapon_;
  }
}

void CSWeaponInBattleRqst::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSWeaponInBattleRqst& CSWeaponInBattleRqst::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSWeaponMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSWeaponMsg_2eproto();
#endif
  return *default_instance_;
}

CSWeaponInBattleRqst* CSWeaponInBattleRqst::default_instance_ = NULL;

CSWeaponInBattleRqst* CSWeaponInBattleRqst::New() const {
  return new CSWeaponInBattleRqst;
}

void CSWeaponInBattleRqst::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_oldweapon()) {
      if (oldweapon_ != NULL) oldweapon_->::vmsg::CSInbattleWeaponElmtBrief::Clear();
    }
    if (has_newweapon()) {
      if (newweapon_ != NULL) newweapon_->::vmsg::CSInbattleWeaponElmtBrief::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSWeaponInBattleRqst::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .vmsg.CSInbattleWeaponElmtBrief OldWeapon = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_oldweapon()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_NewWeapon;
        break;
      }

      // optional .vmsg.CSInbattleWeaponElmtBrief NewWeapon = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_NewWeapon:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_newweapon()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSWeaponInBattleRqst::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .vmsg.CSInbattleWeaponElmtBrief OldWeapon = 1;
  if (has_oldweapon()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->oldweapon(), output);
  }

  // optional .vmsg.CSInbattleWeaponElmtBrief NewWeapon = 2;
  if (has_newweapon()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->newweapon(), output);
  }

}

int CSWeaponInBattleRqst::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .vmsg.CSInbattleWeaponElmtBrief OldWeapon = 1;
    if (has_oldweapon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->oldweapon());
    }

    // optional .vmsg.CSInbattleWeaponElmtBrief NewWeapon = 2;
    if (has_newweapon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->newweapon());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSWeaponInBattleRqst::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSWeaponInBattleRqst*>(&from));
}

void CSWeaponInBattleRqst::MergeFrom(const CSWeaponInBattleRqst& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_oldweapon()) {
      mutable_oldweapon()->::vmsg::CSInbattleWeaponElmtBrief::MergeFrom(from.oldweapon());
    }
    if (from.has_newweapon()) {
      mutable_newweapon()->::vmsg::CSInbattleWeaponElmtBrief::MergeFrom(from.newweapon());
    }
  }
}

void CSWeaponInBattleRqst::CopyFrom(const CSWeaponInBattleRqst& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSWeaponInBattleRqst::IsInitialized() const {

  if (has_oldweapon()) {
    if (!this->oldweapon().IsInitialized()) return false;
  }
  if (has_newweapon()) {
    if (!this->newweapon().IsInitialized()) return false;
  }
  return true;
}

void CSWeaponInBattleRqst::Swap(CSWeaponInBattleRqst* other) {
  if (other != this) {
    std::swap(oldweapon_, other->oldweapon_);
    std::swap(newweapon_, other->newweapon_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSWeaponInBattleRqst::GetTypeName() const {
  return "vmsg.CSWeaponInBattleRqst";
}


// ===================================================================

#ifndef _MSC_VER
const int CSWeaponInBattleRsp::kEquippedWeaponFieldNumber;
const int CSWeaponInBattleRsp::kInBattleWeaponsFieldNumber;
const int CSWeaponInBattleRsp::kHPAddEffFieldNumber;
const int CSWeaponInBattleRsp::kAtkAddEffFieldNumber;
const int CSWeaponInBattleRsp::kDefAddEffFieldNumber;
#endif  // !_MSC_VER

CSWeaponInBattleRsp::CSWeaponInBattleRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSWeaponInBattleRsp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  equippedweapon_ = const_cast< ::vmsg::CSWeapon*>(
      ::vmsg::CSWeapon::internal_default_instance());
#else
  equippedweapon_ = const_cast< ::vmsg::CSWeapon*>(&::vmsg::CSWeapon::default_instance());
#endif
}

CSWeaponInBattleRsp::CSWeaponInBattleRsp(const CSWeaponInBattleRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSWeaponInBattleRsp::SharedCtor() {
  _cached_size_ = 0;
  equippedweapon_ = NULL;
  hpaddeff_ = 0u;
  atkaddeff_ = 0u;
  defaddeff_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSWeaponInBattleRsp::~CSWeaponInBattleRsp() {
  SharedDtor();
}

void CSWeaponInBattleRsp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete equippedweapon_;
  }
}

void CSWeaponInBattleRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSWeaponInBattleRsp& CSWeaponInBattleRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSWeaponMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSWeaponMsg_2eproto();
#endif
  return *default_instance_;
}

CSWeaponInBattleRsp* CSWeaponInBattleRsp::default_instance_ = NULL;

CSWeaponInBattleRsp* CSWeaponInBattleRsp::New() const {
  return new CSWeaponInBattleRsp;
}

void CSWeaponInBattleRsp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_equippedweapon()) {
      if (equippedweapon_ != NULL) equippedweapon_->::vmsg::CSWeapon::Clear();
    }
    hpaddeff_ = 0u;
    atkaddeff_ = 0u;
    defaddeff_ = 0u;
  }
  inbattleweapons_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSWeaponInBattleRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vmsg.CSWeapon EquippedWeapon = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_equippedweapon()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_InBattleWeapons;
        break;
      }

      // repeated .vmsg.CSInbattleWeaponElmt InBattleWeapons = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_InBattleWeapons:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_inbattleweapons()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_InBattleWeapons;
        if (input->ExpectTag(32)) goto parse_HPAddEff;
        break;
      }

      // required uint32 HPAddEff = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_HPAddEff:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hpaddeff_)));
          set_has_hpaddeff();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_AtkAddEff;
        break;
      }

      // required uint32 AtkAddEff = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_AtkAddEff:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &atkaddeff_)));
          set_has_atkaddeff();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_DefAddEff;
        break;
      }

      // required uint32 DefAddEff = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_DefAddEff:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &defaddeff_)));
          set_has_defaddeff();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSWeaponInBattleRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .vmsg.CSWeapon EquippedWeapon = 1;
  if (has_equippedweapon()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->equippedweapon(), output);
  }

  // repeated .vmsg.CSInbattleWeaponElmt InBattleWeapons = 2;
  for (int i = 0; i < this->inbattleweapons_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->inbattleweapons(i), output);
  }

  // required uint32 HPAddEff = 4;
  if (has_hpaddeff()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->hpaddeff(), output);
  }

  // required uint32 AtkAddEff = 5;
  if (has_atkaddeff()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->atkaddeff(), output);
  }

  // required uint32 DefAddEff = 6;
  if (has_defaddeff()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->defaddeff(), output);
  }

}

int CSWeaponInBattleRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .vmsg.CSWeapon EquippedWeapon = 1;
    if (has_equippedweapon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->equippedweapon());
    }

    // required uint32 HPAddEff = 4;
    if (has_hpaddeff()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->hpaddeff());
    }

    // required uint32 AtkAddEff = 5;
    if (has_atkaddeff()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->atkaddeff());
    }

    // required uint32 DefAddEff = 6;
    if (has_defaddeff()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->defaddeff());
    }

  }
  // repeated .vmsg.CSInbattleWeaponElmt InBattleWeapons = 2;
  total_size += 1 * this->inbattleweapons_size();
  for (int i = 0; i < this->inbattleweapons_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->inbattleweapons(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSWeaponInBattleRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSWeaponInBattleRsp*>(&from));
}

void CSWeaponInBattleRsp::MergeFrom(const CSWeaponInBattleRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  inbattleweapons_.MergeFrom(from.inbattleweapons_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_equippedweapon()) {
      mutable_equippedweapon()->::vmsg::CSWeapon::MergeFrom(from.equippedweapon());
    }
    if (from.has_hpaddeff()) {
      set_hpaddeff(from.hpaddeff());
    }
    if (from.has_atkaddeff()) {
      set_atkaddeff(from.atkaddeff());
    }
    if (from.has_defaddeff()) {
      set_defaddeff(from.defaddeff());
    }
  }
}

void CSWeaponInBattleRsp::CopyFrom(const CSWeaponInBattleRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSWeaponInBattleRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001d) != 0x0000001d) return false;

  if (has_equippedweapon()) {
    if (!this->equippedweapon().IsInitialized()) return false;
  }
  for (int i = 0; i < inbattleweapons_size(); i++) {
    if (!this->inbattleweapons(i).IsInitialized()) return false;
  }
  return true;
}

void CSWeaponInBattleRsp::Swap(CSWeaponInBattleRsp* other) {
  if (other != this) {
    std::swap(equippedweapon_, other->equippedweapon_);
    inbattleweapons_.Swap(&other->inbattleweapons_);
    std::swap(hpaddeff_, other->hpaddeff_);
    std::swap(atkaddeff_, other->atkaddeff_);
    std::swap(defaddeff_, other->defaddeff_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSWeaponInBattleRsp::GetTypeName() const {
  return "vmsg.CSWeaponInBattleRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSWeaponLvUpRsp::kWeaponFieldNumber;
const int CSWeaponLvUpRsp::kBagFieldNumber;
#endif  // !_MSC_VER

CSWeaponLvUpRsp::CSWeaponLvUpRsp()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSWeaponLvUpRsp::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  weapon_ = const_cast< ::vmsg::CSWeapon*>(
      ::vmsg::CSWeapon::internal_default_instance());
#else
  weapon_ = const_cast< ::vmsg::CSWeapon*>(&::vmsg::CSWeapon::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  bag_ = const_cast< ::vmsg::CSBagInfo*>(
      ::vmsg::CSBagInfo::internal_default_instance());
#else
  bag_ = const_cast< ::vmsg::CSBagInfo*>(&::vmsg::CSBagInfo::default_instance());
#endif
}

CSWeaponLvUpRsp::CSWeaponLvUpRsp(const CSWeaponLvUpRsp& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSWeaponLvUpRsp::SharedCtor() {
  _cached_size_ = 0;
  weapon_ = NULL;
  bag_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSWeaponLvUpRsp::~CSWeaponLvUpRsp() {
  SharedDtor();
}

void CSWeaponLvUpRsp::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete weapon_;
    delete bag_;
  }
}

void CSWeaponLvUpRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSWeaponLvUpRsp& CSWeaponLvUpRsp::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSWeaponMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSWeaponMsg_2eproto();
#endif
  return *default_instance_;
}

CSWeaponLvUpRsp* CSWeaponLvUpRsp::default_instance_ = NULL;

CSWeaponLvUpRsp* CSWeaponLvUpRsp::New() const {
  return new CSWeaponLvUpRsp;
}

void CSWeaponLvUpRsp::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_weapon()) {
      if (weapon_ != NULL) weapon_->::vmsg::CSWeapon::Clear();
    }
    if (has_bag()) {
      if (bag_ != NULL) bag_->::vmsg::CSBagInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSWeaponLvUpRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .vmsg.CSWeapon Weapon = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_weapon()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_Bag;
        break;
      }

      // required .vmsg.CSBagInfo Bag = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Bag:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bag()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSWeaponLvUpRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .vmsg.CSWeapon Weapon = 1;
  if (has_weapon()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->weapon(), output);
  }

  // required .vmsg.CSBagInfo Bag = 2;
  if (has_bag()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->bag(), output);
  }

}

int CSWeaponLvUpRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .vmsg.CSWeapon Weapon = 1;
    if (has_weapon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->weapon());
    }

    // required .vmsg.CSBagInfo Bag = 2;
    if (has_bag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->bag());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSWeaponLvUpRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSWeaponLvUpRsp*>(&from));
}

void CSWeaponLvUpRsp::MergeFrom(const CSWeaponLvUpRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_weapon()) {
      mutable_weapon()->::vmsg::CSWeapon::MergeFrom(from.weapon());
    }
    if (from.has_bag()) {
      mutable_bag()->::vmsg::CSBagInfo::MergeFrom(from.bag());
    }
  }
}

void CSWeaponLvUpRsp::CopyFrom(const CSWeaponLvUpRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSWeaponLvUpRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_weapon()) {
    if (!this->weapon().IsInitialized()) return false;
  }
  if (has_bag()) {
    if (!this->bag().IsInitialized()) return false;
  }
  return true;
}

void CSWeaponLvUpRsp::Swap(CSWeaponLvUpRsp* other) {
  if (other != this) {
    std::swap(weapon_, other->weapon_);
    std::swap(bag_, other->bag_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSWeaponLvUpRsp::GetTypeName() const {
  return "vmsg.CSWeaponLvUpRsp";
}


// ===================================================================

#ifndef _MSC_VER
const int CSWeaponRequest::kWeaponChangeRqstFieldNumber;
const int CSWeaponRequest::kWeaponLvUpRqstFieldNumber;
const int CSWeaponRequest::kWeaponStarStepRqstFieldNumber;
const int CSWeaponRequest::kWeaponRefitRqstFieldNumber;
const int CSWeaponRequest::kChangeWeaponInBattleRqstFieldNumber;
#endif  // !_MSC_VER

CSWeaponRequest::CSWeaponRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSWeaponRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  weaponchange_rqst_ = const_cast< ::vmsg::CSWeaponChangeRqst*>(
      ::vmsg::CSWeaponChangeRqst::internal_default_instance());
#else
  weaponchange_rqst_ = const_cast< ::vmsg::CSWeaponChangeRqst*>(&::vmsg::CSWeaponChangeRqst::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  weaponlvup_rqst_ = const_cast< ::vmsg::CSWeaponLvUpRqst*>(
      ::vmsg::CSWeaponLvUpRqst::internal_default_instance());
#else
  weaponlvup_rqst_ = const_cast< ::vmsg::CSWeaponLvUpRqst*>(&::vmsg::CSWeaponLvUpRqst::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  weaponstarstep_rqst_ = const_cast< ::vmsg::CSWeaponStarStepRqst*>(
      ::vmsg::CSWeaponStarStepRqst::internal_default_instance());
#else
  weaponstarstep_rqst_ = const_cast< ::vmsg::CSWeaponStarStepRqst*>(&::vmsg::CSWeaponStarStepRqst::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  weaponrefit_rqst_ = const_cast< ::vmsg::CSWeaponRefitRqst*>(
      ::vmsg::CSWeaponRefitRqst::internal_default_instance());
#else
  weaponrefit_rqst_ = const_cast< ::vmsg::CSWeaponRefitRqst*>(&::vmsg::CSWeaponRefitRqst::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  changeweaponinbattle_rqst_ = const_cast< ::vmsg::CSWeaponInBattleRqst*>(
      ::vmsg::CSWeaponInBattleRqst::internal_default_instance());
#else
  changeweaponinbattle_rqst_ = const_cast< ::vmsg::CSWeaponInBattleRqst*>(&::vmsg::CSWeaponInBattleRqst::default_instance());
#endif
}

CSWeaponRequest::CSWeaponRequest(const CSWeaponRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSWeaponRequest::SharedCtor() {
  _cached_size_ = 0;
  weaponchange_rqst_ = NULL;
  weaponlvup_rqst_ = NULL;
  weaponstarstep_rqst_ = NULL;
  weaponrefit_rqst_ = NULL;
  changeweaponinbattle_rqst_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSWeaponRequest::~CSWeaponRequest() {
  SharedDtor();
}

void CSWeaponRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete weaponchange_rqst_;
    delete weaponlvup_rqst_;
    delete weaponstarstep_rqst_;
    delete weaponrefit_rqst_;
    delete changeweaponinbattle_rqst_;
  }
}

void CSWeaponRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSWeaponRequest& CSWeaponRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSWeaponMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSWeaponMsg_2eproto();
#endif
  return *default_instance_;
}

CSWeaponRequest* CSWeaponRequest::default_instance_ = NULL;

CSWeaponRequest* CSWeaponRequest::New() const {
  return new CSWeaponRequest;
}

void CSWeaponRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_weaponchange_rqst()) {
      if (weaponchange_rqst_ != NULL) weaponchange_rqst_->::vmsg::CSWeaponChangeRqst::Clear();
    }
    if (has_weaponlvup_rqst()) {
      if (weaponlvup_rqst_ != NULL) weaponlvup_rqst_->::vmsg::CSWeaponLvUpRqst::Clear();
    }
    if (has_weaponstarstep_rqst()) {
      if (weaponstarstep_rqst_ != NULL) weaponstarstep_rqst_->::vmsg::CSWeaponStarStepRqst::Clear();
    }
    if (has_weaponrefit_rqst()) {
      if (weaponrefit_rqst_ != NULL) weaponrefit_rqst_->::vmsg::CSWeaponRefitRqst::Clear();
    }
    if (has_changeweaponinbattle_rqst()) {
      if (changeweaponinbattle_rqst_ != NULL) changeweaponinbattle_rqst_->::vmsg::CSWeaponInBattleRqst::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSWeaponRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .vmsg.CSWeaponChangeRqst WeaponChange_Rqst = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_weaponchange_rqst()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_WeaponLvUp_Rqst;
        break;
      }

      // optional .vmsg.CSWeaponLvUpRqst WeaponLvUp_Rqst = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_WeaponLvUp_Rqst:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_weaponlvup_rqst()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_WeaponStarStep_Rqst;
        break;
      }

      // optional .vmsg.CSWeaponStarStepRqst WeaponStarStep_Rqst = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_WeaponStarStep_Rqst:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_weaponstarstep_rqst()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_WeaponRefit_Rqst;
        break;
      }

      // optional .vmsg.CSWeaponRefitRqst WeaponRefit_Rqst = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_WeaponRefit_Rqst:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_weaponrefit_rqst()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_ChangeWeaponInBattle_Rqst;
        break;
      }

      // optional .vmsg.CSWeaponInBattleRqst ChangeWeaponInBattle_Rqst = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ChangeWeaponInBattle_Rqst:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_changeweaponinbattle_rqst()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSWeaponRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .vmsg.CSWeaponChangeRqst WeaponChange_Rqst = 1;
  if (has_weaponchange_rqst()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->weaponchange_rqst(), output);
  }

  // optional .vmsg.CSWeaponLvUpRqst WeaponLvUp_Rqst = 2;
  if (has_weaponlvup_rqst()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->weaponlvup_rqst(), output);
  }

  // optional .vmsg.CSWeaponStarStepRqst WeaponStarStep_Rqst = 3;
  if (has_weaponstarstep_rqst()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->weaponstarstep_rqst(), output);
  }

  // optional .vmsg.CSWeaponRefitRqst WeaponRefit_Rqst = 4;
  if (has_weaponrefit_rqst()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->weaponrefit_rqst(), output);
  }

  // optional .vmsg.CSWeaponInBattleRqst ChangeWeaponInBattle_Rqst = 5;
  if (has_changeweaponinbattle_rqst()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->changeweaponinbattle_rqst(), output);
  }

}

int CSWeaponRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .vmsg.CSWeaponChangeRqst WeaponChange_Rqst = 1;
    if (has_weaponchange_rqst()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->weaponchange_rqst());
    }

    // optional .vmsg.CSWeaponLvUpRqst WeaponLvUp_Rqst = 2;
    if (has_weaponlvup_rqst()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->weaponlvup_rqst());
    }

    // optional .vmsg.CSWeaponStarStepRqst WeaponStarStep_Rqst = 3;
    if (has_weaponstarstep_rqst()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->weaponstarstep_rqst());
    }

    // optional .vmsg.CSWeaponRefitRqst WeaponRefit_Rqst = 4;
    if (has_weaponrefit_rqst()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->weaponrefit_rqst());
    }

    // optional .vmsg.CSWeaponInBattleRqst ChangeWeaponInBattle_Rqst = 5;
    if (has_changeweaponinbattle_rqst()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->changeweaponinbattle_rqst());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSWeaponRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSWeaponRequest*>(&from));
}

void CSWeaponRequest::MergeFrom(const CSWeaponRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_weaponchange_rqst()) {
      mutable_weaponchange_rqst()->::vmsg::CSWeaponChangeRqst::MergeFrom(from.weaponchange_rqst());
    }
    if (from.has_weaponlvup_rqst()) {
      mutable_weaponlvup_rqst()->::vmsg::CSWeaponLvUpRqst::MergeFrom(from.weaponlvup_rqst());
    }
    if (from.has_weaponstarstep_rqst()) {
      mutable_weaponstarstep_rqst()->::vmsg::CSWeaponStarStepRqst::MergeFrom(from.weaponstarstep_rqst());
    }
    if (from.has_weaponrefit_rqst()) {
      mutable_weaponrefit_rqst()->::vmsg::CSWeaponRefitRqst::MergeFrom(from.weaponrefit_rqst());
    }
    if (from.has_changeweaponinbattle_rqst()) {
      mutable_changeweaponinbattle_rqst()->::vmsg::CSWeaponInBattleRqst::MergeFrom(from.changeweaponinbattle_rqst());
    }
  }
}

void CSWeaponRequest::CopyFrom(const CSWeaponRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSWeaponRequest::IsInitialized() const {

  if (has_weaponchange_rqst()) {
    if (!this->weaponchange_rqst().IsInitialized()) return false;
  }
  if (has_weaponlvup_rqst()) {
    if (!this->weaponlvup_rqst().IsInitialized()) return false;
  }
  if (has_weaponstarstep_rqst()) {
    if (!this->weaponstarstep_rqst().IsInitialized()) return false;
  }
  if (has_weaponrefit_rqst()) {
    if (!this->weaponrefit_rqst().IsInitialized()) return false;
  }
  if (has_changeweaponinbattle_rqst()) {
    if (!this->changeweaponinbattle_rqst().IsInitialized()) return false;
  }
  return true;
}

void CSWeaponRequest::Swap(CSWeaponRequest* other) {
  if (other != this) {
    std::swap(weaponchange_rqst_, other->weaponchange_rqst_);
    std::swap(weaponlvup_rqst_, other->weaponlvup_rqst_);
    std::swap(weaponstarstep_rqst_, other->weaponstarstep_rqst_);
    std::swap(weaponrefit_rqst_, other->weaponrefit_rqst_);
    std::swap(changeweaponinbattle_rqst_, other->changeweaponinbattle_rqst_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSWeaponRequest::GetTypeName() const {
  return "vmsg.CSWeaponRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int CSWeaponRespond::kWeaponQueryBagRspFieldNumber;
const int CSWeaponRespond::kWeaponChangeRspFieldNumber;
const int CSWeaponRespond::kWeaponLvUpRspFieldNumber;
const int CSWeaponRespond::kWeaponStarStepRspFieldNumber;
const int CSWeaponRespond::kWeaponRefitRspFieldNumber;
const int CSWeaponRespond::kChangeWeaponInBattleRspFieldNumber;
const int CSWeaponRespond::kQueryWeaponInBattleRspFieldNumber;
#endif  // !_MSC_VER

CSWeaponRespond::CSWeaponRespond()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CSWeaponRespond::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  weaponquerybag_rsp_ = const_cast< ::vmsg::CSWeaponBag*>(
      ::vmsg::CSWeaponBag::internal_default_instance());
#else
  weaponquerybag_rsp_ = const_cast< ::vmsg::CSWeaponBag*>(&::vmsg::CSWeaponBag::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  weaponchange_rsp_ = const_cast< ::vmsg::CSWeaponBag*>(
      ::vmsg::CSWeaponBag::internal_default_instance());
#else
  weaponchange_rsp_ = const_cast< ::vmsg::CSWeaponBag*>(&::vmsg::CSWeaponBag::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  weaponlvup_rsp_ = const_cast< ::vmsg::CSWeaponLvUpRsp*>(
      ::vmsg::CSWeaponLvUpRsp::internal_default_instance());
#else
  weaponlvup_rsp_ = const_cast< ::vmsg::CSWeaponLvUpRsp*>(&::vmsg::CSWeaponLvUpRsp::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  weaponstarstep_rsp_ = const_cast< ::vmsg::CSWeaponBag*>(
      ::vmsg::CSWeaponBag::internal_default_instance());
#else
  weaponstarstep_rsp_ = const_cast< ::vmsg::CSWeaponBag*>(&::vmsg::CSWeaponBag::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  weaponrefit_rsp_ = const_cast< ::vmsg::CSWeaponBag*>(
      ::vmsg::CSWeaponBag::internal_default_instance());
#else
  weaponrefit_rsp_ = const_cast< ::vmsg::CSWeaponBag*>(&::vmsg::CSWeaponBag::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  changeweaponinbattle_rsp_ = const_cast< ::vmsg::CSWeaponInBattleRsp*>(
      ::vmsg::CSWeaponInBattleRsp::internal_default_instance());
#else
  changeweaponinbattle_rsp_ = const_cast< ::vmsg::CSWeaponInBattleRsp*>(&::vmsg::CSWeaponInBattleRsp::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  queryweaponinbattle_rsp_ = const_cast< ::vmsg::CSWeaponInBattleRsp*>(
      ::vmsg::CSWeaponInBattleRsp::internal_default_instance());
#else
  queryweaponinbattle_rsp_ = const_cast< ::vmsg::CSWeaponInBattleRsp*>(&::vmsg::CSWeaponInBattleRsp::default_instance());
#endif
}

CSWeaponRespond::CSWeaponRespond(const CSWeaponRespond& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CSWeaponRespond::SharedCtor() {
  _cached_size_ = 0;
  weaponquerybag_rsp_ = NULL;
  weaponchange_rsp_ = NULL;
  weaponlvup_rsp_ = NULL;
  weaponstarstep_rsp_ = NULL;
  weaponrefit_rsp_ = NULL;
  changeweaponinbattle_rsp_ = NULL;
  queryweaponinbattle_rsp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CSWeaponRespond::~CSWeaponRespond() {
  SharedDtor();
}

void CSWeaponRespond::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete weaponquerybag_rsp_;
    delete weaponchange_rsp_;
    delete weaponlvup_rsp_;
    delete weaponstarstep_rsp_;
    delete weaponrefit_rsp_;
    delete changeweaponinbattle_rsp_;
    delete queryweaponinbattle_rsp_;
  }
}

void CSWeaponRespond::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CSWeaponRespond& CSWeaponRespond::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_CSWeaponMsg_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_CSWeaponMsg_2eproto();
#endif
  return *default_instance_;
}

CSWeaponRespond* CSWeaponRespond::default_instance_ = NULL;

CSWeaponRespond* CSWeaponRespond::New() const {
  return new CSWeaponRespond;
}

void CSWeaponRespond::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_weaponquerybag_rsp()) {
      if (weaponquerybag_rsp_ != NULL) weaponquerybag_rsp_->::vmsg::CSWeaponBag::Clear();
    }
    if (has_weaponchange_rsp()) {
      if (weaponchange_rsp_ != NULL) weaponchange_rsp_->::vmsg::CSWeaponBag::Clear();
    }
    if (has_weaponlvup_rsp()) {
      if (weaponlvup_rsp_ != NULL) weaponlvup_rsp_->::vmsg::CSWeaponLvUpRsp::Clear();
    }
    if (has_weaponstarstep_rsp()) {
      if (weaponstarstep_rsp_ != NULL) weaponstarstep_rsp_->::vmsg::CSWeaponBag::Clear();
    }
    if (has_weaponrefit_rsp()) {
      if (weaponrefit_rsp_ != NULL) weaponrefit_rsp_->::vmsg::CSWeaponBag::Clear();
    }
    if (has_changeweaponinbattle_rsp()) {
      if (changeweaponinbattle_rsp_ != NULL) changeweaponinbattle_rsp_->::vmsg::CSWeaponInBattleRsp::Clear();
    }
    if (has_queryweaponinbattle_rsp()) {
      if (queryweaponinbattle_rsp_ != NULL) queryweaponinbattle_rsp_->::vmsg::CSWeaponInBattleRsp::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CSWeaponRespond::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .vmsg.CSWeaponBag WeaponQueryBag_Rsp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_weaponquerybag_rsp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_WeaponChange_Rsp;
        break;
      }

      // optional .vmsg.CSWeaponBag WeaponChange_Rsp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_WeaponChange_Rsp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_weaponchange_rsp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_WeaponLvUp_Rsp;
        break;
      }

      // optional .vmsg.CSWeaponLvUpRsp WeaponLvUp_Rsp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_WeaponLvUp_Rsp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_weaponlvup_rsp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_WeaponStarStep_Rsp;
        break;
      }

      // optional .vmsg.CSWeaponBag WeaponStarStep_Rsp = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_WeaponStarStep_Rsp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_weaponstarstep_rsp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_WeaponRefit_Rsp;
        break;
      }

      // optional .vmsg.CSWeaponBag WeaponRefit_Rsp = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_WeaponRefit_Rsp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_weaponrefit_rsp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_ChangeWeaponInBattle_Rsp;
        break;
      }

      // optional .vmsg.CSWeaponInBattleRsp ChangeWeaponInBattle_Rsp = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ChangeWeaponInBattle_Rsp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_changeweaponinbattle_rsp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_QueryWeaponInBattle_Rsp;
        break;
      }

      // optional .vmsg.CSWeaponInBattleRsp QueryWeaponInBattle_Rsp = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_QueryWeaponInBattle_Rsp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_queryweaponinbattle_rsp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CSWeaponRespond::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .vmsg.CSWeaponBag WeaponQueryBag_Rsp = 1;
  if (has_weaponquerybag_rsp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->weaponquerybag_rsp(), output);
  }

  // optional .vmsg.CSWeaponBag WeaponChange_Rsp = 2;
  if (has_weaponchange_rsp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->weaponchange_rsp(), output);
  }

  // optional .vmsg.CSWeaponLvUpRsp WeaponLvUp_Rsp = 3;
  if (has_weaponlvup_rsp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->weaponlvup_rsp(), output);
  }

  // optional .vmsg.CSWeaponBag WeaponStarStep_Rsp = 4;
  if (has_weaponstarstep_rsp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->weaponstarstep_rsp(), output);
  }

  // optional .vmsg.CSWeaponBag WeaponRefit_Rsp = 5;
  if (has_weaponrefit_rsp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->weaponrefit_rsp(), output);
  }

  // optional .vmsg.CSWeaponInBattleRsp ChangeWeaponInBattle_Rsp = 6;
  if (has_changeweaponinbattle_rsp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->changeweaponinbattle_rsp(), output);
  }

  // optional .vmsg.CSWeaponInBattleRsp QueryWeaponInBattle_Rsp = 7;
  if (has_queryweaponinbattle_rsp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->queryweaponinbattle_rsp(), output);
  }

}

int CSWeaponRespond::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .vmsg.CSWeaponBag WeaponQueryBag_Rsp = 1;
    if (has_weaponquerybag_rsp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->weaponquerybag_rsp());
    }

    // optional .vmsg.CSWeaponBag WeaponChange_Rsp = 2;
    if (has_weaponchange_rsp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->weaponchange_rsp());
    }

    // optional .vmsg.CSWeaponLvUpRsp WeaponLvUp_Rsp = 3;
    if (has_weaponlvup_rsp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->weaponlvup_rsp());
    }

    // optional .vmsg.CSWeaponBag WeaponStarStep_Rsp = 4;
    if (has_weaponstarstep_rsp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->weaponstarstep_rsp());
    }

    // optional .vmsg.CSWeaponBag WeaponRefit_Rsp = 5;
    if (has_weaponrefit_rsp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->weaponrefit_rsp());
    }

    // optional .vmsg.CSWeaponInBattleRsp ChangeWeaponInBattle_Rsp = 6;
    if (has_changeweaponinbattle_rsp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->changeweaponinbattle_rsp());
    }

    // optional .vmsg.CSWeaponInBattleRsp QueryWeaponInBattle_Rsp = 7;
    if (has_queryweaponinbattle_rsp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->queryweaponinbattle_rsp());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CSWeaponRespond::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CSWeaponRespond*>(&from));
}

void CSWeaponRespond::MergeFrom(const CSWeaponRespond& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_weaponquerybag_rsp()) {
      mutable_weaponquerybag_rsp()->::vmsg::CSWeaponBag::MergeFrom(from.weaponquerybag_rsp());
    }
    if (from.has_weaponchange_rsp()) {
      mutable_weaponchange_rsp()->::vmsg::CSWeaponBag::MergeFrom(from.weaponchange_rsp());
    }
    if (from.has_weaponlvup_rsp()) {
      mutable_weaponlvup_rsp()->::vmsg::CSWeaponLvUpRsp::MergeFrom(from.weaponlvup_rsp());
    }
    if (from.has_weaponstarstep_rsp()) {
      mutable_weaponstarstep_rsp()->::vmsg::CSWeaponBag::MergeFrom(from.weaponstarstep_rsp());
    }
    if (from.has_weaponrefit_rsp()) {
      mutable_weaponrefit_rsp()->::vmsg::CSWeaponBag::MergeFrom(from.weaponrefit_rsp());
    }
    if (from.has_changeweaponinbattle_rsp()) {
      mutable_changeweaponinbattle_rsp()->::vmsg::CSWeaponInBattleRsp::MergeFrom(from.changeweaponinbattle_rsp());
    }
    if (from.has_queryweaponinbattle_rsp()) {
      mutable_queryweaponinbattle_rsp()->::vmsg::CSWeaponInBattleRsp::MergeFrom(from.queryweaponinbattle_rsp());
    }
  }
}

void CSWeaponRespond::CopyFrom(const CSWeaponRespond& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSWeaponRespond::IsInitialized() const {

  if (has_weaponquerybag_rsp()) {
    if (!this->weaponquerybag_rsp().IsInitialized()) return false;
  }
  if (has_weaponchange_rsp()) {
    if (!this->weaponchange_rsp().IsInitialized()) return false;
  }
  if (has_weaponlvup_rsp()) {
    if (!this->weaponlvup_rsp().IsInitialized()) return false;
  }
  if (has_weaponstarstep_rsp()) {
    if (!this->weaponstarstep_rsp().IsInitialized()) return false;
  }
  if (has_weaponrefit_rsp()) {
    if (!this->weaponrefit_rsp().IsInitialized()) return false;
  }
  if (has_changeweaponinbattle_rsp()) {
    if (!this->changeweaponinbattle_rsp().IsInitialized()) return false;
  }
  if (has_queryweaponinbattle_rsp()) {
    if (!this->queryweaponinbattle_rsp().IsInitialized()) return false;
  }
  return true;
}

void CSWeaponRespond::Swap(CSWeaponRespond* other) {
  if (other != this) {
    std::swap(weaponquerybag_rsp_, other->weaponquerybag_rsp_);
    std::swap(weaponchange_rsp_, other->weaponchange_rsp_);
    std::swap(weaponlvup_rsp_, other->weaponlvup_rsp_);
    std::swap(weaponstarstep_rsp_, other->weaponstarstep_rsp_);
    std::swap(weaponrefit_rsp_, other->weaponrefit_rsp_);
    std::swap(changeweaponinbattle_rsp_, other->changeweaponinbattle_rsp_);
    std::swap(queryweaponinbattle_rsp_, other->queryweaponinbattle_rsp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CSWeaponRespond::GetTypeName() const {
  return "vmsg.CSWeaponRespond";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace vmsg

// @@protoc_insertion_point(global_scope)
